<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dyd-true.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="rt">
<meta property="og:type" content="article">
<meta property="og:title" content="模板汇总">
<meta property="og:url" content="https://dyd-true.github.io/2022/05/29/%E6%A8%A1%E6%9D%BF%E6%B1%87%E6%80%BB/index.html">
<meta property="og:site_name" content="Dyd&#39;s Blog">
<meta property="og:description" content="rt">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-05-29T02:56:18.000Z">
<meta property="article:modified_time" content="2022-06-14T06:47:53.254Z">
<meta property="article:author" content="Dyd">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="模板">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://dyd-true.github.io/2022/05/29/%E6%A8%A1%E6%9D%BF%E6%B1%87%E6%80%BB/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>模板汇总 | Dyd's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Dyd's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Dyd's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">He who has a strong enough why can bear almost any how.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    

  <a href="https://github.com/Dyd-true" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dyd-true.github.io/2022/05/29/%E6%A8%A1%E6%9D%BF%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Dyd">
      <meta itemprop="description" content="一人一人が、自分の森,迷う人を见失い、再会できた人は更にと対面した。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dyd's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          模板汇总
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-29 10:56:18" itemprop="dateCreated datePublished" datetime="2022-05-29T10:56:18+08:00">2022-05-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-14 14:47:53" itemprop="dateModified" datetime="2022-06-14T14:47:53+08:00">2022-06-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>81k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1:14</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p> rt</p>
<span id="more"></span>

<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>总结一下板子；顺序没有意义；尽量不会压行（但有时候略微压）；限于本人水平，有概率会错；有些东西的运用要视情况而定，会给出类似伪代码的东西，还有些之间用文字给出流程</p>
<p>关于编译选项，默认是 <code>-O2 -std=c++11 -Wl,--stack=1145141919</code></p>
<p>关于头文件，默认是万能头 <code>#include &lt;bits/stdc++.h&gt;</code> </p>
<p>关于宏（包括 <code>using</code> ），默认包含以下宏</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STC static</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> DB = <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> LDB = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="keyword">using</span> PR = std::pair&lt;T1, T2&gt;;</span><br><span class="line"><span class="keyword">using</span> PII = std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">std</span>:</span>:<span class="keyword">size_t</span> num&gt;</span><br><span class="line"><span class="keyword">using</span> AR = std::array&lt;T, num&gt;;</span><br></pre></td></tr></table></figure>

<p>大部分情况默认数据范围是 <code>int</code> </p>
<p>大部分情况默认 $P$ 为模数， $INF$ 为正无穷</p>
<p>如未特殊说明，那些写在外面的语句就是主函数里的</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span> <span class="keyword">int</span> ne, ver, w; &#125; e[M];</span><br><span class="line"><span class="keyword">int</span> h[N], idx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="built_in">memset</span>(h, <span class="number">-1</span>, (n + <span class="number">1</span>) * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)), idx = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>&#123; e[idx] = &#123;h[x], y, z&#125;, h[x] = idx++; &#125;</span><br></pre></td></tr></table></figure>

<p>使用前要初始化（如何使用： <code>for (int i = h[x]; ~i; i = e[i].ne)</code> ）</p>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">get</span>(fa[x]); &#125; <span class="comment">//路径压缩</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = <span class="built_in">get</span>(x), y = <span class="built_in">get</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (rk[x] &gt; rk[y]) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">    fa[x] = y, rk[y] += rk[x] == rk[y]; <span class="comment">//按秩合并</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>STL （大根堆）： <code>std::priority_queue&lt;int&gt; q;</code> </p>
<p>手打（小根堆）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Hp <span class="comment">//Heap</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> hp[N], tot;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">for</span> (; x &gt; <span class="number">1</span> &amp;&amp; hp[x] &lt; hp[x &gt;&gt; <span class="number">1</span>]; x &gt;&gt;= <span class="number">1</span>) std::<span class="built_in">swap</span>(hp[x], hp[x &gt;&gt; <span class="number">1</span>]); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dw</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> y = x &lt;&lt; <span class="number">1</span>; y &lt;= tot; y = x &lt;&lt; <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (y &lt; tot &amp;&amp; hp[y + <span class="number">1</span>] &lt; hp[y]) ++y;</span><br><span class="line">			<span class="keyword">if</span> (hp[y] &lt; hp[x])</span><br><span class="line">			&#123;</span><br><span class="line">				std::<span class="built_in">swap</span>(hp[y], hp[x]);</span><br><span class="line">				x = y;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; hp[++tot] = x, <span class="built_in">up</span>(tot); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x = <span class="number">1</span>)</span></span>&#123; hp[x] = hp[tot--], <span class="built_in">up</span>(x), <span class="built_in">dw</span>(x); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>左偏树（小根堆）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> LH <span class="comment">//Left Heap</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> fa[N], tot; <span class="comment">//并查集维护根</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> <span class="keyword">int</span> lc, rc, v, dis; &#125; lh[N];</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> lc lh[x].lc</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> rc lh[x].rc</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> v(x) lh[(x)].v</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> ds(x) lh[(x)].dis</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//新建一个只有值x的堆</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		lh[++tot] = &#123;<span class="number">0</span>, <span class="number">0</span>, x, <span class="number">0</span>&#125;;</span><br><span class="line">		fa[tot] = tot;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> _merge(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">v</span>(x) &gt; <span class="built_in">v</span>(y)) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">		rc = _merge(rc, y);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">ds</span>(rc) &gt; <span class="built_in">ds</span>(lc)) std::<span class="built_in">swap</span>(rc, lc);</span><br><span class="line">		<span class="built_in">ds</span>(x) = <span class="built_in">ds</span>(rc) + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">get</span>(fa[x]); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">v</span>(x) == <span class="number">-1</span> || <span class="built_in">v</span>(y) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		x = <span class="built_in">get</span>(x), y = <span class="built_in">get</span>(y);</span><br><span class="line">		<span class="keyword">if</span> (x != y) <span class="keyword">return</span> fa[x] = fa[y] = _merge(x, y);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="built_in">v</span>(x) = <span class="number">-1</span>, fa[lc] = lc, fa[rc] = rc, fa[x] = <span class="built_in">merge</span>(lc, rc); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">v</span>(x) == <span class="number">-1</span> ? <span class="number">-1</span> : <span class="built_in">v</span>(<span class="built_in">get</span>(x)); &#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">undef</span> v</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">undef</span> ds</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="树状树组"><a href="#树状树组" class="headerlink" title="树状树组"></a>树状树组</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> BIT</span><br><span class="line">&#123;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> lb(x) ((x) &amp; (-(x)))</span></span><br><span class="line">	<span class="keyword">int</span> c[N];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span></span>&#123; <span class="keyword">for</span> (; x &lt;= n; x += <span class="built_in">lb</span>(x)) c[x] += d; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (; x; x ^= <span class="built_in">lb</span>(x)) res += c[x];</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">undef</span> lb</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意下标必须从 $1$ 开始，否则会死循环</p>
<h2 id="ST-表"><a href="#ST-表" class="headerlink" title="ST 表"></a>ST 表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> ST</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> mx[N][D], lg2[N];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">prev</span><span class="params">(<span class="keyword">int</span> x[])</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) mx[i][<span class="number">0</span>] = x[i];</span><br><span class="line">		lg2[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) lg2[i] = lg2[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> t = lg2[n] + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; t; ++j)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - (<span class="number">1</span> &lt;&lt; j) + <span class="number">1</span>; ++i) mx[i][j] = std::<span class="built_in">max</span>(mx[i][j - <span class="number">1</span>], mx[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> t = lg2[r - l + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">return</span> std::<span class="built_in">max</span>(mx[l][t], mx[r - (<span class="number">1</span> &lt;&lt; t) + <span class="number">1</span>][t]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四毛子"><a href="#四毛子" class="headerlink" title="四毛子"></a>四毛子</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> FR <span class="comment">//Four Russians</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> L = N &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span> <span class="keyword">int</span> lc, rc, dat; &#125; tr[N];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Block</span>&#123;</span> <span class="keyword">int</span> l, r, tp; &#125; b[N];</span><br><span class="line">    <span class="keyword">int</span> dfn[N], bid[L], cnt = <span class="number">0</span>, rt, num = <span class="number">0</span>, B, bk[L];</span><br><span class="line">    PII dat[L];</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">bool</span> <span class="title">cmn</span><span class="params">(T &amp;x, T y)</span></span>&#123; <span class="keyword">return</span> y &lt; x ? x = y, <span class="literal">true</span> : <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="keyword">namespace</span> ST</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> D = <span class="number">18</span>;</span><br><span class="line">        <span class="keyword">int</span> lg2[L];</span><br><span class="line">        PII mn[L][D];</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            lg2[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= num; ++i) lg2[i] = lg2[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++i) mn[i][<span class="number">0</span>] = dat[b[i].l + bk[b[i].tp] - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, t = lg2[num]; j &lt;= t; ++j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num - (<span class="number">1</span> &lt;&lt; j) + <span class="number">1</span>; ++i) mn[i][j] = std::<span class="built_in">min</span>(mn[i][j - <span class="number">1</span>], mn[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">PII <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> &#123;INF, INF&#125;;</span><br><span class="line">            <span class="keyword">int</span> t = lg2[r - l + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">min</span>(mn[l][t], mn[r - (<span class="number">1</span> &lt;&lt; t) + <span class="number">1</span>][t]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> x[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        FF&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>[])&gt; bct = [&amp;](<span class="keyword">int</span> len, <span class="keyword">int</span> x[])</span><br><span class="line">        &#123;</span><br><span class="line">            STC <span class="keyword">int</span> stk[N];</span><br><span class="line">            <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) tr[i].dat = x[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, k; i &lt;= len; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (k = top; k &amp;&amp; tr[stk[k]].dat &lt; tr[i].dat; --k);</span><br><span class="line">                <span class="keyword">if</span> (k) tr[stk[k]].rc = i;</span><br><span class="line">                <span class="keyword">if</span> (k &lt; top) tr[i].lc = stk[k + <span class="number">1</span>];</span><br><span class="line">                stk[top = k + <span class="number">1</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            rt = stk[<span class="number">1</span>];</span><br><span class="line">        &#125; ; </span><br><span class="line">        <span class="built_in">bct</span>(len, x);</span><br><span class="line">        FF&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> dep)</span><br><span class="line">        &#123;</span><br><span class="line">            dfn[x] = ++cnt, dat[cnt] = &#123;dep, x&#125;;</span><br><span class="line">            <span class="keyword">if</span> (tr[x].lc) <span class="built_in">dfs</span>(tr[x].lc, dep + <span class="number">1</span>), dat[++cnt] = &#123;dep, x&#125;;</span><br><span class="line">            <span class="keyword">if</span> (tr[x].rc) <span class="built_in">dfs</span>(tr[x].rc, dep + <span class="number">1</span>), dat[++cnt] = &#123;dep, x&#125;;</span><br><span class="line">        &#125; ;</span><br><span class="line">        <span class="built_in">dfs</span>(rt, <span class="number">1</span>);</span><br><span class="line">        B = <span class="built_in">log2</span>(cnt) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i += B) b[++num].l = i, b[num].r = i + B - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = cnt + <span class="number">1</span>; i &lt;= b[num].r; ++i) dat[i] = &#123;INF, INF&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = b[i].l; j &lt;= b[i].r; ++j) bid[j] = i;</span><br><span class="line">        FF&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>)&gt; calc = [&amp;](<span class="keyword">int</span> x)</span><br><span class="line">        &#123;</span><br><span class="line">            bk[x] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, mn = <span class="number">0</span>, sum = <span class="number">0</span>; i &lt;= B; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ((x &gt;&gt; (i - <span class="number">1</span>)) &amp; <span class="number">1</span>) ++sum;</span><br><span class="line">                <span class="keyword">else</span> --sum;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">cmn</span>(mn, sum)) bk[x] = i; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; ;</span><br><span class="line">        FF&lt;<span class="built_in"><span class="keyword">int</span></span>(Block)&gt; get_tp = [&amp;](Block x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = x.l + <span class="number">1</span>; i &lt;= x.r; ++i) res |= (dat[i].fi - dat[i - <span class="number">1</span>].fi &gt;= <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>) &lt;&lt; (i - x.l);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; ; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="number">1</span> &lt;&lt; B) - <span class="number">1</span>; ~i; --i) <span class="built_in">calc</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++i) b[i].tp = <span class="built_in">get_tp</span>(b[i]);</span><br><span class="line">        ST::<span class="built_in">init</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">PII <span class="title">to_ask</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="built_in">to_ask</span>(r, l);</span><br><span class="line">        FF&lt;<span class="built_in">PII</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; bask = [&amp;](<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span><br><span class="line">        &#123;</span><br><span class="line">            Block &amp;x = b[bid[l]];</span><br><span class="line">            <span class="keyword">int</span> t = x.tp, ll = l - x.l + <span class="number">1</span>, rr = r - x.l + <span class="number">1</span>;</span><br><span class="line">            t &gt;&gt;= ll - <span class="number">1</span>;</span><br><span class="line">            t |= ((<span class="number">1</span> &lt;&lt; (rr - ll + <span class="number">1</span>)) - <span class="number">1</span>) ^ ((<span class="number">1</span> &lt;&lt; B) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> dat[l + bk[t] - <span class="number">1</span>];</span><br><span class="line">        &#125; ;</span><br><span class="line">        <span class="keyword">if</span> (bid[l] == bid[r]) <span class="keyword">return</span> <span class="built_in">bask</span>(l, r); </span><br><span class="line">        PII res = std::<span class="built_in">min</span>(<span class="built_in">bask</span>(l, b[bid[l]].r), <span class="built_in">bask</span>(b[bid[r]].l, r));</span><br><span class="line">        <span class="keyword">if</span> (bid[r] - bid[l] &gt; <span class="number">1</span>) <span class="built_in">cmn</span>(res, ST::<span class="built_in">ask</span>(bid[l] + <span class="number">1</span>, bid[r] - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123; <span class="keyword">return</span> tr[<span class="built_in">to_ask</span>(dfn[l], dfn[r]).se].dat; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> LT</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> ... &#125; tr[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> lc (u &lt;&lt; 1)</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> rc ((u &lt;&lt; 1) | 1)</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123; ... &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">adt</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> d)</span></span>&#123; ... &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dw</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">tg</span>(u))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">adt</span>(lc, <span class="built_in">tg</span>(u)), <span class="built_in">adt</span>(rc, <span class="built_in">tg</span>(u));</span><br><span class="line">			<span class="built_in">tg</span>(u) = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">(<span class="keyword">int</span> u = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		tr[u] = &#123;<span class="number">0</span>, ...&#125;;</span><br><span class="line">		<span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line">		<span class="built_in">bd</span>(lc, l, mid), <span class="built_in">bd</span>(rc, mid + <span class="number">1</span>, r);</span><br><span class="line">		<span class="built_in">up</span>(u); <span class="comment">//有时候可以不要</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">cg</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> d, <span class="keyword">int</span> u = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="built_in">adt</span>(u, d);</span><br><span class="line">		<span class="built_in">dw</span>(u);</span><br><span class="line">		pos &lt;= mid ? <span class="built_in">cg</span>(pos, d, lc, l, mid) : <span class="built_in">cg</span>(pos, d, rc, mid + <span class="number">1</span>, r);</span><br><span class="line">		<span class="built_in">up</span>(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">mdf</span><span class="params">(<span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> d, <span class="keyword">int</span> u = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) <span class="built_in">adt</span>(u, d);</span><br><span class="line">		<span class="built_in">dw</span>(u);</span><br><span class="line">		<span class="keyword">if</span> (ql &lt;= mid) <span class="built_in">mdf</span>(ql, qr, d, lc, l, mid);</span><br><span class="line">		<span class="keyword">if</span> (qr &gt; mid) <span class="built_in">mdf</span>(ql, qr, d, rc, mid + <span class="number">1</span>, r);</span><br><span class="line">		<span class="built_in">up</span>(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> u = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (l == r) <span class="keyword">return</span> ...;</span><br><span class="line">		<span class="built_in">dw</span>(u);</span><br><span class="line">		<span class="keyword">return</span> pos &lt;= mid ? <span class="built_in">ask</span>(pos, lc, l, mid) : <span class="built_in">ask</span>(pos, rc, mid + <span class="number">1</span>, r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> u = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) <span class="keyword">return</span> ...;</span><br><span class="line">		<span class="built_in">dw</span>(u);</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (ql &lt;= mid) res ? <span class="built_in">qry</span>(ql, qr, lc, l, mid); <span class="comment">//?表示某种运算</span></span><br><span class="line">		<span class="keyword">if</span> (qr &gt; mid) res ? <span class="built_in">qry</span>(ql, qr, rc, mid + <span class="number">1</span>, r);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">undef</span> mid</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意空间开 $4$ 倍</p>
<h2 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">读入</span><br><span class="line">将询问按照(l所在块号，r)双关键字排序</span><br><span class="line">依次处理每一个询问:</span><br><span class="line">	移动指针</span><br><span class="line">    维护答案</span><br><span class="line">输出</span><br></pre></td></tr></table></figure>

<h2 id="莫队二次离线"><a href="#莫队二次离线" class="headerlink" title="莫队二次离线"></a>莫队二次离线</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> TOF <span class="comment">//Twice Offline</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">320</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Tag</span>&#123;</span> <span class="keyword">int</span> l, r, id, pos; &#125; tg1[N], tg2[N]; <span class="comment">//用vector可以不必排序,但慢一些,且有时候不好优化</span></span><br><span class="line">    <span class="keyword">int</span> tp1 = <span class="number">0</span>, tp2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> bid[N], f[<span class="number">2</span>][N]; <span class="comment">//f[0/1][i]:f(i,[1,i-1/i+1])</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prev</span><span class="params">()</span> <span class="comment">//处理块号并排序询问</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) bid[i] = (i - <span class="number">1</span>) / B + <span class="number">1</span>;</span><br><span class="line">        std::<span class="built_in">sort</span>(q + <span class="number">1</span>, q + m + <span class="number">1</span>, [&amp;](Q x, Q y)&#123; <span class="keyword">return</span> bid[x.l] == bid[y.l] ? x.r &lt; y.r : x.l &lt; y.l; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_tag</span><span class="params">()</span> <span class="comment">//打上离线标记</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, il = q[<span class="number">1</span>].r + <span class="number">1</span>, ir = q[<span class="number">1</span>].r; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (il &gt; q[i].l) tg1[++tp1] = &#123;q[i].l, il - <span class="number">1</span>, -i, ir&#125;;</span><br><span class="line">            <span class="keyword">else</span>  <span class="keyword">if</span> (il &lt; q[i].l) tg1[++tp1] = &#123;il, q[i].l - <span class="number">1</span>, i, ir&#125;; </span><br><span class="line">            il = q[i].l; <span class="comment">//一定要记得移动指针</span></span><br><span class="line">            <span class="keyword">if</span> (ir &lt; q[i].r) tg2[++tp2] = &#123;ir + <span class="number">1</span>, q[i].r, -i, il - <span class="number">1</span>&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ir &gt; q[i].r) tg2[++tp2] = &#123;q[i].r + <span class="number">1</span>, ir, i, il - <span class="number">1</span>&#125;;</span><br><span class="line">            ir = q[i].r;</span><br><span class="line">        &#125;</span><br><span class="line">        std::<span class="built_in">sort</span>(tg1 + <span class="number">1</span>, tg1 + tp1 + <span class="number">1</span>, [&amp;](Tag x, Tag y)&#123; <span class="keyword">return</span> x.pos &lt; y.pos; &#125;); <span class="comment">//标记排序</span></span><br><span class="line">        std::<span class="built_in">sort</span>(tg2 + <span class="number">1</span>, tg2 + tp2 + <span class="number">1</span>, [&amp;](Tag x, Tag y)&#123; <span class="keyword">return</span> x.pos &lt; y.pos; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">offline</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tp2; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (p &lt; tg2[i].pos &amp;&amp; ++p)</span><br><span class="line">            &#123;</span><br><span class="line">				计算f[<span class="number">0</span>][p]</span><br><span class="line">				完成a[p]的修改</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = tg2[i].l, r = tg2[i].r, k = (tg2[i].id &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>), id = tg2[i].id * k; l &lt;= r; ++l) q[id].ans += (计算贡献) * k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p &lt; n &amp;&amp; ++p)</span><br><span class="line">        &#123;</span><br><span class="line">            计算f[<span class="number">0</span>][p]</span><br><span class="line">			完成a[p]的修改</span><br><span class="line">        &#125;</span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tp1; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (p &lt; tg1[i].pos &amp;&amp; ++p)</span><br><span class="line">            &#123;</span><br><span class="line">				完成a[p]的修改</span><br><span class="line">                计算f[<span class="number">1</span>][p]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = tg1[i].l, r = tg1[i].r, k = (tg1[i].id &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>), id = tg1[i].id * k; l &lt;= r; ++l) q[id].ans += (计算贡献) * k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p &lt; n &amp;&amp; ++p)</span><br><span class="line">        &#123;</span><br><span class="line">            完成a[p]的修改</span><br><span class="line">            计算f[<span class="number">1</span>][p]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modui</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, il = q[<span class="number">1</span>].r + <span class="number">1</span>, ir = q[<span class="number">1</span>].r; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (il != q[i].l) q[i].ans += f[<span class="number">1</span>][il - <span class="number">1</span>] - f[<span class="number">1</span>][q[i].l - <span class="number">1</span>];</span><br><span class="line">            il = q[i].l;</span><br><span class="line">            <span class="keyword">if</span> (ir != q[i].r) q[i].ans += f[<span class="number">0</span>][q[i].r] - f[<span class="number">0</span>][ir];</span><br><span class="line">            ir = q[i].r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) q[i].ans += q[i - <span class="number">1</span>].ans; <span class="comment">//前缀和后才是答案</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) ans[q[i].id] = q[i].ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123; <span class="built_in">prev</span>(), <span class="built_in">add_tag</span>(), <span class="built_in">offline</span>(), <span class="built_in">modui</span>(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h2><p>额……，略</p>
<h2 id="点分治"><a href="#点分治" class="headerlink" title="点分治"></a>点分治</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_si</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (del[x]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = e[i].ne) <span class="keyword">if</span> (e[i].ver != fa) res += <span class="built_in">get_si</span>(e[i].ver, x);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_wc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> si, <span class="keyword">int</span> &amp;wc)</span> <span class="comment">//求重心(其实是一个保证删去后子树大小小于n/2的点,不一定是重心)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (del[x]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">1</span>, mx = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y, t; ~i; i = e[i].ne) <span class="keyword">if</span> ((y = e[i].ver) != fa)</span><br><span class="line">	&#123;</span><br><span class="line">		t = <span class="built_in">get_wc</span>(y, x, si, wc);</span><br><span class="line">		mx = <span class="built_in">max</span>(mx, t);</span><br><span class="line">		sum += t;</span><br><span class="line">	&#125;</span><br><span class="line">	mx = <span class="built_in">max</span>(mx, si - sum);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">LL</span>(mx &lt;&lt; <span class="number">1</span>) &lt;= si) wc = x;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//cp,cq是p[],q[]的计数器</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (del[x]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">get_wc</span>(x, <span class="number">-1</span>, <span class="built_in">get_si</span>(x, <span class="number">-1</span>), x);</span><br><span class="line">	del[x] = <span class="literal">true</span>;</span><br><span class="line">	cp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne)</span><br><span class="line">	&#123;</span><br><span class="line">		y = e[i].ver;</span><br><span class="line">		cq = <span class="number">0</span>;</span><br><span class="line">		得到y子树的,记录在q[]中</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cq; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			利用q[j]计算答案</span><br><span class="line">			将q[j]的信息记录在p[]中</span><br><span class="line">		&#125;</span><br><span class="line">		可能需要修正一些偏差量(比如多算的减掉)</span><br><span class="line">	&#125;</span><br><span class="line">	用p[]还原q[]计算时的修改</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = e[i].ne) res += <span class="built_in">calc</span>(e[i].ver);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h2><p>STL1 ： <code>std::set&lt;int&gt; s;</code> </p>
<p>STL2  ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ext/pb_ds/assoc_container.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ext/pb_ds/tree_policy.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_pbds;</span><br><span class="line">tree&lt;LL, null_type, less&lt;LL&gt;, rb_tree_tag,tree_order_statistics_node_update&gt; tr;</span><br><span class="line">函数为:</span><br><span class="line">tr.<span class="built_in">insert</span>(val);</span><br><span class="line">tr.<span class="built_in">erase</span>(tr.<span class="built_in">lower_bound</span>(val));</span><br><span class="line">tr.<span class="built_in">order_of_key</span>(val);</span><br><span class="line">tr.<span class="built_in">find_by_order</span>(rank);</span><br><span class="line">tr.<span class="built_in">lower_bound</span>(val)</span><br><span class="line">tr.<span class="built_in">upper_bound</span>(val)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>Splay ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Splay</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> rt, tot;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> <span class="keyword">int</span> ch[<span class="number">2</span>], fa, val, size, tag, cnt; &#125; tr[N];</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> ch(x, y) tr[(x)].ch[(y)]</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> fa(x) tr[(x)].fa</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> v(x) tr[(x)].val</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> si(x) tr[(x)].size</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> tg(x) tr[(x)].tag</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> c(x) tr[(x)].cnt</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="built_in">si</span>(x) = <span class="built_in">si</span>(<span class="built_in">ch</span>(x, <span class="number">0</span>)) + <span class="built_in">si</span>(<span class="built_in">ch</span>(x, <span class="number">1</span>)) + <span class="built_in">c</span>(x); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dw</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//文艺平衡树的交换</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">tg</span>(x))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">tg</span>(<span class="built_in">ch</span>(x, <span class="number">0</span>)) ^= <span class="number">1</span>, <span class="built_in">tg</span>(<span class="built_in">ch</span>(x, <span class="number">1</span>)) ^= <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">tg</span>(x) = <span class="number">0</span>;</span><br><span class="line">			std::<span class="built_in">swap</span>(<span class="built_in">ch</span>(x, <span class="number">0</span>), <span class="built_in">ch</span>(x, <span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">rot</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> y = <span class="built_in">fa</span>(x), z = <span class="built_in">fa</span>(y);</span><br><span class="line">		<span class="keyword">int</span> k = <span class="built_in">ch</span>(y, <span class="number">1</span>) == x;</span><br><span class="line">		<span class="built_in">ch</span>(z, <span class="built_in">ch</span>(z, <span class="number">1</span>) == y) = x, <span class="built_in">fa</span>(x) = z;</span><br><span class="line">		<span class="built_in">ch</span>(y, k) = <span class="built_in">ch</span>(x, k ^ <span class="number">1</span>), <span class="built_in">fa</span>(<span class="built_in">ch</span>(x, k ^ <span class="number">1</span>)) = y;</span><br><span class="line">		<span class="built_in">ch</span>(x, k ^ <span class="number">1</span>) = y, <span class="built_in">fa</span>(y) = x;</span><br><span class="line">		<span class="built_in">up</span>(y), <span class="built_in">up</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="built_in">fa</span>(x) != f)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> y = <span class="built_in">fa</span>(x), z = <span class="built_in">fa</span>(y);</span><br><span class="line">			<span class="keyword">if</span> (z != f) (<span class="built_in">ch</span>(y, <span class="number">1</span>) == x) ^ (<span class="built_in">ch</span>(z, <span class="number">1</span>) == y) ? <span class="built_in">rot</span>(x) : <span class="built_in">rot</span>(y);</span><br><span class="line">			<span class="built_in">rot</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!f) rt = x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> u = rt;</span><br><span class="line">		<span class="keyword">if</span> (!u) <span class="keyword">return</span> ;</span><br><span class="line">		<span class="keyword">while</span> (x != <span class="built_in">v</span>(u) &amp;&amp; <span class="built_in">ch</span>(u, x &gt; <span class="built_in">v</span>(u)) ) u = <span class="built_in">ch</span>(u, x &gt; <span class="built_in">v</span>(u));</span><br><span class="line">		<span class="built_in">splay</span>(u, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">near</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> dir)</span> <span class="comment">//查询前驱(0)后继(1)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">find</span>(x);</span><br><span class="line">		<span class="keyword">int</span> u = rt;</span><br><span class="line">		<span class="keyword">if</span> ((<span class="built_in">v</span>(u) &gt; x &amp;&amp; dir) || (<span class="built_in">v</span>(u) &lt; x &amp;&amp; !dir)) <span class="keyword">return</span> u;</span><br><span class="line">		u = <span class="built_in">ch</span>(u, dir);</span><br><span class="line">		<span class="keyword">while</span> (<span class="built_in">ch</span>(u, dir ^ <span class="number">1</span>)) u = <span class="built_in">ch</span>(u, dir ^ <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> u;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> last = <span class="built_in">near</span>(x, <span class="number">0</span>), next = <span class="built_in">near</span>(x, <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">splay</span>(last, <span class="number">0</span>), <span class="built_in">splay</span>(next, last);</span><br><span class="line">		<span class="keyword">int</span> t = <span class="built_in">ch</span>(next, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">c</span>(t) &gt; <span class="number">1</span>) --<span class="built_in">c</span>(t), <span class="built_in">splay</span>(t, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">ch</span>(next, <span class="number">0</span>) = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> u = rt, f = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (u &amp;&amp; <span class="built_in">v</span>(u) != x) f = u, u = <span class="built_in">ch</span>(u, x &gt; <span class="built_in">v</span>(u));</span><br><span class="line">		<span class="keyword">if</span> (u) ++<span class="built_in">c</span>(u);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			u = ++tot;</span><br><span class="line">			<span class="keyword">if</span> (f) <span class="built_in">ch</span>(f, x &gt; <span class="built_in">v</span>(f)) = u;</span><br><span class="line">			tr[u] = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, f, x, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">splay</span>(u, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get_k</span><span class="params">(<span class="keyword">int</span> k)</span> <span class="comment">//查询排名为k的数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> u = rt;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">si</span>(u) &lt; k) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">dw</span>(u);</span><br><span class="line">			<span class="keyword">int</span> y = <span class="built_in">ch</span>(u, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (k &gt; <span class="built_in">si</span>(y) + <span class="built_in">c</span>(u)) k -= <span class="built_in">si</span>(y) + <span class="built_in">c</span>(u), u = <span class="built_in">ch</span>(u, <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">si</span>(y) &gt;= k) u = y;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">v</span>(u);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">undef</span> ch</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">undef</span> fa</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">undef</span> v</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">undef</span> si</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">undef</span> tg</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">undef</span> c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点是可拓展性强，缺点是慢（被卡的化可以试试多转几下）</p>
<p>FHQ Treap ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> FHQ</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> <span class="keyword">int</span> priority, size, val, left_child, right_child; &#125; tr[N];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> p(x) tr[(x)].priority</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> si(x) tr[(x)].size</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> v(x) tr[(x)].val</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc(x) tr[(x)].left_child</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc(x) tr[(x)].right_child</span></span><br><span class="line">    <span class="keyword">int</span> rub[N], top = <span class="number">0</span>, num = <span class="number">0</span>, rt;</span><br><span class="line">    <span class="function">std::mt19937 <span class="title">rud</span><span class="params">(<span class="number">114514</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="built_in">si</span>(x) = <span class="built_in">si</span>(<span class="built_in">lc</span>(x)) + <span class="built_in">si</span>(<span class="built_in">rc</span>(x)) + <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnd</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = (top ? rub[top--] : ++num);</span><br><span class="line">        tr[res] = &#123;(<span class="keyword">int</span>)<span class="built_in">rud</span>(), <span class="number">1</span>, val, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">//合并以x,y为根的树,返回合并后的根(要保证x的val都小于y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">p</span>(x) &gt; <span class="built_in">p</span>(y))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">rc</span>(x) = <span class="built_in">merge</span>(<span class="built_in">rc</span>(x), y);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">up</span>(x), x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">lc</span>(y) = <span class="built_in">merge</span>(x, <span class="built_in">lc</span>(y));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">up</span>(y), y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> val, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span> <span class="comment">//把以u为根的树分裂为x,y</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!u) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(x = y = <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">v</span>(u) &lt;= val) <span class="built_in">split</span>(<span class="built_in">rc</span>(x = u), val, <span class="built_in">rc</span>(u), y);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">split</span>(<span class="built_in">lc</span>(y = u), val, x, <span class="built_in">lc</span>(u));</span><br><span class="line">        <span class="built_in">up</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tx, ty;</span><br><span class="line">        <span class="built_in">split</span>(rt, val, tx, ty), rt = <span class="built_in">merge</span>(<span class="built_in">merge</span>(tx, <span class="built_in">newnd</span>(val)), ty);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tx, ty, tz;</span><br><span class="line">        <span class="built_in">split</span>(rt, val, tx, ty);</span><br><span class="line">        <span class="built_in">split</span>(tx, val - <span class="number">1</span>, tx, tz);</span><br><span class="line">        rub[++top] = tz;</span><br><span class="line">        tz = <span class="built_in">merge</span>(<span class="built_in">lc</span>(tz), <span class="built_in">rc</span>(tz));</span><br><span class="line">        rt = <span class="built_in">merge</span>(<span class="built_in">merge</span>(tx, tz), ty);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rank</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tx, ty, res;</span><br><span class="line">        <span class="built_in">split</span>(rt, val - <span class="number">1</span>, tx, ty);</span><br><span class="line">        res = <span class="built_in">si</span>(tx) + <span class="number">1</span>;</span><br><span class="line">        rt = <span class="built_in">merge</span>(tx, ty);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getk</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t; u; )</span><br><span class="line">            <span class="keyword">if</span> ((t = <span class="built_in">si</span>(<span class="built_in">lc</span>(u)) + <span class="number">1</span>) == k) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t &gt; k) u = <span class="built_in">lc</span>(u);</span><br><span class="line">            <span class="keyword">else</span> k -= t, u = <span class="built_in">rc</span>(u);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">v</span>(u); <span class="comment">//可视题目改</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getk</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">getk</span>(rt, k); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tx, ty, res;</span><br><span class="line">        <span class="built_in">split</span>(rt, val - <span class="number">1</span>, tx, ty);</span><br><span class="line">        res = <span class="built_in">getk</span>(tx, <span class="built_in">si</span>(tx));</span><br><span class="line">        rt = <span class="built_in">merge</span>(tx, ty);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">suc</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tx, ty, res;</span><br><span class="line">        <span class="built_in">split</span>(rt, val, tx, ty);</span><br><span class="line">        res = <span class="built_in">getk</span>(ty, <span class="number">1</span>);</span><br><span class="line">        rt = <span class="built_in">merge</span>(tx, ty);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> p</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> si</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> v</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点是好打且较快</p>
<p>SBT ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> SBT</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">SBT</span>&#123;</span> <span class="keyword">int</span> size, lc, rc, val; &#125; tr[N];</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> si(x) tr[(x)].size</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> rc(x) tr[(x)].rc</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> lc(x) tr[(x)].lc</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> v(x) tr[(x)].val</span></span><br><span class="line">	<span class="keyword">int</span> rt, tot;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">r_r</span><span class="params">(<span class="keyword">int</span> &amp;t)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> k = <span class="built_in">lc</span>(t);</span><br><span class="line">		<span class="built_in">lc</span>(t) = <span class="built_in">rc</span>(k), <span class="built_in">rc</span>(k) = t;</span><br><span class="line">		<span class="built_in">si</span>(k) = <span class="built_in">si</span>(t), <span class="built_in">si</span>(t) = <span class="built_in">si</span>(<span class="built_in">rc</span>(t)) + <span class="built_in">si</span>(<span class="built_in">lc</span>(t)) + <span class="number">1</span>;</span><br><span class="line">		t = k;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">l_r</span><span class="params">(<span class="keyword">int</span> &amp;t)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> k = <span class="built_in">rc</span>(t);</span><br><span class="line">		<span class="built_in">rc</span>(t) = <span class="built_in">lc</span>(k), <span class="built_in">lc</span>(k) = t;</span><br><span class="line">		<span class="built_in">si</span>(k) = <span class="built_in">si</span>(t), <span class="built_in">si</span>(t) = <span class="built_in">si</span>(<span class="built_in">rc</span>(t)) + <span class="built_in">si</span>(<span class="built_in">lc</span>(t)) + <span class="number">1</span>;</span><br><span class="line">		t = k;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">mt</span><span class="params">(<span class="keyword">int</span> &amp;t, <span class="keyword">bool</span> f)</span> <span class="comment">//maintain</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!f)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">si</span>(<span class="built_in">lc</span>(<span class="built_in">lc</span>(t))) &gt; <span class="built_in">si</span>(<span class="built_in">rc</span>(t))) <span class="built_in">r_r</span>(t);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">si</span>(<span class="built_in">rc</span>(<span class="built_in">lc</span>(t))) &gt; <span class="built_in">si</span>(<span class="built_in">rc</span>(t))) <span class="built_in">l_r</span>(<span class="built_in">lc</span>(t)), <span class="built_in">r_r</span>(t);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">si</span>(<span class="built_in">rc</span>(<span class="built_in">rc</span>(t))) &gt; <span class="built_in">si</span>(<span class="built_in">lc</span>(t))) <span class="built_in">l_r</span>(t);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">si</span>(<span class="built_in">lc</span>(<span class="built_in">rc</span>(t))) &gt; <span class="built_in">si</span>(<span class="built_in">lc</span>(t))) <span class="built_in">r_r</span>(<span class="built_in">rc</span>(t)), <span class="built_in">l_r</span>(t);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">mt</span>(<span class="built_in">lc</span>(t), <span class="literal">false</span>), <span class="built_in">mt</span>(<span class="built_in">rc</span>(t), <span class="literal">true</span>);</span><br><span class="line">		<span class="built_in">mt</span>(t, <span class="literal">false</span>), <span class="built_in">mt</span>(t, <span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> &amp;t, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!t) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(tr[t = ++tot] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, x&#125;);</span><br><span class="line">		++<span class="built_in">si</span>(t);</span><br><span class="line">		x &lt;= <span class="built_in">v</span>(t) ? <span class="built_in">ins</span>(<span class="built_in">lc</span>(t), x) : <span class="built_in">ins</span>(<span class="built_in">rc</span>(t), x);</span><br><span class="line">		<span class="built_in">mt</span>(t, x &gt; <span class="built_in">v</span>(t));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> &amp;t, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		--<span class="built_in">si</span>(t);</span><br><span class="line">		<span class="keyword">if</span> ((<span class="built_in">v</span>(t) == x) || (<span class="built_in">v</span>(t) &gt; x &amp;&amp; !<span class="built_in">lc</span>(t)) || (<span class="built_in">v</span>(t) &lt; x &amp;&amp; !<span class="built_in">rc</span>(t)))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> res = <span class="built_in">v</span>(t);</span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">lc</span>(t) || !<span class="built_in">rc</span>(t)) t = <span class="built_in">lc</span>(t) + <span class="built_in">rc</span>(t);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">v</span>(t) = <span class="built_in">del</span>(<span class="built_in">lc</span>(t), <span class="built_in">v</span>(t) + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">return</span> res;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">v</span>(t) &gt; x ? <span class="built_in">del</span>(<span class="built_in">lc</span>(t), x) : <span class="built_in">del</span>(<span class="built_in">rc</span>(t), x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">rk</span><span class="params">(<span class="keyword">int</span> &amp;t, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">v</span>(t) &gt;= x ? <span class="built_in">rk</span>(<span class="built_in">lc</span>(t), x) : <span class="built_in">si</span>(<span class="built_in">lc</span>(t)) + <span class="number">1</span> + <span class="built_in">rk</span>(<span class="built_in">rc</span>(t), x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get_k</span><span class="params">(<span class="keyword">int</span> &amp;t, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (x == <span class="built_in">si</span>(<span class="built_in">lc</span>(t)) + <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">v</span>(t);</span><br><span class="line">		<span class="keyword">return</span> x &lt;= <span class="built_in">si</span>(<span class="built_in">lc</span>(t)) ? <span class="built_in">get_k</span>(<span class="built_in">lc</span>(t), x) : <span class="built_in">get_k</span>(<span class="built_in">rc</span>(t), x - <span class="number">1</span> - <span class="built_in">si</span>(<span class="built_in">lc</span>(t)));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">pred</span><span class="params">(<span class="keyword">int</span> &amp;t, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!t) <span class="keyword">return</span> x;</span><br><span class="line">		<span class="keyword">if</span> (x &lt;= <span class="built_in">v</span>(t)) <span class="keyword">return</span> <span class="built_in">pred</span>(<span class="built_in">lc</span>(t), x);</span><br><span class="line">		<span class="keyword">int</span> res = <span class="built_in">pred</span>(<span class="built_in">rc</span>(t), x);</span><br><span class="line">		<span class="keyword">if</span> (res == x) res = <span class="built_in">v</span>(t);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">succ</span><span class="params">(<span class="keyword">int</span> &amp;t, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!t) <span class="keyword">return</span> x;</span><br><span class="line">		<span class="keyword">if</span> (x &gt;= <span class="built_in">v</span>(t)) <span class="keyword">return</span> <span class="built_in">succ</span>(<span class="built_in">rc</span>(t), x);</span><br><span class="line">		<span class="keyword">int</span> res = <span class="built_in">succ</span>(<span class="built_in">lc</span>(t), x);</span><br><span class="line">		<span class="keyword">if</span> (res == x) res = <span class="built_in">v</span>(t);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">undef</span> si</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">undef</span> v</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点是快</p>
<h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> SL <span class="comment">//Skip List</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> D = <span class="number">15</span>;</span><br><span class="line">    <span class="function">std::mt19937 <span class="title">rud</span><span class="params">(<span class="number">114514</span>)</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        Node *nx = <span class="literal">nullptr</span>, *dw = <span class="literal">nullptr</span>; <span class="comment">//后继,下层</span></span><br><span class="line">        <span class="keyword">int</span> v = <span class="number">0</span>, si = <span class="number">0</span>, lvl = <span class="number">0</span>; <span class="comment">//权值,对应范围的大小,层数</span></span><br><span class="line">    &#125; pool[N &lt;&lt; <span class="number">2</span>], *upd[D + <span class="number">1</span>], *rt; <span class="comment">//池,待跟新,根</span></span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="function">Node* <span class="title">newnd</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> &amp;pool[++tot]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(Node *u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;dw == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(u-&gt;si = (u-&gt;v != -INF));</span><br><span class="line">        Node *end = u-&gt;nx == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : u-&gt;nx-&gt;dw;</span><br><span class="line">        u-&gt;si = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node *it = u-&gt;dw; it != end; it = it-&gt;nx) u-&gt;si += it-&gt;si;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> val, Node *u = rt)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        upd[u-&gt;lvl] = u;</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;nx != <span class="literal">nullptr</span> &amp;&amp; u-&gt;nx-&gt;v &lt;= val) <span class="keyword">return</span> <span class="built_in">find</span>(val, u-&gt;nx);</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;dw != <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="built_in">find</span>(val, u-&gt;dw);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        rt = <span class="built_in">newnd</span>();</span><br><span class="line">        rt-&gt;lvl = <span class="number">1</span>, rt-&gt;v = -INF, upd[<span class="number">1</span>] = rt;</span><br><span class="line">        Node *t = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (rt-&gt;lvl &lt; D)</span><br><span class="line">        &#123;</span><br><span class="line">            t = rt, rt = <span class="built_in">newnd</span>();</span><br><span class="line">            upd[rt-&gt;lvl = t-&gt;lvl + <span class="number">1</span>] = rt;</span><br><span class="line">            rt-&gt;dw = t, rt-&gt;v = -INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">find</span>(val - <span class="number">1</span>);</span><br><span class="line">        Node *p = <span class="built_in">newnd</span>(), *t = <span class="literal">nullptr</span>;</span><br><span class="line">        p-&gt;v = val, p-&gt;nx = upd[<span class="number">1</span>]-&gt;nx, upd[<span class="number">1</span>]-&gt;nx = p;</span><br><span class="line">        <span class="built_in">up</span>(upd[<span class="number">1</span>]);</span><br><span class="line">        upd[p-&gt;lvl = <span class="number">1</span>] = p;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;lvl &lt; D &amp;&amp; !(<span class="built_in">rud</span>() &amp; <span class="number">2</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            t = p, p = <span class="built_in">newnd</span>();</span><br><span class="line">            p-&gt;lvl = t-&gt;lvl + <span class="number">1</span>, p-&gt;v = val, p-&gt;dw = t;</span><br><span class="line">            p-&gt;nx = upd[p-&gt;lvl]-&gt;nx, upd[p-&gt;lvl]-&gt;nx = p;</span><br><span class="line">            <span class="built_in">up</span>(upd[p-&gt;lvl]);</span><br><span class="line">            upd[p-&gt;lvl] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= D; ++i) <span class="built_in">up</span>(upd[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">find</span>(val - <span class="number">1</span>);</span><br><span class="line">        Node *t = <span class="literal">nullptr</span>; <span class="keyword">bool</span> f = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= D; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (f &amp;&amp; upd[i]-&gt;nx != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">1</span> &amp;&amp; upd[i]-&gt;nx-&gt;dw != t) f = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> t = upd[i]-&gt;nx, upd[i]-&gt;nx = t-&gt;nx;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">up</span>(upd[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rk</span><span class="params">(<span class="keyword">int</span> val, Node *u = rt)</span> <span class="comment">//查小于val的数的个数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;nx != <span class="literal">nullptr</span> &amp;&amp; u-&gt;nx-&gt;v &lt; val) <span class="keyword">return</span> u-&gt;si + <span class="built_in">rk</span>(val, u-&gt;nx);</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;dw != <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="built_in">rk</span>(val, u-&gt;dw);</span><br><span class="line">        <span class="keyword">return</span> u-&gt;si;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> k, Node *u = rt)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;si &lt; k) <span class="keyword">return</span> <span class="built_in">kth</span>(k - u-&gt;si, u-&gt;nx);</span><br><span class="line">        <span class="keyword">return</span> u-&gt;dw == <span class="literal">nullptr</span> ? u-&gt;v : <span class="built_in">kth</span>(k, u-&gt;dw);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">find</span>(val - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> upd[<span class="number">1</span>]-&gt;v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">suc</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">find</span>(val);</span><br><span class="line">        <span class="keyword">return</span> upd[<span class="number">1</span>]-&gt;nx-&gt;v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CDQ-分治"><a href="#CDQ-分治" class="headerlink" title="CDQ 分治"></a>CDQ 分治</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdq</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cdq</span>(l, mid);</span><br><span class="line">    计算[l, mid]对[mid + <span class="number">1</span>, r]的影响/计算跨过mid的贡献</span><br><span class="line">    <span class="built_in">cdq</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个顺序不是严格的，可以先左右都递归了再计算中间</p>
<h2 id="李超线段树"><a href="#李超线段树" class="headerlink" title="李超线段树"></a>李超线段树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> k; LL b;</span><br><span class="line">    <span class="function">LL <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> dis[bid[x]] * k + b; &#125;</span><br><span class="line">&#125; li[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">namespace</span> LC</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> std::max;</span><br><span class="line">    <span class="keyword">using</span> std::min;</span><br><span class="line">    <span class="keyword">int</span> id[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    LL mn[N &lt;&lt; <span class="number">4</span>];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mid (l + r &gt;&gt; 1)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc (u &lt;&lt; 1)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc (u &lt;&lt; 1 | 1)</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> li[a].<span class="built_in">calc</span>(x) &gt; li[b].<span class="built_in">calc</span>(x); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		mn[u] = <span class="built_in">min</span>(mn[u], <span class="built_in">min</span>(li[id[u]].<span class="built_in">calc</span>(l), li[id[u]].<span class="built_in">calc</span>(r)));</span><br><span class="line">		mn[u] = <span class="built_in">min</span>(mn[u], <span class="built_in">min</span>(mn[lc], mn[rc])); </span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">judge</span>(id[u], d, mid)) std::<span class="built_in">swap</span>(id[u], d);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">judge</span>(id[u], d, l)) <span class="built_in">upd</span>(lc, l, mid, ql, qr, d);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">judge</span>(id[u], d, r)) <span class="built_in">upd</span>(rc, mid + <span class="number">1</span>, r, ql, qr, d);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">up</span>(u, l, r); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= mid) <span class="built_in">upd</span>(lc, l, mid, ql, qr, d);</span><br><span class="line">        <span class="keyword">if</span> (qr &gt; mid) <span class="built_in">upd</span>(rc, mid + <span class="number">1</span>, r, ql, qr, d);</span><br><span class="line">        <span class="built_in">up</span>(u, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">LL <span class="title">ask</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) <span class="keyword">return</span> mn[u];</span><br><span class="line">        LL res = <span class="built_in">min</span>(li[id[u]].<span class="built_in">calc</span>(<span class="built_in">max</span>(l, ql)), li[id[u]].<span class="built_in">calc</span>(<span class="built_in">min</span>(r, qr)));</span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= mid) res = <span class="built_in">min</span>(res, <span class="built_in">ask</span>(lc, l, mid, ql, qr));</span><br><span class="line">        <span class="keyword">if</span> (qr &gt; mid) res = <span class="built_in">min</span>(res, <span class="built_in">ask</span>(rc, mid + <span class="number">1</span>, r, ql, qr));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> mid</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="主席树"><a href="#主席树" class="headerlink" title="主席树"></a>主席树</h2><p>普通：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> CT <span class="comment">//Chairman Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> NN = <span class="number">5e6</span> + <span class="number">100</span>; <span class="comment">//点一定要开够</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> <span class="keyword">int</span> lc, rc, dat; &#125; tr[NN];</span><br><span class="line">    <span class="keyword">int</span> rt[N], tot = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc(x) tr[(x)].lc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc(x) tr[(x)].rc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> dat(x) tr[(x)].dat</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">(<span class="keyword">int</span> &amp;u, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        u = ++tot;</span><br><span class="line">        tr[u] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) <span class="built_in">bd</span>(<span class="built_in">lc</span>(u), l, mid), <span class="built_in">bd</span>(<span class="built_in">rc</span>(u), mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cg</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> d, <span class="keyword">int</span> &amp;u, <span class="keyword">int</span> la, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        u = ++tot;</span><br><span class="line">        tr[u] = tr[la];</span><br><span class="line">        <span class="built_in">dat</span>(u) += d;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line">        (pos &lt;= mid) ? <span class="built_in">cg</span>(pos, d, <span class="built_in">lc</span>(u), <span class="built_in">lc</span>(la), l, mid) : <span class="built_in">cg</span>(pos, d, <span class="built_in">rc</span>(u), <span class="built_in">rc</span>(la), mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> ul, <span class="keyword">int</span> ur, <span class="keyword">int</span> k, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="built_in">dat</span>(<span class="built_in">lc</span>(ur)) - <span class="built_in">dat</span>(<span class="built_in">lc</span>(ul));</span><br><span class="line">        <span class="keyword">return</span> (t &gt;= k) ? <span class="built_in">ask</span>(<span class="built_in">lc</span>(ul), <span class="built_in">lc</span>(ur), k, l, mid) : <span class="built_in">ask</span>(<span class="built_in">rc</span>(ul), <span class="built_in">rc</span>(ur), k - t, mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> dat</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> mid </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>带修：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> BIT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> NN = <span class="number">6e7</span> + <span class="number">100</span>, D = <span class="number">20</span>; <span class="comment">//任然是空间要开够</span></span><br><span class="line">    <span class="keyword">int</span> rts[<span class="number">2</span>][D];</span><br><span class="line">    <span class="keyword">namespace</span> CT</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> <span class="keyword">int</span> lc, rc, cnt; &#125; tr[NN];</span><br><span class="line">        <span class="keyword">int</span> rt[N], tot = <span class="number">0</span>;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> lc(x) tr[(x)].lc</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> rc(x) tr[(x)].rc</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> ct(x) tr[(x)].cnt</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">cg</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> d, <span class="keyword">int</span> &amp;u, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = num)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!u) u = ++tot;</span><br><span class="line">            <span class="built_in">ct</span>(u) += d;</span><br><span class="line">            <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line">            (pos &lt;= mid) ? <span class="built_in">cg</span>(pos, d, <span class="built_in">lc</span>(u), l, mid) : <span class="built_in">cg</span>(pos, d, <span class="built_in">rc</span>(u), mid + <span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = num)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = rts[<span class="number">1</span>][<span class="number">0</span>]; i; --i) sum += <span class="built_in">ct</span>(<span class="built_in">lc</span>(rts[<span class="number">1</span>][i]));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = rts[<span class="number">0</span>][<span class="number">0</span>]; i; --i) sum -= <span class="built_in">ct</span>(<span class="built_in">lc</span>(rts[<span class="number">0</span>][i]));</span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = rts[<span class="number">1</span>][<span class="number">0</span>]; i; --i) rts[<span class="number">1</span>][i] = <span class="built_in">lc</span>(rts[<span class="number">1</span>][i]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = rts[<span class="number">0</span>][<span class="number">0</span>]; i; --i) rts[<span class="number">0</span>][i] = <span class="built_in">lc</span>(rts[<span class="number">0</span>][i]);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">ask</span>(k, l, mid);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = rts[<span class="number">1</span>][<span class="number">0</span>]; i; --i) rts[<span class="number">1</span>][i] = <span class="built_in">rc</span>(rts[<span class="number">1</span>][i]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = rts[<span class="number">0</span>][<span class="number">0</span>]; i; --i) rts[<span class="number">0</span>][i] = <span class="built_in">rc</span>(rts[<span class="number">0</span>][i]);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">ask</span>(k - sum, mid + <span class="number">1</span>, r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">undef</span> ct</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">undef</span> mid</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">using</span> CT::rt;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lb(x) ((x) &amp; (-(x)))</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cg</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span></span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += <span class="built_in">lb</span>(i)) CT::<span class="built_in">cg</span>(a[x], d, rt[i]); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        rts[<span class="number">0</span>][<span class="number">0</span>] = rts[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i; i ^= <span class="built_in">lb</span>(i)) rts[<span class="number">1</span>][++rts[<span class="number">1</span>][<span class="number">0</span>]] = rt[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l - <span class="number">1</span>; i; i ^= <span class="built_in">lb</span>(i)) rts[<span class="number">0</span>][++rts[<span class="number">0</span>][<span class="number">0</span>]] = rt[i];</span><br><span class="line">        <span class="keyword">return</span> CT::<span class="built_in">ask</span>(k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> lb</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="K-D-Tree"><a href="#K-D-Tree" class="headerlink" title="K-D Tree"></a>K-D Tree</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span> <span class="keyword">int</span> x[D], w; &#125;;</span><br><span class="line"><span class="keyword">namespace</span> KDT <span class="comment">//K-D Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> DB a = <span class="number">0.725</span>;</span><br><span class="line">    <span class="keyword">int</span> rt, top, rub[M], cur, tot; <span class="comment">//rub:回收空间</span></span><br><span class="line">    Point p[M];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> mn[D], mx[D], sum, lc, rc, si, k;</span><br><span class="line">        Point p;</span><br><span class="line">    &#125; tr[M];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mn(x) tr[(x)].mn</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mx(x) tr[(x)].mx</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sum(x) tr[(x)].sum</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc(x) tr[(x)].lc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc(x) tr[(x)].rc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> si(x) tr[(x)].si</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> k(x) tr[(x)].k</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> p(x) tr[(x)].p</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> top ? rub[top--] : ++cur; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ls = <span class="built_in">lc</span>(u), rs = <span class="built_in">rc</span>(u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; D; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">mn</span>(u)[i] = <span class="built_in">mx</span>(u)[i] = <span class="built_in">p</span>(u).x[i];</span><br><span class="line">            <span class="keyword">if</span> (ls) <span class="built_in">mn</span>(u)[i] = <span class="built_in">min</span>(<span class="built_in">mn</span>(u)[i], <span class="built_in">mn</span>(ls)[i]), <span class="built_in">mx</span>(u)[i] = <span class="built_in">max</span>(<span class="built_in">mx</span>(u)[i], <span class="built_in">mx</span>(ls)[i]);</span><br><span class="line">            <span class="keyword">if</span> (rs) <span class="built_in">mn</span>(u)[i] = <span class="built_in">min</span>(<span class="built_in">mn</span>(u)[i], <span class="built_in">mn</span>(rs)[i]), <span class="built_in">mx</span>(u)[i] = <span class="built_in">max</span>(<span class="built_in">mx</span>(u)[i], <span class="built_in">mx</span>(rs)[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sum</span>(u) = <span class="built_in">sum</span>(ls) + <span class="built_in">sum</span>(rs) + <span class="built_in">p</span>(u).w, <span class="built_in">si</span>(u) = <span class="built_in">si</span>(ls) + <span class="built_in">si</span>(rs) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>, u = <span class="built_in">newnode</span>();</span><br><span class="line">        <span class="built_in">nth_element</span>(p + l, p + mid, p + r + <span class="number">1</span>, [&amp;](Point a, Point b)&#123; <span class="keyword">return</span> a.x[k] &lt; b.x[k]; &#125;);</span><br><span class="line">        <span class="built_in">k</span>(u) = k, <span class="built_in">p</span>(u) = p[mid], <span class="built_in">lc</span>(u) = <span class="built_in">build</span>(l, mid - <span class="number">1</span>, k ^ <span class="number">1</span>), <span class="built_in">rc</span>(u) = <span class="built_in">build</span>(mid + <span class="number">1</span>, r, k ^ <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">up</span>(u), u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get_p</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123; <span class="keyword">if</span> (u) <span class="built_in">get_p</span>(<span class="built_in">lc</span>(u)), p[++tot] = <span class="built_in">p</span>(u), rub[++top] = u, <span class="built_in">get_p</span>(<span class="built_in">rc</span>(u)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> &amp;u)</span></span>&#123; <span class="keyword">if</span> (<span class="built_in">si</span>(u) * a &lt; <span class="built_in">max</span>(<span class="built_in">si</span>(<span class="built_in">lc</span>(u)), <span class="built_in">si</span>(<span class="built_in">rc</span>(u)))) tot = <span class="number">0</span>, <span class="built_in">get_p</span>(u), u = <span class="built_in">build</span>(<span class="number">1</span>, tot, <span class="built_in">k</span>(u)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> &amp;u, Point x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!u)</span><br><span class="line">        &#123;</span><br><span class="line">            u = <span class="built_in">newnode</span>();</span><br><span class="line">            <span class="built_in">lc</span>(u) = <span class="built_in">rc</span>(u) = <span class="built_in">k</span>(u) = <span class="number">0</span>, <span class="built_in">p</span>(u) = x;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">up</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x.x[<span class="built_in">k</span>(u)] &lt;= <span class="built_in">p</span>(u).x[<span class="built_in">k</span>(u)]) <span class="built_in">ins</span>(<span class="built_in">lc</span>(u), x);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">ins</span>(<span class="built_in">rc</span>(u), x);</span><br><span class="line">        <span class="built_in">up</span>(u), <span class="built_in">chk</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> mx[D], <span class="keyword">int</span> mn[D], <span class="keyword">int</span> l[D], <span class="keyword">int</span> r[D])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; D; ++i) <span class="keyword">if</span> (r[i] &lt; mx[i] || l[i] &gt; mn[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">out</span><span class="params">(<span class="keyword">int</span> mx[D], <span class="keyword">int</span> mn[D], <span class="keyword">int</span> l[D], <span class="keyword">int</span> r[D])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; D; ++i) <span class="keyword">if</span> (l[i] &gt; mx[i] || r[i] &lt; mn[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l[D], <span class="keyword">int</span> r[D])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!u || <span class="built_in">out</span>(<span class="built_in">mx</span>(u), <span class="built_in">mn</span>(u), l, r)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">in</span>(<span class="built_in">mx</span>(u), <span class="built_in">mn</span>(u), l, r)) <span class="keyword">return</span> <span class="built_in">sum</span>(u);</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">in</span>(<span class="built_in">p</span>(u).x, <span class="built_in">p</span>(u).x, l, r) ? <span class="built_in">p</span>(u).w : <span class="number">0</span>) + <span class="built_in">ask</span>(<span class="built_in">lc</span>(u), l, r) + <span class="built_in">ask</span>(<span class="built_in">rc</span>(u), l, r);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">undef</span> mn</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">undef</span> mx</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">undef</span> sum</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">undef</span> si</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">undef</span> k</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">undef</span> p</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="笛卡尔树"><a href="#笛卡尔树" class="headerlink" title="笛卡尔树"></a>笛卡尔树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) tr[i].dat = a[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, k; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		k = top;</span><br><span class="line">		<span class="comment">//找到最下面的一个比当前小的,满足小根堆</span></span><br><span class="line">		<span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; tr[stk[k]].dat &gt; tr[i].dat) --k;</span><br><span class="line">		<span class="keyword">if</span> (k) tr[stk[k]].rc = i;</span><br><span class="line">		<span class="keyword">if</span> (k &lt; top) tr[i].lc = stk[k + <span class="number">1</span>];</span><br><span class="line">		top = k;</span><br><span class="line">		stk[++top] = i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>二叉：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">建立小根堆q,把所有点放入</span><br><span class="line"><span class="keyword">while</span> (堆中元素个数 &gt;= <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">int</span> y = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">    ans += x + y;</span><br><span class="line">    q.<span class="built_in">push</span>(x + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多叉：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">用权值为<span class="number">0</span>的点补足点数,使(n - <span class="number">1</span>) % (k - <span class="number">1</span>) == <span class="number">0</span></span><br><span class="line">建立小根堆q,把所有点放入</span><br><span class="line"><span class="keyword">while</span> (堆中元素个数 &gt;= k)</span><br><span class="line">&#123;</span><br><span class="line">    取出前k个元素</span><br><span class="line">    ans += 前k个元素和;</span><br><span class="line">    q.<span class="built_in">push</span>(前k个元素和);</span><br><span class="line">&#125;</span><br><span class="line">把堆中剩下元素取出,计算贡献</span><br></pre></td></tr></table></figure>

<h2 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h2><p>重链剖分：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> father, <span class="keyword">int</span> depth)</span> <span class="comment">//求每个的重儿子</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dep[x] = depth, fa[x] = father, si[x] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne) <span class="keyword">if</span> ((y = e[i].ver) != father)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">dfs1</span>(y, x, depth + <span class="number">1</span>);</span><br><span class="line">		si[x] += si[y];</span><br><span class="line">		<span class="keyword">if</span> (si[son[x]] &lt; si[y]) son[x] = y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> t)</span> <span class="comment">//求dfs序,t:当前节点所在重链的顶点</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	id[x] = ++cnt, nw[cnt] = w[x], top[x] = t;</span><br><span class="line">	<span class="keyword">if</span> (!son[x]) <span class="keyword">return</span>; <span class="comment">//若是叶节点,直接返回</span></span><br><span class="line">	<span class="built_in">dfs2</span>(son[x], t);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = e[i].ne)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> y = e[i].ver;</span><br><span class="line">		<span class="keyword">if</span> (y == fa[x] || y == son[x]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs2</span>(y, y); <span class="comment">//轻儿子一定是其所在重链的顶点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">path</span><span class="params">(<span class="keyword">int</span> )</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> <span class="comment">//路径操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (top[u] != top[v]) <span class="comment">//当这两个点不在同一重链</span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> (dep[top[u]] &lt; dep[top[v]]) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">		<span class="built_in">work</span>(id[top[u]], id[u]); <span class="comment">//注意在dfs序中top[u]在u前面</span></span><br><span class="line">		u = fa[top[u]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dep[u] &lt; dep[v]) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">	<span class="built_in">work</span>(id[v], id[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123; <span class="built_in">work</span>(id[u], id[u] + si[u] - <span class="number">1</span>); &#125; <span class="comment">//子树操作</span></span><br></pre></td></tr></table></figure>

<p>长链剖分：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[x] = dep[fa] + <span class="number">1</span>, fa[x] = fa;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne) <span class="keyword">if</span> ((y = e[i].ver) != fa)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">dfs1</span>(y, x);</span><br><span class="line">		<span class="keyword">if</span> (len[y] &gt; len[son[x]]) son[x] = y;</span><br><span class="line">	&#125;</span><br><span class="line">	len[x] = len[son[x]] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> tp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    top[x] = tp;</span><br><span class="line">	<span class="keyword">if</span> (!son[x]) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="built_in">dfs2</span>(son[x], tp);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne) <span class="keyword">if</span> ((y = e[i].ver) != fa[x] &amp;&amp; y != son[x]) <span class="built_in">dfs2</span>(y, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//常套在dp上:</span></span><br><span class="line"><span class="keyword">int</span> dd[N], *d[N], *cur = dd + <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    初始化d[x]和答案</span><br><span class="line">	<span class="keyword">if</span> (!son[x]) <span class="keyword">return</span> ;</span><br><span class="line">	d[son[x]] = d[x] + <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">dfs2</span>(son[x], x);</span><br><span class="line">	用长儿子的答案跟新x的答案</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne) <span class="keyword">if</span> ((y = e[i].ver) != fa[x] &amp;&amp; y != son[x])</span><br><span class="line">	&#123;</span><br><span class="line">		d[y] = cur, cur += len[y];</span><br><span class="line">		<span class="built_in">dfs2</span>(y, x);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len[y]; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			d[x][j] += d[y][j - <span class="number">1</span>]; <span class="comment">//合并链</span></span><br><span class="line">			跟新答案</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态树"><a href="#动态树" class="headerlink" title="动态树"></a>动态树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> LCT</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> stk[N]; <span class="comment">//中间要用的栈</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node_of_Slpay</span>&#123;</span> <span class="keyword">int</span> ch[<span class="number">2</span>], fa, v, sum, rev; &#125; tr[N];</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> ch(x, y) tr[(x)].ch[(y)]</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> fa(x) tr[(x)].fa</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> v(x) tr[(x)].v</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> sum(x) tr[(x)].sum</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> rev(x) tr[(x)].rev</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">adt</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="built_in">swap</span>(<span class="built_in">ch</span>(x, <span class="number">0</span>),<span class="built_in">ch</span>(x, <span class="number">1</span>)), <span class="built_in">rev</span>(x) ^= <span class="number">1</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="built_in">sum</span>(x) = <span class="built_in">sum</span>(<span class="built_in">ch</span>(x, <span class="number">0</span>)) ^ <span class="built_in">sum</span>(<span class="built_in">ch</span>(x, <span class="number">1</span>)) ^ <span class="built_in">v</span>(x); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dw</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">rev</span>(x))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">adt</span>(<span class="built_in">ch</span>(x, <span class="number">0</span>)), <span class="built_in">adt</span>(<span class="built_in">ch</span>(x, <span class="number">1</span>));</span><br><span class="line">			<span class="built_in">rev</span>(x) = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">is_rt</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">ch</span>(<span class="built_in">fa</span>(x), <span class="number">0</span>) != x &amp;&amp; <span class="built_in">ch</span>(<span class="built_in">fa</span>(x), <span class="number">1</span>) != x; &#125; <span class="comment">//判断x是否是所在splay的根</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">rot</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> y = <span class="built_in">fa</span>(x), z = <span class="built_in">fa</span>(y);</span><br><span class="line">		<span class="keyword">int</span> k = <span class="built_in">ch</span>(y, <span class="number">1</span>) == x;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">is_rt</span>(y)) <span class="built_in">ch</span>(z, <span class="built_in">ch</span>(z, <span class="number">1</span>) == y) = x;</span><br><span class="line">		<span class="built_in">fa</span>(x) = z;</span><br><span class="line">		<span class="built_in">ch</span>(y, k) = <span class="built_in">ch</span>(x, k ^ <span class="number">1</span>), <span class="built_in">fa</span>(<span class="built_in">ch</span>(x, k ^ <span class="number">1</span>)) = y;</span><br><span class="line">		<span class="built_in">ch</span>(x, k ^ <span class="number">1</span>) = y, <span class="built_in">fa</span>(y) = x;</span><br><span class="line">		<span class="built_in">up</span>(y), <span class="built_in">up</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> top = <span class="number">0</span>, t = x, y, z;</span><br><span class="line">		stk[++top] = t;</span><br><span class="line">		<span class="keyword">while</span> (!<span class="built_in">is_rt</span>(t)) stk[++top] = t = <span class="built_in">fa</span>(t);</span><br><span class="line">		<span class="keyword">while</span> (top) <span class="built_in">dw</span>(stk[top--]);</span><br><span class="line">		<span class="keyword">while</span> (!<span class="built_in">is_rt</span>(x))</span><br><span class="line">		&#123;</span><br><span class="line">			y = <span class="built_in">fa</span>(x), z = <span class="built_in">fa</span>(y);</span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">is_rt</span>(y)) (<span class="built_in">ch</span>(y, <span class="number">1</span>) == x) ^ (<span class="built_in">ch</span>(z, <span class="number">1</span>) == y) ? <span class="built_in">rot</span>(x) : <span class="built_in">rot</span>(y);</span><br><span class="line">			<span class="built_in">rot</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//将根到x之间的路径变成实边</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> z = x;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; x; y = x, x = <span class="built_in">fa</span>(x))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">splay</span>(x);</span><br><span class="line">			<span class="built_in">ch</span>(x, <span class="number">1</span>) = y;</span><br><span class="line">			<span class="built_in">up</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">splay</span>(z);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">make_rt</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="built_in">access</span>(x), <span class="built_in">adt</span>(x); &#125; <span class="comment">//将x变成树根</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">find_rt</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//找到x所在树的根并将其转到splay的根节点上</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">access</span>(x);</span><br><span class="line">		<span class="keyword">while</span> (<span class="built_in">ch</span>(x, <span class="number">0</span>)) <span class="built_in">dw</span>(x), x = <span class="built_in">ch</span>(x, <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">splay</span>(x);</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="built_in">make_rt</span>(x), <span class="built_in">access</span>(y); &#125; <span class="comment">//将x到y的路径变成实边</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">//加边(x, y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">make_rt</span>(x);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">find_rt</span>(y) != x) <span class="built_in">fa</span>(x) = y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">//断边(x, y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">make_rt</span>(x);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">find_rt</span>(y) == x &amp;&amp; <span class="built_in">fa</span>(y) == x &amp;&amp; !<span class="built_in">ch</span>(y, <span class="number">0</span>)) <span class="built_in">ch</span>(x, <span class="number">1</span>) = <span class="built_in">fa</span>(y) = <span class="number">0</span>, <span class="built_in">up</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ne[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= s_len; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; s[i] != s[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (s[i] == s[j + <span class="number">1</span>]) ++j;</span><br><span class="line">    ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= t_len; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; (t[i] != s[j + <span class="number">1</span>] || j == s_len)) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (t[i] == s[j + <span class="number">1</span>]) ++j;</span><br><span class="line">    <span class="keyword">if</span> (j == s_len); <span class="comment">// 此时t[i - s_len + 1, i] = s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下标均从 $1$ 开始</p>
<h2 id="Z函数"><a href="#Z函数" class="headerlink" title="Z函数"></a>Z函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Z[<span class="number">1</span>] = s_len;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, l = <span class="number">0</span>, r = <span class="number">0</span>; i &lt;= s_len; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= r) Z[i] = std::<span class="built_in">min</span>(Z[i - l + <span class="number">1</span>], r - i + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (Z[i] + i &lt;= s_len &amp;&amp; s[Z[i] + i] == s[Z[i] + <span class="number">1</span>]) ++Z[i];</span><br><span class="line">    <span class="keyword">if</span> (i + Z[i] - <span class="number">1</span> &gt; r) r = i + Z[i] - <span class="number">1</span>, l = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l = <span class="number">0</span>, r = <span class="number">0</span>, as; i &lt;= t_len; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    as = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= r) as = std::<span class="built_in">min</span>(Z[i - l + <span class="number">1</span>], r - i + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (as + i &lt;= t_len &amp;&amp; s[as + <span class="number">1</span>] == t[as + i]) ++as;</span><br><span class="line">    <span class="keyword">if</span> (i + as - <span class="number">1</span> &gt; r) r = i + as - <span class="number">1</span>, l = i;</span><br><span class="line">    <span class="comment">//此时的as就是t[i, s_len]与s的LCP长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下标从 $1$ 开始</p>
<h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><p>普通：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Trie</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> ch[N][<span class="number">26</span>], ed[N], tot = <span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (; *s != <span class="string">&#x27;\0&#x27;</span>; ++s)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!ch[p][*s - <span class="string">&#x27;a&#x27;</span>]) ch[p][*s - <span class="string">&#x27;a&#x27;</span>] = ++tot;</span><br><span class="line">			p = ch[p][*s - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		++ed[p];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (; *s != <span class="string">&#x27;\0&#x27;</span>; ++s)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!ch[p][*s - <span class="string">&#x27;a&#x27;</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			p = ch[p][*s - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (ed[p]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Trie 的根是 $1$ ；注意空间要开够</p>
<p>可持久化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Trie</span><br><span class="line">&#123;</span><br><span class="line">	AR&lt;<span class="keyword">int</span>, <span class="number">26</span>&gt; ch[N];</span><br><span class="line">	<span class="keyword">int</span> rt[M], cid, tot;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> p = rt[cid], q = rt[++cid] = ++tot;</span><br><span class="line">		<span class="keyword">for</span> (; *s != <span class="string">&#x27;\0&#x27;</span>; ++s)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (p) ch[q] = ch[p];</span><br><span class="line">			ch[q][*s - <span class="string">&#x27;a&#x27;</span>] = ++tot;</span><br><span class="line">			p = ch[p][*s - <span class="string">&#x27;a&#x27;</span>], q = ch[q][*s - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> p = rt[id];</span><br><span class="line">		<span class="keyword">for</span> (; *s != <span class="string">&#x27;\0&#x27;</span>; ++s)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!ch[p][*s - <span class="string">&#x27;a&#x27;</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			p = ch[p][*s - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任然是要注意空间</p>
<h2 id="最小表示法"><a href="#最小表示法" class="headerlink" title="最小表示法"></a>最小表示法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_min</span><span class="params">(<span class="keyword">char</span> *s)</span> <span class="comment">//求串s的最小表示,完成后答案存在s[k...k + len - 1]中</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) s[i + len] = s[i];</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">2</span>, k;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= len &amp;&amp; j &lt;= len)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt;= len &amp;&amp; s[i + k] == s[j + k]; ++k);</span><br><span class="line">		<span class="keyword">if</span> (k &gt; len) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (s[i + k] &gt; s[j + k]) i += k + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> j += k + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (i == j) ++j;</span><br><span class="line">	&#125;</span><br><span class="line">	k = std::<span class="built_in">min</span>(i, j);</span><br><span class="line">	s[k + len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意空间要开两倍</p>
<h2 id="Manacher"><a href="#Manacher" class="headerlink" title="Manacher"></a>Manacher</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">manacher</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	STC <span class="keyword">char</span> t[N &lt;&lt; <span class="number">1</span>]; <span class="comment">//临时字符串要两倍</span></span><br><span class="line">	STC <span class="keyword">int</span> p[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in">strlen</span>(s + <span class="number">1</span>), mr = <span class="number">0</span>, mid, res = <span class="number">0</span>;</span><br><span class="line">	t[++mr] = <span class="string">&#x27;$&#x27;</span>, t[++mr] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) t[++mr] = s[i], t[++mr] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">	t[++mr] = <span class="string">&#x27;^&#x27;</span>;</span><br><span class="line">	len = mr, mr = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		p[i] = i &lt; mr ? std::<span class="built_in">min</span>(p[mid * <span class="number">2</span> - i], mr - i) : <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (t[i - p[i]] == t[i + p[i]]) ++p[i];</span><br><span class="line">		<span class="keyword">if</span> (i + p[i] &gt; mr) mr = i + p[i], mid = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) res = std::<span class="built_in">max</span>(res, p[i]);</span><br><span class="line">	<span class="keyword">return</span> res - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AC-自动机"><a href="#AC-自动机" class="headerlink" title="AC 自动机"></a>AC 自动机</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> AC</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> ch[N][<span class="number">26</span>], tot, in[N], as[N], fail[N];</span><br><span class="line">	std::vector&lt;<span class="keyword">int</span>&gt; ed[N];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (; *s != <span class="string">&#x27;\0&#x27;</span>; ++s)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!ch[p][*s - <span class="string">&#x27;a&#x27;</span>]) ch[p][*s - <span class="string">&#x27;a&#x27;</span>] = ++tot;</span><br><span class="line">			p = ch[p][*s - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		ed[p].<span class="built_in">pb</span>(id);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">get_fail</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">		fail[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) <span class="keyword">if</span> (ch[<span class="number">0</span>][i])</span><br><span class="line">		&#123;</span><br><span class="line">			fail[ch[<span class="number">0</span>][i]] = <span class="number">0</span>;</span><br><span class="line">			q.<span class="built_in">push</span>(ch[<span class="number">0</span>][i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">				<span class="keyword">if</span> (v = ch[u][i])</span><br><span class="line">				&#123;</span><br><span class="line">					fail[v] = ch[fail[u]][i];</span><br><span class="line">					++in[fail[v]];</span><br><span class="line">					q.<span class="built_in">push</span>(v);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> ch[u][i] = ch[fail[u]][i]; <span class="comment">//优化</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> ans[])</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">		std::queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">		<span class="keyword">int</span> ct = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (; *s != <span class="string">&#x27;\0&#x27;</span>; ++s)</span><br><span class="line">		&#123;</span><br><span class="line">			++ct;</span><br><span class="line">			p = ch[p][*s - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">			++as[p];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) <span class="keyword">if</span> (!in[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line">		<span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> u = q.<span class="built_in">front</span>(), v; q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i : ed[u]) ans[i] = as[u];</span><br><span class="line">			v = fail[u];</span><br><span class="line">			as[v] += as[u];</span><br><span class="line">			<span class="keyword">if</span> (!(--in[v])) q.<span class="built_in">push</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SAM"><a href="#SAM" class="headerlink" title="SAM"></a>SAM</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> SAM</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//1为空节点</span></span><br><span class="line">	<span class="keyword">int</span> tot = <span class="number">1</span>, last = <span class="number">1</span>; <span class="comment">//last:未加入此字符前最长的前缀所属的节点的编号</span></span><br><span class="line">	<span class="comment">//这里的节点只维护了最长的串,因为所有长度小于它但同结尾的串一定被它的祖先维护了</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="keyword">int</span> len, fa; <span class="comment">//最长长度,父节点</span></span><br><span class="line">		<span class="keyword">int</span> ch[<span class="number">26</span>]; <span class="comment">//类似于Trie</span></span><br><span class="line">	&#125; nd[N &lt;&lt; <span class="number">1</span>]; <span class="comment">//开2倍</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> p = last, np = last = ++tot;</span><br><span class="line">		nd[np].len = nd[p].len + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (; p &amp;&amp; !nd[p].ch[x]; p = nd[p].fa) nd[p].ch[x] = np; <span class="comment">//遍历所有长度小于它但同结尾的串,加字符</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		如果最后形成的新字符串没有旧串里出现过,</span></span><br><span class="line"><span class="comment">		说明x实际上是一个在旧串中没有出现过的字符</span></span><br><span class="line"><span class="comment">		因此不可能存在除节点1以外的祖先</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="keyword">if</span> (!p) nd[np].fa = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> q = nd[p].ch[x];</span><br><span class="line">			<span class="keyword">if</span> (nd[q].len == nd[p].len + <span class="number">1</span>) nd[np].fa = q; <span class="comment">//判断np是否为q的子节点</span></span><br><span class="line">			<span class="keyword">else</span> <span class="comment">//不是就说明q含了不该含的子串,直接新建节点为np的父节点</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> nq = ++tot;</span><br><span class="line">				nd[nq] = nd[q], nd[nq].len = nd[p].len + <span class="number">1</span>; <span class="comment">//这里就相当于去掉不该含的串</span></span><br><span class="line">				nd[q].fa = nd[np].fa = nq;</span><br><span class="line">				<span class="keyword">for</span> (; p &amp;&amp; nd[p].ch[x] == q; p = nd[p].fa) nd[p].ch[x] = nq; <span class="comment">//同理跟新</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SA"><a href="#SA" class="headerlink" title="SA"></a>SA</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_sa</span><span class="params">(<span class="keyword">int</span> _num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	STC <span class="keyword">int</span> x[N], y[N], c[N]; <span class="comment">//排序用,第一关键字,第二关键字,cnt</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++c[x[i] = s[i]]; <span class="comment">//第一次只有一个字符,不必离散化</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= _num; ++i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) sa[c[x[i]]--] = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>, num; k &lt;= n; k &lt;&lt;= <span class="number">1</span>) <span class="comment">//k枚举关键字长度,合并后长度应为2k</span></span><br><span class="line">	&#123;</span><br><span class="line">		num = <span class="number">0</span>; <span class="comment">//记录离散化后的值域</span></span><br><span class="line">		<span class="comment">//先以第二关键字排序</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = n - k + <span class="number">1</span>; i &lt;= n; ++i) y[++num] = i; <span class="comment">//没有第二关键字的牌最前</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (sa[i] &gt; k) y[++num] = sa[i] - k;</span><br><span class="line">		<span class="comment">//以第一关键字排序</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= _num; ++i) c[i] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++c[x[i]];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= _num; ++i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) sa[c[x[y[i]]]--] = y[i], y[i] = <span class="number">0</span>;  <span class="comment">//这里清空y实际上是清空x,因为后面交换了</span></span><br><span class="line">		std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">		<span class="comment">//将排好序的字符串离散化</span></span><br><span class="line">		x[sa[<span class="number">1</span>]] = num = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) x[sa[i]] = (y[sa[i]] == y[sa[i - <span class="number">1</span>]] &amp;&amp; y[sa[i] + k] == y[sa[i - <span class="number">1</span>] + k]) ? num : ++num;</span><br><span class="line">		<span class="keyword">if</span> (num == n) <span class="keyword">break</span>;</span><br><span class="line">		_num = num;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) rk[sa[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_hei</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (rk[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (k) --k;</span><br><span class="line">		<span class="keyword">int</span> j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">while</span> (i + k &lt;= n &amp;&amp; j + k &lt;= n &amp;&amp; s[i + k] == s[j + k]) ++k;</span><br><span class="line">		hei[rk[i]] = k;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h2><p>树上倍增法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	f[x][<span class="number">0</span>] = fa, dep[x] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = e[i].ne) <span class="keyword">if</span> (e[i].ver != fa) <span class="built_in">dfs</span>(e[i].ver, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; D; ++j)</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i][j] = f[f[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dep[x] &gt; dep[y]) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = D - <span class="number">1</span>; ~i; --i) <span class="keyword">if</span> (dep[f[y][i]] &gt;= dep[x]) y = f[y][i];</span><br><span class="line">	<span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = D - <span class="number">1</span>; ~i; --i) <span class="keyword">if</span> (f[y][i] != f[x][i]) y = f[y][i], x = f[x][i];</span><br><span class="line">	<span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常数较打，优点是好打且可用于求一个点的 $k$ 级祖先</p>
<p>树剖：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">在前面树剖的基础上加入如下代码:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (top[x] != top[y])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (dep[top[x]] &lt; dep[top[y]]) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">		x = fa[top[x]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dep[x] &lt; dep[y] ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点是常数小</p>
<p>ST 表：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dep[N &lt;&lt; <span class="number">1</span>], cnt = <span class="number">0</span>, id_b[N &lt;&lt; <span class="number">1</span>], id[N], lg2[N &lt;&lt; <span class="number">1</span>]; <span class="comment">//注意2倍</span></span><br><span class="line">PII mn[N &lt;&lt; <span class="number">1</span>][D]; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    id[x] = ++cnt, dep[cnt] = depth, id_b[cnt] = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne) <span class="keyword">if</span> ((y = e[i].ver) != fa)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(y, x, depth + <span class="number">1</span>);</span><br><span class="line">        id_b[++cnt] = x, dep[cnt] = depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prev</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lg2[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cnt; ++i) lg2[i] = lg2[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) mn[i][<span class="number">0</span>] = &#123;dep[i], id_b[i]&#125;;</span><br><span class="line">    <span class="keyword">int</span> t = lg2[cnt] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; t; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt - (<span class="number">1</span> &lt;&lt; j) + <span class="number">1</span>; ++i) mn[i][j] = std::<span class="built_in">min</span>(mn[i][j - <span class="number">1</span>], mn[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = lg2[r - l + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">min</span>(mn[l][t], mn[r - (<span class="number">1</span> &lt;&lt; t) + <span class="number">1</span>][t]).se;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">ask</span>(std::<span class="built_in">min</span>(id[a], id[b]), std::<span class="built_in">max</span>(id[a], id[b])); &#125;</span><br></pre></td></tr></table></figure>

<p>优点当然是 $O(1)$ 查询，缺点是有点难打</p>
<p>也可以用四毛子，但太难打了几乎用不到</p>
<h2 id="单源最短路"><a href="#单源最短路" class="headerlink" title="单源最短路"></a>单源最短路</h2><p>Dij ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dij</span><span class="params">(<span class="keyword">int</span> star)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::priority_queue&lt;PII&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) dis[i] = INF;</span><br><span class="line">    dis[star] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, star&#125;);</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        x = q.<span class="built_in">top</span>().se, q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne) <span class="keyword">if</span> (!vis[y = e[i].ver] &amp;&amp; dis[y] &gt; dis[x] + e[i].w)</span><br><span class="line">		&#123;</span><br><span class="line">			dis[y] = dis[x] + e[i].w;</span><br><span class="line">			q.<span class="built_in">push</span>(&#123;-dis[y], y&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>spfa（慎用）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> star)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) dis[i] = INF;</span><br><span class="line">    dis[star] = <span class="number">0</span>, vis[star] = <span class="literal">true</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(star);</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        x = q.<span class="built_in">front</span>(), q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[x] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = e[i].ne) <span class="keyword">if</span> (dis[y = e[i].ver] &gt; dis[x] + e[i].w)</span><br><span class="line">		&#123;</span><br><span class="line">			dis[y] = dis[x] + e[i].w;</span><br><span class="line">			<span class="keyword">if</span> (!vis[y]) vis[y] = <span class="literal">true</span>, q.<span class="built_in">push</span>(y);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="判负环"><a href="#判负环" class="headerlink" title="判负环"></a>判负环</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> star)</span> <span class="comment">//判断是否有能从star到达的负环</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) dis[i] = INF, cnt[i] = <span class="number">0</span>, vis[i] = <span class="literal">false</span>;</span><br><span class="line">    dis[star] = <span class="number">0</span>, vis[star] = <span class="literal">true</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(star);</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        x = q.<span class="built_in">front</span>(), q.<span class="built_in">pop</span>();</span><br><span class="line">        v[x] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = e[i].ne) <span class="keyword">if</span> (dis[y = e[i].ver] &gt; dis[x] + e[i].w)</span><br><span class="line">		&#123;</span><br><span class="line">			dis[y] = dis[x] + e[i].w, cnt[y] = cnt[x] + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (cnt[y] &gt;= n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">if</span> (!vis[y]) vis[y] = <span class="literal">true</span>, q.<span class="built_in">push</span>(y);</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">建图:</span><br><span class="line">	对于每个形如x[i] - x[j] &lt;= c的不等式,连有向边(j, i, c)</span><br><span class="line">    增加一个<span class="number">0</span>号节点,对于每个i,连边(<span class="number">0</span>, i, <span class="number">0</span>),表示x[i] &lt;= <span class="number">0</span>(我们先求出一组负解)</span><br><span class="line">完成以后以<span class="number">0</span>为源点跑spfa,若出现负环则无解;否则dis[]即为一组负数解</span><br></pre></td></tr></table></figure>

<h2 id="多源最短路"><a href="#多源最短路" class="headerlink" title="多源最短路"></a>多源最短路</h2><p>Floyed ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) dis[i][i] = <span class="number">0</span>;</span><br><span class="line">用dis做邻接矩阵存图</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) dis[i][j] = std::<span class="built_in">min</span>(dis[i][j], dis[i][k] + dis[k][j]);</span><br></pre></td></tr></table></figure>

<p>当然也可以做 $n$ 次单源最短路</p>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>Kruskal ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span> <span class="keyword">int</span> from, to, w; &#125; e[M];</span><br><span class="line">读入数据,初始化并查集</span><br><span class="line"><span class="built_in">sort</span>(e + <span class="number">1</span>, e + <span class="number">1</span> + m, [&amp;](Edge x, Edge y)&#123; <span class="keyword">return</span> x.w &lt; y.w; &#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= m; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    x = <span class="built_in">get</span>(e[i].from), y = <span class="built_in">get</span>(e[i].to); <span class="comment">//这里的get和merge就是并查集</span></span><br><span class="line">    <span class="keyword">if</span> (x != y) ans += e[i].w, <span class="built_in">merge</span>(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Prim ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, t; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    t = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) <span class="keyword">if</span> (!vis[j] &amp;&amp; (t == <span class="number">-1</span> || dis[j] &lt; dis[t])) t = j;</span><br><span class="line">    vis[t] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) <span class="keyword">if</span> (!vis[j]) dis[j] = std::<span class="built_in">min</span>(dis[j], map[t][j]);</span><br><span class="line">&#125;</span><br><span class="line">此时dis[]的和就是答案</span><br></pre></td></tr></table></figure>

<h2 id="Kruskal-重构树"><a href="#Kruskal-重构树" class="headerlink" title="Kruskal 重构树"></a>Kruskal 重构树</h2><p>Kruskal 重构树的建树流程为：</p>
<ol>
<li>把所有边排序，记边为 $(x, y, z)$ ，表示 $x \to y$ ，权为 $z$ </li>
<li>构建 $n$ 个无权点，没有边</li>
<li>每次取出一条边 $(x, y, z)$ ：<ul>
<li>若 $x, y$ 联通（在同一棵树），不管它</li>
<li>否则，新建一个节点 $t$ ，记 $x, y$ 所在树的根为 $r_x, r_y$ ，让 $t$ 的左右儿子分别为 $r_x, r_y$ ，并让 $t$ 的点权为 $z$ </li>
</ul>
</li>
</ol>
<p>不难发现 kruskal 重构树有如下性质：</p>
<ol>
<li>它是一棵二叉树（更进一步，它其实就是个二叉堆），树上除叶子结点以外的点都对应着原来生成树中的边，叶子结点就是原来生成树上的节点</li>
<li>除叶节点外，儿子节点对应边一定排序在父亲前面，即从每个点到根节点上除叶子结点外按顺序访问到的点的点权是单调的</li>
<li>对于叶节点 $x, y$ ， $lca(x, y)$ 对应的边就是最小生成树中联通 $x, y$ 的“瓶颈边”（它排序在最后）</li>
</ol>
<h2 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h2><p>dp 自然可以，但不好求出具体的路径</p>
<p>两次 bfs/dfs 的流程如下：</p>
<ol>
<li>任选一个点出发，找到离该点最远的节点 $p$ </li>
<li>从 $p$ 出发，找到离 $p$ 最远的节点 $q$ </li>
<li> $p, q$ 间的路径就是树的一条直径；如要得到具体路径，在进行 $2$ 时记录前驱即可</li>
</ol>
<h2 id="无向图-Tarjan"><a href="#无向图-Tarjan" class="headerlink" title="无向图 Tarjan"></a>无向图 Tarjan</h2><p>判桥：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> in_e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dfn[x] = low[x] = ++num;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne)</span><br><span class="line">		<span class="keyword">if</span> (!dfn[y = e[i].ver;])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">tarjan</span>(y, i);</span><br><span class="line">			low[x] = std::<span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">			<span class="keyword">if</span> (low[y] &gt; dfn[x]) bridge[i] = bridge[i ^ <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (i != (in_e ^ <span class="number">1</span>)) low[x] = std::<span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(!dfn[i]) <span class="built_in">tarjan</span>(i,<span class="number">-1</span>);</span><br></pre></td></tr></table></figure>

<p>边双联通分量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在判桥的代码后加入以下代码:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	c[x] = dcc;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne) <span class="keyword">if</span> (!bridge[i] &amp;&amp; !c[y = e[i].ver]) <span class="built_in">dfs</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (!c[i]) ++dcc, <span class="built_in">dfs</span>(i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;the num of e-DCC is %d\n&quot;</span>, dcc);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d blongs to e-DCC %d\n&quot;</span>, i, c[i]);</span><br></pre></td></tr></table></figure>

<p>判割点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dfn[x] = low[x] = ++num;</span><br><span class="line">    (<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne)</span><br><span class="line">		<span class="keyword">if</span> (!dfn[y = e[i].ver])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">tarjan</span>(y);</span><br><span class="line">			low[x] = std::<span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">			<span class="keyword">if</span> (low[y] &gt;= dfn[x])</span><br><span class="line">			&#123;</span><br><span class="line">				++f;</span><br><span class="line">				<span class="keyword">if</span> (x != root || f &gt; <span class="number">1</span>) cut[x] = <span class="literal">true</span>;</span><br><span class="line">				(<span class="number">2</span>)</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> low[x] = std::<span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (!dfn[i]) root = i, <span class="built_in">tarjan</span>(i);</span><br></pre></td></tr></table></figure>

<p>点双联通分量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在上面求割点的代码的(<span class="number">1</span>), (<span class="number">2</span>)处加入以下两段代码:</span><br><span class="line">(<span class="number">1</span>):</span><br><span class="line">stk[++top] = x; <span class="comment">//栈记录经过的节点</span></span><br><span class="line"><span class="keyword">if</span> (x == root &amp;&amp; h[x] == <span class="number">-1</span>) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(dcc[++cnt].<span class="built_in">pb</span>(x)); <span class="comment">//孤立点</span></span><br><span class="line">(<span class="number">2</span>):</span><br><span class="line">++cnt;</span><br><span class="line"><span class="keyword">int</span> z;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    z = stk[top--];</span><br><span class="line">    dcc[cnt].<span class="built_in">pb</span>(z);</span><br><span class="line">&#125; <span class="keyword">while</span> (z != y);</span><br><span class="line">dcc[cnt].<span class="built_in">pb</span>(x);</span><br></pre></td></tr></table></figure>

<h2 id="有向图-Tarjan"><a href="#有向图-Tarjan" class="headerlink" title="有向图 Tarjan"></a>有向图 Tarjan</h2><p>强连通分量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dfn[x] = low[x] = ++num;</span><br><span class="line">	stk[++top] = x, ins[x] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne)</span><br><span class="line">		<span class="keyword">if</span> (!dfn[y = e[i].ver])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">tarjan</span>(y);</span><br><span class="line">			low[x] = std::<span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ins[y]) low[x] = std::<span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">	<span class="keyword">if</span> (dfn[x] == low[x])</span><br><span class="line">	&#123;</span><br><span class="line">		++cnt;</span><br><span class="line">		<span class="keyword">int</span> y;</span><br><span class="line">		<span class="keyword">do</span></span><br><span class="line">		&#123;</span><br><span class="line">			y = stk[top--], ins[y] = <span class="literal">false</span>;</span><br><span class="line">			c[y] = cnt, scc[cnt].<span class="built_in">pb</span>(y);</span><br><span class="line">		&#125; <span class="keyword">while</span> (x != y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-SAT"><a href="#2-SAT" class="headerlink" title="2-SAT"></a>2-SAT</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">建图:</span><br><span class="line">	图中有<span class="number">2</span>n个节点,i表示x[i]为假,i + n表示x[i]为真</span><br><span class="line">    按命题连边:</span><br><span class="line">		<span class="number">1.</span>x[i] <span class="keyword">and</span> x[j] = <span class="number">0</span>:连(i + n, j)和(j + n, i)</span><br><span class="line">        <span class="number">2.</span>x[i] <span class="keyword">and</span> x[j] = <span class="number">1</span>:连(i, i + n)和(j, j + n) (若有一个为<span class="number">0</span>就产生矛盾)</span><br><span class="line">        <span class="number">3.</span>x[i] <span class="keyword">or</span> x[j] = <span class="number">0</span>:连(i + n, i)和(j + n, j) (若有一个为<span class="number">1</span>就产生矛盾)</span><br><span class="line">        <span class="number">4.</span>x[i] <span class="keyword">or</span> x[j] = <span class="number">1</span>:连(i, j + n)和(j, i + n)</span><br><span class="line">        <span class="number">5.</span>x[i] <span class="keyword">xor</span> x[j] = <span class="number">0</span>:连(i, j), (j, i), (i + n, j + n)和(j + n, i + n)</span><br><span class="line">        <span class="number">6.</span>x[i] <span class="keyword">xor</span> x[j] = <span class="number">1</span>:连(i, j + n), (j, i + n), (i + n, j)和(j + n, i)</span><br><span class="line">    有向图Tarjan缩点,若i和i + n在一个强联通分量说明无解;否则任意一个强连通分量代表一组解</span><br></pre></td></tr></table></figure>

<h2 id="圆方树"><a href="#圆方树" class="headerlink" title="圆方树"></a>圆方树</h2><p>直接对原图进行无向图 Tarjan ，因为原图上每个环都是一个点双，而且在栈中的顺序就是环上点的顺序，如果一个点 $i$ 的出边 $(i, j)$ 满足 $dfn(i) &lt; low(j)$ ，说明 $(i, j)$ 是一条树边，直接加上即可；如果 $dfn(i) = low(j)$ ，那么我们找到了一个环（可能是重边造成的二元环），则从栈中取出点直到取出 $j$ 为止，设这样从栈中取出的点集为 $R$ ，则 $i$ 和 $R$ 构成一个环</p>
<p>对于环，我们新建一个方点，对环上每个点连边即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    low[x] = dfn[x] = ++dfc;</span><br><span class="line">    stk[++top] = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> y : G[x])</span><br><span class="line">        <span class="keyword">if</span> (!dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(y);</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">            <span class="keyword">if</span> (low[y] == dfn[x])<span class="comment">//标志着找到一个以x为根的点双连通分量</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++cnt; <span class="comment">//增加方点个数</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> z = <span class="number">0</span>; z != y; --top) <span class="comment">//这里一定要让z=0!</span></span><br><span class="line">                &#123;</span><br><span class="line">                    z = stk[top];</span><br><span class="line">                    T[cnt].<span class="built_in">push_back</span>(z);</span><br><span class="line">                    T[z].<span class="built_in">push_back</span>(cnt);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//注意x自身也要连边（但不退栈）</span></span><br><span class="line">                T[cnt].<span class="built_in">push_back</span>(x);</span><br><span class="line">                T[x].<span class="built_in">push_back</span>(cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[x] = <span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (!dfn[i]) <span class="built_in">tarjan</span>(i), --top; <span class="comment">//注意到退出Tarjan时栈中还有一个元素即根,将其退栈</span></span><br></pre></td></tr></table></figure>

<p>注意新图的节点数变成两倍</p>
<h2 id="三元环计数"><a href="#三元环计数" class="headerlink" title="三元环计数"></a>三元环计数</h2><p>要改造一下边，把无向图变成有向图，总时间为 $O(m \sqrt{m})$ ，这同时也是三元环的个数上界</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">读入数据,去掉重边,记录每个点的度(下面假设用PII存的边)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_e[i].fi &lt; _e[i].se) std::<span class="built_in">swap</span>(_e[i].fi, _e[i].se);</span><br><span class="line">	dep[_e[i].fi] &gt;= dep[_e[i].se] ? <span class="built_in">add</span>(_e[i].fi, _e[i].se) : <span class="built_in">add</span>(_e[i].se, _e[i].fi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find3c</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = e[i].ne) vis[e[i].ver] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = e[i].ne)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = h[e[i].ver]; ~j; j = e[j].ne) res += vis[e[j].ver];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = e[i].ne) vis[e[i].ver] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四元环计数"><a href="#四元环计数" class="headerlink" title="四元环计数"></a>四元环计数</h2><p><strong>我们将每个点按度数大小重新编号，度数相同原来编号大的点在前</strong>的方法，就可以通过编号直接得到任意两个点的关系</p>
<p>设重新编号后排名为 $rk$ ，枚举四圆环中 $rk$ 最大的点 $x$ ，再枚举 $x$ 的出点 $y$ ，枚举  $y$ 的出点 $z$ （这里直接枚举无向边，注意判断 $rk(x) &gt; rk(y) &gt; rk(z)$ ）， 这里就得到了一个长度为 $2$ 的链了，再枚举一个点 $c$ ，只要 $rk(x) &gt; rk(c)$ 就计入答案的贡献，不管 $rk(c)$ 和 $rk(z)$ 的关系</p>
<p>时间复杂度还是 $O(m \sqrt{m})$ ，注意四元环的个数上界是 $nm\sqrt{m}$ ，可能要 <code>LL</code> </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">读入数据,记录每个点的度</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) id[i] = i;</span><br><span class="line">std::<span class="built_in">sort</span>(id + <span class="number">1</span>, id + n + <span class="number">1</span>, [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123; <span class="keyword">return</span> deg[x] == dep[y] ? x &lt; y : dep[x] &lt; dep[y]; &#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) rk[id[i]] = i;</span><br><span class="line"><span class="function">LL <span class="title">find4c</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = e[i].ne) <span class="keyword">if</span> (rk[x] &gt; rk[e[i].ver])</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = h[e[i].ver]; ~j; j = e[j].ne) <span class="keyword">if</span> (rk[x] &gt; rk[e[j].ver]) res += cnt[e[j].ver]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = e[i].ne) <span class="keyword">if</span> (rk[x] &gt; rk[e[i].ver])</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = h[e[i].ver]; j != <span class="number">-1</span>; j = e[j].ne) cnt[e[i].ver] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="欧拉回路"><a href="#欧拉回路" class="headerlink" title="欧拉回路"></a>欧拉回路</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">euler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stk[++top] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (top)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> x = stk[top], i = h[x];</span><br><span class="line">		<span class="keyword">while</span> (i != <span class="number">-1</span> &amp;&amp; vis[i]) i = ne[i];</span><br><span class="line">		<span class="keyword">if</span> (i != <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			stk[++top] = e[i].ver;</span><br><span class="line">			vis[i] = vis[i ^ <span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">//这里用了成对存储的技巧</span></span><br><span class="line">			h[x] = ne[i]; <span class="comment">//保证时间复杂度</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			--top;</span><br><span class="line">			ans[++cnt] = x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">最后ans[]存有一条欧拉回路</span><br></pre></td></tr></table></figure>

<h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><p>判定：染色法</p>
<p>求最大匹配：</p>
<p>网络流可做，这里介绍匈牙利，时间为 $O(nm)$ ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne) <span class="keyword">if</span> (!vis[y = e[i].ver])</span><br><span class="line">	&#123;</span><br><span class="line">		vis[y] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (!match[y] || <span class="built_in">dfs</span>(match[y])) <span class="keyword">return</span> match[y] = x, <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">dfs</span>(i)) ++ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一般图最大匹配"><a href="#一般图最大匹配" class="headerlink" title="一般图最大匹配"></a>一般图最大匹配</h2><p>智慧法（可能被卡）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::mt19937 <span class="title">rud</span><span class="params">(<span class="number">114514</span>)</span></span>;</span><br><span class="line"><span class="function">DB <span class="title">when</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> (DB)(<span class="built_in">clock</span>() - st) / CLOCKS_PER_SEC; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; match[x] = y, match[y] = x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="built_in">shuffle</span>(e[x].<span class="built_in">begin</span>(), e[x].<span class="built_in">end</span>(), rud);</span><br><span class="line">    vis[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> y : e[x]) <span class="keyword">if</span> (!match[y]) <span class="keyword">return</span> <span class="built_in">link</span>(x, y), vis[y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> y : e[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> z = match[y];</span><br><span class="line">        <span class="keyword">if</span> (vis[z]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">link</span>(x, y), match[z] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">work</span>(z)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">link</span>(y, z), match[x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">读入(用vector存图)</span><br><span class="line"><span class="keyword">clock_t</span> st = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">when</span>() &lt; <span class="number">0.9</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (!match[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis + <span class="number">1</span>, <span class="literal">false</span>, n * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">bool</span>));</span><br><span class="line">        ans += <span class="built_in">work</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">最后ans是最大匹配数,match即为匹配  </span><br></pre></td></tr></table></figure>

<p>带花树：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">link同上,get就是并查集</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dad</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!match[x] &amp;&amp; !match[y]) <span class="built_in">link</span>(x, y), ++ans; <span class="comment">//优化</span></span><br><span class="line">    <span class="built_in">add</span>(x, y), <span class="built_in">add</span>(y, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rev</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">if</span> (x) <span class="built_in">rev</span>(match[pre[x]]), <span class="built_in">link</span>(x, pre[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    STC <span class="keyword">int</span> dfn[N], cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    dfn是一个标记数组,一边打标即一边上跳，第一个重复点就是花根</span></span><br><span class="line"><span class="comment">	花根一定是一个绿点,所以可以隔点上跳</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (++cnt; ;x = pre[match[x]], <span class="built_in">swap</span>(x, y))</span><br><span class="line">		<span class="keyword">if</span> (dfn[x = <span class="built_in">get</span>(x)] == cnt) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x) dfn[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blossom</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span> <span class="comment">//缩奇环(开花)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">get</span>(x) != w; x = pre[y])</span><br><span class="line">    &#123;</span><br><span class="line">        pre[x] = y, y = match[x];</span><br><span class="line">        fa[x] = fa[y] = w;</span><br><span class="line">        <span class="keyword">if</span> (col[y] == <span class="number">2</span>) col[y] = <span class="number">1</span>, q.<span class="built_in">push</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aug</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//带花树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((ans + <span class="number">1</span>) * <span class="number">2</span> &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fa[i] = i, col[i] = pre[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (q.<span class="built_in">push</span>(x), col[x] = <span class="number">1</span>; !q.<span class="built_in">empty</span>(); q.<span class="built_in">pop</span>())</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = q.<span class="built_in">front</span>(), i = h[u], v, w; ~i; i = e[i].ne)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">get</span>(u) == <span class="built_in">get</span>(v = e[i].ver) || col[v] == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!col[v])</span><br><span class="line">            &#123;</span><br><span class="line">                col[v] = <span class="number">2</span>, pre[v] = u;</span><br><span class="line">                <span class="keyword">if</span> (!match[v]) <span class="keyword">return</span> <span class="built_in">rev</span>(v), <span class="number">1</span>;</span><br><span class="line">                col[match[v]] = <span class="number">1</span>, q.<span class="built_in">push</span>(match[v]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">blossom</span>(u, v, w = <span class="built_in">lca</span>(u, v)), <span class="built_in">blossom</span>(v, u, w); <span class="comment">//缩环两个方向各一次拼起来</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">读入，加边用<span class="function">dad</span></span><br><span class="line"><span class="function"><span class="title">for</span> <span class="params">(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span> ans +</span>= (!match[i] &amp;&amp; <span class="built_in">aug</span>(i));</span><br></pre></td></tr></table></figure>

<h2 id="Prufer-序列"><a href="#Prufer-序列" class="headerlink" title="Prufer 序列"></a>Prufer 序列</h2><p>每次选择一个编号最小的叶结点并删掉它，然后在序列中记录下它连接到的那个结点，重复 $n - 2$ 次后就只剩下两个结点，算法结束，得到的序列可以与原树一一对应</p>
<h2 id="虚树"><a href="#虚树" class="headerlink" title="虚树"></a>虚树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!top) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(stk[++top] = x);</span><br><span class="line">    <span class="keyword">int</span> z = <span class="built_in">lca</span>(stk[top], x);</span><br><span class="line">    <span class="keyword">for</span> (; tp &gt; <span class="number">1</span> &amp;&amp; dep[z] &lt; dep[stk[top - <span class="number">1</span>]]; --top) <span class="built_in">add</span>(stk[top - <span class="number">1</span>], stk[top]);</span><br><span class="line">    <span class="keyword">if</span> (dep[z] &lt; dep[stk[top]]) <span class="built_in">add</span>(z, stk[top--]);</span><br><span class="line">    <span class="keyword">if</span> (!top || stk[top] != z) stk[++top] = z;</span><br><span class="line">    stk[++top] = x;</span><br><span class="line">&#125;</span><br><span class="line">std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + k + <span class="number">1</span>, [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123; <span class="keyword">return</span> dfn[x] &lt; dfn[y]; &#125;);</span><br><span class="line">top = ans = idf = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">1</span>] != <span class="number">1</span>) stk[++top] = <span class="number">1</span>; <span class="comment">//根</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) <span class="built_in">ins</span>(a[i]);</span><br><span class="line"><span class="keyword">for</span> (; top &gt; <span class="number">1</span>; --top) <span class="built_in">adf</span>(stk[top - <span class="number">1</span>], stk[top]); <span class="comment">//在虚树上建边</span></span><br><span class="line">计算答案,记得撤销!</span><br></pre></td></tr></table></figure>

<p>虚树的空间和撤销是易错点</p>
<h1 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h1><h2 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h2><p>注意下面初始化都是 <code>0xcf</code> （最小值）</p>
<p> $01$ ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(f, <span class="number">0xcf</span>, <span class="keyword">sizeof</span> f), ans = -INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= v[i]; --j) f[j] = std::<span class="built_in">max</span>(f[j - v[i]] + w[i], f[j]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) ans = <span class="built_in">max</span>(ans, f[i]);</span><br></pre></td></tr></table></figure>

<p> $01$ 退背包（只能求方案数）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) f[i] -= f[i - <span class="number">1</span>] * x; <span class="comment">//禁用贡献为x的物品</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = m; i; --i) f[i] += f[i - <span class="number">1</span>] * x; <span class="comment">//加入贡献为x的物品</span></span><br></pre></td></tr></table></figure>

<p>完全：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(f, <span class="number">0xcf</span>, <span class="keyword">sizeof</span> f), ans = -INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = v[i]; j &lt;= m; ++j) f[j] = std::<span class="built_in">max</span>(f[j - v[i]] + w[i], f[j]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) ans = <span class="built_in">max</span>(ans, f[i]);</span><br></pre></td></tr></table></figure>

<p>多重背包二进制拆分（以下给出拆分代码）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(Node x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (x.p &gt;= p)</span><br><span class="line">	&#123;</span><br><span class="line">		b[++o].c = x.c * p;</span><br><span class="line">		b[o].t = x.t * p;</span><br><span class="line">		b[o].p = <span class="number">1</span>;</span><br><span class="line">		x.p -= p;</span><br><span class="line">		p &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (x.p)</span><br><span class="line">	&#123;</span><br><span class="line">		b[++o].c = x.c * x.p;</span><br><span class="line">		b[o].t = x.t * x.p;</span><br><span class="line">		b[o].p = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多重背包单调队列优化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> u, <span class="keyword">int</span> k)</span></span>&#123; <span class="keyword">return</span> f[u + k * v[i]] - k * w[i]; &#125;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0xcf</span>, <span class="keyword">sizeof</span> f), f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; v[i]; ++u) <span class="comment">// u:余数</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">int</span> hh = <span class="number">1</span>, tt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxp = (m - u) / v[i];</span><br><span class="line">        <span class="comment">//将初始的候选集合插入队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = maxp - <span class="number">1</span>; k &gt;= <span class="built_in">max</span>(maxp - c[i], <span class="number">0</span>); --k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">calc</span>(i, u, q[tt]) &lt;= <span class="built_in">calc</span>(i, u, k)) --tt;</span><br><span class="line">            q[++tt] = k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dp</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p = maxp; p &gt;= <span class="number">0</span>; p--) <span class="comment">//循环状态</span></span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; q[hh] &gt; p - <span class="number">1</span>) ++hh; <span class="comment">//排除过时决策</span></span><br><span class="line">            <span class="keyword">if</span> (hh &lt;= tt) f[u + p * v[i]] = std::<span class="built_in">max</span>(f[u + p * v[i]], <span class="built_in">calc</span>(i, u, q[hh]) + p * w[i]); <span class="comment">//取队头转移</span></span><br><span class="line">            <span class="keyword">if</span> (p - c[i] - <span class="number">1</span> &gt;= <span class="number">0</span>) <span class="comment">//新决策入队,同时维护单调</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">calc</span>(i, u, q[tt]) &lt;= <span class="built_in">calc</span>(i, u, p - c[i] - <span class="number">1</span>)) --tt;</span><br><span class="line">                q[++tt] = p - c[i] - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) ans = std::<span class="built_in">max</span>(ans, f[i]);</span><br></pre></td></tr></table></figure>

<h2 id="单调队列优化"><a href="#单调队列优化" class="headerlink" title="单调队列优化"></a>单调队列优化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> q[N], l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r &amp;&amp; 队头不再合法) ++l;</span><br><span class="line">    用队头跟新d[i]</span><br><span class="line">   	<span class="keyword">while</span> (l &lt;= r &amp;&amp; i优于队尾) --r;</span><br><span class="line">    q[++r] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>各操作顺序不是严格</p>
<h2 id="斜率优化"><a href="#斜率优化" class="headerlink" title="斜率优化"></a>斜率优化</h2><p>考虑 $j$ 优与 $k$ 的条件，把 dp 方程化成 $\frac{Y(j) - Y(k)}{X(j) - X(k)} \le 无关j,k的值K$  的形式，然后分情况（以最大值为例）：</p>
<p> $X, K$ 单调：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> q[N], l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//有时候需要先把0入队</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r &amp;&amp; (<span class="built_in">Y</span>(q[l + <span class="number">1</span>]) - <span class="built_in">Y</span>(q[l])) &gt; <span class="built_in">K</span>(i) * (<span class="built_in">X</span>(q[l + <span class="number">1</span>]) - <span class="built_in">X</span>(q[l]))) ++l; <span class="comment">//至少保证队列中有一个数</span></span><br><span class="line">    用队头跟新<span class="function">i</span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="params">(l &lt; r &amp;&amp; (Y(i) - Y(q[r])) * (X(q[r]) - X(q[r - <span class="number">1</span>])) &gt;= (Y(q[r]) - Y(q[r - <span class="number">1</span>])) * (X(i) - X(q[r])))</span> --r</span>;</span><br><span class="line">    q[++r] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> $X$ 不单调， $K$ 单调：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> q[l];</span><br><span class="line">    <span class="keyword">int</span> ll = l, rr = r, mid, res;</span><br><span class="line">    <span class="keyword">while</span> (ll &lt;= rr)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = ll + rr &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> ((<span class="built_in">Y</span>(q[mid + <span class="number">1</span>]) - <span class="built_in">Y</span>(q[mid])) &lt;= (<span class="built_in">X</span>(q[mid + <span class="number">1</span>]) - <span class="built_in">X</span>(q[mid])) * k) res = mid, rr = mid - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> ll = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q[res];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> q[N], l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="built_in">find</span>(i, <span class="built_in">K</span>(i));</span><br><span class="line">    用j跟新<span class="function">i</span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="params">(l &lt; r &amp;&amp; (Y(i) - Y(q[r])) * (X(q[r]) - X(q[r - <span class="number">1</span>])) &gt;= (Y(q[r]) - Y(q[r - <span class="number">1</span>])) * (X(i) - X(q[r])))</span> --r</span>;</span><br><span class="line">    q[++r] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> $X, K$ 都不单调：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">X</span>(x) == <span class="built_in">X</span>(y) ? <span class="built_in">Y</span>(x) &gt; <span class="built_in">Y</span>(y) : <span class="built_in">X</span>(x) &lt; <span class="built_in">X</span>(y); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdq</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        有时候这里有些操作</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    lp = l - <span class="number">1</span>, rp = mid;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) (p[i] &lt;= mid ? tmp[++lp] : tmp[++rp]) = p[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) p[i] = tmp[i];</span><br><span class="line">    <span class="built_in">cdq</span>(l, mid);</span><br><span class="line">    ql = <span class="number">1</span>, qr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= mid; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &gt; l &amp;&amp; <span class="built_in">X</span>(p[i]) == <span class="built_in">X</span>(p[i - <span class="number">1</span>])) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span> (ql &lt; qr &amp;&amp; (<span class="built_in">Y</span>(q[qr]) - <span class="built_in">Y</span>(q[qr - <span class="number">1</span>])) * (<span class="built_in">X</span>(p[i]) - <span class="built_in">X</span>(q[qr])) &lt;= (<span class="built_in">Y</span>(p[i]) - <span class="built_in">Y</span>(q[qr])) * (<span class="built_in">X</span>(q[qr]) - <span class="built_in">X</span>(q[qr - <span class="number">1</span>]))) --qr;</span><br><span class="line">        q[++qr] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>, u, v; i &lt;= r; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (ql &lt; qr &amp;&amp; (<span class="built_in">Y</span>(q[ql + <span class="number">1</span>]) - <span class="built_in">Y</span>(q[ql])) &gt; (<span class="built_in">X</span>(q[ql + <span class="number">1</span>]) - <span class="built_in">X</span>(q[ql])) * <span class="built_in">K</span>(p[i])) ++ql;</span><br><span class="line">        u = p[i], v = q[ql];</span><br><span class="line">		用v跟新u</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cdq</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    lp = tp = l, rp = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lp &lt;= mid &amp;&amp; rp &lt;= r) tmp[tp++] = (<span class="built_in">cmp</span>(p[lp], p[rp]) ? p[lp++] : p[rp++]);</span><br><span class="line">    <span class="keyword">while</span> (lp &lt;= mid) tmp[tp++] = p[lp++];</span><br><span class="line">    <span class="keyword">while</span> (rp &lt;= r) tmp[tp++] = p[rp++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) p[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">在进入cdq之前:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) p[i] = i;</span><br><span class="line">std::<span class="built_in">sort</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>, [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123; <span class="keyword">return</span> <span class="built_in">K</span>(x) &lt; <span class="built_in">K</span>(y); &#125;);</span><br><span class="line">初始化dp数组</span><br></pre></td></tr></table></figure>

<h2 id="四边形不等式"><a href="#四边形不等式" class="headerlink" title="四边形不等式"></a>四边形不等式</h2><p>式子： $a \le b \le c \le d$ 若 $w(a, d) + w(b, c) \ge w(a, c) + w(b, d)$ 则满足四边形不等式（想象一个四边形，对边和小于对角线和）</p>
<p>分治打法：</p>
<p>设函数 <code>sol(l, r, L, R)</code> 表示“当然正在处理 $d[l \sim r]$ ，最优决策存在于区间 $[L, R]$ ”，函数伪代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sol</span>(l, r, L, R)</span><br><span class="line">	<span class="keyword">if</span> (l &gt; r || L &gt; R) <span class="keyword">return</span> ;</span><br><span class="line">	mid &lt;- (l + r) &gt;&gt; <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i : L -&gt; R</span><br><span class="line">		找到最优决策点 pos </span><br><span class="line">	end <span class="keyword">for</span></span><br><span class="line">	用 pos 跟新 d[mid]</span><br><span class="line">	<span class="built_in">sol</span>(l, mid - <span class="number">1</span>, L, pos)</span><br><span class="line">	<span class="built_in">sol</span>(mid + <span class="number">1</span>, r, pos, R)</span><br><span class="line">end sol</span><br></pre></td></tr></table></figure>

<p>要求 $val(i, j)$ 不含与 $d[j]$ 有关的项</p>
<p>队列 + 二分打法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">q[h = t = <span class="number">1</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, n&#125;; <span class="comment">//把0先入队</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, pos; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (h &lt;= t &amp;&amp; q[h].r &lt; i) ++h;</span><br><span class="line">	用q[h].pos跟新i</span><br><span class="line">	pos = n + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (h &lt;= t &amp;&amp; 对于q[t].l,i比q[t].pos优) pos = q[t--].l;</span><br><span class="line">	<span class="keyword">if</span> (h &lt;= t &amp;&amp; 对于q[t].r,i比q[t].pos优)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> l = q[t].l, r = q[t].r, mid;</span><br><span class="line">		<span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">		&#123;</span><br><span class="line">			mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (对于mid,i比q[t].pos优) pos = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		q[t].r = pos - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (pos &lt;= n) q[++t] = &#123;i, pos, n&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SOS"><a href="#SOS" class="headerlink" title="SOS"></a>SOS</h2><p>子集：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>; ~j; --j) <span class="keyword">if</span> ((j &gt;&gt; i) &amp; <span class="number">1</span>) d[j] += d[j ^ (<span class="number">1</span> &lt;&lt; i)];</span><br></pre></td></tr></table></figure>

<p>超集：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>; ~j; --j) <span class="keyword">if</span> (!(j &gt;&gt; i) &amp; <span class="number">1</span>) d[j] += d[j ^ (<span class="number">1</span> &lt;&lt; i)];</span><br></pre></td></tr></table></figure>

<h1 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h1><h2 id="最大流（-Dinic-）："><a href="#最大流（-Dinic-）：" class="headerlink" title="最大流（ Dinic ）："></a>最大流（ Dinic ）：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    STC <span class="keyword">int</span> q[N];</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">1</span>, tt = <span class="number">1</span>, x, y;</span><br><span class="line">	<span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="keyword">sizeof</span> dep), q[dep[S] = <span class="number">1</span>] = S, cur[S] = h[S]</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x = q[hh++]]; ~i; i = e[i].ne) <span class="keyword">if</span> (!dep[y = e[i].ver] &amp;&amp; e[i].w)</span><br><span class="line">		&#123;</span><br><span class="line">			dep[y] = dep[x] + <span class="number">1</span>, cur[y] = h[y];</span><br><span class="line">			<span class="keyword">if</span> (y == T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			q[++tt] = y;</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> lim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == T) <span class="keyword">return</span> lim;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, y, t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cur[x]; i != <span class="number">-1</span> &amp;&amp; flow &lt; lim;  i = e[i].ne)</span><br><span class="line">    &#123;</span><br><span class="line">        cur[x] = i; <span class="comment">//这里非常玄学,一定要这样写,压行的话可能会TLE</span></span><br><span class="line">        <span class="keyword">if</span> (dep[y = e[i].ver] == dep[x] + <span class="number">1</span> &amp;&amp; e[i].w)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(t = <span class="built_in">find</span>(y, std::<span class="built_in">min</span>(lim - flow, e[i].w)))) dep[y] = <span class="number">0</span>;</span><br><span class="line">            e[i].w -= t, e[i ^ <span class="number">1</span>].w += t, flow += t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>, flow;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">dfs</span>()) <span class="keyword">while</span>(flow = <span class="built_in">find</span>(S, INF)) res += flow;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最大流（-HLPP-）："><a href="#最大流（-HLPP-）：" class="headerlink" title="最大流（ HLPP ）："></a>最大流（ HLPP ）：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hi[N], ex[N], gap[N]; <span class="comment">//hi:高度,ex:超额流,gap[i]:高度为i的节点的数量</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; B[N]; <span class="comment">// 桶B[i]中记录所有hi[x]=i的x</span></span><br><span class="line"><span class="keyword">int</span> level = <span class="number">0</span>; <span class="comment">//溢出节点的最高高度</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) hi[i] = INF;</span><br><span class="line">	hi[T] = <span class="number">0</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(T);</span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		x = q.<span class="built_in">front</span>(), q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">		&#123;</span><br><span class="line">			y = e[i].ver;</span><br><span class="line">			<span class="keyword">if</span> (e[i ^ <span class="number">1</span>].w &amp;&amp; hi[y] &gt; hi[x] + <span class="number">1</span>) hi[y] = hi[x] + <span class="number">1</span>, q.<span class="built_in">push</span>(y); <span class="comment">//从T倒着搜回去走的是反向边,^1以后就变回正向边</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> hi[S] != INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//尽可能通过能够推送的边推送超额流</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> init = x == S;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y, k; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">	&#123;</span><br><span class="line">		y = e[i].ver;</span><br><span class="line">		<span class="keyword">if</span> (!e[i].w || (init == <span class="literal">false</span> &amp;&amp; hi[x] != hi[y] + <span class="number">1</span>)) <span class="keyword">continue</span>; <span class="comment">//初始化时不考虑高度差为1</span></span><br><span class="line">		k = init ? e[i].w : <span class="built_in">min</span>(e[i].w, ex[x]); <span class="comment">//取到剩余容量和超额流的最小值初始化时可以使源的溢出量为负数</span></span><br><span class="line">		<span class="keyword">if</span> (y != S &amp;&amp; y != T &amp;&amp; !ex[y]) B[hi[y]].<span class="built_in">push_back</span>(y), level = <span class="built_in">max</span>(level, hi[y]);</span><br><span class="line">		ex[x] -= k, ex[y] += k, e[i].w -=k, e[i ^ <span class="number">1</span>].w += k;</span><br><span class="line">		<span class="keyword">if</span> (!ex[x]) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//如果已经推送完就返回</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">relabel</span><span class="params">(<span class="keyword">int</span> x)</span>  <span class="comment">//重贴标签(高度)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	hi[x] = INF;</span><br><span class="line"> 	<span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)<span class="keyword">if</span> (e[i].w) hi[x] = <span class="built_in">min</span>(hi[x], hi[e[i].ver]);</span><br><span class="line">  	<span class="keyword">if</span> (++hi[x] &lt; n) <span class="comment">//只处理高度小于n的节点</span></span><br><span class="line">  	&#123;</span><br><span class="line">	  	<span class="comment">//新的高度,更新gap</span></span><br><span class="line">	  	B[hi[x]].<span class="built_in">push_back</span>(x);</span><br><span class="line">	  	level = <span class="built_in">max</span>(level, hi[x]);</span><br><span class="line">	  	++gap[hi[x]];  </span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_max</span><span class="params">()</span> <span class="comment">//选出当前高度最大的节点之一,如果已经没有溢出节点返回0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (B[level].<span class="built_in">empty</span>() &amp;&amp; level &gt; <span class="number">-1</span>) --level;</span><br><span class="line">	<span class="keyword">return</span> level == <span class="number">-1</span> ? <span class="number">0</span> : B[level].<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hlpp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">bfs</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i) gap[i] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (hi[i] != INF) ++gap[hi[i]];</span><br><span class="line">	hi[S] = n;</span><br><span class="line">	<span class="built_in">push</span>(S); <span class="comment">//初始化预流</span></span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">while</span> (x = <span class="built_in">find_max</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		B[level].<span class="built_in">pop_back</span>();</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">push</span>(x)) <span class="comment">//仍然溢出</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!--gap[hi[x]])</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">					<span class="keyword">if</span> (i != S &amp;&amp; i != T &amp;&amp; hi[i] &gt; hi[x] &amp;&amp; hi[i] &lt; n + <span class="number">1</span>)</span><br><span class="line">						hi[i] = n + <span class="number">1</span>;  <span class="comment">// 这里重贴成 n+1 的节点都不是溢出节点</span></span><br><span class="line">      		<span class="built_in">relabel</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ex[T];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="费用流"><a href="#费用流" class="headerlink" title="费用流"></a>费用流</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) dis[i] = INF, cur[i] = h[i];</span><br><span class="line">    std::queue&lt;<span class="keyword">int</span>&gt; q; <span class="comment">//这里只能stl,因为spfa一个点可能入队多次,空间大小未知</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (dis[S] = <span class="number">0</span>, q.<span class="built_in">push</span>(S), vis[S] = <span class="literal">true</span>; !q.<span class="built_in">empty</span>(); )</span><br><span class="line">    &#123;</span><br><span class="line">        vis[x = q.<span class="built_in">front</span>()] = <span class="literal">false</span>, q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne) <span class="keyword">if</span> (dis[y = e[i].ver] &gt; dis[x] + e[i].c &amp;&amp; e[i].w)</span><br><span class="line">        &#123;</span><br><span class="line">            dis[y] = dis[x] + e[i].c;</span><br><span class="line">            <span class="keyword">if</span> (!vis[y]) vis[y] = <span class="literal">true</span>, q.<span class="built_in">push</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[T] != INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> lim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == T) <span class="keyword">return</span> lim;</span><br><span class="line">    vis[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, y, t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cur[x]; i != <span class="number">-1</span> &amp;&amp; flow &lt; lim; i = e[i].ne)</span><br><span class="line">    &#123;</span><br><span class="line">        cur[x] = i;</span><br><span class="line">        <span class="keyword">if</span> (!vis[y = e[i].ver] &amp;&amp; dis[y] == dis[x] + e[i].c &amp;&amp; e[i].w)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(t = <span class="built_in">find</span>(y, std::<span class="built_in">min</span>(lim - flow, e[i].w)))) <span class="keyword">continue</span>;</span><br><span class="line">            e[i].w -= t, e[i ^ <span class="number">1</span>].w += t, flow += t, mincost += t * e[i].c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[x] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mcmf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    maxflow = mincost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> flow;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">spfa</span>()) <span class="keyword">while</span>(flow = <span class="built_in">find</span>(S, INF)) maxflow += flow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最小割树"><a href="#最小割树" class="headerlink" title="最小割树"></a>最小割树</h2><p>把 Dinic 的函数改一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _s, <span class="keyword">int</span> <span class="keyword">_t</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S = _s, T = <span class="keyword">_t</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; idx; i += <span class="number">2</span>) e[i].w = (e[i].w + e[i ^ <span class="number">1</span>].w), e[i ^ <span class="number">1</span>].w = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> _s, <span class="keyword">int</span> <span class="keyword">_t</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>(_s, <span class="keyword">_t</span>);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, flow;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">bfs</span>()) <span class="keyword">while</span> (flow = <span class="built_in">find</span>(S, INF)) res += flow;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再加上：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> GHT <span class="comment">//Gomory-Hu Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> D = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> nd[N], h[N], idx = <span class="number">0</span>, dep[N], f[N][D], mn[N][D];</span><br><span class="line">    <span class="function">std::mt19937 <span class="title">rud</span><span class="params">(<span class="number">114514</span>)</span></span>;</span><br><span class="line">    Edge e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>&#123; e[idx] = &#123;h[x], y, z&#125;, h[x] = idx++; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line">        STC <span class="keyword">int</span> tp1[N], tp2[N];</span><br><span class="line">        <span class="keyword">int</span> s, t, flow, ct1 = <span class="number">0</span>, ct2 = <span class="number">0</span>;</span><br><span class="line">        s = nd[l], t = nd[l + <span class="number">1</span>];</span><br><span class="line">        flow = Dinic::<span class="built_in">dinic</span>(s, t);</span><br><span class="line">        <span class="built_in">add</span>(s, t, flow), <span class="built_in">add</span>(t, s, flow);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) (Dinic::dep[nd[i]] ? tp1[++ct1] : tp2[++ct2]) = nd[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ct1; ++i) nd[i + l - <span class="number">1</span>] = tp1[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ct2; ++i) nd[i + l + ct1 - <span class="number">1</span>] = tp2[i];</span><br><span class="line">        <span class="built_in">build</span>(l, l + ct1 - <span class="number">1</span>), <span class="built_in">build</span>(l + ct1, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (q.<span class="built_in">push</span>(<span class="number">1</span>), dep[<span class="number">1</span>] = <span class="number">1</span>; !q.<span class="built_in">empty</span>(); )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne) <span class="keyword">if</span> (!dep[y = e[i].ver])</span><br><span class="line">            &#123;</span><br><span class="line">                dep[y] = dep[x] + <span class="number">1</span>, f[y][<span class="number">0</span>] = x, mn[y][<span class="number">0</span>] = e[i].w;</span><br><span class="line">                q.<span class="built_in">push</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; D; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                mn[i][j] = std::<span class="built_in">min</span>(mn[i][j - <span class="number">1</span>], mn[f[i][j - <span class="number">1</span>]][j - <span class="number">1</span>]);</span><br><span class="line">                f[i][j] = f[f[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) nd[i] = i;</span><br><span class="line">        <span class="built_in">shuffle</span>(nd + <span class="number">1</span>, nd + <span class="number">1</span> + n, rud); <span class="comment">//随机化</span></span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, n), <span class="built_in">bfs</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = INF;</span><br><span class="line">        <span class="keyword">if</span> (dep[x] &gt; dep[y]) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = D - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) <span class="keyword">if</span> (dep[f[y][i]] &gt;= dep[x]) res = std::<span class="built_in">min</span>(res, mn[y][i]), y = f[y][i];</span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">return</span> res == INF ? <span class="number">-1</span> : res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = D - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) <span class="keyword">if</span> (f[x][i] != f[y][i])</span><br><span class="line">        &#123;</span><br><span class="line">            res = std::<span class="built_in">min</span>(res, std::<span class="built_in">min</span>(mn[x][i], mn[y][i]));</span><br><span class="line">            x = f[x][i], y = f[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">        res = std::<span class="built_in">min</span>(res, std::<span class="built_in">min</span>(mn[x][<span class="number">0</span>], mn[y][<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> res == INF ? <span class="number">-1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h1><h2 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a>FFT</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3000000</span> + <span class="number">5</span>; <span class="comment">//注意N要大于二倍n</span></span><br><span class="line"><span class="keyword">const</span> DB PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span> //定义复数</span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	DB a, b;</span><br><span class="line">	<span class="function">Complex <span class="title">make_C</span><span class="params">(<span class="keyword">const</span> DB _a, <span class="keyword">const</span> DB _b)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Complex res;</span><br><span class="line">		res.a = _a, res.b = _b;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;<span class="keyword">_t</span>) <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="built_in">make_C</span>(a + <span class="keyword">_t</span>.a, b + <span class="keyword">_t</span>.b); &#125;</span><br><span class="line">	Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp;<span class="keyword">_t</span>) <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="built_in">make_C</span>(a - <span class="keyword">_t</span>.a, b - <span class="keyword">_t</span>.b); &#125;</span><br><span class="line">	Complex <span class="keyword">operator</span>*(<span class="keyword">const</span> Complex &amp;<span class="keyword">_t</span>) <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="built_in">make_C</span>(a * <span class="keyword">_t</span>.a - b * <span class="keyword">_t</span>.b, a * <span class="keyword">_t</span>.b + b * <span class="keyword">_t</span>.a); &#125;</span><br><span class="line">&#125; a[N], b[N];</span><br><span class="line"><span class="keyword">int</span> r[N], bit, tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(Complex x[], <span class="keyword">int</span> inv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) <span class="keyword">if</span> (i &lt; r[i]) std::<span class="built_in">swap</span>(x[i], x[r[i]]);</span><br><span class="line">	Complex w1, wk, a1, a2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; tot; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		w1 = w1.<span class="built_in">make_C</span>(<span class="built_in">cos</span>(PI / mid), inv * <span class="built_in">sin</span>(PI / mid)); <span class="comment">//由于cos正负相同,不必乘inv</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i += (mid &lt;&lt; <span class="number">1</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			wk = wk.<span class="built_in">make_C</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; ++j, wk = wk * w1)</span><br><span class="line">			&#123;</span><br><span class="line">				a1 = x[i + j], a2 = wk * x[i + j + mid];</span><br><span class="line">				x[i + j] = a1 + a2, x[i + j + mid] = a1 - a2;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; bit) &lt; n + m + <span class="number">1</span>) ++bit;</span><br><span class="line">tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (bit - <span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<h2 id="NTT-全家桶"><a href="#NTT-全家桶" class="headerlink" title="NTT + 全家桶"></a>NTT + 全家桶</h2><p>超长警告</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>, I = <span class="number">86583718</span>, G = <span class="number">3</span>; <span class="comment">//模数,二次剩余,原根</span></span><br><span class="line"><span class="keyword">namespace</span> Poly</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> Cipolla</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> w;</span><br><span class="line">		<span class="function">std::mt19937 <span class="title">rud</span><span class="params">(<span class="number">114514</span>)</span></span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="keyword">int</span> x, y;</span><br><span class="line">            Complex <span class="keyword">operator</span> * (<span class="keyword">const</span> Complex t) <span class="keyword">const</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> (Complex)&#123;((LL)x * t.x % P + (LL)y * t.y % P * w % P) % P, ((LL)x * t.y % P + (LL)y * t.x % P) % P&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; ;</span><br><span class="line">        <span class="function">Complex <span class="title">Cqpow</span><span class="params">(Complex x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Complex res = (Complex)&#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">			<span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = x * x) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = res * x;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">Csqrt</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">qpow</span>(x, (P - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) == P - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> t;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                t = <span class="built_in">rud</span>();</span><br><span class="line">                w = ((LL)t * t % P - x + P) % P;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">qpow</span>(w, (P - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) == P - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="built_in">Cqpow</span>((Complex)&#123;t, <span class="number">1</span>&#125;, (P + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>).x;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(res, P - res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> r[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; ++i) x[i] = y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; ++i) x[i] = y[i]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ready</span><span class="params">(<span class="keyword">int</span> &amp;bit, <span class="keyword">int</span> &amp;tot, <span class="keyword">int</span> len)</span></span>&#123; <span class="keyword">for</span> (tot = <span class="number">1</span>, bit = <span class="number">0</span>; tot &lt; (len &lt;&lt; <span class="number">1</span>); ) tot &lt;&lt;= <span class="number">1</span>, ++bit; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get_r</span><span class="params">(<span class="keyword">int</span> bit, <span class="keyword">int</span> tot)</span></span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (bit - <span class="number">1</span>)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ntt</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> tot, <span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) <span class="keyword">if</span> (i &lt; r[i]) std::<span class="built_in">swap</span>(x[i], x[r[i]]);</span><br><span class="line">        <span class="keyword">int</span> mid, i, j, len, gn, g, a, b;</span><br><span class="line">        <span class="keyword">for</span> (mid = <span class="number">1</span>; mid &lt; tot; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            len = mid &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            gn = <span class="built_in">qpow</span>(G, (P - <span class="number">1</span>) / len);</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="number">-1</span>) gn = <span class="built_in">qpow</span>(gn, P - <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tot; i += len)</span><br><span class="line">            &#123;</span><br><span class="line">                g = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; mid; ++j, g = (LL)g * gn % P)</span><br><span class="line">                &#123;</span><br><span class="line">                    a = x[i + j], b = (LL)g * x[i + j + mid] % P;</span><br><span class="line">                    x[i + j] = (a + b) % P;</span><br><span class="line">                    x[i + j + mid] = (a - b + P) % P;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">        gn = <span class="built_in">qpow</span>(tot, P - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) x[i] = (LL)x[i] * gn % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polymul</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bit, tot;</span><br><span class="line">        <span class="built_in">ready</span>(bit, tot, len);</span><br><span class="line">        <span class="built_in">get_r</span>(bit, tot);</span><br><span class="line">        <span class="built_in">ntt</span>(x, tot, <span class="number">1</span>), <span class="built_in">ntt</span>(y, tot, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) x[i] = (LL)x[i] * y[i] % P;</span><br><span class="line">        <span class="built_in">ntt</span>(x, tot, <span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//记得把x中不用的清0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polyinv</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> len)</span> <span class="comment">//求逆,y记录答案</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(y[<span class="number">0</span>] = <span class="built_in">qpow</span>(x[<span class="number">0</span>], P - <span class="number">2</span>));</span><br><span class="line">        <span class="built_in">polyinv</span>(x, y, (len + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> bit = <span class="number">0</span>, tot = <span class="number">1</span>;</span><br><span class="line">        STC <span class="keyword">int</span> t[N];</span><br><span class="line">        <span class="built_in">ready</span>(bit, tot, len);</span><br><span class="line">        <span class="built_in">get_r</span>(bit, tot);</span><br><span class="line">        <span class="built_in">fill</span>(y, <span class="number">0</span>, (len + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, tot);</span><br><span class="line">        <span class="built_in">fill</span>(t, x, <span class="number">0</span>, len);</span><br><span class="line">        <span class="built_in">fill</span>(t, <span class="number">0</span>, len, tot);</span><br><span class="line">        <span class="built_in">ntt</span>(t, tot, <span class="number">1</span>), <span class="built_in">ntt</span>(y, tot, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) y[i] = (<span class="number">2</span> - (LL)t[i] * y[i] % P + P) % P * y[i] % P;</span><br><span class="line">        <span class="built_in">ntt</span>(y, tot, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">fill</span>(y, <span class="number">0</span>, len, tot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polydiv</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> n, <span class="keyword">int</span> y[], <span class="keyword">int</span> m, <span class="keyword">int</span> a[], <span class="keyword">int</span> b[])</span> <span class="comment">//x除以y商a余b</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        STC <span class="keyword">int</span> ta[N], tb[N];</span><br><span class="line">        <span class="keyword">int</span> dt = n - m + <span class="number">1</span>, tot, bit;</span><br><span class="line">        <span class="built_in">ready</span>(bit, tot, n);</span><br><span class="line">        <span class="built_in">fill</span>(ta, <span class="number">0</span>, <span class="number">0</span>, tot);</span><br><span class="line">        <span class="built_in">fill</span>(tb, <span class="number">0</span>, <span class="number">0</span>, tot);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) ta[i] = y[m - i - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">polyinv</span>(ta, tb, dt);</span><br><span class="line">        <span class="built_in">get_r</span>(bit, tot);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) ta[i] = x[n - i - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">ntt</span>(ta, tot, <span class="number">1</span>), <span class="built_in">ntt</span>(tb, tot, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) ta[i] = (LL)ta[i] * tb[i] %P;</span><br><span class="line">        <span class="built_in">ntt</span>(ta, tot, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dt; ++i) a[i] = ta[dt - i - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">fill</span>(ta, <span class="number">0</span>, <span class="number">0</span>, tot);</span><br><span class="line">        <span class="built_in">fill</span>(tb, <span class="number">0</span>, <span class="number">0</span>, tot);</span><br><span class="line">        <span class="built_in">fill</span>(ta, a, <span class="number">0</span>, dt);</span><br><span class="line">        <span class="built_in">fill</span>(tb, y, <span class="number">0</span>, m);</span><br><span class="line">        <span class="built_in">ntt</span>(ta, tot, <span class="number">1</span>), <span class="built_in">ntt</span>(tb, tot, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) ta[i] = (LL)ta[i] * tb[i] % P;</span><br><span class="line">        <span class="built_in">ntt</span>(ta, tot, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; ++i) b[i] = (x[i] - ta[i] + P) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polydif</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> len)</span> <span class="comment">//求导,y记录答案</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i) y[i - <span class="number">1</span>] = (LL)x[i] * i % P;</span><br><span class="line">        y[len - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polyint</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> len)</span> <span class="comment">//积分,y记录答案</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i) y[i] = (LL)x[i - <span class="number">1</span>] * <span class="built_in">qpow</span>(i, P - <span class="number">2</span>) % P;</span><br><span class="line">        y[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polyln</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        STC <span class="keyword">int</span> a[N], b[N];</span><br><span class="line">        <span class="built_in">polydif</span>(x, a, len);</span><br><span class="line">        <span class="built_in">polyinv</span>(x, b, len);</span><br><span class="line">        <span class="keyword">int</span> bit, tot;</span><br><span class="line">        <span class="built_in">ready</span>(bit, tot, len);</span><br><span class="line">        <span class="built_in">get_r</span>(bit,tot);</span><br><span class="line">        <span class="built_in">fill</span>(a, <span class="number">0</span>, len, tot);</span><br><span class="line">        <span class="built_in">fill</span>(b, <span class="number">0</span>, len, tot);</span><br><span class="line">        <span class="built_in">ntt</span>(a, tot, <span class="number">1</span>), <span class="built_in">ntt</span>(b, tot, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) a[i] = (LL)a[i] * b[i] % P;</span><br><span class="line">        <span class="built_in">ntt</span>(a, tot, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">fill</span>(a, <span class="number">0</span>, len, tot);</span><br><span class="line">        <span class="built_in">polyint</span>(a, y, len);</span><br><span class="line">        <span class="built_in">fill</span>(y, <span class="number">0</span>, len, tot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polyexp</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(y[<span class="number">0</span>] = <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">polyexp</span>(x, y, (len + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> bit, tot;</span><br><span class="line">        STC <span class="keyword">int</span> t[N];</span><br><span class="line">        <span class="built_in">ready</span>(bit, tot, len);</span><br><span class="line">        <span class="built_in">fill</span>(t, <span class="number">0</span>, <span class="number">0</span>, tot);</span><br><span class="line">        <span class="built_in">polyln</span>(y, t, len);</span><br><span class="line">        <span class="built_in">get_r</span>(bit, tot);</span><br><span class="line">        t[<span class="number">0</span>] = (x[<span class="number">0</span>] + <span class="number">1</span> - t[<span class="number">0</span>] + P) % P;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i) t[i] = (x[i] - t[i] + P) % P;</span><br><span class="line">        <span class="built_in">fill</span>(t, <span class="number">0</span>, len, tot);</span><br><span class="line">        <span class="built_in">ntt</span>(t, tot, <span class="number">1</span>), <span class="built_in">ntt</span>(y, tot, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) y[i] = (LL)y[i] * t[i] % P;</span><br><span class="line">        <span class="built_in">ntt</span>(y, tot, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">fill</span>(y, <span class="number">0</span>, len, tot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	k1是真实指数(可以是模后的)</span></span><br><span class="line"><span class="comment">	k2是真实指数模P - 1(欧拉定理)</span></span><br><span class="line"><span class="comment">	k3用于确定前导0个数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polypow</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> k1, <span class="keyword">int</span> k2, <span class="keyword">int</span> k3, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!x[num] &amp;&amp; num &lt; len) ++num;</span><br><span class="line">        <span class="keyword">if</span> ((LL)num * k3 &gt;= len) <span class="keyword">return</span> <span class="built_in">fill</span>(y, <span class="number">0</span>, <span class="number">0</span>, len);</span><br><span class="line">        STC <span class="keyword">int</span> t[N];</span><br><span class="line">        <span class="keyword">int</span> x0 = x[num], inv = <span class="built_in">qpow</span>(x0, P - <span class="number">2</span>);</span><br><span class="line">        len -= num;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) x[i] = (LL)x[i + num] * inv % P;</span><br><span class="line">        <span class="keyword">int</span> bit, tot;</span><br><span class="line">        <span class="built_in">ready</span>(bit, tot, len);</span><br><span class="line">        <span class="built_in">fill</span>(t, <span class="number">0</span>, <span class="number">0</span>, tot);</span><br><span class="line">        <span class="built_in">fill</span>(x, <span class="number">0</span>, len, tot);</span><br><span class="line">        <span class="built_in">polyln</span>(x, t, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) t[i] = (LL)t[i] * k1 % P;</span><br><span class="line">        <span class="built_in">fill</span>(t, <span class="number">0</span>, len, tot);</span><br><span class="line">        <span class="built_in">polyexp</span>(t, y, len);</span><br><span class="line">        len += num;</span><br><span class="line">        x0 = <span class="built_in">qpow</span>(x0, k2);</span><br><span class="line">        num = num * k3;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= num; --i) y[i] = (LL)y[i - num] * x0 % P;</span><br><span class="line">        <span class="built_in">fill</span>(y, <span class="number">0</span>, <span class="number">0</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ready_for_pow</span><span class="params">(<span class="keyword">char</span> *k, <span class="keyword">int</span> &amp;k1, <span class="keyword">int</span> &amp;k2, <span class="keyword">int</span> &amp;k3)</span> <span class="comment">//k太大,计算k1,k2,k3</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        k1 = k2 = k3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l = <span class="built_in">strlen</span>(k + <span class="number">1</span>); i &lt;= l; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            k1 = ((LL)k1 * <span class="number">10</span> + (k[i] ^ <span class="number">48</span>)) % P;</span><br><span class="line">            k2 = ((LL)k2 * <span class="number">10</span> + (k[i] ^ <span class="number">48</span>)) % (P - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> ((LL)k3 * <span class="number">10</span> + (k[i] ^ <span class="number">48</span>) &lt;= P) k3 = (LL)k3 * <span class="number">10</span> + (k[i] ^ <span class="number">48</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polysqrt</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sq = Cipolla::<span class="built_in">Csqrt</span>(x[<span class="number">0</span>]), inv = <span class="built_in">qpow</span>(x[<span class="number">0</span>], P - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) x[i] = (LL)x[i] * inv % P;</span><br><span class="line">        <span class="built_in">polypow</span>(x, y, (P + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, (P + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, <span class="number">1</span>, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) y[i] = (LL)y[i] * sq % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polysin</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        STC <span class="keyword">int</span> a[N], b[N], c[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) a[i] = (LL)x[i] * I % P;</span><br><span class="line">        <span class="built_in">polyexp</span>(a, b, len);</span><br><span class="line">        <span class="built_in">polyinv</span>(b, c, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) b[i] = (b[i] - c[i] + P) % P;</span><br><span class="line">        <span class="keyword">int</span> inv = <span class="built_in">qpow</span>((I &lt;&lt; <span class="number">1</span>) % P, P - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) y[i] = (LL)b[i] * inv % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polycos</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        STC <span class="keyword">int</span> a[N], b[N], c[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) a[i] = (LL)x[i] * I % P;</span><br><span class="line">        <span class="built_in">polyexp</span>(a, b, len);</span><br><span class="line">        <span class="built_in">polyinv</span>(b, c, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) b[i] = (b[i] + c[i]) % P;</span><br><span class="line">        <span class="keyword">int</span> inv = <span class="built_in">qpow</span>(<span class="number">2</span>, P - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) y[i] = (LL)b[i] * inv % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polytan</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        STC <span class="keyword">int</span> a[N], b[N], c[N];</span><br><span class="line">        <span class="built_in">polysin</span>(x, a, len);</span><br><span class="line">        <span class="built_in">polycos</span>(x, b, len);</span><br><span class="line">        <span class="built_in">polyinv</span>(b, c, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) y[i] = a[i] * c[i] % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polyasin</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        STC <span class="keyword">int</span> a[N], b[N], c[N];</span><br><span class="line">        <span class="built_in">polydif</span>(x, a, len);</span><br><span class="line">        <span class="keyword">int</span> bit, tot;</span><br><span class="line">        <span class="built_in">ready</span>(bit, tot, len);</span><br><span class="line">        <span class="built_in">get_r</span>(bit, tot);</span><br><span class="line">        <span class="built_in">ntt</span>(x, tot, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) b[i] = (<span class="number">1</span> - (LL)x[i] * x[i]% P + P) % P;</span><br><span class="line">        <span class="built_in">ntt</span>(b, tot, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">fill</span>(b, <span class="number">0</span>, len, tot);</span><br><span class="line">        <span class="built_in">polysqrt</span>(b, c, len);</span><br><span class="line">        <span class="built_in">fill</span>(b, <span class="number">0</span>, <span class="number">0</span>, tot);</span><br><span class="line">        <span class="built_in">polyinv</span>(c, b, len);</span><br><span class="line">        <span class="built_in">ntt</span>(a, tot, <span class="number">1</span>), <span class="built_in">ntt</span>(b, tot, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) a[i] = (LL)a[i] * b[i] % P;</span><br><span class="line">        <span class="built_in">ntt</span>(a, tot, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">polyint</span>(a, y, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polyacos</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">polyasin</span>(x, y, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) y[i] = y[i] ? P - y[i] : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polyatan</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        STC <span class="keyword">int</span> a[N], b[N], c[N];</span><br><span class="line">        <span class="built_in">polydif</span>(x, a, len);</span><br><span class="line">        <span class="keyword">int</span> bit, tot;</span><br><span class="line">        <span class="built_in">ready</span>(bit, tot, len);</span><br><span class="line">        <span class="built_in">get_r</span>(bit, tot);</span><br><span class="line">        <span class="built_in">ntt</span>(x, tot, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) b[i] = (<span class="number">1</span> + (LL)x[i] * x[i]% P) % P;</span><br><span class="line">        <span class="built_in">ntt</span>(b, tot, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">fill</span>(b, <span class="number">0</span>, len, tot);</span><br><span class="line">        <span class="built_in">polyinv</span>(b, c, len);</span><br><span class="line">        <span class="built_in">ntt</span>(a, tot, <span class="number">1</span>), <span class="built_in">ntt</span>(c, tot, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) a[i] = (LL)a[i] * c[i] % P;</span><br><span class="line">        <span class="built_in">ntt</span>(a, tot, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">polyint</span>(a, y, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h1><h2 id="浮点数比较"><a href="#浮点数比较" class="headerlink" title="浮点数比较"></a>浮点数比较</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(DB x, DB y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(x - y) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="平面最近点对"><a href="#平面最近点对" class="headerlink" title="平面最近点对"></a>平面最近点对</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LDB p[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Point &amp;t) <span class="keyword">const</span> &#123; <span class="keyword">return</span> p[<span class="number">0</span>] * p[<span class="number">1</span>] &lt; t.p[<span class="number">0</span>] * t.p[<span class="number">1</span>]; &#125;</span><br><span class="line">&#125; p[N];</span><br><span class="line"><span class="function">std::mt19937 <span class="title">rud</span><span class="params">(<span class="number">114514</span>)</span></span>;</span><br><span class="line">LDB th = <span class="built_in">rud</span>(), ans = INF;</span><br><span class="line">LDB z = <span class="built_in">sin</span>(th), w = <span class="built_in">cos</span>(th);</span><br><span class="line">LDB a, b, c, d;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%Lf %Lf&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    p[i] = &#123;a * w + b * z, -a * z + b * w, a, b&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">stable_sort</span>(p + <span class="number">1</span>, p + <span class="number">1</span> + n); <span class="comment">//stable是稳定排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    a = p[i].p[<span class="number">2</span>], b = p[i].p[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= K &amp;&amp; i + j &lt;= n; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        c = p[i + j].p[<span class="number">2</span>], d = p[i + j].p[<span class="number">3</span>];</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, (a - c) * (a - c) + (b - d) * (b - d));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="点间距离"><a href="#点间距离" class="headerlink" title="点间距离"></a>点间距离</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DB <span class="title">dist</span><span class="params">(Point x, Point y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point t = x - y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(t.x * t.x + t.y * t.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><p>用点表示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	DB x, y;</span><br><span class="line">	Point <span class="keyword">operator</span> + (Point t)&#123; <span class="keyword">return</span> (Point)&#123;x + t.x, y + t.y&#125;; &#125;</span><br><span class="line">	Point <span class="keyword">operator</span> - (Point t)&#123; <span class="keyword">return</span> (Point)&#123;x - t.x, y - t.y&#125;; &#125;</span><br><span class="line">	Point <span class="keyword">operator</span> * (DB t)&#123; <span class="keyword">return</span> (Point)&#123;x * t, y * t&#125;; &#125;</span><br><span class="line">	DB <span class="keyword">operator</span> &amp; (Point t)&#123; <span class="keyword">return</span> x * t.x + y * t.y; &#125; <span class="comment">//点乘</span></span><br><span class="line">	DB <span class="keyword">operator</span> * (Point t)&#123; <span class="keyword">return</span> x * t.y - y * t.x; &#125; <span class="comment">//叉乘</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DB <span class="title">mo</span><span class="params">(Point x)</span></span>&#123; <span class="keyword">return</span> std::<span class="built_in">sqrt</span>(x &amp; x); &#125; <span class="comment">//模长</span></span><br><span class="line"><span class="function">DB <span class="title">angle</span><span class="params">(Point x, Point y)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">acos</span>((x &amp; y) / <span class="built_in">mo</span>(x) / <span class="built_in">mo</span>(y)); &#125; <span class="comment">//计算向量夹角</span></span><br><span class="line"><span class="function">Point <span class="title">rot</span><span class="params">(Point x, DB theta)</span> <span class="comment">//向量(点)顺时针旋转角度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;x.x * <span class="built_in">cos</span>(theta) + x.y * <span class="built_in">sin</span>(theta), -x.x * <span class="built_in">sin</span>(theta) + x.y * <span class="built_in">cos</span>(theta)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DB <span class="title">area</span><span class="params">(Point x, Point y, Point z)</span></span>&#123; <span class="keyword">return</span> (y - x) * (z - x); &#125; <span class="comment">//计算XY,XZ围成平行四边形面积</span></span><br></pre></td></tr></table></figure>

<h2 id="点与线"><a href="#点与线" class="headerlink" title="点与线"></a>点与线</h2><p>点到直线距离：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DB <span class="title">dis_z</span><span class="params">(Point p, Point x, Point y)</span> <span class="comment">//p到直线(x-&gt;y)的距离</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point u = y - x, v = p - x;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>((u * v) / <span class="built_in">mo</span>(u));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点到线段距离：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DB <span class="title">dis_x</span><span class="params">(Point p, Point x, Point y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="built_in">mo</span>(p - x);</span><br><span class="line">    Point u = y - x, v = p - x, w = p - y;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cmp</span>(u &amp; v, <span class="number">0</span>) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">mo</span>(v);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cmp</span>(u &amp; w, <span class="number">0</span>) &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">mo</span>(w);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dis_z</span>(p, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点在直线上的投影：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DB <span class="title">proj</span><span class="params">(Point p, Point x, Point y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point u = y - x;</span><br><span class="line">    <span class="keyword">return</span> x + u * (u &amp; (p - x)) / (u &amp; u));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点是否在直线上：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_on</span><span class="params">(Point p, Point x, Point y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">cmp</span>((p - x) * (p - y), <span class="number">0</span>) &amp;&amp; <span class="built_in">cmp</span>((p - x) &amp; (p - y), <span class="number">0</span>) &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线与线"><a href="#线与线" class="headerlink" title="线与线"></a>线与线</h2><p>直线交点：</p>
<p> 注意点向式表达直线： $p = p_0 + t \vec{v}$ </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">jiao</span><span class="params">(Point p, Point u, Point q, Point v)</span> <span class="comment">//点项式</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u * v == <span class="number">0</span>) <span class="keyword">return</span> &#123;INF, INF&#125;; <span class="comment">//平行或者重合</span></span><br><span class="line">    DB t = (p - q) * v / (u * v);</span><br><span class="line">    <span class="keyword">return</span> p + u * t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断线段是否相交：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_jiao</span><span class="params">(Point x_1, Point y_1, Point x_2, Point y_2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> c1 = <span class="built_in">cross</span>(y_1 - x_1, x_2 - x_1), c2 = <span class="built_in">cross</span>(y_1 - x_1, y_2 - x_1);</span><br><span class="line">    <span class="keyword">double</span> c3 = <span class="built_in">cross</span>(y_2 - x_2, y_1 - x_2), c4 = <span class="built_in">cross</span>(y_2 - x_2, x_1 - x_2);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cmp</span>(c1, <span class="number">0</span>) * <span class="built_in">cmp</span>(c2, <span class="number">0</span>) &lt;= <span class="number">0</span> &amp;&amp; <span class="built_in">cmp</span>(c3, <span class="number">0</span>) * <span class="built_in">cmp</span>(c4, <span class="number">0</span>) &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多边形"><a href="#多边形" class="headerlink" title="多边形"></a>多边形</h2><p>按<strong>逆时针</strong>存储所有点</p>
<p>面积：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DB <span class="title">pgarea</span><span class="params">(Point p[], <span class="keyword">int</span> n)</span> <span class="comment">//polygon area</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DB res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i) res += (p[i] - p[<span class="number">0</span>]) * (p[i + <span class="number">1</span>] - p[<span class="number">0</span>]); <span class="comment">// //这里点编号为0~n-1</span></span><br><span class="line">    <span class="keyword">return</span> res / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断点是否在多边形内：</p>
<p>射线法，从该点任意做一条和所有边都不平行的射线，交点个数为偶数，则在多边形外，为奇数，则在多边形内</p>
<h2 id="最小圆覆盖"><a href="#最小圆覆盖" class="headerlink" title="最小圆覆盖"></a>最小圆覆盖</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::mt19937 <span class="title">rud</span><span class="params">(<span class="number">114514</span>)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span>&#123;</span> Point p; DB r; &#125; ;</span><br><span class="line"><span class="function">PR&lt;Point, Point&gt; <span class="title">get_line</span><span class="params">(Point x, Point y)</span> </span>&#123; <span class="keyword">return</span> &#123;(x + y) / <span class="number">2</span>, <span class="built_in">rotate</span>(y - x, PI / <span class="number">2</span>)&#125;; &#125; <span class="comment">//找中垂线</span></span><br><span class="line"><span class="function">Circle <span class="title">get_c</span><span class="params">(Point x, Point y, Point z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> u = <span class="built_in">get_line</span>(x, y), v = <span class="built_in">get_line</span>(x, z);</span><br><span class="line">    <span class="keyword">auto</span> p = <span class="built_in">jiao</span>(u.first, u.second, v.first, v.second);</span><br><span class="line">    <span class="keyword">return</span> &#123;p, <span class="built_in">dist</span>(p, x)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(Point p[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::<span class="built_in">shuffle</span>(q, q + n, rud);</span><br><span class="line">    <span class="function">Circle <span class="title">c</span><span class="params">(&#123;q[<span class="number">0</span>], <span class="number">0</span>&#125;)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) <span class="keyword">if</span> (<span class="built_in">cmp</span>(c.r, <span class="built_in">dist</span>(c.p, q[i])) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c = &#123;q[i], <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) <span class="keyword">if</span> (<span class="built_in">cmp</span>(c.r, <span class="built_in">dist</span>(c.p, q[j])) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            c = &#123;(q[i] + q[j]) / <span class="number">2</span>, <span class="built_in">dist</span>(q[i], q[j]) / <span class="number">2</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; j; ++k) <span class="keyword">if</span> (<span class="built_in">cmp</span>(c.r, <span class="built_in">dist</span>(c.p, q[k])) &lt; <span class="number">0</span>) c = <span class="built_in">get_c</span>(q[i], q[j], q[k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DB <span class="title">andrew</span><span class="params">(Point x[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    STC <span class="keyword">int</span> stk[N];</span><br><span class="line">    STC <span class="keyword">bool</span> used[N];</span><br><span class="line">    std::<span class="built_in">sort</span>(x, x + n);</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &gt;= <span class="number">2</span> &amp;&amp; <span class="built_in">area</span>(x[stk[top - <span class="number">1</span>]], x[stk[top]], x[i]) &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 凸包边界上的点即使被从栈中删掉，也不能删掉used上的标记</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">area</span>(x[stk[top - <span class="number">1</span>]], x[stk[top]], x[i])) --top;</span><br><span class="line">            <span class="keyword">else</span> used[stk[top--]] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stk[++top] = i;</span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    used[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (used[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//为了应对所有点共线的情况,这里不能取&lt;=</span></span><br><span class="line">        <span class="keyword">while</span> (top &gt;= <span class="number">2</span> &amp;&amp; <span class="built_in">area</span>(x[stk[top - <span class="number">1</span>]], x[stk[top]], x[i]) &lt; <span class="number">0</span>) --top;</span><br><span class="line">        stk[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    DB res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= top; ++i) res += <span class="built_in">dist</span>(x[stk[i - <span class="number">1</span>]], x[stk[i]]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数也叫 <code>convex(int x[], int n)</code> </p>
<h2 id="半平面交"><a href="#半平面交" class="headerlink" title="半平面交"></a>半平面交</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	Point st, ed;</span><br><span class="line">	<span class="function">DB <span class="title">angle</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="built_in">atan2</span>(ed.y - st.y, ed.x - st.x); &#125;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="function">Point <span class="title">jiao</span><span class="params">(Line x, Line y)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">jiao</span>(x.st, x.ed - x.st, y.st, y.ed - y.st); &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">on_r</span><span class="params">(Line &amp;x, Line y, Line z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Point o = <span class="built_in">jiao</span>(y, z);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">cmp</span>(<span class="built_in">area</span>(x.st, x.ed, o), <span class="number">0</span>) &lt;= <span class="number">0</span>; <span class="comment">//这里取不取等依题意</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DB <span class="title">halfp</span><span class="params">(Line x[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">sort</span>(x, x + len);</span><br><span class="line">	<span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">	STC <span class="keyword">int</span> q[N];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i &amp;&amp; !<span class="built_in">cmp</span>(x[i].<span class="built_in">angle</span>(), x[i - <span class="number">1</span>].<span class="built_in">angle</span>())) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_r</span>(x[i], x[q[tt - <span class="number">1</span>]], x[q[tt]])) --tt;</span><br><span class="line">		<span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_r</span>(x[i], x[q[hh + <span class="number">1</span>]], x[q[hh]])) ++hh;</span><br><span class="line">		q[++tt] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_r</span>(x[q[hh]], x[q[tt - <span class="number">1</span>]], x[q[tt]])) --tt;</span><br><span class="line">	<span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_r</span>(x[q[tt]], x[q[hh + <span class="number">1</span>]], x[q[hh]])) ++hh;</span><br><span class="line">	q[++tt] = q[hh];</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = hh; i &lt; tt; ++i) ans[k++] = <span class="built_in">jiao</span>(x[q[i]], x[q[i + <span class="number">1</span>]]);</span><br><span class="line">   	DB res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + <span class="number">1</span> &lt; k; ++i) res += <span class="built_in">area</span>(ans[<span class="number">0</span>], ans[i], ans[i + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> res / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="旋转卡壳"><a href="#旋转卡壳" class="headerlink" title="旋转卡壳"></a>旋转卡壳</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DB <span class="title">rot_cal</span><span class="params">(Point x[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">convex</span>(x, len);</span><br><span class="line">    <span class="keyword">if</span> (top &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">dist</span>(x[<span class="number">0</span>], x[len - <span class="number">1</span>]);</span><br><span class="line">    DB res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">2</span>; i &lt; top; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> d = x[stk[i]], e = x[stk[i + <span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">area</span>(d, e, x[stk[j]]) &lt; <span class="built_in">area</span>(d, e, x[stk[j + <span class="number">1</span>]])) j = (j + <span class="number">1</span>) % top;</span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="built_in">max</span>(<span class="built_in">dist</span>(d, x[stk[j]]), <span class="built_in">dist</span>(e, x[stk[j]])));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = <span class="built_in">LL</span>(x) * x % P) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = <span class="built_in">LL</span>(res) * x % P;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="光速幂"><a href="#光速幂" class="headerlink" title="光速幂"></a>光速幂</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BL = (<span class="number">1</span> &lt;&lt; <span class="number">16</span>) + <span class="number">5</span>, B = <span class="built_in">sqrt</span>(P);</span><br><span class="line"><span class="keyword">int</span> qp[BL][<span class="number">2</span>], ph;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= x; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) res = res / x * (x - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ph = <span class="built_in">phi</span>(P);</span><br><span class="line">    qp[<span class="number">0</span>][<span class="number">0</span>] = qp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= B; ++i) qp[i][<span class="number">0</span>] = qp[i - <span class="number">1</span>][<span class="number">0</span>] * x % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= B; ++i) qp[i][<span class="number">1</span>] = qp[i - <span class="number">1</span>][<span class="number">1</span>] * qp[B][<span class="number">0</span>] % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qqpow</span><span class="params">(<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    y %= ph;</span><br><span class="line">    <span class="keyword">return</span> qp[y % B][<span class="number">0</span>] * qp[y / B][<span class="number">1</span>] % P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="龟速乘"><a href="#龟速乘" class="headerlink" title="龟速乘"></a>龟速乘</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">mul</span><span class="params">(LL x, LL y, LL p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LL res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (x + x) % P) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (res + x) % P;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h2><p>质数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!vis[i]) pri[++cnt] = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; <span class="built_in">LL</span>(pri[j]) * i &lt;= n; ++j)</span><br><span class="line">	&#123;</span><br><span class="line">		vis[pri[j] * i] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>莫比乌斯函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mu[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 1特判</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!vis[i]) pri[++cnt] = i, mu[i] = <span class="number">-1</span>; <span class="comment">//质数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; <span class="built_in">LL</span>(pri[j]) * i &lt;= n; ++j)</span><br><span class="line">	&#123;</span><br><span class="line">		vis[pri[j] * i] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>) <span class="comment">//若有一个质因数指数大于1</span></span><br><span class="line">		&#123; </span><br><span class="line">			mu[i * pri[j]] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		mu[i * pri[j]] = -mu[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>欧拉函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!vis[i]) pri[++cnt] = i, phi[i] = i - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; <span class="built_in">LL</span>(pri[j]) * i &lt;= n; ++j)</span><br><span class="line">	&#123;</span><br><span class="line">		vis[pri[j] * i] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			phi[i * pri[j]] = phi[i] * pri[j];</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		phi[i * pri[j]] = phi[i] * (pri[j] - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分解因数-质因数"><a href="#分解因数-质因数" class="headerlink" title="分解因数/质因数"></a>分解因数/质因数</h2><p>根号暴力即可</p>
<h2 id="数论分块"><a href="#数论分块" class="headerlink" title="数论分块"></a>数论分块</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	r = n / (n / l);</span><br><span class="line">	[l, r]之间的数的(n/i)都相等</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">return</span> y ? <span class="built_in">gcd</span>(y, x % y) : x; &#125;</span><br></pre></td></tr></table></figure>

<p>拓展版：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!b) <span class="keyword">return</span> x = <span class="number">1</span>, y = <span class="number">0</span>, a;</span><br><span class="line">	<span class="keyword">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">	y -= a / b * x;</span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BSGS"><a href="#BSGS" class="headerlink" title="BSGS"></a>BSGS</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsgs</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">1</span> % p == b % p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="built_in">sqrt</span>(p) + <span class="number">1</span>;</span><br><span class="line">	std::map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ha;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = b % p; i &lt; k; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		ha[j] = i;</span><br><span class="line">		j = (LL)j * a % p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ak = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) ak = (LL)ak * a % p;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = ak; i &lt;= k; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (ha.<span class="built_in">find</span>(j) != ha.<span class="built_in">end</span>()) <span class="keyword">return</span> i * k - ha[j];</span><br><span class="line">		j = (LL)j * ak % p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -INF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拓展版：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exbsgs</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	b = (b % p + p) % p; <span class="comment">//保证b为正数</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">1</span> % p == b % p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">	<span class="keyword">int</span> d = <span class="built_in">exgcd</span>(a, p, x, y);</span><br><span class="line">	<span class="keyword">if</span> (d &gt; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (b % d) <span class="keyword">return</span> -INF;</span><br><span class="line">		<span class="built_in">exgcd</span>(a / d, p / d, x, y);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">exbsgs</span>(a, (LL)b / d * x % (p / d), p / d) + <span class="number">1</span>; <span class="comment">//注意加1 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">bsgs</span>(a, b, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">crt</span><span class="params">(<span class="keyword">int</span> m[], <span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LL M = <span class="number">1</span>, res = <span class="number">0</span>, mt, x, y;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) M *= m[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		mt = M / m[i];</span><br><span class="line">		<span class="built_in">exgcd</span>(mt, m[i], x, y);</span><br><span class="line">		res += mt * a[i] * (x &lt; <span class="number">0</span> ? x + m[t] : x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拓展：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">excrt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LL x, y, k, M = m[<span class="number">1</span>], res = a[<span class="number">1</span>]; <span class="comment">//第一个方程的解特判</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		LL a = M, b = m[i], c = (a[i] - res % b + b) % b; <span class="comment">// ax = c (p b)</span></span><br><span class="line">		LL d = <span class="built_in">exgcd</span>(a, b, x, y), bg = b / d;</span><br><span class="line">		<span class="keyword">if</span> (c % d != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//判断是否无解</span></span><br><span class="line">		x = <span class="built_in">mul</span>(x, c / d, bg); <span class="comment">//龟速乘</span></span><br><span class="line">		res += x * M; <span class="comment">//更新前k个方程组的答案</span></span><br><span class="line">		M *= bg;	  <span class="comment">// M为前k个m的lcm</span></span><br><span class="line">		res = (res % M + M) % M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (res % M + M) % M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="逆元递推式"><a href="#逆元递推式" class="headerlink" title="逆元递推式"></a>逆元递推式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) inv[i] = -(P / i) * inv[P % i];</span><br></pre></td></tr></table></figure>

<h2 id="斐波拉契数列推导"><a href="#斐波拉契数列推导" class="headerlink" title="斐波拉契数列推导"></a>斐波拉契数列推导</h2><p>$$<br>\begin{aligned}<br>&amp; 设系数r,s使得: \\<br>&amp; F(n) - r F(n - 1) = s[F(n - 1) - rF(n - 2)] \\<br>&amp; F(n) = (s + r)F(n - 1) - sr F(n - 2) \\<br>&amp; 那么有: \\<br>&amp; r + s = 1, rs = -1 \\<br>&amp; 再考虑这些式子: \\<br>&amp; \begin{cases}<br>F(n) - rF(n - 1) = s [F(n - 1) - rF(n - 2)] \\<br>F(n - 1) - rF(n - 2) = s [F(n - 2) - rF(n - 3)] \\<br>…\\<br>F(3) - F(2) = s [F(2) - r F(1)]<br>\end{cases} \\<br>&amp; 联立得: \\<br>&amp; F(n) - rF(n - 1) = s^{n - 2} [F(2) - F(1)] \\<br>&amp; 又因为: s = 1 - r, F(1) = F(2) = 1 \\<br>&amp; 有: F(n) = s^{n - 1} + r F(n - 1) \\<br>&amp; F(n) = s^{n - 1} + r F(n - 1) \\<br>&amp; F(n) = s^{n - 1} + r s^{n - 2} + r^{2} F(n - 2) \\<br>&amp; … \\<br>&amp; F(n) = s^{n - 1} + r s^{n - 2} + r^{2} s^{n - 3} + … + r^{n - 2} s + r^{n - 1} \\<br>&amp; 等比数列求和得: F(n) = \frac{s^{n - 1} - r^{n - 1}\frac{r}{s}}{1 - \frac{r}{s}} \\<br>&amp; F(n) = \frac{s^n - r^n}{s - r} \\<br>&amp; 再由: r + s = 1, rs = -1得: \\<br>&amp; \begin{cases}<br>s = \frac{1 + \sqrt{5}}{2} \\<br>r = \frac{1 - \sqrt{5}}{2}<br>\end{cases} \\<br>&amp; 于是 F(n) = \frac{\sqrt{5}}{5}[(\frac{1 + \sqrt{5}}{2})^n - (\frac{1 - \sqrt{5}}{2})^n]<br>\end{aligned}<br>$$</p>
<h2 id="威尔逊定理"><a href="#威尔逊定理" class="headerlink" title="威尔逊定理"></a>威尔逊定理</h2><p>$(P - 1)! \equiv -1 \pmod P$ </p>
<h2 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h2><p>$a^b \equiv a^{b \mod \varphi(P)} \pmod P$ </p>
<p>顺便还有欧拉函数的一个运用：<br>$$<br>[1 \sim n] 之间与 m 互质的数的个数为 Ans = \frac{n}{m} \varphi(m)<br>$$<br>再给出计算式： $\varphi(x) = x \prod \frac{p - 1}{p}, 其中p是x的质因数$ </p>
<h2 id="Miller-Rabin-素数测试"><a href="#Miller-Rabin-素数测试" class="headerlink" title="Miller-Rabin 素数测试"></a>Miller-Rabin 素数测试</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="function">std::mt19937 <span class="title">rud</span><span class="params">(<span class="number">114514</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>) <span class="keyword">return</span> a % p;</span><br><span class="line">    <span class="keyword">int</span> w = <span class="built_in">exp</span>(a, m / <span class="number">2</span>, p);</span><br><span class="line">    w = <span class="built_in">LL</span>(w) * w % p;</span><br><span class="line">    <span class="keyword">if</span> (m &amp; <span class="number">1</span>) w = <span class="built_in">LL</span>(w) * a % p;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">miller_rabin</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="built_in">rud</span>() % (n - <span class="number">2</span>) + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">exp</span>(a, n, n) != a) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="组合计数"><a href="#组合计数" class="headerlink" title="组合计数"></a>组合计数</h1><h2 id="组合数计算"><a href="#组合数计算" class="headerlink" title="组合数计算"></a>组合数计算</h2><p>$A_n^m = \frac{n!}{(n - m)!}$ </p>
<p>$C_n^m = \binom{n}{m} =  \frac{A_n^m}{m!} = \frac{n!}{m!(n - m)!}$ </p>
<p>特别的，当 $m &gt; n$ 时， $C_n^m = A_n^m = 0$ </p>
<p>多重排列： $\binom{n}{n_1, n_2, …, n_k} = \frac{n!}{\prod n_i!}$ </p>
<p>错位排列： $f(n) = (n - 1)(f(n - 1) + f(n - 2))$ </p>
<p>错位排列2 ： $f(n) = n!(\frac{1}{1!} - \frac{1}{2!} + \frac{1}{3!} - … + (-1)^{n - 1} \frac{1}{n!})$ </p>
<p> 圆排： $Q_n^r = \frac{A_n^r}{r}$  </p>
<p>组合数的一些性质：<br>$$<br>\begin{aligned}<br>&amp; \binom{n}{m} = \binom{n}{n - m} \\<br>&amp; \binom{n}{k} = \frac{n}{k} \binom{n - 1}{k - 1} \\<br>&amp; \binom{n}{m} = \binom{n - 1}{m} + \binom{n - 1}{m} \\<br>&amp; \binom{n}{0} + \binom{n}{1} + … + \binom{n}{n} = 2^n \\<br>&amp; \sum_{0}^n (-1)^i \binom{n}{i} = [n == 0] \<br>&amp; \sum_{i = 0}^{m} \binom{n}{i} \binom{m}{m - i} = \binom{m + n}{m} (n \ge m)\\<br>&amp; \sum_{i = 0}^n \binom{n}{i}^2 = \binom{2n}{n} \\<br>&amp; \sum_{i = 0}^n i \binom{n}{i} = n 2^{n - 1} \\<br>&amp; \sum_{i = 0}^n i^2 \binom{n}{i} = n (n + 1) 2^{n - 2} \\<br>&amp; \sum_{i = 0}^n \binom{i}{k} = \binom{n + 1}{k + 1} \\<br>&amp; \binom{n}{t} \binom{t}{k} = \binom{n}{k} = \binom{n - k}{t - k} \\<br>&amp; \sum_{i = 0}^n \binom{n - i}{i} = F(n + 1) (其中F(n + 1)表示斐波拉契数列)<br>\end{aligned}<br>$$</p>
<p>做 $k$ 次前缀异或和，对于最后一个数，第 $i$ 个数被计算次数为 $\binom{n - i + k - 1}{k - 1} = \binom{n - i + k - 1}{n - i}$ </p>
<h2 id="Lucas-定理"><a href="#Lucas-定理" class="headerlink" title="Lucas 定理"></a>Lucas 定理</h2><p>$\binom{n}{m} \mod P = \binom{\lfloor n / P \rfloor}{\lfloor m / P \rfloor} * \binom{n \mod P}{m \mod P} \mod P$ </p>
<p>推论： $\binom{n}{m} \equiv 1 \pmod 2$ 的充要条件是 $m \subseteq n$ </p>
<h2 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h2><p>$$<br>\begin{aligned}<br>&amp; Cat(n) = \frac{\binom{2n}{n}}{n + 1} \\<br>&amp; Cat(n) =<br>\begin{cases}<br>\sum_{i = 1}^n Cat(i - 1)Cat(n - i) &amp; n \ge 2 \\<br>1 &amp; n = 0, 1<br>\end{cases} \\<br>&amp; Cat(n) = \frac{Cat(n - 1)(4n - 2)}{n + 1} \\<br>&amp; Cat(n) = \binom{2n}{n} - \binom{2n}{n - 1}<br>\end{aligned}<br>$$</p>
<h2 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h2><p>$$<br>\begin{aligned}<br>&amp; F(n) = \sum_{d \mid n} f(d) \Rightarrow f(n) = \sum_{d \mid n} \mu(d) F(\frac{n}{d}) \\<br>&amp; F(n) = \sum_{n \mid d} f(d) \Rightarrow f(n) = \sum_{n \mid d} \mu(\frac{d}{n}) F(d) \\<br>&amp; \sum_{d \mid n} \mu(d) = [n == 1] \\<br>&amp; \sum_{d \mid n} \frac{\mu(d)}{d} = \frac{\varphi(n)}{n} \\<br>&amp; d(nm) = \sum_{i \mid n} \sum_{j \mid m} [\gcd(i, j) == 1] (其中d(x)表示x的约数个数)<br>\end{aligned}<br>$$</p>
<h2 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h2><p>普通型 OGF ：<br>$$<br>\begin{aligned}<br>&amp; \prod_{i = 1}^n( \sum_{m \in M_i} x^m) (其中M_i是a_i的出现次数集合) \\<br>&amp; 常见的有: \\<br>&amp; \frac{1}{(1 - x)^n} = 1 + nx + \frac{n * (n + 1)}{2!}x^2 + \frac{n * (n + 1) * (n + 2)}{3!} + … \\<br>&amp; \frac{1}{1 - x} = 1 + x + x^2 + x^3 + …<br>\end{aligned}<br>$$<br>指数型 EGF ：<br>$$<br>\begin{aligned}<br>&amp; \prod_{i = 1}^n( \sum_{m \in M_i} \frac{x^m}{m!}) (其中M_i是a_i的出现次数集合) \\<br>&amp; 常见的有: \\<br>&amp; e^x = \sum_{n = 0}^{\infty} \frac{x^n}{n!} = 1 + x + \frac{x^2}{2!} + … \\<br>&amp; \frac{e^x + e{-x}}{2} = \sum_{n = 0}^{\infty} \frac{x^{2n}}{(2n)!} = 1 + \frac{x^2}{2!} + \frac{x^4}{4!} + … \\<br>&amp; \frac{e^x - e^{-x}}{2} = \sum_{n = 0}^{\infty} \frac{x^{2n + 1}}{(2n + 1)!} = x + \frac{x^3}{3!} + \frac{x^5}{5!} + …<br>\end{aligned}<br>$$</p>
<h1 id="群论"><a href="#群论" class="headerlink" title="群论"></a>群论</h1><h2 id="置换群"><a href="#置换群" class="headerlink" title="置换群"></a>置换群</h2><p> $n$ 个元素 $1, 2, …, n$ 之间的一个置换 $f = \binom{1, 2, 3, …, n}{a_1, a_2, a_3, …, a_n}$ ，表示“ $1$ 被 $a_1$ 取代， $2$ 被 $a_2$ 取代，依此类推”，其中 $a_1, a_2, …, a_n$是 $1 \sim n$ 的一个排列</p>
<h2 id="Burnside-引理"><a href="#Burnside-引理" class="headerlink" title="Burnside 引理"></a>Burnside 引理</h2><p>$$<br>L = \frac{1}{\mid G \mid} \sum_{j = 1}^s D(a_j)<br>$$</p>
<p>其中 $L$ 表示本质不同的方案数，$D(a_j)$  表示在置换 $a_i$ 下不变的元素个数， $\mid G \mid$ 是置换群大小</p>
<h2 id="Polya-定理"><a href="#Polya-定理" class="headerlink" title="Polya 定理"></a>Polya 定理</h2><p>记 $c(f)$ 为置换 $f$ 的循环节个数， .$m$ 为颜色总数，有 $D(f) = m^{c(f)}$  ，则有：<br>$$<br>L = \frac{1}{\mid G \mid} (\sum_{j = 1}^s m^{c(a_j)})<br>$$</p>
<h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mtx</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DB x[N][N];</span><br><span class="line">    DB* <span class="keyword">operator</span> [] (<span class="keyword">int</span> id)&#123; <span class="keyword">return</span> x[id]; &#125;</span><br><span class="line">&#125; a;</span><br></pre></td></tr></table></figure>

<h2 id="LU分解"><a href="#LU分解" class="headerlink" title="LU分解"></a>LU分解</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> DLT <span class="comment">//Doolittle</span></span><br><span class="line">&#123;</span><br><span class="line">    Mtx l, u;</span><br><span class="line">    DB X[N], Y[N];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_lu</span><span class="params">(Mtx x, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k, i, j, r;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= len; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = k; j &lt;= len; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                u[k][j] = x[k][j];</span><br><span class="line">                <span class="keyword">for</span> (r = k - <span class="number">1</span>; r; --r) u[k][j] -= l[k][r] * u[r][j];</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">fabs</span>(u[k][j]) &lt; eps) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!(<span class="built_in">fabs</span>(u[k][j]) &gt; eps)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i = k; i &lt;= len; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                l[i][k] = x[i][k];</span><br><span class="line">                <span class="keyword">for</span> (r = k - <span class="number">1</span>; r; --r) l[i][k] -= l[i][r] * u[r][k];</span><br><span class="line">                l[i][k] /= u[k][k];</span><br><span class="line">            &#125;</span><br><span class="line">            l[k][k] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(DB x[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k, r;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= len; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            Y[k] = x[k];</span><br><span class="line">            <span class="keyword">for</span> (r = k - <span class="number">1</span>; r; --r) Y[k] -= l[k][r] * Y[r];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (k = len; k; --k)</span><br><span class="line">        &#123;</span><br><span class="line">            X[k] = Y[k];</span><br><span class="line">            <span class="keyword">for</span> (r = k + <span class="number">1</span>; r &lt;= len; ++r) X[k] -= u[k][r] * X[r];</span><br><span class="line">            X[k] /= u[k][k];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(X[k]) &lt; eps) X[k] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">guass</span><span class="params">(Mtx &amp;x, <span class="keyword">int</span> len)</span> <span class="comment">//注意传实参</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, t, now;</span><br><span class="line">    <span class="keyword">for</span> (i = now = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t = now;</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &lt;= len; ++j) <span class="keyword">if</span> (<span class="built_in">fabs</span>(x[j][i]) &gt; <span class="built_in">fabs</span>(x[t][i])) t = j;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(x[t][i]) &lt; eps) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (t != now) std::<span class="built_in">swap</span>(x.x[t], x.x[now]);</span><br><span class="line">        <span class="keyword">for</span> (j = len + <span class="number">1</span>; j &gt;= i; --j) x[now][j] /= x[now][i];</span><br><span class="line">        <span class="keyword">for</span> (j = now + <span class="number">1</span>; j &lt;= len; ++j) <span class="keyword">if</span> (<span class="built_in">fabs</span>(x[j][i]))</span><br><span class="line">            <span class="keyword">for</span> (k = len + <span class="number">1</span>; k &gt;= i; --k) x[j][k] -= x[j][i] * x[now][k];</span><br><span class="line">        ++now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (now &lt;= len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = now; i &lt;= len; ++i) <span class="keyword">if</span> (<span class="built_in">fabs</span>(x[i][len + <span class="number">1</span>]) &gt; eps) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> len - now + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = len; i; --i)</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= len; ++j) x[i][len + <span class="number">1</span>] -= x[i][j] * x[j][len + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = len; i; --i) <span class="keyword">if</span> (<span class="built_in">fabs</span>(x[i][len + <span class="number">1</span>]) &lt; eps) x[i][len + <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//防止出现-0.00</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="矩阵求逆"><a href="#矩阵求逆" class="headerlink" title="矩阵求逆"></a>矩阵求逆</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mtxinv</span><span class="params">(Mtx &amp;x, Mtx &amp;as, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, t;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (t = i; t &lt;= len; ++t) <span class="keyword">if</span> (x[t][i]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (t &gt; len) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (t != i) std::<span class="built_in">swap</span>(x.x[t], x.x[i]), std::<span class="built_in">swap</span>(as.x[t], as.x[i]);</span><br><span class="line">        <span class="keyword">if</span> (x[i][i] != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = len, t = <span class="built_in">qpow</span>(x[i][i], P - <span class="number">2</span>); j &gt;= <span class="number">1</span>; --j) as[i][j] = <span class="built_in">LL</span>(t) * as[i][j] % P;</span><br><span class="line">            <span class="keyword">for</span> (j = len, t = <span class="built_in">qpow</span>(x[i][i], P - <span class="number">2</span>); j &gt;= i; --j) x[i][j] = <span class="built_in">LL</span>(t) * x[i][j] % P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= len; ++j) <span class="keyword">if</span> (x[j][i])</span><br><span class="line">            <span class="keyword">for</span> (k = len; k &gt;= <span class="number">1</span>; --k) <span class="built_in">adj</span>(as[j][k] -= <span class="built_in">LL</span>(x[j][i]) * as[i][k] % P);</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= len; ++j) <span class="keyword">if</span> (x[j][i])</span><br><span class="line">            <span class="keyword">for</span> (k = len; k &gt;= i; --k) <span class="built_in">adj</span>(x[j][k] -= <span class="built_in">LL</span>(x[j][i]) * x[i][k] % P);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = len; i; --i)</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= len; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (k = len; k &gt;= <span class="number">1</span>; --k) <span class="built_in">adj</span>(as[i][k] -= <span class="built_in">LL</span>(x[i][j]) * as[j][k] % P);</span><br><span class="line">            <span class="built_in">adj</span>(x[i][len + <span class="number">1</span>] -= <span class="built_in">LL</span>(x[i][j]) * x[j][len + <span class="number">1</span>] % P);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">det</span><span class="params">(Mtx x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>, i, j, t, k, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (x[i][i]) <span class="comment">//对第i行和第j行做辗转相减</span></span><br><span class="line">            &#123;</span><br><span class="line">                t = x[j][i] / x[i][i];</span><br><span class="line">                <span class="keyword">for</span> (k = i; k &lt;= n; ++k) <span class="built_in">adj</span>(x[j][k] -= <span class="built_in">LL</span>(t) * x[i][k] % p);</span><br><span class="line">                std::<span class="built_in">swap</span>(x.x[i], x.x[j]), f ^= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            std::<span class="built_in">swap</span>(x.x[i], x.x[j]), f ^= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">LL</span>(res) * x[i][i] % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!f) <span class="built_in">adj</span>(res = -res); <span class="comment">//注意res=0时</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用前要保证是正数</p>
<h2 id="Matrix-Tree"><a href="#Matrix-Tree" class="headerlink" title="Matrix-Tree"></a>Matrix-Tree</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">det</span><span class="params">(<span class="keyword">int</span> x[][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">1</span>, w = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">2</span>; i &lt;= n; ++i) <span class="comment">//以1为根,故删掉1行1列</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span> (x[i][i])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> div = x[j][i] / x[i][i];</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= n; ++k)</span><br><span class="line">					x[j][k] = (x[j][k] - (LL)div * x[i][k] % P + P) % P;</span><br><span class="line">				<span class="built_in">swap</span>(x[i], x[j]);</span><br><span class="line">				w = -w;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">swap</span>(x[i], x[j]);</span><br><span class="line">			w = -w;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">		res = (LL)x[i][i] * res % P;</span><br><span class="line">	res *= w;</span><br><span class="line">	<span class="keyword">return</span> (res + P) % P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  $k$ 是度数矩阵减邻接矩阵 </p>
<h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><h2 id="快读快输"><a href="#快读快输" class="headerlink" title="快读快输"></a>快读快输</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> FIO</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> L = (<span class="number">1</span> &lt;&lt; <span class="number">20</span>) + <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[L], out[L], *S, *E;</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> gh() (S == E ? E = (S = buf) + fread(buf, 1, L, stdin), (S == E ? EOF : *S++) : *S++)</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">flus</span><span class="params">()</span></span>&#123; <span class="built_in">fwrite</span>(out, <span class="number">1</span>, l, stdout), l = <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">chk</span><span class="params">()</span></span>&#123; <span class="keyword">if</span> (l &gt;= L - <span class="number">100</span>) <span class="built_in">flus</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">putc</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123; out[l++] = x, <span class="built_in">chk</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">rd</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">char</span> ch = <span class="built_in">gh</span>();</span><br><span class="line">		<span class="keyword">while</span> (ch &lt; <span class="number">33</span> || ch &gt; <span class="number">126</span>) ch = <span class="built_in">gh</span>();</span><br><span class="line">		<span class="keyword">for</span> (; ch &gt;= <span class="number">33</span> &amp;&amp; ch &lt;= <span class="number">126</span>; ch = <span class="built_in">gh</span>()) *s++ = ch;</span><br><span class="line">		*s = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">wt</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123; <span class="keyword">while</span> (*s != <span class="string">&#x27;\0&#x27;</span>) <span class="built_in">putc</span>(*s++); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">wt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>&#123; <span class="keyword">while</span> (*s != <span class="string">&#x27;\0&#x27;</span>) <span class="built_in">putc</span>(*s++); &#125; <span class="comment">//这是为了可以直接&quot;&quot;构造字符串输出</span></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">	<span class="keyword">void</span> <span class="title">rd</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">char</span> ch = <span class="built_in">gh</span>(), t = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (; ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>; ch = <span class="built_in">gh</span>()) t |= ch == <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">		<span class="keyword">for</span> (x = <span class="number">0</span>; ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>; ch = <span class="built_in">gh</span>()) x = x * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">		<span class="keyword">if</span> (t) x = -x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">	<span class="keyword">void</span> <span class="title">wt</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (x &lt; <span class="number">0</span>) x = -x;</span><br><span class="line">		<span class="keyword">if</span> (x &gt; <span class="number">9</span>) <span class="built_in">wt</span>(x / <span class="number">10</span>);</span><br><span class="line">		out[l++] = x % <span class="number">10</span> + <span class="number">48</span>, <span class="built_in">chk</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function">	<span class="keyword">void</span> <span class="title">rd</span><span class="params">(T &amp;x, Args &amp;...args)</span></span>&#123; <span class="built_in">rd</span>(x), <span class="built_in">rd</span>(args...); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function">	<span class="keyword">void</span> <span class="title">rd</span><span class="params">(<span class="keyword">char</span> *x, Args ...args)</span></span>&#123; <span class="built_in">rd</span>(x), <span class="built_in">rd</span>(args...); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function">	<span class="keyword">void</span> <span class="title">wt</span><span class="params">(T x, Args ...args)</span></span>&#123; <span class="built_in">wt</span>(x), <span class="built_in">wt</span>(args...); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function">	<span class="keyword">void</span> <span class="title">wt</span><span class="params">(<span class="keyword">char</span> *x, Args ...args)</span></span>&#123; <span class="built_in">wt</span>(x), <span class="built_in">wt</span>(args...); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function">	<span class="keyword">void</span> <span class="title">wt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *x, Args ...args)</span></span>&#123; <span class="built_in">wt</span>(x), <span class="built_in">wt</span>(args...); &#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">undef</span> gh</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> FIO::flus;</span><br><span class="line"><span class="keyword">using</span> FIO::rd;</span><br><span class="line"><span class="keyword">using</span> FIO::wt;</span><br></pre></td></tr></table></figure>

<p>无法读入浮点数；不可以字符串和整型一起读入（但可以一起输出）；注意最后要 <code>flus()</code> 一下；只能文件输入（但可以随意输出），如果要本地输入请 <code>#define gh() getchar()</code>  </p>
<h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><p>只会很不优美的写法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> l, r, mid, res;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line">    mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">chk</span>(mid)) l = mid + <span class="number">1</span>, res = mid;</span><br><span class="line">    <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>

<h2 id="三分"><a href="#三分" class="headerlink" title="三分"></a>三分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> l, r, lm, rm, res, len;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line">    len = (r - l + <span class="number">1</span>) / <span class="number">3</span>;</span><br><span class="line">    lm = l + len;</span><br><span class="line">    rm = lm + len;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">f</span>(lm) &lt; <span class="built_in">f</span>(rm)) res = rm, l = lm + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">f</span>(lm) &gt; <span class="built_in">f</span>(rm)) res = lm, r = rm - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>

<h2 id="模拟退火"><a href="#模拟退火" class="headerlink" title="模拟退火"></a>模拟退火</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> DB T0 = <span class="number">1e4</span>, TE = <span class="number">1e-4</span>, C = <span class="number">0.99</span>, SP = <span class="number">1e3</span>; <span class="comment">//这是参数,影响时间和精度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">E</span><span class="params">()</span></span>&#123; 这是一个估计函数(同时会跟新ans),越优的状态其估计越小 &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simulate_anneal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    预处理</span><br><span class="line">    DB now = <span class="built_in">E</span>(), np, dt, ct;</span><br><span class="line">    <span class="keyword">for</span> (DB t = E0; t &gt; TE; t *= C)</span><br><span class="line">    &#123;</span><br><span class="line">        随机进入新的状态,新状态与现状态的差异大小最好和t正相关</span><br><span class="line">        np = <span class="built_in">E</span>();</span><br><span class="line">        dt = np - now;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">exp</span>(-dt / t) &gt; 生成的一个(<span class="number">0</span>, <span class="number">1</span>)之间的随机数)</span><br><span class="line">        &#123;</span><br><span class="line">            跳至新状态</span><br><span class="line">           	now = np；</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            恢复原状态</span><br><span class="line">            <span class="keyword">if</span> ((++ct) &gt; SP) <span class="keyword">return</span> ; <span class="comment">//一个优化:多次为转移就直接以当前状态做最优解</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">一般会多次调用simulate_anneal或调小C以保证正确性</span><br></pre></td></tr></table></figure>

<h2 id="取模优化"><a href="#取模优化" class="headerlink" title="取模优化"></a>取模优化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adj</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123; x += (x &gt;&gt; <span class="number">31</span>) &amp; P; &#125;</span><br></pre></td></tr></table></figure>

<p>仅限 $x$ 为负数时可用，当 $x$ 是 <code>LL</code> 时把 $31$ 改成 $63$ </p>
<h2 id="Min-Max-容斥"><a href="#Min-Max-容斥" class="headerlink" title="Min-Max 容斥"></a>Min-Max 容斥</h2><p>$$<br>\begin{aligned}<br>&amp; \max(S) = \sum_{T \subseteq S} (-1)^{\mid T \mid - 1} \min(T) \\<br>&amp; \min(S) = \sum_{T \subseteq S} (-1)^{\mid T \mid - 1} \max(T) \\<br>&amp; kmax(S) = \sum_{T \subseteq S} (-1)^{\mid T \mid - k} \binom{\mid T \mid - 1}{k - 1} \min(T)<br>\end{aligned}<br>$$</p>
<h2 id="FWT"><a href="#FWT" class="headerlink" title="FWT"></a>FWT</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> FWT</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> iv2 = <span class="number">499122177</span>; <span class="comment">//2的逆元</span></span><br><span class="line">	<span class="keyword">void</span> _or(<span class="keyword">int</span> x[], <span class="keyword">int</span> len)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; i &lt;&lt;= <span class="number">1</span>) <span class="comment">//当前区间长度</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> mid = i &gt;&gt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; len; j += i) <span class="comment">//j当前区间前端</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k) <span class="built_in">adj</span>(x[k + mid] += x[k] - P);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">u_or</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> mid = i &gt;&gt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; len; j += i)</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k) <span class="built_in">adj</span>(x[k + mid] -= x[k]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">void</span> _and(<span class="keyword">int</span> x[], <span class="keyword">int</span> len)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> mid = i &gt;&gt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; len; j += i)</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k) <span class="built_in">adj</span>(x[k] += x[k + mid] - P);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">u_and</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> mid = i &gt;&gt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; len; j += i)</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k) <span class="built_in">adj</span>(x[k] -= x[k + mid]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">void</span> _xor(<span class="keyword">int</span> x[], <span class="keyword">int</span> len)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, t1, t2; i &lt;= len; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> mid = i &gt;&gt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; len; j += i)</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k)</span><br><span class="line">				&#123;</span><br><span class="line">					t1 = x[k], t2 = x[k + mid];</span><br><span class="line">					<span class="built_in">adj</span>(x[k] = t1 + t2 - P), <span class="built_in">adj</span>(x[k + mid] = t1 - t2);</span><br><span class="line">				&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">u_xor</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, t1, t2; i &lt;= len; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> mid = i &gt;&gt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; len; j += i)</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k)</span><br><span class="line">				&#123;</span><br><span class="line">					t1 = x[k], t2 = x[k + mid];</span><br><span class="line">					<span class="built_in">adj</span>(x[k] = t1 + t2 - P), <span class="built_in">adj</span>(x[k + mid] = t1 - t2);</span><br><span class="line">					x[k] = <span class="built_in">LL</span>(iv2) * x[k] % P, x[k + mid] = <span class="built_in">LL</span>(iv2) * x[k + mid] % P;</span><br><span class="line">				&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="子集卷积"><a href="#子集卷积" class="headerlink" title="子集卷积"></a>子集卷积</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pct(x) __builtin_popcount(x)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;bit), n = (<span class="number">1</span> &lt;&lt; bit);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;f[<span class="built_in">pct</span>(i)][i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;g[<span class="built_in">pct</span>(i)][i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= bit; ++i) <span class="built_in">fwt</span>(f[i], n), <span class="built_in">fwtor</span>(g[i], n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= bit; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j + i &lt;= bit; ++j)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; n; ++s) <span class="built_in">adj</span>(h[i + j][s] += <span class="built_in">LL</span>(f[i][s]) * g[j][s] % P - P);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= bit; ++i) <span class="built_in">ufwtor</span>(h[i], n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, h[<span class="built_in">pct</span>(i)][i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线性基"><a href="#线性基" class="headerlink" title="线性基"></a>线性基</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STC static</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">int</span> n; <span class="comment">//n是题目中插入到线性基里的个数</span></span><br><span class="line"><span class="keyword">namespace</span> LB  <span class="comment">//Linear Basis</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">63</span>;</span><br><span class="line">    LL a[L + <span class="number">5</span>], si;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123; <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a), si = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(LL  x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L; ~i; --i) <span class="keyword">if</span> ((x &gt;&gt; i) &amp; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> (!a[i]) <span class="keyword">return</span> ++si, <span class="built_in"><span class="keyword">void</span></span>(a[i] = x);</span><br><span class="line">            <span class="keyword">else</span> x ^= a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">LL <span class="title">gmx</span><span class="params">()</span> <span class="comment">//get max</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LL res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L; ~i; --i) res = std::<span class="built_in">max</span>(res ^ a[i], res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">LL <span class="title">gmn</span><span class="params">()</span> <span class="comment">//get min</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (si &lt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= L; ++i) <span class="keyword">if</span> (a[i]) <span class="keyword">return</span> a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L; ~i; --i) <span class="keyword">if</span> ((x &gt;&gt; i) &amp; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> (!a[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> x ^= a[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reb</span><span class="params">()</span> <span class="comment">//rebuild</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        STC <span class="keyword">int</span> tp[L + <span class="number">5</span>];</span><br><span class="line">        si = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= L; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; ~j; --j) <span class="keyword">if</span> ((a[i] &gt;&gt; j) &amp; <span class="number">1</span>) a[i] ^= a[j];</span><br><span class="line">            <span class="keyword">if</span> (a[i]) tp[si++] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; si; ++i) a[i] = tp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">LL <span class="title">gk</span><span class="params">(LL k)</span> <span class="comment">//get k</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LL res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (si &lt; n &amp;&amp; !(--k)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= (<span class="number">1ll</span> &lt;&lt; si)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; si; ++i) <span class="keyword">if</span> ((k &gt;&gt; i) &amp; <span class="number">1</span>) res ^= a[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="脚本和指令"><a href="#脚本和指令" class="headerlink" title="脚本和指令"></a>脚本和指令</h2><p>win：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g++ %<span class="number">1</span>.cpp -o %<span class="number">1</span>.exe -O2 -std=c++<span class="number">11</span> -Wall -Wextra -Wl,--stack=<span class="number">1145141919</span></span><br><span class="line"><span class="keyword">if</span> &quot;<span class="variable">%errorlevel%</span>&quot; == &quot;<span class="number">0</span>&quot; (</span><br><span class="line">    %<span class="number">1</span>.exe</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>linux：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">g++ $1.cpp -o $1 -O2 -std=c++11 -Wall -Wextra</span><br><span class="line">if [ $? -eq 0 ]</span><br><span class="line">then </span><br><span class="line">    ./$1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"><i class="fa fa-tag"></i> 笔记</a>
              <a href="/tags/%E6%A8%A1%E6%9D%BF/" rel="tag"><i class="fa fa-tag"></i> 模板</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/05/28/CF1119H-Triple/" rel="prev" title="CF1119H Triple">
      <i class="fa fa-chevron-left"></i> CF1119H Triple
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/06/04/%E4%BC%98%E5%8C%96dp4/" rel="next" title="优化dp4">
      优化dp4 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="nav-number">1.</span> <span class="nav-text">写在前面</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="nav-number">2.1.</span> <span class="nav-text">邻接表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-number">2.2.</span> <span class="nav-text">并查集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86"><span class="nav-number">2.3.</span> <span class="nav-text">堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E7%8A%B6%E6%A0%91%E7%BB%84"><span class="nav-number">2.4.</span> <span class="nav-text">树状树组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ST-%E8%A1%A8"><span class="nav-number">2.5.</span> <span class="nav-text">ST 表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E6%AF%9B%E5%AD%90"><span class="nav-number">2.6.</span> <span class="nav-text">四毛子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="nav-number">2.7.</span> <span class="nav-text">线段树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%AB%E9%98%9F"><span class="nav-number">2.8.</span> <span class="nav-text">莫队</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%AB%E9%98%9F%E4%BA%8C%E6%AC%A1%E7%A6%BB%E7%BA%BF"><span class="nav-number">2.9.</span> <span class="nav-text">莫队二次离线</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%9D%97"><span class="nav-number">2.10.</span> <span class="nav-text">分块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%82%B9%E5%88%86%E6%B2%BB"><span class="nav-number">2.11.</span> <span class="nav-text">点分治</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="nav-number">2.12.</span> <span class="nav-text">平衡树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%B3%E8%A1%A8"><span class="nav-number">2.13.</span> <span class="nav-text">跳表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CDQ-%E5%88%86%E6%B2%BB"><span class="nav-number">2.14.</span> <span class="nav-text">CDQ 分治</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="nav-number">2.15.</span> <span class="nav-text">李超线段树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E5%B8%AD%E6%A0%91"><span class="nav-number">2.16.</span> <span class="nav-text">主席树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#K-D-Tree"><span class="nav-number">2.17.</span> <span class="nav-text">K-D Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91"><span class="nav-number">2.18.</span> <span class="nav-text">笛卡尔树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="nav-number">2.19.</span> <span class="nav-text">哈夫曼树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86"><span class="nav-number">2.20.</span> <span class="nav-text">树链剖分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E6%A0%91"><span class="nav-number">2.21.</span> <span class="nav-text">动态树</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">3.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#KMP"><span class="nav-number">3.1.</span> <span class="nav-text">KMP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Z%E5%87%BD%E6%95%B0"><span class="nav-number">3.2.</span> <span class="nav-text">Z函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Trie"><span class="nav-number">3.3.</span> <span class="nav-text">Trie</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-number">3.4.</span> <span class="nav-text">最小表示法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Manacher"><span class="nav-number">3.5.</span> <span class="nav-text">Manacher</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AC-%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="nav-number">3.6.</span> <span class="nav-text">AC 自动机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SAM"><span class="nav-number">3.7.</span> <span class="nav-text">SAM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SA"><span class="nav-number">3.8.</span> <span class="nav-text">SA</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE%E8%AE%BA"><span class="nav-number">4.</span> <span class="nav-text">图论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">4.1.</span> <span class="nav-text">最近公共祖先</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="nav-number">4.2.</span> <span class="nav-text">单源最短路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A4%E8%B4%9F%E7%8E%AF"><span class="nav-number">4.3.</span> <span class="nav-text">判负环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F"><span class="nav-number">4.4.</span> <span class="nav-text">差分约束</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="nav-number">4.5.</span> <span class="nav-text">多源最短路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">4.6.</span> <span class="nav-text">最小生成树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kruskal-%E9%87%8D%E6%9E%84%E6%A0%91"><span class="nav-number">4.7.</span> <span class="nav-text">Kruskal 重构树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84"><span class="nav-number">4.8.</span> <span class="nav-text">树的直径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE-Tarjan"><span class="nav-number">4.9.</span> <span class="nav-text">无向图 Tarjan</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE-Tarjan"><span class="nav-number">4.10.</span> <span class="nav-text">有向图 Tarjan</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-SAT"><span class="nav-number">4.11.</span> <span class="nav-text">2-SAT</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%86%E6%96%B9%E6%A0%91"><span class="nav-number">4.12.</span> <span class="nav-text">圆方树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E5%85%83%E7%8E%AF%E8%AE%A1%E6%95%B0"><span class="nav-number">4.13.</span> <span class="nav-text">三元环计数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E5%85%83%E7%8E%AF%E8%AE%A1%E6%95%B0"><span class="nav-number">4.14.</span> <span class="nav-text">四元环计数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF"><span class="nav-number">4.15.</span> <span class="nav-text">欧拉回路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="nav-number">4.16.</span> <span class="nav-text">二分图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E8%88%AC%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D"><span class="nav-number">4.17.</span> <span class="nav-text">一般图最大匹配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Prufer-%E5%BA%8F%E5%88%97"><span class="nav-number">4.18.</span> <span class="nav-text">Prufer 序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%A0%91"><span class="nav-number">4.19.</span> <span class="nav-text">虚树</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DP"><span class="nav-number">5.</span> <span class="nav-text">DP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%8C%E5%8C%85"><span class="nav-number">5.1.</span> <span class="nav-text">背包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96"><span class="nav-number">5.2.</span> <span class="nav-text">单调队列优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96"><span class="nav-number">5.3.</span> <span class="nav-text">斜率优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F"><span class="nav-number">5.4.</span> <span class="nav-text">四边形不等式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SOS"><span class="nav-number">5.5.</span> <span class="nav-text">SOS</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%B5%81"><span class="nav-number">6.</span> <span class="nav-text">网络流</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E6%B5%81%EF%BC%88-Dinic-%EF%BC%89%EF%BC%9A"><span class="nav-number">6.1.</span> <span class="nav-text">最大流（ Dinic ）：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E6%B5%81%EF%BC%88-HLPP-%EF%BC%89%EF%BC%9A"><span class="nav-number">6.2.</span> <span class="nav-text">最大流（ HLPP ）：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B4%B9%E7%94%A8%E6%B5%81"><span class="nav-number">6.3.</span> <span class="nav-text">费用流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E5%89%B2%E6%A0%91"><span class="nav-number">6.4.</span> <span class="nav-text">最小割树</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F"><span class="nav-number">7.</span> <span class="nav-text">多项式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#FFT"><span class="nav-number">7.1.</span> <span class="nav-text">FFT</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NTT-%E5%85%A8%E5%AE%B6%E6%A1%B6"><span class="nav-number">7.2.</span> <span class="nav-text">NTT + 全家桶</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95"><span class="nav-number">8.</span> <span class="nav-text">计算几何</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E6%AF%94%E8%BE%83"><span class="nav-number">8.1.</span> <span class="nav-text">浮点数比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B3%E9%9D%A2%E6%9C%80%E8%BF%91%E7%82%B9%E5%AF%B9"><span class="nav-number">8.2.</span> <span class="nav-text">平面最近点对</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%82%B9%E9%97%B4%E8%B7%9D%E7%A6%BB"><span class="nav-number">8.3.</span> <span class="nav-text">点间距离</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%91%E9%87%8F"><span class="nav-number">8.4.</span> <span class="nav-text">向量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%82%B9%E4%B8%8E%E7%BA%BF"><span class="nav-number">8.5.</span> <span class="nav-text">点与线</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E4%B8%8E%E7%BA%BF"><span class="nav-number">8.6.</span> <span class="nav-text">线与线</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E8%BE%B9%E5%BD%A2"><span class="nav-number">8.7.</span> <span class="nav-text">多边形</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E5%9C%86%E8%A6%86%E7%9B%96"><span class="nav-number">8.8.</span> <span class="nav-text">最小圆覆盖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%B8%E5%8C%85"><span class="nav-number">8.9.</span> <span class="nav-text">凸包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8A%E5%B9%B3%E9%9D%A2%E4%BA%A4"><span class="nav-number">8.10.</span> <span class="nav-text">半平面交</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3"><span class="nav-number">8.11.</span> <span class="nav-text">旋转卡壳</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E8%AE%BA"><span class="nav-number">9.</span> <span class="nav-text">数论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="nav-number">9.1.</span> <span class="nav-text">快速幂</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%89%E9%80%9F%E5%B9%82"><span class="nav-number">9.2.</span> <span class="nav-text">光速幂</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%BE%9F%E9%80%9F%E4%B9%98"><span class="nav-number">9.3.</span> <span class="nav-text">龟速乘</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E7%AD%9B"><span class="nav-number">9.4.</span> <span class="nav-text">线性筛</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E8%A7%A3%E5%9B%A0%E6%95%B0-%E8%B4%A8%E5%9B%A0%E6%95%B0"><span class="nav-number">9.5.</span> <span class="nav-text">分解因数&#x2F;质因数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E8%AE%BA%E5%88%86%E5%9D%97"><span class="nav-number">9.6.</span> <span class="nav-text">数论分块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95"><span class="nav-number">9.7.</span> <span class="nav-text">欧几里得算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BSGS"><span class="nav-number">9.8.</span> <span class="nav-text">BSGS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86"><span class="nav-number">9.9.</span> <span class="nav-text">中国剩余定理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%86%E5%85%83%E9%80%92%E6%8E%A8%E5%BC%8F"><span class="nav-number">9.10.</span> <span class="nav-text">逆元递推式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%90%E6%B3%A2%E6%8B%89%E5%A5%91%E6%95%B0%E5%88%97%E6%8E%A8%E5%AF%BC"><span class="nav-number">9.11.</span> <span class="nav-text">斐波拉契数列推导</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A8%81%E5%B0%94%E9%80%8A%E5%AE%9A%E7%90%86"><span class="nav-number">9.12.</span> <span class="nav-text">威尔逊定理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86"><span class="nav-number">9.13.</span> <span class="nav-text">欧拉定理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Miller-Rabin-%E7%B4%A0%E6%95%B0%E6%B5%8B%E8%AF%95"><span class="nav-number">9.14.</span> <span class="nav-text">Miller-Rabin 素数测试</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0"><span class="nav-number">10.</span> <span class="nav-text">组合计数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%95%B0%E8%AE%A1%E7%AE%97"><span class="nav-number">10.1.</span> <span class="nav-text">组合数计算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lucas-%E5%AE%9A%E7%90%86"><span class="nav-number">10.2.</span> <span class="nav-text">Lucas 定理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0"><span class="nav-number">10.3.</span> <span class="nav-text">卡特兰数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94"><span class="nav-number">10.4.</span> <span class="nav-text">莫比乌斯反演</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0"><span class="nav-number">10.5.</span> <span class="nav-text">生成函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BE%A4%E8%AE%BA"><span class="nav-number">11.</span> <span class="nav-text">群论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%AE%E6%8D%A2%E7%BE%A4"><span class="nav-number">11.1.</span> <span class="nav-text">置换群</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Burnside-%E5%BC%95%E7%90%86"><span class="nav-number">11.2.</span> <span class="nav-text">Burnside 引理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Polya-%E5%AE%9A%E7%90%86"><span class="nav-number">11.3.</span> <span class="nav-text">Polya 定理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5"><span class="nav-number">12.</span> <span class="nav-text">矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8"><span class="nav-number">12.1.</span> <span class="nav-text">存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LU%E5%88%86%E8%A7%A3"><span class="nav-number">12.2.</span> <span class="nav-text">LU分解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83"><span class="nav-number">12.3.</span> <span class="nav-text">高斯消元</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E6%B1%82%E9%80%86"><span class="nav-number">12.4.</span> <span class="nav-text">矩阵求逆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%8C%E5%88%97%E5%BC%8F"><span class="nav-number">12.5.</span> <span class="nav-text">行列式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Matrix-Tree"><span class="nav-number">12.6.</span> <span class="nav-text">Matrix-Tree</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B6%E5%AE%83"><span class="nav-number">13.</span> <span class="nav-text">其它</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E8%AF%BB%E5%BF%AB%E8%BE%93"><span class="nav-number">13.1.</span> <span class="nav-text">快读快输</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%88%86"><span class="nav-number">13.2.</span> <span class="nav-text">二分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E5%88%86"><span class="nav-number">13.3.</span> <span class="nav-text">三分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB"><span class="nav-number">13.4.</span> <span class="nav-text">模拟退火</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%96%E6%A8%A1%E4%BC%98%E5%8C%96"><span class="nav-number">13.5.</span> <span class="nav-text">取模优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Min-Max-%E5%AE%B9%E6%96%A5"><span class="nav-number">13.6.</span> <span class="nav-text">Min-Max 容斥</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FWT"><span class="nav-number">13.7.</span> <span class="nav-text">FWT</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%90%E9%9B%86%E5%8D%B7%E7%A7%AF"><span class="nav-number">13.8.</span> <span class="nav-text">子集卷积</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E5%9F%BA"><span class="nav-number">13.9.</span> <span class="nav-text">线性基</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%84%9A%E6%9C%AC%E5%92%8C%E6%8C%87%E4%BB%A4"><span class="nav-number">13.10.</span> <span class="nav-text">脚本和指令</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Dyd"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Dyd</p>
  <div class="site-description" itemprop="description">一人一人が、自分の森,迷う人を见失い、再会できた人は更にと対面した。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">176</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">151</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Dyd-true" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Dyd-true" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2741501882@qq.com" title="E-Mail → mailto:2741501882@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://sighttp.qq.com/msgrd?v=1&uin=2741501882" title="QQ → https:&#x2F;&#x2F;sighttp.qq.com&#x2F;msgrd?v&#x3D;1&amp;uin&#x3D;2741501882" rel="noopener" target="_blank"><i class="fab fa-qq fa-fw"></i>QQ</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.luogu.com.cn/user/141393" title="LuoGu → https:&#x2F;&#x2F;www.luogu.com.cn&#x2F;user&#x2F;141393" rel="noopener" target="_blank"><i class=" fa-fw"></i>LuoGu</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      some of my mates
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.pigaunt.top/" title="https:&#x2F;&#x2F;www.pigaunt.top" rel="noopener" target="_blank">PigAunt</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://hewo233.blog.luogu.org/" title="https:&#x2F;&#x2F;hewo233.blog.luogu.org" rel="noopener" target="_blank">Hewo</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://wiki.pigaunt.top/" title="https:&#x2F;&#x2F;wiki.pigaunt.top" rel="noopener" target="_blank">PekingOpera</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://luckyleaves.github.io/" title="https:&#x2F;&#x2F;luckyleaves.github.io" rel="noopener" target="_blank">lucky叶</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://rusunoi.github.io/" title="https:&#x2F;&#x2F;rusunoi.github.io" rel="noopener" target="_blank">RuSun</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://evrgardenviolet.github.io/" title="http:&#x2F;&#x2F;evrgardenviolet.github.io" rel="noopener" target="_blank">闲人</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://mydcwfy.github.io/" title="https:&#x2F;&#x2F;mydcwfy.github.io" rel="noopener" target="_blank">mydcwfy</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.luogu.com.cn/blog/koshentoP/" title="https:&#x2F;&#x2F;www.luogu.com.cn&#x2F;blog&#x2F;koshentoP&#x2F;" rel="noopener" target="_blank">Tir_JK_LOVER</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dyd</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">861k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">13:03</span>
</div>

<div>
<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("11/17/2021 00:00:00");
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "The site has running for "+dnum+" days ";
        document.getElementById("times").innerHTML = hnum + " hours " + mnum + " minutes " + snum + " seconds";
    }
setInterval("createtime()",250);
</script>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = 'https://dyd-true.github.io/mathjax/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
