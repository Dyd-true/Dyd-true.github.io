<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>luoguP3896 [湖南集训]Clever Rabbit</title>
      <link href="/2021/12/08/luoguP3896-%E6%B9%96%E5%8D%97%E9%9B%86%E8%AE%AD-Clever-Rabbit/"/>
      <url>/2021/12/08/luoguP3896-%E6%B9%96%E5%8D%97%E9%9B%86%E8%AE%AD-Clever-Rabbit/</url>
      
        <content type="html"><![CDATA[<p>  一道很暴力的题</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P3896">Clever Rabbit</a></p><p>一看 $n \le 30$ ，时限4s，第一反应打表能过，仔细回味，发现 $10^{30}$ 铁挂，而且20分的 $n \le 10$ 都会挂，这……</p><p>但不能浪费我辛苦打出来的表（由于 $x = 0$ 对答案无贡献，故保证 $x &gt; 0$ ）：</p><table><thead><tr><th align="center">n</th><th align="center">x</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">-</td></tr><tr><td align="center">2</td><td align="center">-</td></tr><tr><td align="center">3</td><td align="center">495</td></tr><tr><td align="center">4</td><td align="center">6174</td></tr><tr><td align="center">5</td><td align="center">-</td></tr><tr><td align="center">6</td><td align="center">549945<br/>631764</td></tr><tr><td align="center">7</td><td align="center">-</td></tr><tr><td align="center">8</td><td align="center">63317664<br/>97508421</td></tr><tr><td align="center">9</td><td align="center">554999445<br/>864197532</td></tr></tbody></table><p>9的数据都跑了进3min……</p><p>然后又是全凭rp的找规律时间，浪费时间ing</p><p>发现一个小规律，看图：</p><p><img src="https://s2.loli.net/2021/12/12/repxRFMSVkOgN7f.png" alt="竖式"></p><p>我们发现 $b$ 数是对称且单调下降的（下降不严格），证明也很好证（自己列个竖式就知道了），那么我们可以枚举 $b$ 的一半，计算另一半，然后得到 $b’$ 排序后得到 $c, d$ ，计算检验即可，然鹅， $10^{\frac{n}{2}} = 10^{15}$ 次方也是挂了</p><p>突然发现只需枚举 $0 \sim 9$ 每个数出现了多少次，计算 $max,min,max - min$ 判断即可，考虑时间复杂度，看似是 $n^{10} * n$ （跑不满），但实际上用隔板法可知为 $O(\binom{n + 10 - 1}{9}n)$ ， 注意解决一下高精减法，可以得60分（开了O2可以70分）</p><p>再考虑我们打表发现的性质，还是生成 $b$ ，但和上面一样，只枚举 $b$ 的前 $\frac{n}{2}$ 个数中 $0 \sim 9$ 各出现了多少次，由于 $b$ 单调，故只有一种合法排列，生成  $b’$ 后暴力检验 ，特殊处理一下  $n$ 为奇数时中间的数（一定是0）</p><p>不开O2最慢的点1.89s（时限4s，能过），开了O2快得飞起，最慢的点412ms</p><p>考虑优化（毕竟1.89s太讨厌了），那个排序可以开个桶，把 $\log n$ 优化了（然鹅 $n \le 30$ 所以 $\log n$ 几乎就是常数），再就是其实可以先不求出 $b’$ 用 $b$ 的一半即可判断是否合法，合法再求（常数优化），然后卡卡常，时间复杂度为 $O(\binom{\frac{n}{2} + 10 -1}{9}n)$ ，不开O2最慢的点322ms，开了O2最慢的点205ms，好像除了打表的大佬（竟然真的可以打表，蒟蒻想都不敢想）我混了个最快？估计马上就会被大佬们超过</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IL inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>  N = <span class="number">30</span> + <span class="number">5</span>, A = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">int</span> n, p, m, o;</span><br><span class="line"><span class="keyword">int</span> t, cnt;</span><br><span class="line"><span class="keyword">int</span> a[A], b[N], c[N], d[N];</span><br><span class="line"><span class="keyword">int</span> B[A]; <span class="comment">//桶</span></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i)</span><br><span class="line"><span class="keyword">for</span> (re <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= B[i]; ++j)</span><br><span class="line">c[++t] = i, d[n - t + <span class="number">1</span>] = i;</span><br><span class="line"><span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">d[i] = d[i] - c[i];</span><br><span class="line"><span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line"><span class="keyword">if</span> (d[i] != b[i])</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">b[n + <span class="number">1</span> - i] = -b[i];</span><br><span class="line"><span class="keyword">for</span> (re <span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line"><span class="keyword">if</span> (b[i] &lt; <span class="number">0</span>)</span><br><span class="line">b[i] += <span class="number">10</span>, --b[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">t = ((LL)t * <span class="number">10</span> + b[i]) % p;</span><br><span class="line">ans = (((LL)t * t % p) + ans) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> <span class="comment">//生成b&#x27;</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i)</span><br><span class="line">B[i] = <span class="number">0</span>;</span><br><span class="line">cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line"><span class="keyword">for</span> (re <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= a[i]; ++j)</span><br><span class="line">b[++cnt] = i;</span><br><span class="line"><span class="keyword">if</span> (o)</span><br><span class="line">b[cnt + <span class="number">1</span>] = <span class="number">0</span>, ++B[<span class="number">9</span>];</span><br><span class="line"><span class="keyword">for</span> (re <span class="keyword">int</span> i = cnt, f = <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i != <span class="number">1</span>)</span><br><span class="line">++B[<span class="number">9</span> - b[i]];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">++B[<span class="number">10</span> - b[i]];</span><br><span class="line"><span class="keyword">if</span> (b[i] == <span class="number">0</span> &amp;&amp; f)</span><br><span class="line">++B[<span class="number">9</span>];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (f)</span><br><span class="line">++B[b[i] - <span class="number">1</span>], f = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">++B[b[i]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">9</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[x] = r;</span><br><span class="line"><span class="built_in">work</span>();</span><br><span class="line"><span class="built_in">check</span>();</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= r; ++i)</span><br><span class="line">&#123;</span><br><span class="line">a[x] = i;</span><br><span class="line"><span class="built_in">dfs</span>(x + <span class="number">1</span>, r - i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;p);</span><br><span class="line">o = n &amp; <span class="number">1</span>;</span><br><span class="line">m = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>, m);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans % p);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> luogu </tag>
            
            <tag> 练习 </tag>
            
            <tag> 暴力 </tag>
            
            <tag> 找规律 </tag>
            
            <tag> 高精 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>luoguP4892 GodFly的寻宝之旅</title>
      <link href="/2021/12/06/luoguP4892-GodFly%E7%9A%84%E5%AF%BB%E5%AE%9D%E4%B9%8B%E6%97%85/"/>
      <url>/2021/12/06/luoguP4892-GodFly%E7%9A%84%E5%AF%BB%E5%AE%9D%E4%B9%8B%E6%97%85/</url>
      
        <content type="html"><![CDATA[<p> 随机跳题都给我跳些神马玩意</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P4892">GodFly的寻宝之旅</a></p><p>看了数据范围，感觉 $m$ （边数）应该只是做权值的，时间应和 $n$ 关系大些（毕竟  $n \le 18, m \le 10^5$ ），先考虑了暴力，暴搜走法，以边数为权值，时间复杂度为  $O(n!)$ 期望30分（我也没打所以正确性没保证） </p><p>然后继续以  $m$ 为权值的思路，考虑状压dp，设 $f[i][j][w]$ 表示“走到点 $i$ ，当前点集合为 $j$ 且当前代价为 $w$ 的方案数”，转移很显然，下面以 $w = 0$ 的转移为例：<br>$$<br>\begin{align}<br>&amp;\text{设当前地图为}j \text{（不存在}v \text{），和为}sum(j) \text{且存在边}u \rightarrow v \text{数为}mp[u][v] \text{，} j + v \text{指将点}v \text{压入状态}\\<br>&amp;f[v][j + v][0] += mp[u][v] *<br>\begin{cases}<br>f[u][j][0] &amp; if(v \mod 2 = 0)\\<br>f[u][j][0] &amp; if(v \mod 2 = 1 \wedge sum(j) \mod 2 = 0)\\<br>f[u][j][1] &amp; if(v \mod 2 = 1 \wedge sum(j) \mod 2 = 1)<br>\end{cases}<br>\end{align}<br>$$<br>打的很快，注意了取模，结果一交——WA</p><p>想对着样例调一下，于是翻出了2018的比赛（这是那次比赛的第三题），正打算下载样例，结果……谁家出题组样例用百度网盘发呀！下一个百度网盘太麻烦，于是放弃，只好对着死调</p><p>就在我万念俱灰之时，突然感觉 $f[i][j][w]$ 的顺序怪怪的，因为dp的无后效性是用第二维（当前点集只增不减）来保证的，那么是不是应该先枚举 $j$ 再枚举 $i$ 呢？怀着如果还不过就只有手造样例心态，把第二层循环调到了最外层，结果，柳暗花明又一村，AC了！</p><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>, P = <span class="number">19260817</span>, D = (<span class="number">1</span> &lt;&lt; <span class="number">18</span>);</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> mp[N][N];</span><br><span class="line"><span class="keyword">int</span> f[N][D][<span class="number">2</span>]; <span class="comment">//f[i][j][w]:走到i,当前点集为j,价值为w的方案数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">have</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ((x &gt;&gt; (y - <span class="number">1</span>)) &amp; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x | (<span class="number">1</span> &lt;&lt; (y - <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_s</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">have</span>(x, i))</span><br><span class="line">res += i;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">see</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//debug</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; x &lt;&lt; <span class="string">&quot; have&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">have</span>(x, i))</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> c, d;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">d = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">++mp[u][v], ++mp[v][u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="comment">//每个点只走一次,故没有自环</span></span><br><span class="line">mp[i][i] = <span class="number">0</span>;</span><br><span class="line">f[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, sum; j &lt;= d; ++j) <span class="comment">//将第二层循环移到最外</span></span><br><span class="line">&#123;</span><br><span class="line">sum = <span class="built_in">get_s</span>(j);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) <span class="comment">//到n就停止,故不可能从n走到其它点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">have</span>(j, i))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">have</span>(j, k))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (!mp[i][k])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (k &amp; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (sum &amp; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">f[k][<span class="built_in">add</span>(j, k)][<span class="number">1</span>] = ((LL)f[i][j][<span class="number">0</span>] * mp[i][k] % P + f[k][<span class="built_in">add</span>(j, k)][<span class="number">1</span>]) % P;</span><br><span class="line">f[k][<span class="built_in">add</span>(j, k)][<span class="number">0</span>] = ((LL)f[i][j][<span class="number">1</span>] * mp[i][k] % P + f[k][<span class="built_in">add</span>(j, k)][<span class="number">0</span>]) % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">f[k][<span class="built_in">add</span>(j, k)][<span class="number">1</span>] = ((LL)f[i][j][<span class="number">1</span>] * mp[i][k] % P + f[k][<span class="built_in">add</span>(j, k)][<span class="number">1</span>]) % P;</span><br><span class="line">f[k][<span class="built_in">add</span>(j, k)][<span class="number">0</span>] = ((LL)f[i][j][<span class="number">0</span>] * mp[i][k] % P + f[k][<span class="built_in">add</span>(j, k)][<span class="number">0</span>]) % P;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">f[k][<span class="built_in">add</span>(j, k)][<span class="number">1</span>] = ((LL)f[i][j][<span class="number">1</span>] * mp[i][k] % P + f[k][<span class="built_in">add</span>(j, k)][<span class="number">1</span>]) % P;</span><br><span class="line">f[k][<span class="built_in">add</span>(j, k)][<span class="number">0</span>] = ((LL)f[i][j][<span class="number">0</span>] * mp[i][k] % P + f[k][<span class="built_in">add</span>(j, k)][<span class="number">0</span>]) % P;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c);</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d; ++i)</span><br><span class="line">ans = (ans + f[n][i][c]) % P;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉这个状压比较简单，毕竟连我这种<strong>奆弱</strong>都可以做</p><p>说句题外话，找样例的时候虽然样例没找到，但发现GodFly是“牛虻”的意思</p>]]></content>
      
      
      
        <tags>
            
            <tag> luogu </tag>
            
            <tag> 练习 </tag>
            
            <tag> dp </tag>
            
            <tag> 状态压缩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>luoguP2441 角色属性树</title>
      <link href="/2021/12/06/luoguP2441-%E8%A7%92%E8%89%B2%E5%B1%9E%E6%80%A7%E6%A0%91/"/>
      <url>/2021/12/06/luoguP2441-%E8%A7%92%E8%89%B2%E5%B1%9E%E6%80%A7%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p> 暴力出奇迹</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P2441">角色属性树</a></p><p>第一眼看过去想的是分解质因数后建图处理，一看 $a \le 2^31 - 1$ 完蛋</p><p>再仔细端详了一下数据， $n \le 2 \times 10^5$ ，估计是 $O(n \log n)$ 的算法，  $\text{修改次数} \le 50$ 似乎在提示我们暴力修改，估计是个树上倍增的算法，但具体实现还没想好，就被说明/提示的最后一行吸引：<strong>本题测试数据随机，可能是假题</strong>，随机生成，也就是说……暴力的<strong>期望</strong>复杂度也是 $O(n \log n)$ ，<del>本着能偷懒就偷懒的心态</del>，含泪AC了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> w[N], fa[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> y == <span class="number">0</span> ? x : <span class="built_in">gcd</span>(y, x % y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">gcd</span>(w[x], a) != <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">ask</span>(fa[x], a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k, op, u;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt; n; ++i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y), fa[y] = x;</span><br><span class="line"><span class="keyword">while</span> (k--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;u);</span><br><span class="line"><span class="keyword">if</span> (op == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">ask</span>(fa[u], w[u]));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后来看题解，也有树上倍增lca的做法，但是那样要维护区间乘积了，需要打高精，直接放弃</p>]]></content>
      
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> 暴力 </tag>
            
            <tag> lca </tag>
            
            <tag> 倍增 </tag>
            
            <tag> 素数 </tag>
            
            <tag> 最大公约数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小表示法</title>
      <link href="/2021/12/06/%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95/"/>
      <url>/2021/12/06/%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p> 简单的缓和一下</p><span id="more"></span><h1 id="最小表示法"><a href="#最小表示法" class="headerlink" title="最小表示法"></a>最小表示法</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>给定一个字符串 $S$ ，通过将 $S$ 循环移动可以得到至多 $n$ 个不同的串，其中 $n = |S|$ ，例如： $S = bcacd$ ，它循环移动一位可以得到 $S’ = cacdb$ （即把最后第一位放到最后）</p><p>对于得到的所有不同的字符串，字典序最小的串就叫原串的<strong>最小表示法</strong>，在上面的例子中， $S$ 的最小表示法为 $acdbc$ </p><h2 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h2><p>最小表示法的求法比较简单，把字符串复制一倍接在原串后面（破环成链），然后用一个双指针 $i, j$ 指向两个不同串的开头，初始时 $i = 1, j = 2$ （假设字符串从1开始）</p><p>然后暴力找到一个最小的非负整数 $k$ 满足 $S_{i + k} \ne S_{j + k}$ ：</p><ol><li>若 $S_{i + k} &lt; S_{j + k}$ ，则说明 $j \sim j + k$ 之间的所有位置开头的字符串都不是最小表示，因为它们都可以找到 $i \sim i + k$ 之间对应的开头的字符串，两个字符串到 $j + k$ （ $i + k$ ）前都相同，而 $S_{i + k} &lt; S_{j + k}$ ，故直接令 $j = j + k + 1$ </li><li>若 $S_{i + k} &gt; S_{j + k}$ ，同理令 $i = i + k + 1$ </li></ol><p>有几个特判：</p><ol><li> $i = j$ 时，让 $i = i + 1$ （加 $j$ 也行）</li><li>  $k &gt; n$ 时，说明两个开头的串一样，画图不难发现此时 $i \sim j$ 一定时一个循环节，而 $i \sim j$ 我们一定遍历过，所以直接结束</li></ol><p>完成后 $\min(i, j)$ 即为最小表示法的开头</p><p>时间复杂度为 $O(n)$ </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_min</span><span class="params">(<span class="keyword">char</span> *s)</span> <span class="comment">//求串s的最小表示,完成后答案存在s[k...k + len - 1]中</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">s[len + i] = s[i];</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">2</span>, k;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= len &amp;&amp; j &lt;= len)</span><br><span class="line">&#123;</span><br><span class="line">k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (k &lt;= len &amp;&amp; s[i + k] == s[j + k])</span><br><span class="line">++k;</span><br><span class="line"><span class="keyword">if</span> (k &gt; len)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (s[i + k] &gt; s[j + k])</span><br><span class="line">i += k + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">j += k + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i == j)</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line">k = <span class="built_in">min</span>(i, j);</span><br><span class="line">s[k + len] = <span class="number">0</span>; <span class="comment">//加上结束符</span></span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主函数中：</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, a + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> x = <span class="built_in">get_min</span>(a);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 最小表示法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test2021/12/06总结</title>
      <link href="/2021/12/06/test2021-12-06%E6%80%BB%E7%BB%93/"/>
      <url>/2021/12/06/test2021-12-06%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p> 你以为的不是你以为的，而是你以为的</p><span id="more"></span><h1 id="test2021-12-06总结"><a href="#test2021-12-06总结" class="headerlink" title="test2021/12/06总结"></a>test2021/12/06总结</h1><h2 id="题目、成绩和题解"><a href="#题目、成绩和题解" class="headerlink" title="题目、成绩和题解"></a>题目、成绩和题解</h2><p><a href="./day1.pdf">题目</a></p><p><a href="./result.pdf">成绩</a></p><p><a href="./solution.pdf">题解</a></p><h2 id="考前"><a href="#考前" class="headerlink" title="考前"></a>考前</h2><p>考前的白天，老师让我们学了<strong>点分治</strong>和<strong>启发式合并</strong>，估计要考（预判）</p><p>晚上在寝室里还发生了一件不同往常的事，这也就<strong>为后文埋下伏笔</strong>（出于保护隐私，不能说发生了什么，但只能说，<del>泡面真香</del>）</p><h2 id="考试"><a href="#考试" class="headerlink" title="考试"></a>考试</h2><p>开考前老师说这次考试<strong>不给大样例</strong>，预感到要凉凉</p><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>老规矩先开T1，望过去心中一片呼伦贝尔大草原（<del>简直好优美的中国话</del>），没有大样例，题目的样例又没有解释，我连答案怎么算出来的都不知道</p><p>于是就根本不管样例了，按照自己的理解来，于是想了个<strong>点分治</strong>，每次取重心：</p><ol><li>对于不含1号节点的子树，计算每个点到重心的边数和长度，用线段树维护，每次查询区间最值（路过过重心）或者直接跟新答案（路径以重心为端点），记在重心的答案里，一棵子树统计完后在修改线段树（保证不存在两个端点都在一棵子树内的情况）</li><li>对于含1号点的子树，dfs，传递的参数中含有一个 $y$ 意为正在跟新 $y$ 号点的答案，每次进入下一层时，若进入 $fa[x]$ （ $x$ 是当前节点），则让 $y = fa[x]$ ，否则  $y$ 不变</li></ol><p>时间复杂度为  $O(n \log^2 n)$ ， $n \le 10^6$  , 时限给的4m，期望得分50（<del>然而只是个期望</del>）</p><h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>花了大概  $1.5 \sim 2h$ 打完T1，浏览了一下T2、T3，T3的没看懂，T2感觉像是个博弈论，决定先开T2</p><p>回忆了一下SG函数（忘了有一半的样子吧），只记得如何判必胜，想了一会<strong>决定打暴力</strong>（这将是我本次考试最正确的决定），大概思路是对于当前操作者，dfs搜索每一种情况，找到自己赢的情况就返回自己赢（因为走最优策略），如果没有自己赢的情况就返回对方赢</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IL <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> who)</span> <span class="comment">//返回winner </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vis[x][y] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> xx, yy, t;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">xx = x + dx[i], yy = y + dy[i];</span><br><span class="line"><span class="keyword">if</span> (mp[xx][yy] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; !vis[xx][yy])</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">dfs</span>(xx, yy, who ^ <span class="number">1</span>) == who)</span><br><span class="line">&#123;</span><br><span class="line">vis[x][y] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> who;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">vis[x][y] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> who ^ <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没怎么调试，手算了一组数据就去T3了</p><h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>最开始没看懂题，加上<strong>昨天晚上的伏笔</strong>（忘了的可以上去看）差点放弃，但最后还是坚持着读懂了题，其实最大的歧义在于“价值恰好是 $P$ 的倍数”其实指的是“价值在模 $P$ 意义下为0”</p><p>读懂了题，就开做，第一反应是<strong>笛卡尔树</strong>，因为价值的定义有一个“最大”，感觉可以每次找最大点，以它为根处理所有过了它的路径，然后再删掉它，递归处理几个子树</p><p>具体实现用的是类似于点分治的构架，只是把找重心改成找最大点而已，时间复杂度当然是<strong>完全假掉</strong>的  $O(n \log n)$ ，目标是  $n \le 2000$ 和随机生成数据两个部分分，度数不大于2感觉太难打了就先没打，期望得分44（<del>我是有多么自信啊</del>）</p><h3 id="T？"><a href="#T？" class="headerlink" title="T？"></a>T？</h3><p>打完T3，感觉这场考试要凉，只有T1感觉像个正常思路，于是去<strong>检查了一下T1</strong>（用了约30min）</p><p>然后，由于<strong>昨天晚上的伏笔</strong>，接下来的约  $1 \sim 1.5h$ 处于掉线状态，没有再改动代码</p><p>提交时已经做好垫底的准备，估计只有T1有点分，T2、T3虽然打了但没怎么花时间看，心中不稳，估分 $30 + 0 + 0 \sim 60 + 30 + 44$ ，即 $30 \sim 134$ 的样子吧（然而事实与我所料大不相同）</p><h2 id="出成绩"><a href="#出成绩" class="headerlink" title="出成绩"></a>出成绩</h2><p>11：40考完就跑代码了，结果是 $0 + 80(20) + 28 = 106$ ，第二题括号里的是数据加强版</p><p>总分在预料内吧，但T1和T2的分数是不是反了啊？！T1我那么认真、那么自信的打了5kb的代码，结果 $WA + TLE = 0$ ，T2打了个稍微聪明点的暴力，时间花的最少，结果80……T3得了个正常的暴力分（<del>还比别人的暴力高4分好耶！</del>）</p><p>T1<strong>wfy</strong>大佬打的启发式合并（正解也是<strong>启发式合并</strong>，但<strong>wfy</strong>大佬的<strong>时间复杂度好像假掉了</strong>），太厉害了，我想过启发式合并（毕竟老师提示过），但完全不会，T1好像确实很难，我们都<strong>爆零</strong>了</p><p>T3<strong>rusun</strong>大佬的思路和标程一样（<strong>点分治</strong>），可惜的是求 $size$ 时少打一行判断该点是否被删，令人遗憾</p><p>T2好像大家都是基于SG函数打的暴力，大概得了20分，我（<del>打不出来SG函数</del>）打的基于dfs的暴力可能是和正解<strong>匈牙利</strong>的dfs有相似之处吧，骗了个不错的分数，但加强数据只有我反而低了（他们都是30分）</p><p>不管了，下午来改</p><h2 id="改题"><a href="#改题" class="headerlink" title="改题"></a>改题</h2><h3 id="T2-1"><a href="#T2-1" class="headerlink" title="T2"></a>T2</h3><p>本来想先改T1的（毕竟早上T1打的不容易），但一是找不出错，题解又看不懂，看来一下T2的题解比较简单，先改T2</p><p>题解很清楚了，就是判断每个点是否<strong>一定</strong>在最大匹配中，具体地，可以先匈牙利求出最大匹配，然后对于每一个未匹配的点，尝试让它匹配（work函数），这样一定会释放一个点，且匹配数不变，如此迭代下即可</p><p>考虑时间复杂度，匈牙利是 $O(n^4)$ （设 $n, m$ 同级），对于work函数，设未匹配的点有 $x(0 \le x \le n^2)$ 个，则有  $n^2 - x$ 个点已匹配，work会在主函数被调用 $x$ 次，每次最多遍历 $n^2 - x$ 个点（实际上远远达不到）， $O(x * (n^2 - x)) \le O(n^4)$ 故总的实际复杂度为 $O(n^4)$ ，由于 $n \le 100$ ，且时间远远达不到上界，普通版和加强版都可以过</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IL inline</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> mp[N][N];</span><br><span class="line"><span class="keyword">int</span> id[N][N], cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dy[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ne, ver;</span><br><span class="line">&#125; e[(N * N) &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> h[N * N], idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> vis[N * N], match[N * N], win[N * N];</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx] = (Edge)&#123;h[x], y&#125;, h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line"><span class="keyword">if</span> (!vis[y = e[i].ver])</span><br><span class="line">&#123;</span><br><span class="line">vis[y] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (!match[y] || <span class="built_in">dfs</span>(match[y]))</span><br><span class="line">&#123;</span><br><span class="line">match[y] = x;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">addedge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line"><span class="keyword">if</span> (mp[i][j] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">4</span>; ++k)</span><br><span class="line">&#123;</span><br><span class="line">x = i + dx[k], y = j + dy[k];</span><br><span class="line"><span class="keyword">if</span> (mp[x][y] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"><span class="built_in">add</span>(id[i][j], id[x][y]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">get_match</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line"><span class="keyword">if</span> (mp[i][j] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; ((i + j) &amp; <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= cnt; ++k)</span><br><span class="line">vis[k] = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">dfs</span>(id[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line"><span class="keyword">if</span> (match[i])</span><br><span class="line">match[match[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line"><span class="keyword">if</span> (match[e[i].ver] &amp;&amp; !win[match[e[i].ver]])</span><br><span class="line">&#123;</span><br><span class="line">++ans;</span><br><span class="line">win[match[e[i].ver]] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">work</span>(match[e[i].ver] );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;b.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;b.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, mp[i] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">id[i][j] = ++cnt, h[cnt] = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">addedge</span>();</span><br><span class="line"><span class="built_in">get_match</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line"><span class="keyword">if</span> (!match[id[i][j]] &amp;&amp; mp[i][j] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">++ans;</span><br><span class="line">win[id[i][j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">work</span>(id[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line"><span class="keyword">if</span> (win[id[i][j]])</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, i, j);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="T3-1"><a href="#T3-1" class="headerlink" title="T3"></a>T3</h3><p>T1<strong>wfy</strong>大佬改了半天发现自己时间复杂度是假的，反观T3<strong>rusun</strong>dalao很快就改好了，于是决定先改T3</p><p>和题解一样，考虑点分治，每次分治找重心，划分子树，只处理过重心的路径，其它递归处理，现在考虑如何处理过重心的路径</p><p>其实类似于点分治的例题1，就是在不同子树选两个数模  $P$ 意义下和为0，开一个桶维护“到重心权值和为  $i$ （模 $P$ 意义）的点有多少个”，先统计出每个子树中每个点到重心的最大权值以及权值和，以最大权值从小到大计算答案并插入桶中，类似例题1，用容斥解决两个端点在同一个子树的情况，每次计算完后清空桶即可</p><p>需要注意的是0的特判，会出现以重心为端点的路径，这只需在计算时多差一个到重心权值为0的点即可；还有就是每个点自己构成的路径价值为0，故答案最后要加  $n$ </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IL inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gh() getchar()</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, PP = <span class="number">1e7</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, P;</span><br><span class="line"><span class="keyword">int</span> h[N], idx;</span><br><span class="line"><span class="keyword">int</span> w[N];</span><br><span class="line"><span class="keyword">int</span> as[N], ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b[PP];</span><br><span class="line"><span class="keyword">bool</span> del[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ne, ver;</span><br><span class="line">&#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> mx, sum;</span><br><span class="line">IL <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;t) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> mx &lt; t.mx;</span><br><span class="line">&#125;</span><br><span class="line">&#125; p[N], q[N];</span><br><span class="line"><span class="keyword">int</span> cp, cq;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx] = (Edge)&#123;h[x], y&#125;, h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = <span class="built_in">gh</span>(), t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">t |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">gh</span>();</span><br><span class="line"><span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">x = x * <span class="number">10</span> + (ch ^ <span class="number">48</span>), ch = <span class="built_in">gh</span>();</span><br><span class="line"><span class="keyword">if</span> (t)</span><br><span class="line">x = -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">int</span> <span class="title">get_si</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x])</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line"><span class="keyword">if</span> (e[i].ver != fa)</span><br><span class="line">res += <span class="built_in">get_si</span>(e[i].ver, x);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">int</span> <span class="title">get_wc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> si, <span class="keyword">int</span> &amp;wc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x])</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">1</span>, mx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], t; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (e[i].ver == fa)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">t = <span class="built_in">get_wc</span>(e[i].ver, x, si, wc);</span><br><span class="line">mx = <span class="built_in">max</span>(mx, t);</span><br><span class="line">sum += t;</span><br><span class="line">&#125;</span><br><span class="line">mx = <span class="built_in">max</span>(mx, si - sum);</span><br><span class="line"><span class="keyword">if</span> (mx &lt;= si / <span class="number">2</span>)</span><br><span class="line">wc = x;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">get_Node</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, Node t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x])</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">t.mx = <span class="built_in">max</span>(t.mx, w[x]);</span><br><span class="line">t.sum = (t.sum + w[x]) % P;</span><br><span class="line">q[++cq] = t;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line"><span class="keyword">if</span> (e[i].ver != fa)</span><br><span class="line"><span class="built_in">get_Node</span>(e[i].ver, x, t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">int</span> <span class="title">work</span><span class="params">(Node x[], <span class="keyword">int</span> cnt, <span class="keyword">int</span> wr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(x + <span class="number">1</span>, x + <span class="number">1</span> + cnt);</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, t; i &lt;= cnt; ++i)</span><br><span class="line">&#123;</span><br><span class="line">t = (x[i].sum + wr - <span class="built_in">max</span>(wr, x[i].mx)) % P;</span><br><span class="line">t = (P - t) % P;</span><br><span class="line">res += b[t];</span><br><span class="line">++b[x[i].sum];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">--b[x[i].sum];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x])</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"><span class="built_in">get_wc</span>(x, <span class="number">-1</span>, <span class="built_in">get_si</span>(x, <span class="number">-1</span>), x);</span><br><span class="line">del[x] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">cp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">cq = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">get_Node</span>(e[i].ver, x, (Node)&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">ans -= <span class="built_in">work</span>(q, cq, w[x]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cq; ++j)</span><br><span class="line">p[++cp] = q[j];</span><br><span class="line">&#125;</span><br><span class="line">p[++cp] = (Node)&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">ans += <span class="built_in">work</span>(p, cp, w[x]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line"><span class="built_in">calc</span>(e[i].ver);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;c.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;c.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="built_in">read</span>(n), <span class="built_in">read</span>(P);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">h[i] = <span class="number">-1</span>;</span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">read</span>(u), <span class="built_in">read</span>(v);</span><br><span class="line"><span class="built_in">add</span>(u, v), <span class="built_in">add</span>(v, u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="built_in">read</span>(w[i]);</span><br><span class="line"><span class="built_in">calc</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans + n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="T3-2"><a href="#T3-2" class="headerlink" title="T3"></a>T3</h3><p>还没改出来，先挖个坑吧（<del>估计是不会填了</del>）</p>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
            <tag> 点分治 </tag>
            
            <tag> 启发式合并 </tag>
            
            <tag> 二分图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Manacher</title>
      <link href="/2021/12/05/Manacher/"/>
      <url>/2021/12/05/Manacher/</url>
      
        <content type="html"><![CDATA[<p> 马拉车算法</p><span id="more"></span><h1 id="Manacher"><a href="#Manacher" class="headerlink" title="Manacher"></a>Manacher</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>Manacher算法是一中可以在  $O(n)$ 时间内求出最长回文子串的算法（以前的 $O(n \log n)$ hash+二分可以退役了）</p><p>在使用马拉车前，由于马拉车只能求<strong>长度为奇数</strong>的回文串，所有我们首先要有一个转换，把长度为偶数的回文串化为长度为奇数，具体方法为：</p><p>在字符串的头部插入开始符（一般为“\$”），在尾部插入结尾符（一般为“^”），然后每两个字符间都插入一个分隔符（一般为“#”），例如，字符串“abbcac”转化后就是“\$#a#b#b#c#a#c#^”，这样，就可以把原串的每一个回文串都化为一个“由#开头和结尾的长度为奇数的回文串”</p><p>然后，考虑如何求最大的长度为奇数的回文串</p><p>类似kmp我们扫描整个串，记 $p[i]$ 表示“以 $i$ 为中点的最长回文串的长度的一半（包括 $i$ ）”，考虑用已有的信息求出现在的 $p[i]$ </p><p><img src="https://s2.loli.net/2021/12/05/kiKbhwgSEDUZ7YJ.png" alt="马拉车"></p><p>如图，假设现在要求 $p[i]$ ，则  $p[1 \sim i - 1]$ 已知，定义一个回文串的位置为 $[l, r]$ ，则已知的最大的 $r$ 记为 $mr(maxright)$ ，其对应的回文串中点为 $mid$ ，则分类讨论：</p><ul><li><p> $i &gt; mr$ ，此时先令 $p[i] = 1$</p></li><li><p>$i \le mr$ 此时必有 $j = mid * 2 - i$ 与 $i$ 对应，再次分类：</p><ol><li> $p[j] \le mr - i + 1$ ，此时 $j$ 所在的最大回文串全部能和 $i$ 对应（图中蓝色部分），让 $p[i] = p[j]$</li><li> $p[j] &gt; mr - i + 1$ ，此时由于 $mr$ 右边的情况未知，故只能先让 $p[i] = mr - i + 1$ </li></ol></li></ul><p>由上，我们通过已有的信息计算出了“<strong>保证合法但不保证最大</strong>的情况下 $p[i]$ 的值”，其中没有保证最大的原因是 $mr$ 右边的情况不知道，若 $i$ 所在的最大回文串的右边界大于 $mr$ ，就无法统计，解决办法是——暴力！对于分类讨论得到的 $p[i]$ ，我们暴力尝试让它加1，直到不行为止</p><p>最后统计答案时，由于 $p[i]$ 只是长度的一半应该要乘二，但由于我们把原串扩充了一倍，所以实际答案就是 $\max_{i = 1}^{n}(p[i] - 1)$ </p><p>需要注意的是，在具体的代码实现中，常常让 $mr = mr + 1$ ，换句话说，以 $mid$ 为中心的最大回文串不是 $[l, r]$ ，而是 $[l, r)$ ，上面讲成闭区间只是为了方便理解</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://www.luogu.com.cn/problem/P3805">【模板】manacher 算法</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1.1e7</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> a[N], b[N &lt;&lt; <span class="number">1</span>];  <span class="comment">//二倍</span></span><br><span class="line"><span class="keyword">int</span> p[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">b[++k] = <span class="string">&#x27;$&#x27;</span>, b[++k] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">b[++k] = a[i], b[++k] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">b[++k] = <span class="string">&#x27;^&#x27;</span>;</span><br><span class="line">n = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manacher</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mr = <span class="number">0</span>, mid;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; mr)</span><br><span class="line">p[i] = <span class="built_in">min</span>(p[mid * <span class="number">2</span> - i], mr - i);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">p[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (b[i - p[i]] == b[i + p[i]])</span><br><span class="line">++p[i];</span><br><span class="line"><span class="keyword">if</span> (i + p[i] &gt; mr)</span><br><span class="line">mr = i + p[i], mid = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, a + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">n = <span class="built_in">strlen</span>(a + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="built_in">manacher</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">ans = <span class="built_in">max</span>(ans, p[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>和kmp一样，马拉车的两个循环也是“假的”，简证：</p><p>首先，如果 $i$ 所在的最大回文串 $[l, r]$ 的右断点 $r \le mr$ ，while只会执行一次，因为如果此时 $p[i]$ 一定是与 $p[j]$ 对于的，若还可以加1，这与 $p[j]$ 的“最大”矛盾</p><p>其次，若 $r &gt; mr$ ，则一定会跟新 $mr$ ，而 $mr$ 明显是不下降的，当 $mr = n$ 时，就不可能再有 $r &gt; mr$ 了，换句话说， $mr$ 最多遍历一次 $n$ ，之后就不会再跟新 $mr$ 也就不会再有 $r &gt; mr$ 了</p><p>综上，马拉车的时间复杂度为 $O(n)$ </p>]]></content>
      
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 回文串 </tag>
            
            <tag> Manacher </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>启发式合并</title>
      <link href="/2021/12/05/%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"/>
      <url>/2021/12/05/%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/</url>
      
        <content type="html"><![CDATA[<p> 聪明的合并</p><span id="more"></span><h1 id="启发式合并"><a href="#启发式合并" class="headerlink" title="启发式合并"></a>启发式合并</h1><p>其实我们很早就接触过启发式合并了，比如并查集的<strong>按秩合并</strong>就是一种启发式合并（<del>虽然基本没用过</del>），但还是单独提一提</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在解决问题时，我们常常要用到“合并”操作，而该操作是<strong>可以</strong>满足<strong>交换律</strong>的（即可以把 $a$ 合并到 $b$ 里面，也可以把 $b$ 合并到 $a$ 里面），这个时候我们可以通过一些额外的信息（如安秩合并中的秩）来决定合并的顺序，从而降低时间复杂度</p><h2 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h2><p><a href="https://www.luogu.com.cn/problem/P3201">[HNOI2009] 梦幻布丁</a></p><p>对于每种颜色，用一个集合维护其下标，每次操作就是<strong>合并两个集合</strong>，合并完后颜色的段数是<strong>不会增加</strong>的，考虑如何维护段数，设合并颜色 $a$ 和颜色 $b$ ，枚举颜色 $a$ 的所有下标，若它左右的颜色中有  $x(0 \le x \le 2)$ 个颜色是 $b$ ，就让段数减 $x$ </p><p>不难发现暴力合并时间复杂度为 $O(mn)$ ，无法接受，考虑启发式合并，每次让小的集合合并到大的集合中</p><p>要用启发式合并，我们首先要解决一个问题：合并操作是满足交换律的吗？当然没有那么简单，由于操作是“把颜色 $a$ 变成颜色 $b$ ”，交换就成了“把颜色 $b$ 变成颜色 $a$ ”，当然不行</p><p>但是可以通过转化让其满足交换律吗？考虑用链表存储集合，那么只需要将表头映射一下，交换一下颜色即可，总的时间复杂度期望为 $O(n \log n)$ （<del>然而可以被hack，但可以过题</del>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, A = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[A], idx;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ne, ver;</span><br><span class="line">&#125; e[N];</span><br><span class="line"><span class="keyword">int</span> c[N], si[A], p[A];</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx] = (Edge)&#123;h[x], y&#125;, h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == y)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (si[x] &gt; si[y])</span><br><span class="line"><span class="built_in">swap</span>(x, y);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], z; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">z = e[i].ver;</span><br><span class="line">ans -= (c[z + <span class="number">1</span>] == y) + (c[z - <span class="number">1</span>] == y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], z; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">c[e[i].ver] = y;</span><br><span class="line"><span class="keyword">if</span> (e[i].ne == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">e[i].ne = h[y], h[y] = h[x];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">si[y] += si[x];</span><br><span class="line">h[x] = <span class="number">-1</span>, si[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A; ++i)</span><br><span class="line">h[i] = <span class="number">-1</span>, p[i] = i;</span><br><span class="line">idx = ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i]);</span><br><span class="line"><span class="keyword">if</span> (c[i] != c[i - <span class="number">1</span>])</span><br><span class="line">++ans;</span><br><span class="line"><span class="built_in">add</span>(c[i], i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> op, x, y;</span><br><span class="line"><span class="keyword">while</span> (m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line"><span class="keyword">if</span> (op == <span class="number">2</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line"><span class="built_in">merge</span>(p[x], p[y]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h2><p><a href="https://www.luogu.com.cn/problem/CF600E">Lomsat gelral</a></p><p>其实是一道树上并查集，类似树链剖分找出重儿子，暴力计算每一棵子树，但最后再计算重儿子，这样可以把重儿子的信息保留下来，下一次用的时候就不必再算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> h[N], idx;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ne, ver;</span><br><span class="line">&#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> c[N], cnt[N], mx;</span><br><span class="line">LL ans[N], sum;</span><br><span class="line"><span class="keyword">int</span> si[N], h_son[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx] = (Edge)&#123;h[x], y&#125;, h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">si[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (y == fa)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs1</span>(y, x);</span><br><span class="line">si[x] += si[y];</span><br><span class="line"><span class="keyword">if</span> (si[y] &gt; si[h_son[x]])</span><br><span class="line">h_son[x] = y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> dt, <span class="keyword">int</span> pass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> _c = c[x];</span><br><span class="line">cnt[_c] += dt;</span><br><span class="line"><span class="keyword">if</span> (cnt[_c] &gt; mx)</span><br><span class="line">mx = cnt[_c], sum = _c;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cnt[_c] == mx)</span><br><span class="line">sum += _c;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (y == fa || y == pass)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">update</span>(y, x, dt, pass);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (y == fa || y == h_son[x])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs</span>(y, x, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (h_son[x])</span><br><span class="line"><span class="built_in">dfs</span>(h_son[x], x, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">update</span>(x, fa, <span class="number">1</span>, h_son[x]);</span><br><span class="line">ans[x] = sum;</span><br><span class="line"><span class="keyword">if</span> (!op)</span><br><span class="line"><span class="built_in">update</span>(x, fa, <span class="number">-1</span>, <span class="number">0</span>), mx = sum = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">h[i] = <span class="number">-1</span>;</span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line"><span class="built_in">add</span>(u, v), <span class="built_in">add</span>(v, u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> 并查集 </tag>
            
            <tag> 启发式合并 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>点分治</title>
      <link href="/2021/12/05/%E7%82%B9%E5%88%86%E6%B2%BB/"/>
      <url>/2021/12/05/%E7%82%B9%E5%88%86%E6%B2%BB/</url>
      
        <content type="html"><![CDATA[<p> 连分治也变得难了起来……</p><span id="more"></span><h1 id="点分治"><a href="#点分治" class="headerlink" title="点分治"></a>点分治</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>点分治是<strong>树上分治</strong>的种常用方法，主要思想是每次在树上选一个点，将整棵树的问题划分为两类（如图）：三角形的子树内问题和过了点跨子树的问题</p><p><img src="https://s2.loli.net/2021/12/05/mJCZwSPnvaE3W4K.png" alt="点和子树"></p><p>然后每个子树也这样划分，这个点每次取<strong>重心</strong>，可以保证最多划分 $\log n$ 层</p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p><a href="https://www.acwing.com/problem/content/254/">树</a></p><p>题意非常简单：求树上距离不超过 $k$ 的点对数量，点分治的思路也非常简单，每次选重心（记选的节点为 $c$ ），分三类：</p><ol><li>对于两个点都在同一子树内部的情况，递归处理</li><li>对于有一个点恰好是 $c$ 的情况，直接dfs求</li><li>对于跨子树的情况，可以先求出每棵子树内每个点到 $c$ 的距离，然后对于所有距离，记录任选两个距离和小于等于 $k$ 的情况，再删掉同一棵子树内两个点距离和小于等于 $k$ 的情况即可，而求解“一个集合内任取两个数和小于等于 $k$ 的方案数”可以用排序后双指针来解决（也可以排序后二分，麻烦点）</li></ol><p>考虑时间复杂度，最多有 $\log n$ 层，每层 $n$ 个点都要排序，一共是 $O(n \log^2 n)$ </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ne, ver, w;</span><br><span class="line">&#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> h[N], idx;</span><br><span class="line"><span class="keyword">bool</span> del[N];</span><br><span class="line"><span class="keyword">int</span> p[N], q[N], cp, cq;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx] = (Edge)&#123;h[x], y, z&#125;, h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_si</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x])</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line"><span class="keyword">if</span> (e[i].ver != fa)</span><br><span class="line">res += <span class="built_in">get_si</span>(e[i].ver, x);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_wc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> si, <span class="keyword">int</span> &amp;wc)</span> <span class="comment">// 求重心(其实是一个保证删去后子树大小小于n/2的点,不一定是重心)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x])</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">1</span>, mx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y, t; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (y == fa)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">t = <span class="built_in">get_wc</span>(y, x, si, wc);</span><br><span class="line">mx = <span class="built_in">max</span>(mx, t);</span><br><span class="line">sum += t;</span><br><span class="line">&#125;</span><br><span class="line">mx = <span class="built_in">max</span>(mx, si - sum);</span><br><span class="line"><span class="keyword">if</span> (mx &lt;= si / <span class="number">2</span>)</span><br><span class="line">wc = x;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_dis</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> dis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x])</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">q[++cq] = dis;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line"><span class="keyword">if</span> (e[i].ver != fa)</span><br><span class="line"><span class="built_in">get_dis</span>(e[i].ver, x, dis + e[i].w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> c)</span> <span class="comment">//计算集合a中有多少对相加不大于k</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + c);</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = c, j = <span class="number">0</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (j + <span class="number">1</span> &lt; i &amp;&amp; a[j + <span class="number">1</span>] + a[i] &lt;= k)</span><br><span class="line">++j;</span><br><span class="line">j = <span class="built_in">min</span>(j, i - <span class="number">1</span>);</span><br><span class="line">res += j + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x])</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">get_wc</span>(x, <span class="number">-1</span>, <span class="built_in">get_si</span>(x, <span class="number">-1</span>), x);</span><br><span class="line">del[x] = <span class="literal">true</span>;</span><br><span class="line">cp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line">cq = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">get_dis</span>(y, <span class="number">-1</span>, e[i].w);</span><br><span class="line">res -= <span class="built_in">work</span>(q, cq);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cq; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (q[j] &lt;= k)</span><br><span class="line">++res;</span><br><span class="line">p[++cp] = q[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">res += <span class="built_in">work</span>(p, cp);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">res += <span class="built_in">calc</span>(e[i].ver);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k), n || k)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">h[i] = <span class="number">-1</span>, del[i] = <span class="literal">false</span>;;</span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, w; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line"><span class="built_in">add</span>(u + <span class="number">1</span>, v + <span class="number">1</span>, w), <span class="built_in">add</span>(v + <span class="number">1</span>, u + <span class="number">1</span>, w); <span class="comment">//输入的下标是从0开始的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">calc</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.acwing.com/problem/content/266/">权值</a></p><p>类似于模板，看注释吧，时间复杂度 $O(n \log n)$ ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>, S = <span class="number">1e6</span> + <span class="number">5</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, ans = INF;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ne, ver, w;</span><br><span class="line">&#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> dis, num;</span><br><span class="line">&#125; p[N], q[N];</span><br><span class="line"><span class="keyword">int</span> h[N], idx;</span><br><span class="line"><span class="keyword">bool</span> del[N];</span><br><span class="line"><span class="keyword">int</span> cp, cq;</span><br><span class="line"><span class="keyword">int</span> b[S]; <span class="comment">//开一个桶记录到重心距离为i的点的最小边数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx] = (Edge)&#123;h[x], y, z&#125;, h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_si</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x])</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line"><span class="keyword">if</span> (e[i].ver != fa)</span><br><span class="line">res += <span class="built_in">get_si</span>(e[i].ver, x);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_wc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> si, <span class="keyword">int</span> &amp;wc)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x])</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">1</span>, mx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y, t; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (y == fa)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">t = <span class="built_in">get_wc</span>(y, x, si, wc);</span><br><span class="line">mx = <span class="built_in">max</span>(mx, t);</span><br><span class="line">sum += t;</span><br><span class="line">&#125;</span><br><span class="line">mx = <span class="built_in">max</span>(mx, si - sum);</span><br><span class="line"><span class="keyword">if</span> (mx &lt;= si / <span class="number">2</span>)</span><br><span class="line">wc = x;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_dis</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> dis, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x] || dis &gt; k)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">q[++cq] = (Node)&#123;dis, num&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line"><span class="keyword">if</span> (e[i].ver != fa)</span><br><span class="line"><span class="built_in">get_dis</span>(e[i].ver, x, dis + e[i].w, num + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x])</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"><span class="built_in">get_wc</span>(x, <span class="number">-1</span>, <span class="built_in">get_si</span>(x, <span class="number">-1</span>), x);</span><br><span class="line">del[x] = <span class="literal">true</span>;</span><br><span class="line">cp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line">cq = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">get_dis</span>(y, x, e[i].w, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cq; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (q[j].dis == k)</span><br><span class="line">ans = <span class="built_in">min</span>(ans, q[j].num);</span><br><span class="line">ans = <span class="built_in">min</span>(ans, b[k - q[j].dis] + q[j].num);</span><br><span class="line">p[++cp] = q[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cq; ++j)</span><br><span class="line">b[q[j].dis] = <span class="built_in">min</span>(b[q[j].dis], q[j].num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cp; ++j) <span class="comment">//将桶清空</span></span><br><span class="line">b[p[j].dis] = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line"><span class="built_in">calc</span>(e[i].ver);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">h[i] = <span class="number">-1</span>;</span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; ++i)</span><br><span class="line">    b[i] = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, w; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line"><span class="built_in">add</span>(u + <span class="number">1</span>, v + <span class="number">1</span>, w), <span class="built_in">add</span>(v + <span class="number">1</span>, u + <span class="number">1</span>, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">calc</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (ans == INF)</span><br><span class="line">ans = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P3806">【模板】点分治1</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>, K = <span class="number">1e7</span> + <span class="number">5</span>, M = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ne, ver, w;</span><br><span class="line">&#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> h[N], idx;</span><br><span class="line"><span class="keyword">bool</span> del[N];</span><br><span class="line"><span class="keyword">int</span> p[N], q[N], o[N], cp, cq, co;</span><br><span class="line">list&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line"><span class="keyword">int</span> _Q[M];</span><br><span class="line"><span class="keyword">bool</span> b[K], ans[K];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx] = (Edge)&#123;h[x], y, z&#125;, h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_si</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x])</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line"><span class="keyword">if</span> (e[i].ver != fa)</span><br><span class="line">res += <span class="built_in">get_si</span>(e[i].ver, x);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_wc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> si, <span class="keyword">int</span> &amp;wc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x])</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">1</span>, mx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y, t; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (y == fa)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">t = <span class="built_in">get_wc</span>(y, x, si, wc);</span><br><span class="line">mx = <span class="built_in">max</span>(mx, t);</span><br><span class="line">sum += t;</span><br><span class="line">&#125;</span><br><span class="line">mx = <span class="built_in">max</span>(mx, si - sum);</span><br><span class="line"><span class="keyword">if</span> (mx &lt;= si / <span class="number">2</span>)</span><br><span class="line">wc = x;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_dis</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> dis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x] || dis &gt; K)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">q[++cq] = dis;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line"><span class="keyword">if</span> (e[i].ver != fa)</span><br><span class="line"><span class="built_in">get_dis</span>(e[i].ver, x, dis + e[i].w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x])</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">get_wc</span>(x, <span class="number">-1</span>, <span class="built_in">get_si</span>(x, <span class="number">-1</span>), x);</span><br><span class="line">del[x] = <span class="literal">true</span>;</span><br><span class="line">cp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line">cq = co = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">get_dis</span>(y, <span class="number">-1</span>, e[i].w);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cq; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r : Q)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (q[j] == r)</span><br><span class="line">ans[r] = <span class="literal">true</span>, o[++co] = r;</span><br><span class="line"><span class="keyword">if</span> (r &gt;= q[j] &amp;&amp; b[r - q[j]])</span><br><span class="line">ans[r] = <span class="literal">true</span>, o[++co] = r;</span><br><span class="line">&#125;</span><br><span class="line">p[++cp] = q[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cq; ++j)</span><br><span class="line">b[q[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= co; ++j)</span><br><span class="line">Q.<span class="built_in">remove</span>(o[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cp; ++j)</span><br><span class="line">b[p[j]] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line"><span class="built_in">calc</span>(e[i].ver);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">h[i] = <span class="number">-1</span>;</span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, w; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line"><span class="built_in">add</span>(u, v, w), <span class="built_in">add</span>(v, u, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;_Q[i]);</span><br><span class="line">Q.<span class="built_in">push_back</span>(_Q[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">calc</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line"><span class="keyword">if</span> (ans[_Q[i]])</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;AYE\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NAY\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态点分治（点分树）"><a href="#动态点分治（点分树）" class="headerlink" title="动态点分治（点分树）"></a>动态点分治（点分树）</h2><p>还是先看模板题<a href="https://www.luogu.com.cn/problem/P3241">[HNOI2015]开店</a></p><p>既然叫点分树了，当然是要建一棵树，而这棵树要保证<strong>每一棵子树的根节点就是该子树的重心</strong></p><p>建好树后，考虑如何解决询问，不难发现，一个节点 $u$ 最多属于 $\log n$ 棵子树，不妨设当前子树根节点为 $r$ ：</p><ol><li>若  $r \ne u$ ，考虑形如 $u \rightarrow r \rightarrow v$  的路径有多少个，计入答案，然后进入  $u$ 所在子树递归</li><li>若 $u = r$ ，遍历当前子树所有点，计入答案，然后停止递归</li></ol><p>由于每个点的度不大于3，直接在每个重心上开三个vector，记录每个子树的所有年龄和它到重心的距离，排好序后前缀和+二分即可，总的空间复杂度为 $O(n \log n)$ 时间复杂度为 $O(m \log^2 n)$ ， $m$ 是询问的数量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VS vector<span class="meta-string">&lt;Son&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1.5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, A;</span><br><span class="line"><span class="keyword">int</span> h[N], idx;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ne, ver, w;</span><br><span class="line">&#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Father</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x, id;</span><br><span class="line">LL dis;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Son</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">LL dis;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Son &amp;t) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> age &lt; t.age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Father&gt; f[N];</span><br><span class="line">VS s[N][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">bool</span> del[N];</span><br><span class="line"><span class="keyword">int</span> age[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx] = (Edge)&#123;h[x], y, z&#125;, h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_si</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x])</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line"><span class="keyword">if</span> (e[i].ver != fa)</span><br><span class="line">res += <span class="built_in">get_si</span>(e[i].ver, x);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_wc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> si, <span class="keyword">int</span> &amp;wc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x])</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">1</span>, mx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], t; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (e[i].ver == fa)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">t = <span class="built_in">get_wc</span>(e[i].ver, x, si, wc);</span><br><span class="line">mx = <span class="built_in">max</span>(mx, t);</span><br><span class="line">sum += t;</span><br><span class="line">&#125;</span><br><span class="line">mx = <span class="built_in">max</span>(mx, si - sum);</span><br><span class="line"><span class="keyword">if</span> (mx &lt;= si / <span class="number">2</span>)</span><br><span class="line">wc = x;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_dis</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, LL dis, <span class="keyword">int</span> wc, <span class="keyword">int</span> k, VS &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x])</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">f[x].<span class="built_in">push_back</span>((Father)&#123;wc, k, dis&#125;);</span><br><span class="line">p.<span class="built_in">push_back</span>((Son)&#123;age[x], dis&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], t; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line"><span class="keyword">if</span> (e[i].ver != fa)</span><br><span class="line"><span class="built_in">get_dis</span>(e[i].ver, x, dis + e[i].w, wc, k, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x])</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">get_wc</span>(x, <span class="number">-1</span>, <span class="built_in">get_si</span>(x, <span class="number">-1</span>), x);</span><br><span class="line">del[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y, k = <span class="number">0</span>; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (del[y])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">VS &amp;p = s[x][k];</span><br><span class="line">p.<span class="built_in">push_back</span>((Son)&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;), p.<span class="built_in">push_back</span>((Son)&#123;A + <span class="number">1</span>, <span class="number">0</span>&#125;); <span class="comment">//哨兵</span></span><br><span class="line"><span class="built_in">get_dis</span>(y, <span class="number">-1</span>, e[i].w, x, k, p);</span><br><span class="line"><span class="built_in">sort</span>(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; p.<span class="built_in">size</span>(); ++i)</span><br><span class="line">p[i].dis += p[i - <span class="number">1</span>].dis;</span><br><span class="line">++k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line"><span class="built_in">calc</span>(e[i].ver);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Father &amp;i : f[x])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> g = age[i.x];</span><br><span class="line"><span class="keyword">if</span> (g &gt;= l &amp;&amp; g &lt;= r)</span><br><span class="line">res += i.dis;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j == i.id)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">VS &amp;p = s[i.x][j];</span><br><span class="line"><span class="keyword">if</span> (p.<span class="built_in">empty</span>())</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> a = <span class="built_in">lower_bound</span>(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), (Son)&#123;l, <span class="number">-1</span>&#125;) - p.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">int</span> b = <span class="built_in">lower_bound</span>(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), (Son)&#123;r + <span class="number">1</span>, <span class="number">-1</span>&#125;) - p.<span class="built_in">begin</span>();</span><br><span class="line">res += i.dis * (b - a) + p[b - <span class="number">1</span>].dis - p[a - <span class="number">1</span>].dis;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">VS &amp;p = s[x][i];</span><br><span class="line"><span class="keyword">if</span> (p.<span class="built_in">empty</span>())</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> a = <span class="built_in">lower_bound</span>(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), (Son)&#123;l, <span class="number">-1</span>&#125;) - p.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">int</span> b = <span class="built_in">lower_bound</span>(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), (Son)&#123;r + <span class="number">1</span>, <span class="number">-1</span>&#125;) - p.<span class="built_in">begin</span>();</span><br><span class="line">res += p[b - <span class="number">1</span>].dis - p[a - <span class="number">1</span>].dis;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;A);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">h[i] = <span class="number">-1</span>;</span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;age[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, w; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line"><span class="built_in">add</span>(u, v, w), <span class="built_in">add</span>(v, u, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">calc</span>(<span class="number">1</span>);</span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> u, a, b, l, r;</span><br><span class="line"><span class="keyword">while</span> (m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;a, &amp;b);</span><br><span class="line">l = (a + ans) % A, r = (b + ans) % A;</span><br><span class="line"><span class="keyword">if</span> (l &gt; r)</span><br><span class="line"><span class="built_in">swap</span>(l, r);</span><br><span class="line">ans = <span class="built_in">ask</span>(u, l, r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 分治 </tag>
            
            <tag> 树 </tag>
            
            <tag> dfs </tag>
            
            <tag> 点分治 </tag>
            
            <tag> 点分树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kmp和hash（讲）</title>
      <link href="/2021/12/03/kmp%E5%92%8Chash%EF%BC%88%E8%AE%B2%EF%BC%89/"/>
      <url>/2021/12/03/kmp%E5%92%8Chash%EF%BC%88%E8%AE%B2%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>​    water</p><span id="more"></span><p>临时准备一下，有点水，就只是当一个提纲用，主要听我讲吧</p><h2 id="前置芝士"><a href="#前置芝士" class="headerlink" title="前置芝士"></a>前置芝士</h2><ul><li><p><a href="https://baike.baidu.com/item/Hash/390310">hash的定义</a>（只要定义即可）</p></li><li><p>char数组存储并使用字符串，尽可能不要使用string，<del>但如果实在没办法就用吧</del></p><p>原因：string的值是不可变的，这就导致每次对string的操作都会生成新的string对象，不仅效率低下，而且大量浪费有限的内存空间，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string a = <span class="string">&quot;1&quot;</span>;  <span class="comment">//假设a指向地址0x0001</span></span><br><span class="line">a = <span class="string">&quot;2&quot;</span>; <span class="comment">//重新赋值后a指向地址0x0002,0x0001地址中保存的&quot;1&quot;依旧存在,但已经不再是a所指向的,a已经指向了其它地址</span></span><br></pre></td></tr></table></figure><p>重新赋值并没有改变地址中保存的”1”，而是直接再申请空间，因此string的操作都是改变赋值地址而不是改变值操作，类似的还有string在函数传参时浪费的空间，并且，时间上讲，string比vector和char都慢</p></li><li><p>一定的抽象思维（我会尽力讲的形象一定）</p></li></ul><p>不管如何，看下去吧</p><h2 id="字符串hash"><a href="#字符串hash" class="headerlink" title="字符串hash"></a>字符串hash</h2><ul><li><p>为何使用</p></li><li><p>正确性如何保证</p></li><li><p>具体如何实现（<a href="https://www.luogu.com.cn/problem/P3370">【模板】字符串哈希</a>）</p></li><li><p> $O(n\log n)$ 最长回文串（没有模板题，看代码吧，重点理解p数组的含义）</p></li></ul>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ULL unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IL inline</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1.1e7</span> + <span class="number">5</span>, H = <span class="number">131</span>;</span><br><span class="line">ULL ha[N], ah[N], p[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function">IL ULL <span class="title">get_ha</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ha[r] - ha[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL ULL <span class="title">get_ah</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ah[l] - ah[r + <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="built_in">min</span>(x - <span class="number">1</span>, n - x), mid, res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line">mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">get_ha</span>(x, x + mid) == <span class="built_in">get_ah</span>(x - mid, x))</span><br><span class="line">&#123;</span><br><span class="line">res = mid;</span><br><span class="line">l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="built_in">min</span>(x - <span class="number">1</span>, n - y), mid, res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line">mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">get_ha</span>(y, y + mid) == <span class="built_in">get_ah</span>(x - mid, x))</span><br><span class="line">&#123;</span><br><span class="line">res = mid;</span><br><span class="line">l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">ha[i] = ha[i - <span class="number">1</span>] * H + s[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">p[i] = p[i - <span class="number">1</span>] * H;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">ah[i] = ah[i + <span class="number">1</span>] * H + s[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">ans = <span class="built_in">max</span>(ans, <span class="built_in">find</span>(i) * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (s[i] == s[i + <span class="number">1</span>])</span><br><span class="line">ans = <span class="built_in">max</span>(ans, <span class="built_in">find</span>(i, i + <span class="number">1</span>) * <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其它应用</li></ul><h2 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a>kmp</h2><ul><li><p>思想：利用已有信息减少枚举</p></li><li><p>实现：ne数组（别取next），重点理解其图形意义和其抽象定义的关系</p><p>对图理解：<img src="https://i.loli.net/2021/12/03/t2A3eYZLdJCqsu6.png" alt="kmp"></p></li><li><p>代码：<a href="https://www.luogu.com.cn/problem/P3375">【模板】KMP字符串匹配</a></p></li><li><p>应用：字符串问题、辅助dp（有点难，不要去掌握）</p></li></ul><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>AC自动机（有blog）、Z函数</p>]]></content>
      
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> hash </tag>
            
            <tag> kmp </tag>
            
            <tag> 备讲 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>luoguP4558 [JSOI2018]机器人</title>
      <link href="/2021/12/02/luoguP4558-JSOI2018-%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
      <url>/2021/12/02/luoguP4558-JSOI2018-%E6%9C%BA%E5%99%A8%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<p> 我以为很好打……</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P4558">机器人</a></p><p>一道很难的题，但可以骗点分</p><p>首先第一眼看过去就是dp， $n, m \le 50$ 说明dp并不简单，但看数据范围，反正我是想打分段骗分</p><h2 id="数据1"><a href="#数据1" class="headerlink" title="数据1"></a>数据1</h2><p> $n, m \le 4$ 直接dfs，注意题目求的是<strong>扫地机器人在撞上障碍之前，经过了多少个格子</strong>，换句话说，没撞上障碍，贡献是0</p><p>20分到手</p><h2 id="数据2"><a href="#数据2" class="headerlink" title="数据2"></a>数据2</h2><h3 id="打表"><a href="#打表" class="headerlink" title="打表"></a>打表</h3><p>除了起点外所有格子都是障碍，明显答案就是所有的方案都输入到了扫地机器人里，但 $n, m \le 50$ ，暴力求所有的方案数时间复杂度和数据1是一样的，但是，通过上面的暴力程序打个小表（把dfs能跑出来的全打了）来<strong>找规律</strong>，发现对于 $n, m$ （不妨设 $n \le m$ ），若 $n \mid m$ ，有如下表：</p><table><thead><tr><th align="center">n</th><th align="center">m</th><th align="center">Ans</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">1</td><td align="center">2</td><td align="center">1</td></tr><tr><td align="center">1</td><td align="center">3</td><td align="center">1</td></tr><tr><td align="center">2</td><td align="center">2</td><td align="center">2</td></tr><tr><td align="center">2</td><td align="center">4</td><td align="center">2</td></tr><tr><td align="center">2</td><td align="center">6</td><td align="center">2</td></tr><tr><td align="center">3</td><td align="center">3</td><td align="center">6</td></tr><tr><td align="center">3</td><td align="center">6</td><td align="center">3</td></tr><tr><td align="center">3</td><td align="center">9</td><td align="center">6</td></tr><tr><td align="center">3</td><td align="center">12</td><td align="center">3</td></tr><tr><td align="center">4</td><td align="center">4</td><td align="center">8</td></tr><tr><td align="center">4</td><td align="center">8</td><td align="center">8</td></tr><tr><td align="center">4</td><td align="center">12</td><td align="center">4</td></tr></tbody></table><p>而若 $n \not\mid m$ ，答案为0，找一手规律，信心满满交上去，WA了</p><p> 好吧，看来没有想象的简单，我们发现我们枚举的数都太小了，它们的<strong>合数</strong>只有4，而且4还没枚举完，但这已经提示我们<strong>和gcd或者互质</strong>有关系</p><h3 id="性质1"><a href="#性质1" class="headerlink" title="性质1"></a>性质1</h3><p>再认真看看打出来的表，以及对应的合法方案数</p><p>发现一个性质：对于一个点 $(x, y)$ ，若它走向 $(x + 1, y)$ ，则 $(x, y + 1)$ ，一定是由 $(x - 1, y + 1)$ 走来；同样的，若它走向 $(x, y + 1)$ ，则 $(x + 1, y)$ ，一定是由 $(x + 1, y - 1)$ 走来，正确性显然</p><p>参考下图：</p><p><img src="https://i.loli.net/2021/12/02/ka14GUhuOMKz9Jf.png" alt="对角线"></p><p>若红点向下，则黄点一定是由紫色向下走到（因为红点已经不可能再向右了），绿、蓝、粉点同理，换句话说，红、紫（绿、粉）点的方向一定相同</p><p>再参考样例：</p><p><img src="https://i.loli.net/2021/12/02/oI9YTryJAwOt1G2.png" alt="样例"></p><p>推广到整个图：<strong>一个矩形内任意一条从右上到左下的对角线方向相同</strong>，其中“一条从右上到左下的对角线”是包含了循环的，如图，颜色相同的是“一条对角线”</p><p><img src="https://i.loli.net/2021/12/02/fBTEp2Oxqkjl5uo.png" alt="对角线2"></p><p>这也和我们上面打的表相符合</p><h3 id="性质2"><a href="#性质2" class="headerlink" title="性质2"></a>性质2</h3><p>由于一个点左下和右下的元素属于同一对角线，所以我们下一步无论怎么走都会走到同一个对角线上，则下一步的方向已经确定，推广一下：<strong>机器人的动作自然就是循环的</strong></p><p>循环节很好求，就是看走多少部可以回到原对角线，手玩一下发现是 $gcd(n, m)$ ，这也和打表的猜测相符合</p><p>证明的话（<del>听大佬说是</del>）把这个矩阵复制几份拼在一起，如果循环节不是 $gcd(n, m)$ 那么在两个矩形的交界出会出现副对角线颜色不同的情况，而循环节是 $gcd(n, m)$ 的时候相当于一堆正方形拼在一起自然不会出现问题</p><h3 id="性质3"><a href="#性质3" class="headerlink" title="性质3"></a>性质3</h3><p>设循环节长度为 $d$ ，且其中有 $a$ 步向右， $d - a$ 步向下，则有 $a \perp d$ 且 $a \perp n, (d - a) \perp m$ </p><p>证明：</p><p>若可到节点 $(x, y)$，则有 $1 + ka \equiv x \pmod n$ ，而 $x$ 取遍 $1 \sim n$ ，由裴蜀定理，若 $gcd(a, n) \ne 1$ ，则必有 $x$ 取不到，故 $a \perp n$ </p><p>同理有 $gcd(d - a, m) = 1$ ，又因为 $d = gcd(n, m)$ ，故 $a \perp d$ </p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>有了以上性质，方案数变得可求，考虑枚举 $a$ 即可<br>$$<br>Ans = \sum_{a = 0} ^ {d} [a \perp d] * [a \perp n] * [(d - a) \perp m] * \binom{d}{a}<br>$$<br>期望得分50</p><h2 id="数据3"><a href="#数据3" class="headerlink" title="数据3"></a>数据3</h2><p>现在考虑撞上障碍，明显应该dp，由于 $n, m$ 很小，dp状态几乎可以随便设，反正维数管够，设 $f[i][j][k]$ 表示在 $(i, j)$ 上撞上障碍的路程的最小值为k的方案数</p><p>同数据2，可以枚举 $a$ ，易得，若该次循环从 $(x, y)$ 出发，必然走到 $(x + a, y + b)$ ，所以只要在 $(1, 1)$ 到 $(1 + a, 1 + b)$ 间dp即可</p><p>设格子 $(x, y), (1 \le x \le 1 + a, 1 \le y \le 1 + b)$ 的权值 $w_{x, y}$ 为走到有障碍格子 $(x + ka, y + kb), (k \in \mathbb{N})$ 的最小步数，则方程为<br>$$<br>\begin{align}<br>f[i][j][k] \rightarrow f[i + 1][j][\min (k, w_{i + 1, j})]\\<br>f[i][j][k] \rightarrow f[i][j + 1][\min (k, w_{i, j + 1})]<br>\end{align}<br>$$<br>考虑时间复杂度，求 $w[i][j]$ 需要枚举 $a, i, j, k$ ，$a, i, j \le d$ ，而 $k \le \frac{nm}{d}$ ，总的时间复杂度为 $O(d^2nm) &lt; O(n^4)$ ，而转移 $f$ 时要枚举 $i, j, k$ ，其中 $i \le n, j \le m, k \le nm$ 故为 $O(n^4)$ ，总的时间复杂度为 $O(Tn^4)$ ，大概 $6 \times 10^8$ 的样子，由于有很多条件特判（如 $a$ 的互质），跑不满（实测跑的飞快），加上时限是5s，可以过</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50</span> + <span class="number">5</span>, P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, d;</span><br><span class="line"><span class="keyword">char</span> s[N][N];</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">int</span> f[N][N][N * N], w[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> y == <span class="number">0</span> ? x : <span class="built_in">gcd</span>(y, x % y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (((a == <span class="number">0</span>) &amp;&amp; (n == <span class="number">1</span>)) || ((b == <span class="number">0</span>) &amp;&amp; (m == <span class="number">1</span>)) || ((<span class="built_in">gcd</span>(a, d) == <span class="number">1</span>) &amp;&amp; (<span class="built_in">gcd</span>(b, d) == <span class="number">1</span>) &amp;&amp; (<span class="built_in">gcd</span>(a, n) == <span class="number">1</span>) &amp;&amp; (<span class="built_in">gcd</span>(b, m) == <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// freopen(&quot;t.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="comment">// freopen(&quot;t.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line"><span class="keyword">while</span> (T--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">d = <span class="built_in">gcd</span>(n, m);</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s[i] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span> &amp;&amp; m == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>, b; a &lt;= d; ++a)</span><br><span class="line">&#123;</span><br><span class="line">b = d - a; <span class="comment">//枚举a,b</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">check</span>(a, b))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y, _w; i &lt;= a + <span class="number">1</span>; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b + <span class="number">1</span>; ++j)</span><br><span class="line">&#123;</span><br><span class="line">x = i, y = j, _w = (i - <span class="number">1</span>) + (j - <span class="number">1</span>); <span class="comment">//设障碍点为(x, y)</span></span><br><span class="line">w[i][j] = n * m;  <span class="comment">//先将权值赋为极大值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k * d &lt;= n * m; ++k)  <span class="comment">//其实是k&lt;=n*m/d</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (s[x][y] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">w[i][j] = <span class="built_in">min</span>(w[i][j], _w);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">x += a, y += b, _w += d;</span><br><span class="line"><span class="keyword">if</span> (x &gt; n)</span><br><span class="line">x -= n;</span><br><span class="line"><span class="keyword">if</span> (y &gt; m)</span><br><span class="line">y -= m;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a + <span class="number">1</span>; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b + <span class="number">1</span>; ++j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= n * m; ++k)</span><br><span class="line">f[i][j][k] = <span class="number">0</span>;</span><br><span class="line">f[<span class="number">1</span>][<span class="number">1</span>][w[<span class="number">1</span>][<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a + <span class="number">1</span>; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b + <span class="number">1</span>; ++j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n * m; ++k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">1</span> &lt;= a + <span class="number">1</span>)</span><br><span class="line">f[i + <span class="number">1</span>][j][<span class="built_in">min</span>(k, w[i + <span class="number">1</span>][j])] = (f[i + <span class="number">1</span>][j][<span class="built_in">min</span>(k, w[i + <span class="number">1</span>][j])] + f[i][j][k]) % P;</span><br><span class="line"><span class="keyword">if</span> (j + <span class="number">1</span> &lt;= b + <span class="number">1</span>)</span><br><span class="line">f[i][j + <span class="number">1</span>][<span class="built_in">min</span>(k, w[i][j + <span class="number">1</span>])] = (f[i][j + <span class="number">1</span>][<span class="built_in">min</span>(k, w[i][j + <span class="number">1</span>])] + f[i][j][k]) % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * m; ++i)</span><br><span class="line">ans = (ans + (LL)f[a + <span class="number">1</span>][b + <span class="number">1</span>][i] * i) % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> luogu </tag>
            
            <tag> 练习 </tag>
            
            <tag> 暴力 </tag>
            
            <tag> dp </tag>
            
            <tag> 骗分 </tag>
            
            <tag> 计数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>luoguP4616 [COCI2017-2018#5] Pictionary</title>
      <link href="/2021/11/30/luoguP4616-COCI2017-2018-5-Pictionary/"/>
      <url>/2021/11/30/luoguP4616-COCI2017-2018-5-Pictionary/</url>
      
        <content type="html"><![CDATA[<p> 不要老往数学上想</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P4616">Pictionary</a></p><p>第一反应是 $O(n^2)$ 40分的做法（很显然），直接 $O(n\sqrt{n})$ 把每个数分解，建图连边，再从大到小扫描每个因数，由此处理出所有 $gcd(a, b)$ ，这里是 $O(n^2)$ ，然后暴力枚举 $i : 1 \rightarrow m$  ，并查集维护即可，这里是 $O(n\log n)$ </p><p>但满数据 $n \le 10^5$ 肯定不允许 $n^2$ ，空间时间都挂了</p><p>仔细看，上面的瓶颈主要在求 $gcd(a, b)$ 只要我们要求出所有 $gcd$ ，就一定会有一个 $n^2$ 的时空复杂度，这显然应该<strong>放弃</strong>，那么考虑题目可否不求或者不求出全部的 $gcd$ </p><p>发现题目的问题有一下性质：</p><ol><li>这 $n$ 个数是 $1 \sim n$ 连续的（我以为很有用，然并卵）</li><li>只是询问图的<strong>联通性</strong>，不询问具体的两个数的 $gcd$ </li><li>答案求的是一个<strong>最值</strong></li><li>图建好后，询问<strong>不会再改变图</strong>了</li></ol><p>除开第一个误导我好久的性质，我们来看看其它性质如何使用：</p><p>首先最好用的是性质3，它明显提示我们建一个有权值的图，将询问转化为求权值，具体的，可以建<strong>一棵有边权的树</strong>，权值对应的时间，两个点之间的路径上的最大边权就是答案</p><p>现在主要问题在建图了，再看现性质2，明显我们不必也不能求 $gcd$ 来建图，正难则反，考虑可否枚举倍数，发现在<strong>只关注图的联通性</strong>的情况下，每天连出的边<strong>等效于从第 $m - i + 1$ 号城向它的所有倍数号城连边</strong>，边权就是天数，正确性显然，而这样建图，时间复杂度为 $O(\frac{n}{1} + \frac{n}{2} + … + \frac{n}{n}) = O(n)$ ，但我们要的是<strong>树</strong>，毕竟如果有多条路径就不好处理了，于是用类似最小生成树的思想，取最小的边权（其实就是天数最小）加入树中，用并查集维护联通性，一共是 $O(n \log n)$ </p><p>现在树建好了，性质2、3也都用了，来考虑询问，上面说过，两个点之间的路径上的最大边权就是答案，但每次暴力求权值肯定不行，结合 $n \le 10^5$ 和所求问题，不难想到<strong>树链剖分</strong>，如果是树剖，当然，本题得以解决</p><p>但是考虑性质4，树剖是支持修改和区间操作的，用在本题这静态的图上不免大材小用（<del>主要是调不出来</del>），于是思考，可否用一个预处理后在 $O(\log n)$ 内回答询问</p><p>当然是可以的，考虑树上倍增，用ST表+lca即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, D = <span class="number">25</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ne, ver, w;</span><br><span class="line">&#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> h[N], idx;</span><br><span class="line"><span class="keyword">int</span> fa[N];</span><br><span class="line"><span class="keyword">int</span> f[N][D], st[N][D], dep[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx] = (Edge)&#123;h[x], y, z&#125;, h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_f</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">get_f</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = m, u, v; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt;= n; j += i)</span><br><span class="line">&#123;</span><br><span class="line">u = <span class="built_in">get_f</span>(i), v = <span class="built_in">get_f</span>(j);</span><br><span class="line"><span class="keyword">if</span> (u != v)</span><br><span class="line">&#123;</span><br><span class="line">fa[u] = v;</span><br><span class="line"><span class="built_in">add</span>(i, j, m - i + <span class="number">1</span>);  <span class="comment">//i枚举的是m-i+1的值,所以这里要变回来</span></span><br><span class="line"><span class="built_in">add</span>(j, i, m - i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">dep[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">st[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">x = q.<span class="built_in">front</span>(), q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (y == f[x][<span class="number">0</span>])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">f[y][<span class="number">0</span>] = x;</span><br><span class="line">st[y][<span class="number">0</span>] = e[i].w;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; D; ++i)</span><br><span class="line">&#123;</span><br><span class="line">f[y][i] = f[f[y][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">st[y][i] = <span class="built_in">max</span>(st[y][i - <span class="number">1</span>], st[f[y][i - <span class="number">1</span>]][i - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">q.<span class="built_in">push</span>(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_ans</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">//类似lca</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (dep[y] &lt; dep[x])</span><br><span class="line"><span class="built_in">swap</span>(x, y);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = D - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line"><span class="keyword">if</span> (dep[f[y][i]] &gt;= dep[x])</span><br><span class="line">&#123;</span><br><span class="line">res = <span class="built_in">max</span>(res, st[y][i]);</span><br><span class="line">y = f[y][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x == y)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = D - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line"><span class="keyword">if</span> (f[x][i] != f[y][i])</span><br><span class="line">&#123;</span><br><span class="line">res = <span class="built_in">max</span>(res, <span class="built_in">max</span>(st[y][i], st[x][i]));</span><br><span class="line">y = f[y][i], x = f[x][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(res, <span class="built_in">max</span>(st[x][<span class="number">0</span>], st[y][<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> Q, u, v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;Q);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">h[i] = <span class="number">-1</span>, fa[i] = i;</span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; D; ++j)</span><br><span class="line">st[i][j] = INF;</span><br><span class="line"><span class="built_in">build</span>();</span><br><span class="line"><span class="built_in">bfs</span>();</span><br><span class="line"><span class="keyword">while</span> (Q--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">get_ans</span>(u, v));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> 图论 </tag>
            
            <tag> luogu </tag>
            
            <tag> 练习 </tag>
            
            <tag> COCI </tag>
            
            <tag> 并查集 </tag>
            
            <tag> ST表 </tag>
            
            <tag> lca </tag>
            
            <tag> 倍增 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test2021/11/29总结</title>
      <link href="/2021/11/29/test2021-11-29%E6%80%BB%E7%BB%93/"/>
      <url>/2021/11/29/test2021-11-29%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p> 暴力狂魔</p><span id="more"></span><h1 id="test2021-11-29总结"><a href="#test2021-11-29总结" class="headerlink" title="test2021/11/29总结"></a>test2021/11/29总结</h1><p>学校测试，考了<strong>2021全国统一省选Day2</strong></p><h2 id="题目、成绩和题解"><a href="#题目、成绩和题解" class="headerlink" title="题目、成绩和题解"></a>题目、成绩和题解</h2><p><a href="./%E7%9C%81%E9%80%892021.A%E5%8D%B7.day2.pdf">题目</a></p><p><a href="./noi2021sx-day2%E6%AF%94%E8%B5%9B%E7%BB%93%E6%9E%9C.pdf">成绩</a></p><p><a href="./NOI2021%E5%85%A8%E5%9B%BD%E7%BB%9F%E4%B8%80%E7%9C%81%E9%80%89A%E5%8D%B7%EF%BC%88%E9%A2%98%E8%A7%A3%EF%BC%89.docx">题解</a></p><h2 id="早上做题"><a href="#早上做题" class="headerlink" title="早上做题"></a>早上做题</h2><p>一大早考试，看到题就已经做好打三道暴力的准备</p><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>快速瞟了一眼，一看，第一感觉暴力可以拿25（<del>实际也是25分，一分不多艹</del>），后来仔细观察了数据范围，特殊性质有两个，一个是 $m \le 300$  再加上满数据的 $m$ 也比 $n$ 小，像是提示我要打权值线段树的样子；又有一个是链，像是提示我树链剖分</p><p>感觉上从数据范围看是 $O(n\log n)$ 或者常数小的 $O(n\log^2 n)$ ，个人考场上偏向于是树剖（<del>特别打脸</del>），想到树剖不好调（同机房的<strong>l18q</strong>就是死调树剖），决定打个暴力往下看</p><p>暴力思路这里简单说一下（免得我忘了）：大概是倍增法的lca找路径，存下来，然后再扫一遍求答案，时间复杂度 $O(qn)$ </p><h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>不多说，计算机一算，$13!$ 都炸了，直接放弃想正解，感觉暴力分挺多的，于是打暴力，dfs求排列，倒序扫排名判定是否可行，时间复杂度 $O(n!n)$ ，考场上得了60分，第三个大样例过不了</p><h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>这个才<del>nm</del>离谱，<strong>wfy</strong>大佬会打支配树，刚开考就（在我旁边）说他先做T3，我内心忐忑的来到T3，一看，连暴力都觉得好麻烦，但麻烦也得打啊，就硬着头皮打暴力</p><p>第一遍打了个非多项式时间复杂度的（<del>其实就是玄学，说的那么文雅</del>），连样例三都超时，样例二还WA了，没多想，换思路</p><p>第二边打了个正经暴力，思路是先bfs求出每个点到1的最短路径，存在vector $D[N]$ 里，然后对于 $D[i]$ 中的每一个点，判断删去该点后1和 $i$ 是否联通，不联通则该点是支配点，对于每个加边操作，就加上边然后再判一次（因为 $D[i]$ 只会变小，不会变大），时间复杂度为 $O(qn^3)$ ，因为第二、三个 $n$ 都绝对跑不满，所以其实大概是 $O(qn\xi)$ 的，反正样例三是没TLE了</p><p>然鹅样例二的WA还是不变！我对着大样例极端痛苦的调到考试快结束，大概最后三分钟（其它人好多都交了）的时候才发现：“ 有 $q$ 次 ${\color{red}\colorbox{yellow}{互相独立}}$ 的询问”，所以每次询问完后要恢复原状！我用的链式前向星，不好复原，三分钟改成vector存图，没来得及调就交了，结果爆零</p><h3 id="总分"><a href="#总分" class="headerlink" title="总分"></a>总分</h3><p>25 + 60 + 0，85分，还算正常分数吧（毕竟我太弱了），最高是<strong>wfy</strong>大佬和<strong>龙巨</strong>，看了一下，T3都打出来了30分，不愧是他们，下午打算先把T3的30分改出来</p><h2 id="下午改题"><a href="#下午改题" class="headerlink" title="下午改题"></a>下午改题</h2><h3 id="T3-1"><a href="#T3-1" class="headerlink" title="T3"></a>T3</h3><p>首先，上午的方法打出来了，不知为何，有几个询问都比答案小1，调了半天没办法，只好<del>看题解</del>，找了个支配树的方法，如下：</p><p>首先，用 $O(n^2)$  建出<strong>支配树</strong>（定义为一棵树，满足点 $u$ 的受支配集 $D_u$ 即为它到根的路径上的所有点组成的集合），建法为先求出 $D[]$ （方法同上午的），然后类似拓扑排序一样，首先把1入队，对于队头 $x$ 删除所以 $D[]$ 中的 $x$ ，若有一个 $i$ 满足 $D[i] = {i}$ 即只剩下自己支配自己，就入队，并连边 $(x, i)$ </p><p>建好支配树后，对于每次添加边 $(u, v)$ ，若一个点 $x$ 的支配集改变，一定是出现了 $1 \rightarrow u \rightarrow v \rightarrow x$ 并且该路径不经过支配树上 $x$ 的某个祖先</p><p>但枚举祖先太麻烦，而且会TLE，我们发现一个性质：若 $x$ 的支配集改变，则支配树上 $x$ 的所有孩子的支配集也会改变，正确性显然</p><p>于是利用该性质，问题转化为：如果存在一条路径 $1 \rightarrow u \rightarrow v \rightarrow x$ 不经过点 $x$ 的<strong>父亲</strong>，那么 $x$ 子树内所有点都会对答案产生贡献（支配集都会发生改变），问贡献和</p><p>我们可以预处理每一个点 $x$ ，把 $x$ 的父亲从原图的反图中删去，$x$ 能到达哪些点，它就可能对这些点产生贡献，对于一组询问 $(u, v)$ ，我们只需要枚举所有可能对 $v$ 产生贡献的点，如果它的父亲不在支配树上的 $1 \rightarrow u$ 这条路径上，它这棵子树就可以产生贡献，时间复杂度 $O(nq)$ </p><p>类似树剖，用dfn化为链，直接差分即可（因为修改一定是在同一子树，不必像树剖一样轻重链划分）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IL inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3000</span> + <span class="number">5</span>, Que = <span class="number">2e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ne, ver;</span><br><span class="line">&#125; e[<span class="number">5</span>][N &lt;&lt; <span class="number">3</span>]; <span class="comment">//1-原图,2-反图,3-支配树</span></span><br><span class="line"><span class="keyword">int</span> h[<span class="number">5</span>][N], idx[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="keyword">int</span> stk[N * N], top;</span><br><span class="line"><span class="keyword">int</span> fa[N], si[N], dfn[N], id;</span><br><span class="line"><span class="keyword">int</span> vs[N], cf[N];  <span class="comment">//vs:第几次询问,cf:差分</span></span><br><span class="line"><span class="keyword">bool</span> del[N], vis[N], can[N][N], ins[N], cc[N][N]; <span class="comment">//cc:能否贡献</span></span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[o][idx[o]] = (Edge)&#123;h[o][x], y&#125;, h[o][x] = idx[o]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">dfs12</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x])</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[o][x]; i != <span class="number">-1</span>; i = e[o][i].ne)</span><br><span class="line"><span class="keyword">if</span> (!vis[e[o][i].ver])</span><br><span class="line"><span class="built_in">dfs12</span>(o, e[o][i].ver);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">del[j] = vis[j] = <span class="literal">false</span>;</span><br><span class="line">del[i] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">dfs12</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line"><span class="keyword">if</span> (!vis[j])</span><br><span class="line">can[j][i] = <span class="literal">true</span>, ++cnt[j];</span><br><span class="line">&#125;</span><br><span class="line">top = <span class="number">1</span>;</span><br><span class="line">stk[top] = <span class="number">1</span>;</span><br><span class="line">ins[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= top; i++)</span><br><span class="line">&#123;</span><br><span class="line">x = stk[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line"><span class="keyword">if</span> (can[j][x])</span><br><span class="line">--cnt[j];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line"><span class="keyword">if</span> (cnt[j] == <span class="number">1</span> &amp;&amp; !ins[j])</span><br><span class="line">ins[j] = <span class="literal">true</span>, <span class="built_in">add</span>(<span class="number">3</span>, x, j), stk[++top] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">si[x] = <span class="number">1</span>;</span><br><span class="line">dfn[x] = ++id;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[<span class="number">3</span>][x], y; i != <span class="number">-1</span>; i = e[<span class="number">3</span>][i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[<span class="number">3</span>][i].ver;</span><br><span class="line">fa[y] = x;</span><br><span class="line"><span class="built_in">dfs3</span>(y);</span><br><span class="line">si[x] += si[y];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">prev</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fa[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">id = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">dfs3</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">del[j] = vis[j] = <span class="literal">false</span>;</span><br><span class="line">del[fa[i]] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">dfs12</span>(<span class="number">2</span>, i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">cc[i][j] = vis[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m, Q, u, v, _u, ans, t;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;Q);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">h[<span class="number">1</span>][i] = h[<span class="number">2</span>][i] = h[<span class="number">3</span>][i] = <span class="number">-1</span>;</span><br><span class="line">idx[<span class="number">1</span>] = idx[<span class="number">2</span>] = idx[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line"><span class="built_in">add</span>(<span class="number">1</span>, u, v);</span><br><span class="line"><span class="built_in">add</span>(<span class="number">2</span>, v, u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">build</span>();</span><br><span class="line"><span class="built_in">prev</span>();</span><br><span class="line">t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (Q--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">_u = u;</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line">++t;</span><br><span class="line"><span class="keyword">while</span> (_u != <span class="number">1</span>)</span><br><span class="line">vs[_u] = t, _u = fa[_u];</span><br><span class="line">vs[<span class="number">1</span>] = t;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i)</span><br><span class="line">cf[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span> (cc[i][v] &amp;&amp; vs[fa[i]] != t)</span><br><span class="line">++cf[dfn[i]], --cf[dfn[i] + si[i]];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">cf[i] += cf[i - <span class="number">1</span>], ans += (cf[i] != <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果一下午+晚上只改了一道题，笑死我了</p>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
            <tag> 差分 </tag>
            
            <tag> 支配树 </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性基</title>
      <link href="/2021/11/28/%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
      <url>/2021/11/28/%E7%BA%BF%E6%80%A7%E5%9F%BA/</url>
      
        <content type="html"><![CDATA[<p> 一堆无意义的定义</p><span id="more"></span><h1 id="线性基"><a href="#线性基" class="headerlink" title="线性基"></a>线性基</h1><p>线性基是竞赛中常用来解决<strong>子集异或</strong>一类题目的算法</p><h2 id="数学相关定义"><a href="#数学相关定义" class="headerlink" title="数学相关定义"></a>数学相关定义</h2><p>一大堆没用的</p><h3 id="向量空间"><a href="#向量空间" class="headerlink" title="向量空间"></a>向量空间</h3><p>向量空间亦称线性空间，具体可见<a href="https://baike.baidu.com/item/%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4">百度百科</a>，反正简单来说，就是定义了加法和乘法的向量的集合（其实完全不一样，但我们只需要用到这么多）</p><h3 id="线性相关和线性无关"><a href="#线性相关和线性无关" class="headerlink" title="线性相关和线性无关"></a>线性相关和线性无关</h3><p>若 $V$ 是一个向量空间（集合），如果存在不全为零的系数数列 $c_1, c_2, …, c_n \in \mathbb{F}$ （ $\mathbb{F}$ 是<a href="https://baike.baidu.com/item/%E4%BB%A3%E6%95%B0%E6%95%B0%E5%9F%9F/9551710?fr=aladdin">代数域</a>），使得 $c_1 \vec{v_1} + c_2 \vec{v_2} + … +c_n \vec{v_n} = 0$ （即 $\exists \vec{v_j}$ 可以被除它本身外其它属于 $V$ 的向量表示出来），那么 $V$ 中的向量就叫做<strong>线性相关</strong>的，反之，则为<strong>线性无关</strong>的</p><h3 id="子空间"><a href="#子空间" class="headerlink" title="子空间"></a>子空间</h3><p>设 $W$ 为向量空间 $V$ 的一个非空子集，若 $W$ 在 $V$ 的加法及标量乘法下是封闭的，且零向量 $\vec{0} \in W$ ，就称 $W$ 为 $V$ 的<strong>线性子空间</strong>，简称<strong>子空间</strong></p><h3 id="扩张和生成集合"><a href="#扩张和生成集合" class="headerlink" title="扩张和生成集合"></a>扩张和生成集合</h3><p>给出一个向量集合 $B$ ，那么<strong>包含它</strong>的<strong>最小</strong>子空间 $W$ 就称为它的<strong>扩张</strong>（也叫<strong>张成</strong>），记作 $span(B)$ ，另外规定空集的扩张为 ${\vec{0}}$ </p><p>而 $B$ 也被叫做 $W$ 的<strong>生成集合</strong>（可以理解为通过 $B$ 中的元素可以将 $W$ 中的所有元素表示出来）</p><h3 id="基和维度"><a href="#基和维度" class="headerlink" title="基和维度"></a>基和维度</h3><p>给出一个向量集合 $B$ ，若 $B$ 是<strong>线性无关</strong>的，且 $B$ 能够生成 $V$ ，就称 $B$ 为 $V$ 的一个<strong>基</strong></p><p>对非零向量空间 $V$ ，基是 $V$ 最小的生成集，也是<a href="https://baike.baidu.com/item/%E6%9E%81%E5%A4%A7%E7%BA%BF%E6%80%A7%E6%97%A0%E5%85%B3%E7%BB%84">极大线性无关组</a></p><p>如果一个向量空间 $V$ 拥有一个元素个数<strong>有限</strong>的生成集，那么就称 $V$ 是一个<strong>有限维空间</strong>，向量空间的所有基拥有<strong>相同基数</strong>，称为该空间的<a href="https://baike.baidu.com/item/%E7%BB%B4%E5%BA%A6">维度</a></p><p>空间内的每个向量都有唯一的方法表达成基中向量的<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E7%BB%84%E5%90%88">线性组合</a>，而且，将基中向量进行排列，表示成有序基，每个向量便可以坐标系统来表示</p><h2 id="线性基-1"><a href="#线性基-1" class="headerlink" title="线性基"></a>线性基</h2><p>扯了那么多没有用的，下面才是真的要用的</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>线性基其实就是上面数学定义中，将向量空间的加法和乘法定义为<strong>异或</strong>的意义下的基，具体来说，在异或的定义下：</p><ul><li>用<strong>无符号整数集</strong>来替代<strong>向量的集合</strong></li><li>对于集合 $B$ ，在其中选出任意多个数，其异或和的所有可能的结果组成的集合 $S$ 称作 $B$ 的<strong>扩张</strong>，记为 $span(B)$ </li><li>对于一个集合 $B$ ，若存在一个元素可以用其它若干个元素异或起来得到，则称 $B$ 中元素<strong>线性相关</strong>，反之，则为<strong>线性无关</strong></li><li>对于集合 $B, S$ ，若 $S \subseteq span(B)$ 且 $B$ 线性无关，则称 $B$ 为 $S$ 的<strong>线性基</strong>，集合 $B$ 中元素的个数，称为线性基的<strong>长度</strong></li></ul><p>个人觉得对照这数学中的定义还是比较好理解的</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>若 $B$ 是 $S$ 的线性基，则 $S$ 中的任意元素都可以<strong>唯一</strong>表示为 $B$ 中若干个元素异或起来的结果，正确性显然</p><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p>设 $S$ 中最大的数在二进制下有 $L$ 为，我们用一个下标为 $0 \sim L$ 的数组 $a[]$ 来存储线性基，在接下来的构造中，我们称第 $i$ 位<strong>存在于</strong>线性基中，当且仅当 $a[i] \ne 0$</p><p>首先，线性基是动态构造的，我们只需要从空的，每次考虑在一个已存在的线性基中插入一个数 $t$ 即可</p><p>从 $t$ 最高位上的1开始考虑，设这是第 $j$ 位，如果这一位已经存在于线性基中，则我们需要将 $t$ 中的这一位消掉（将 $t$ 异或上 $a[i]$ ），才可以继续插入（因为要保证 $B$ 线性无关）；如果这一位不存在于线性基中，则可以将  插入到 $a[j]$ 的位置上</p><p>对于具体实现，我们采用逆序枚举 $t$ 所以为1的二进制位 $j$ ，对于每个 $j$ ：</p><ol><li>若 $a[j] \ne 0$ ，则 $t = t \oplus a[j]$ </li><li>若 $a[j] = 0$ ，则 $a[i] = t$ ，结束</li></ol><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>线性基支持一下操作：</p><ul><li><p>求集合的最大异或和：</p><p>只需倒序枚举每一个 $a[i]$ ，贪心异或即可</p></li><li><p>求集合的最小异或和：</p><p>先特判能否为0，然后正序序枚举每一个 $a[i]$ ，第一个存在的就是答案</p></li><li><p>查询 $t$ 是否在值域中</p><p>类似于插入</p></li><li><p>查询第 $k$ 小的值</p><p>先特判减去0，然后从高到低处理线性基每一位，对于每一位向后扫，如果当前数第 $i$ 位为0，且线性基第 $i$ 位不为0，则将当前数异或上 $a[i]$ ，这一操作可以在 $O(L^2)$ 的时间内解决，我们称其为重构<br>经过这一步操作后，设线性基内共有 $cnt$ 个数，则它们共可以表示出 $2^{cnt}$ 个数<br>随后，我们考虑将 $k$ 二进制拆分，用与快速幂类似的方法就可以求出第 $k$ 小值</p></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>一定要注意long long</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">64</span>; <span class="comment">//这个N一定要开对，大了小了都不行</span></span><br><span class="line">LL a[N], tmp[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">a[i] = tmp[i] = <span class="number">0</span>;</span><br><span class="line">cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line"><span class="keyword">if</span> ((x &gt;&gt; i) &amp; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!a[i])</span><br><span class="line">&#123;</span><br><span class="line">a[i] = x;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">x ^= a[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">get_max</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">res = <span class="built_in">max</span>(res ^ a[i], res);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">get_min</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> _c = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line"><span class="keyword">if</span> (a[i])</span><br><span class="line">++_c;</span><br><span class="line"><span class="keyword">if</span> (_c &lt; n)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line"><span class="keyword">if</span> (a[i])</span><br><span class="line"><span class="keyword">return</span> a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> ((x &gt;&gt; i) &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">if</span> (!a[i])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">x^=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">()</span> <span class="comment">//重构线性基</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line"><span class="keyword">if</span> ((a[i] &gt;&gt; j) &amp; <span class="number">1</span>)</span><br><span class="line">a[i] ^= a[j];</span><br><span class="line"><span class="keyword">if</span> (a[i])</span><br><span class="line">tmp[cnt++] = a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i)</span><br><span class="line">a[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">get_k</span><span class="params">(LL k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (cnt &lt; n)</span><br><span class="line">--k;</span><br><span class="line">    <span class="keyword">if</span>(!k)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= (<span class="number">1ll</span> &lt;&lt; cnt))</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i)</span><br><span class="line">    <span class="keyword">if</span> ((k &gt;&gt; i) &amp; <span class="number">1</span>)</span><br><span class="line">    res ^= a[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个用vector实现，比较短的（太香了）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line">vector&lt;LL&gt; b;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (LL i : b)</span><br><span class="line">x = <span class="built_in">min</span>(x ^ i, x);</span><br><span class="line"><span class="keyword">for</span> (LL &amp;i : b)</span><br><span class="line">i = <span class="built_in">min</span>(x ^ i, i);</span><br><span class="line"><span class="keyword">if</span> (x)</span><br><span class="line">b.<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">get_max</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (LL i : b)</span><br><span class="line">res = <span class="built_in">max</span>(res ^ i, res);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">get_min</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (b.<span class="built_in">size</span>() &lt; n)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> b[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (LL i : b)</span><br><span class="line">x = <span class="built_in">min</span>(x ^ i, x);</span><br><span class="line">    <span class="keyword">return</span> x == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">get_k</span><span class="params">(LL k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (b.<span class="built_in">size</span>() &lt; n) <span class="comment">//减去为0的情况</span></span><br><span class="line">    --k;</span><br><span class="line">    <span class="keyword">for</span> (LL i : b)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span> (k &amp; <span class="number">1</span>)</span><br><span class="line">    res ^= i;</span><br><span class="line">    k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数论,数学 </tag>
            
            <tag> 线性基 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斯特林数</title>
      <link href="/2021/11/28/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"/>
      <url>/2021/11/28/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p> 还是卡特兰数简单一点……</p><span id="more"></span><h1 id="斯特林数"><a href="#斯特林数" class="headerlink" title="斯特林数"></a>斯特林数</h1><h2 id="第一类斯特林数"><a href="#第一类斯特林数" class="headerlink" title="第一类斯特林数"></a>第一类斯特林数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>第一类斯特林数（Stirling）分为无符号第一类斯特林数 $s_s(n, m)$ 和带符号第一类斯特林数 $s_u(n, m)$ ，有无符号斯特林数分别表现为其升阶函数和降阶函数的各项系数（<del>反正我是没看懂</del>），形式如下：<br>$$<br>\begin{aligned}<br>x^{n\uparrow} = x(x + 1)(x + 2)…(x + n - 1) = \sum_{k = 0}^{n}s_u(n, k)x^k\\<br>x^{n\downarrow} = x(x - 1)(x - 2)…(x - n  + 1) = \sum_{k = 0}^{n}s_s(n, k)x^k\\<br>\end{aligned}<br>$$<br>对于有无符号斯特林数之间的关系有 $s_s(n, m) = (-1)^{n + m}s_u(n, m)$</p><p>组合数学中的第一类斯特林数一般指无符号的第一类斯特林数，以下的“第一类斯特林数”若无特殊说明，也指“无符号的第一类斯特林数”，无符号的第一类斯特林数还有一个组合数学上的定义，为： $n$ 个不同元素构成 $m$ 个圆排列（两个圆排列间没有顺序之分）的方案数，记作 $s(n, m)$ 或 ${n \brack m}$ </p><h3 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h3><p>第一类斯特林数有一个递推式：<br>$$<br>{n \brack m} = {n - 1 \brack m - 1} + (n - 1){n - 1 \brack m}<br>$$<br>证明：</p><p>考虑第一类斯特林数的定义，${n \brack m}$ 表示把 $n$ 个不同元素构成 $m$ 个圆排列的方案数，对于第 $n$ 个数，若它单独成为新的一个圆，则它前面的 $n - 1$ 个数构成了 $m - 1$ 个圆，方案数为 ${n - 1 \brack m - 1}$ ；若它加入到前面构成的圆中，则它前面的 $n - 1$ 个数构成了 $m$ 个圆，方案数为 ${n - 1 \brack m}$ ，而这 $n - 1$ 个数间有 $n - 1$ 空位可以选择，共 $(n - 1){n - 1 \brack m}$  种方案</p><p>两种情况综合，即得递推式</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>, P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> s[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">s[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">s[i][j] = (s[i - <span class="number">1</span>][j - <span class="number">1</span>] + (LL)(i - <span class="number">1</span>) * s[i - <span class="number">1</span>][j]) % P;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s[n][m]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul><li> ${0 \brack 0} = 1$ </li><li> ${n \brack 0} = 0$ </li><li> ${n \brack n} = 1$ </li></ul><p>以上三条由定义不难得到</p><ul><li><p>  ${n \brack 1} = (n - 1)!$ </p></li><li><p> ${n \brack n - 1} = \binom{n}{2}$ </p></li></ul><p>  证明：</p><p>  依然考虑定义，$n$ 个不同元素构成 $n - 1$ 个圆排列，必然有一个圆排列有两个数，其它圆排列只有一个数，有两个数的圆排列有 $\binom{n}{2}$ 种方案，对应其它都只有一种方案</p><ul><li> $\sum_{k = 0}^{n} {n \brack k} = n!$ </li></ul><p>  证明：</p><p>  令升阶函数中的 $x = 1$ ，即得原式</p><h2 id="第二类斯特林数"><a href="#第二类斯特林数" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>第二类斯特林数实际上是集合的一个拆分，表示将 $n$ 个不同的元素划分成 $m$ 个集合（两个集合间没有顺序之分）的方案数，记为 $S(n, m)$ 或 ${n \brace m}$ ，和第一类斯特林数不同的是，集合内是不考虑次序的，而圆排列是有序的</p><h3 id="求法-1"><a href="#求法-1" class="headerlink" title="求法"></a>求法</h3><p>递推式：<br>$$<br>{n \brace m} = {n - 1 \brace m - 1} + m {n - 1 \brace m}<br>$$<br>还是考虑定义，将 $n$ 个不同的元素划分成 $m$ 个集合，对于第 $n$ 个数，可以单独为一个集合，则前面 $n - 1$ 个数构成 $m - 1$ 个集合，方案数为 ${n - 1 \brace m - 1}$ ；也可以加入到原有集合中，则前面 $n - 1$ 个数构成 $m$ 个集合，方案数为 ${n - 1 \brace m}$ ，而第 $n$ 个数在 $m$ 个集合中选一个加入，方案数为 $m$ </p><p>两种情况综合，即得递推式</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>, P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> S[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">S[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">S[i][j] = (S[i - <span class="number">1</span>][j - <span class="number">1</span>] + (LL)j * S[i - <span class="number">1</span>][j]) % P;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, S[n][m]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算式：<br>$$<br>{n \brace m} = \frac{1}{m!} \sum_{k = 0}^{m} (-1)^k \binom{m}{k} (m - k)^n<br>$$<br>证明见<a href="https://baike.baidu.com/item/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0">百度百科</a></p><h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><ul><li> ${n \brace 0} = 0^n$ </li><li> ${n \brace 1} = 1$ </li><li> ${n \brace n} = 1$ </li><li> ${n \brace 2} = 2^{n - 1} - 1$ </li><li> ${n \brace n - 1} = \binom{n}{2}$ </li><li> $\sum_{k = 0}^{n} {n \brace k} = B_n$ ，其中 $B_n$ 是<a href="https://baike.baidu.com/item/%E5%80%8D%E5%B0%94%E6%95%B0/369479?fromtitle=%E8%B4%9D%E5%B0%94%E6%95%B0&fromid=9227873">贝尔数</a>  </li></ul><h2 id="两类斯特林数的关系"><a href="#两类斯特林数的关系" class="headerlink" title="两类斯特林数的关系"></a>两类斯特林数的关系</h2><p>其实就一个：<br>$$<br>\sum_{k = 0}^{n} {n \brace k}{k \brack m} = \sum_{k = 0}^{n} {n \brack k}{k \brace m}<br>$$</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.com.cn/problem/P4609">建筑师</a></p><p>以高度为 $n$ 的建筑为分界线，左边选择 $A - 1$ 个建筑让他们可以被看见，右边 $B - 1$ 个，如图：</p><p><img src="https://i.loli.net/2021/11/28/lhKaJEux2kpqHmW.jpg" alt="AB"></p><p>问题转化为将 $1 \sim n - 1$ 划分为 $A + B - 2$ 部分（即红框里的），对于每一个部分，将其中元素排成一个圆排列，放置时保证最高的在最左边（如果是放在 $n$ 右边，则最高的在最右边），故有 ${n \brack m}$ 种方案</p><p>然后将这些部分划分给  $n$ 两边，有 $\binom{A + B - 2}{A - 1}$ 种方案</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span> + <span class="number">5</span>, P = <span class="number">1e9</span> + <span class="number">7</span>, M = <span class="number">200</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> s[N][M], C[M][M];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pred</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">s[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; M; ++j)</span><br><span class="line">s[i][j] = (s[i - <span class="number">1</span>][j - <span class="number">1</span>] + (LL)(i - <span class="number">1</span>) * s[i - <span class="number">1</span>][j]) % P;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j)</span><br><span class="line"><span class="keyword">if</span> (!j)</span><br><span class="line">C[i][j] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">C[i][j] = (C[i - <span class="number">1</span>][j] + C[i - <span class="number">1</span>][j - <span class="number">1</span>]) % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">pred</span>();</span><br><span class="line"><span class="keyword">int</span> T, n, a, b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line"><span class="keyword">while</span> (T--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;a, &amp;b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (LL)s[n - <span class="number">1</span>][a + b - <span class="number">2</span>] * C[a + b - <span class="number">2</span>][a - <span class="number">1</span>] % P);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数论,数学 </tag>
            
            <tag> Stirling数,斯特林数 </tag>
            
            <tag> 排列组合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>luoguP4429 [BJOI2018]染色</title>
      <link href="/2021/11/28/luoguP4429-BJOI2018-%E6%9F%93%E8%89%B2/"/>
      <url>/2021/11/28/luoguP4429-BJOI2018-%E6%9F%93%E8%89%B2/</url>
      
        <content type="html"><![CDATA[<p> 结论题，靠手玩</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P4429">染色</a></p><p>拿到题就先被吓了一跳，然后又看了看数据范围，毫无提示性</p><p>先盲猜一手考的二分图，也就是每个点的颜色集合都相同，然后……<del>理所当然的</del> 错了，但还是给了我们一点希望，因为我们发现明显，存在奇环就是No</p><p>那就还有不存在环和存在偶环两种情况</p><p>不存在环，即 $m &lt; n$ ，考虑节点 $u$ 染为颜色 $A$ ，那么与它相连的节点 $v$ 最多只是有一个颜色不能染，此外便再无其它限制，明显是有染色方案的，故为Yes</p><p>再考虑偶环的情况，若只有一个偶环，即 $n = m$ ，我们将其断开，记断开处两个节点为根节点和尾节点，从根节点开始用无环的方法染色，设根节的颜色集合为 ${A, B}$ ，分三种情况：</p><ol><li>若尾节点的颜色集合为 ${C, D}$ ，则染色成立</li><li>若尾节点的颜色集合为 ${A, C}$ ，只要根节点染为颜色 $B$ 即可</li><li>若尾节点的颜色集合为 ${A, B}$ ，设根节点染为颜色 $A$ 如果要让尾节点也必须染颜色 $A$ 则与尾节点相连的另一个点必须染为颜色 $B$ ，以此类推，每个节点的颜色都是“必须染成颜色 $X$ ”，设于根节点相连的另一个点的颜色是必须染成颜色 $E$ （这个 $E$ 可以等于于任何颜色，包括 $A, B$ ），由于这个“必须”，该节点的颜色集合一定是 ${A, E}$ （这样才能用“根节点染成颜色 $A$ ”推出“该节点染成颜色 $E$ ”），那么只要将根节点染成颜色 $B$ ，该节点染成颜色 $E$ ，由于刚才的一系列“必须”，尾节点只能保持颜色 $A$ 不变，染色成立</li></ol><p>综上，若只有一个偶环，必定可以染色，故为Yes</p><p>那有多个偶环，即 $m &gt; n$ ，怎么办？</p><p>先考虑两个偶环没有公共边，看看下图：</p><p><img src="https://i.loli.net/2021/11/28/41UTVmnNBcKjADr.png" alt="偶环"></p><p>不难发现在这种构造下，最下方的点只能选颜色 $X$ </p><p>于是有下图：</p><p><img src="https://i.loli.net/2021/11/28/OhjP4dcNZMFwrt8.png" alt="卡"></p><p>明显为No</p><p>推广一下，考虑把节点 ${C, D}$ 拆成多个节点相连，换句话说，用多个节点连成的链作为广义的“交叉节点”，我们 <del>玄学的</del> 得出了结论：如果存在两个没有公共边但联通的环，那么答案是No，构造方法类似上图，可以证明（<del>我也不知道咋证</del>）这种情况的充分条件为 $m &gt; n + 1$ </p><p>最后只剩一种情况： $m = n + 1$ 且为偶环</p><p>这种情况下，要么有一个点度数为4，要么有两个点度数为3，度数为四的情况就和上图一样，明显为No</p><p>考虑两个度数为3的点，它们之间必定有3条路径，设路径长度（经过的边数）分别为 $(x, y, z)$ ，<del>手玩一下</del> 发现只有 $(2, 2, 2k), k\in \mathbb{N_+}$ 的情况为Yes</p><hr><p>最后总结一下：</p><ol><li> $m &lt; n$ 为Yes</li><li> $m = n$ 且无奇环为Yes，否则为No</li><li> $m = n + 1$ 且无奇环，若有两个度为3的节点且两点间路径为 $(2, 2, 2k), k\in \mathbb{N_+}$ 则为Yes，否则为No；若有奇环为No</li><li> $m &gt; n + 1$ 为No</li></ol><p>注意以上结论均是在保证图联通的情况下得出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VIT vector<span class="meta-string">&lt;int&gt;</span>::iterator</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, e, v;</span><br><span class="line"><span class="keyword">int</span> c[N], du[N];</span><br><span class="line"><span class="keyword">bool</span> f; <span class="comment">//true-No,false-Yes</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; to[N], cir;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">to[i].<span class="built_in">clear</span>(), c[i] = <span class="number">0</span>;</span><br><span class="line">f = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> _c)</span> <span class="comment">//染色法判奇环</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (f)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span> (c[x])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (c[x] != _c)</span><br><span class="line">f = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">c[x] = _c;</span><br><span class="line">++v;</span><br><span class="line">e += to[x].<span class="built_in">size</span>();</span><br><span class="line">cir.<span class="built_in">push_back</span>(x);</span><br><span class="line"><span class="keyword">for</span> (VIT i = to[x].<span class="built_in">begin</span>(); i != to[x].<span class="built_in">end</span>(); ++i)</span><br><span class="line"><span class="built_in">dfs</span>(*i, <span class="number">3</span> - _c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topu</span><span class="params">()</span> <span class="comment">//拓扑处理非环节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span> (VIT i = cir.<span class="built_in">begin</span>(); i != cir.<span class="built_in">end</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">du[*i] = to[*i].<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (du[*i] == <span class="number">1</span>)</span><br><span class="line">q.<span class="built_in">push</span>(*i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">x = q.<span class="built_in">front</span>(), q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (VIT i = to[x].<span class="built_in">begin</span>(); i != to[x].<span class="built_in">end</span>(); ++i)</span><br><span class="line"><span class="keyword">if</span>(--du[*i] == <span class="number">1</span>)</span><br><span class="line">q.<span class="built_in">push</span>(*i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> T, t, tt;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line"><span class="keyword">while</span> (T--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">to[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">to[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">if</span> (!c[i])</span><br><span class="line">&#123;</span><br><span class="line">e = v = <span class="number">0</span>;</span><br><span class="line">cir.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">dfs</span>(i, <span class="number">1</span>);</span><br><span class="line">e /= <span class="number">2</span>; <span class="comment">//存的是双向边,真正的边数要除以2</span></span><br><span class="line"><span class="keyword">if</span> (e &gt; v + <span class="number">1</span>)</span><br><span class="line">f = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (f)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (e &lt;= v)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">topu</span>();</span><br><span class="line">tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (VIT j = cir.<span class="built_in">begin</span>(); j != cir.<span class="built_in">end</span>(); ++j)</span><br><span class="line"><span class="keyword">if</span> (du[*j] == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (VIT k = to[*j].<span class="built_in">begin</span>(); k != to[*j].<span class="built_in">end</span>(); ++k)</span><br><span class="line"><span class="keyword">if</span> (du[*k] == <span class="number">3</span>)</span><br><span class="line">++t;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="number">2</span>)</span><br><span class="line">++tt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tt &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">f = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (f)</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> luogu </tag>
            
            <tag> 练习 </tag>
            
            <tag> 结论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>luoguP2723 [USACO3.1]丑数 Humble Numbers</title>
      <link href="/2021/11/28/luoguP2723-USACO3-1-%E4%B8%91%E6%95%B0-Humble-Numbers/"/>
      <url>/2021/11/28/luoguP2723-USACO3-1-%E4%B8%91%E6%95%B0-Humble-Numbers/</url>
      
        <content type="html"><![CDATA[<p> 时间复杂度的计算是个技术活</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P2723">丑数</a></p><p>第一次想到的是用一个小根堆，每次取出最小值，乘其它数的积插入堆中，最后取出的第 $n$ 个就是答案，然鹅，时间（ $O(n^2\log n)$ ）和空间（ $O(n^2)$ ）上都不允许（ $n \le 10^5$ 太艹了）</p><p>然后发现其实真正有用的跟新只有 $f[i] * a[i]$ 的形式，其中 $f[i]$ 表示第 $i$ 个丑数， $a[i]$ 表示质数，由于 $k$ 很小，用平衡树维护貌似可做？（<del>黄题啊，平衡树个寂寞啊</del>）</p><p>最后实在 <del>不想打平衡树</del> 想不出来，一看题解：艹，暴力求第 $n$ 个就好了，加个记录的优化，时间复杂度 $O(nk \xi)$ ，其中 $\xi$ 代表玄学因子（因为没人知道那层while会跑多少），空间复杂度 $O(n)$ </p><p>无语，这个故事告诉我们不要一看见 $10^5$ 就想 $n\log n$  </p><p>似乎要long long</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, K = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> LL INF = (LL)<span class="number">1e18</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> k, n;</span><br><span class="line">LL f[N];</span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;k, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"><span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + k);</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//有只有一个质因数的情况,所以从1开始</span></span><br><span class="line">LL mn;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">mn = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里是一个优化(不加会TLE),用b记录每个质数对应的最小的f[i]</span></span><br><span class="line"><span class="comment">下一次的i只会更大而不会更小</span></span><br><span class="line"><span class="comment">当然,也可以写二分查找f[i],时间复杂度更稳定一点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">while</span> (f[b[j]] * a[j] &lt;= f[i - <span class="number">1</span>])</span><br><span class="line">++b[j];</span><br><span class="line">mn = <span class="built_in">min</span>(f[b[j]] * a[j], mn);</span><br><span class="line">&#125;</span><br><span class="line">f[i] = mn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, f[n]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> luogu </tag>
            
            <tag> 练习 </tag>
            
            <tag> USACO </tag>
            
            <tag> 暴力 </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>luoguP2991 [USACO10OPEN]Water Slides G</title>
      <link href="/2021/11/26/luoguP2991-USACO10OPEN-Water-Slides-G/"/>
      <url>/2021/11/26/luoguP2991-USACO10OPEN-Water-Slides-G/</url>
      
        <content type="html"><![CDATA[<p> 题目描述过于“清晰”</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P2991">Water Slides G</a></p><p>最开始理解错了，以为是一个搜索，大概是预处理出每个点到终点的最长路，然后bfs，每个状态由位置、失误次数、权值和组成，不会TLE</p><p>但其实题目要求中失误是走“最坏的”，而不失误是走“最好的”；我理解的失误是走“除最好的以外的节点”（<del>太nm离谱了</del>）</p><p>再看原题，发现只有两种选择（最好的和最坏的），在暴搜的基础上加一个记忆化，令 $f[i][j]$ 表示从 $i$ 走到 $n$ 失误 $j$ 条边的情况下最大权值和，明显有 $f[n][0] = 0$ ， $Ans = f[1][k]$ ，由于是在一个DAG上，在搜索时转移，方程为<br>$$<br>f[u][j] =<br>\begin{cases}<br>    \min(f[v][j - 1] + w_{u,v})\\<br>    \max(f[v][j] + w_{u,v})<br>\end{cases}<br>$$<br>最后，记得开long long</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span> + <span class="number">5</span>, M = <span class="number">1.5e5</span> + <span class="number">5</span>, K = <span class="number">10</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line">LL f[N][K];</span><br><span class="line"><span class="keyword">bool</span> vis[N][K];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ne, ver;</span><br><span class="line">LL w;</span><br><span class="line">&#125; e[M];</span><br><span class="line"><span class="keyword">int</span> h[N], idx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, LL z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx] = (Edge)&#123;h[x], y, z&#125;, h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[x][j])</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="built_in">dp</span>(y, j);</span><br><span class="line">f[x][j] = <span class="built_in">max</span>(f[y][j] + e[i].w, f[x][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="built_in">dp</span>(y, j - <span class="number">1</span>);</span><br><span class="line">f[x][j] = <span class="built_in">min</span>(f[y][j - <span class="number">1</span>] + e[i].w, f[x][j]);</span><br><span class="line">&#125;</span><br><span class="line">vis[x][j] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">h[i] = <span class="number">-1</span>;</span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> u, v;</span><br><span class="line">LL w;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line"><span class="built_in">add</span>(u, v, w);</span><br><span class="line">&#125;</span><br><span class="line">f[n][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">vis[n][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">dp</span>(<span class="number">1</span>, k);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, f[<span class="number">1</span>][k]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> luogu </tag>
            
            <tag> 练习 </tag>
            
            <tag> USACO </tag>
            
            <tag> dp </tag>
            
            <tag> 记忆化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>luoguP5091 【模板】扩展欧拉定理</title>
      <link href="/2021/11/26/luoguP5091-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%89%A9%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/"/>
      <url>/2021/11/26/luoguP5091-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%89%A9%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p> 我太弱了</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P5091">【模板】扩展欧拉定理</a></p><p>本来以为可以秒杀的（<del>毕竟是板子</del>），但遗忘的比我想象的严重，主要是当 $b &lt; \varphi(m)$ 时，不能让 $b = (b \mod \varphi(m)) + \varphi(m)$ 这个特判改了 ${\color{red} \text{三次}}$ </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20000000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a, m, phi, p;</span><br><span class="line"><span class="keyword">char</span> b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">res = (LL)res * x % p;</span><br><span class="line">x = (LL)x * x % p;</span><br><span class="line">y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%s&quot;</span>, &amp;a, &amp;m, b + <span class="number">1</span>);</span><br><span class="line">phi = p = m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j; i &lt;= m; ++i)</span><br><span class="line"><span class="keyword">if</span> (m % i == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">phi = (LL)phi * (i - <span class="number">1</span>) / i;</span><br><span class="line"><span class="keyword">while</span> (m % i == <span class="number">0</span>)</span><br><span class="line">m /= i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">strlen</span>(b + <span class="number">1</span>), bb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">8</span>) <span class="comment">//特判</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">bb = bb * <span class="number">10</span> + b[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (bb &gt;= phi)</span><br><span class="line">bb = bb % phi + phi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">bb = (bb * <span class="number">10</span> + b[i] - <span class="string">&#x27;0&#x27;</span>) % phi;</span><br><span class="line">bb += phi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">qpow</span>(a, bb));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> luogu </tag>
            
            <tag> 练习 </tag>
            
            <tag> 模板 </tag>
            
            <tag> 扩展欧拉定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生成函数</title>
      <link href="/2021/11/24/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
      <url>/2021/11/24/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>too difficult for me</p><span id="more"></span><h1 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>任给我们一个序列 ${ a_i } ( i \in [ 0, n ] )$ ，可以定义一个函数 $g(x) = a_0 + a_1x + a_2x^2 + … + a_nx^n$ （一般为了使函数可以收敛，定义 $x \in ( -1, 1 )$ ），则称 $g(x)$ 为序列 ${ a_i }$ 的生成函数</p><p>我们将序列转化为函数的原因是为了用函数的知识（一般是数学知识，数学不好的慎用）使问题变的简单</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.acwing.com/problem/content/3135/">食物</a></p><p>本题是一个常用的转换，即将乘法原理转化为多项式的乘法，具体如下：</p><p>先将每一种食物当作一个子问题，如，对于食物1 ，定义序列 ${ a_i }$  为只选食物1能够选出 $i$ 个食物的方案数，由于食物以只能选偶数个，故 ${ a_i } = { 1,0,1,0,1…}$ ，定义其生成函数为 $f_1(x) = 1 + x^2 + x^4 + x^6 + … (x \in (-1, 1))$ 由等比数列求和公式有 $f_1(x) = \frac{1 - x^n}{1 - x^2}$ ，又因为 $n \rightarrow \infty$ ，所以 $x^n \rightarrow 0$ ，则 $f_1(x) = \frac{1}{1 - x^2}$ </p><p>同理，有：<br>$$<br>\begin{align}<br>f_2(x) &amp;= 1 + x = \frac{1 - x^2}{1 - x}\\<br>f_3(x) &amp;= 1 + x + x^2 = \frac{1 - x^3}{1 - x}\\<br>f_4(x) &amp;= x + x^3 + x^5 + … = \frac{x}{1 - x^2}\\<br>f_6(x) &amp;= 1 + x^4 + x^8 + … = \frac{1}{1 - x^4}\\<br>f_6(x) &amp;= 1 + x + x^2 + x^3 = \frac{1 - x^4}{1 - x}\\<br>f_7(x) &amp;= 1 + x = \frac{1 - x^2}{1 - x}\\<br>f_8(x) &amp;= 1 + x^3 + x^6 + x^9 = \frac{1}{1 - x^3}\\<br>\end{align}<br>$$<br> 设 $Ans(x) = \prod_{i = 1}^{8} f_i(x)$ ，则答案即为 $Ans(x)$ 展开后 $x^n$ 项的系数，证明可以考虑乘法原理，每一个多项式 $f_i(x)$ 中选一项 $ai_jx^j$ ，代表用第 $i$ 种食物凑成 $j$ 个的方案数有 $ai<br><em>j$ 种，乘起来方案共有 $\prod</em>{i = 1}^{8} ai_j$ 种，这些方案共献到 $x^{\sum j}$ 中，最后 $x^n$ 的系数就是最终方案数，正确性显然</p><p>现在考虑如何求系数<br>$$<br>\begin{align}<br>Ans &amp;= \prod_{i = 1}^{8} f_i(x)\\<br>    &amp;= \frac{1 - x^2}{1 - x} \frac{1 - x^3}{1 - x} \frac{x}{1 - x^2} \frac{1}{1 - x^4} \frac{1 - x^4}{1 - x} \frac{1 - x^2}{1 - x} \frac{1}{1 - x^3}\\<br>    &amp;= \frac{x}{(1 - x)^4}\\<br>    &amp;= x (1 - x)^{-4}\\<br>\text{又由} &amp;\text{牛顿广义二项式定理（广义二项式定理）：}\\<br>(x + y)^\alpha &amp;= \sum_{k = 0}^{\infty} \binom{\alpha}{k} x^{\alpha - k} y^k , \text{其中} \binom{\alpha}{k} = \frac{\alpha (\alpha - 1) (\alpha - 2) … (\alpha - k + 1)}{k!} , (\alpha \in \mathbb{R})\\<br>\text{有：} &amp; \\<br>(1 - x)^{-4} &amp;= \sum_{k = 0}^{\infty} \binom{-4}{k} 1^{-4 - k} (-x)^{k}\\<br>\text{又因} &amp;\binom{-k}{n} * (-x)^n = [(-1)^n * \binom{n+k-1}{n}] * [(-1)^n * x^n] = \binom{n+k-1}{n} x^n\\<br>\text{故} &amp; (1 - x)^4 \text{展开后} x^n \text系数为 \binom{n+k-1}{n}\\<br>\text{所以}\\<br>Ans &amp;= x (1 - x)^{-4}\\<br>    &amp;= x (\sum_{n = 0}^{\infty} \binom{n + 4 - 1}{4 - 1} x^n)\\<br>    &amp;= \sum_{n = 0}^{\infty} \binom{n + 4 - 1}{4 - 1} x^{n + 1}\\<br>\end{align}<br>$$</p><p>由上， $x^n$ 项的系数为 $\binom{n + 2}{3} = \frac{(n + 2)(n + 1)n}{6}$ ，问题得以解决</p><p> 代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500</span>, P = <span class="number">10007</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>, l = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l; ++i)</span><br><span class="line">n = (n * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>) % P;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (LL)n * (n + <span class="number">1</span>) * (n + <span class="number">2</span>) / <span class="number">6</span> % P); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数论,数学 </tag>
            
            <tag> 生成函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斜率优化dp</title>
      <link href="/2021/11/22/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96dp/"/>
      <url>/2021/11/22/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96dp/</url>
      
        <content type="html"><![CDATA[<p>然而我dp废的一比</p><span id="more"></span><p>用例题开讲：<br><a href="https://www.luogu.com.cn/problem/P2365">P2365 任务安排</a><br>明显<del>看题解</del>可知，dp方程为：<br> $f_i=min(f_j+sumt_i*(sumc_i-sumc_j)+s*(sumc_n-sunc_j),f_i)$<br> 故标程如下：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//P2365</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> t, c;</span><br><span class="line">&#125; sum[N];</span><br><span class="line"><span class="keyword">int</span> n, s;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;t, &amp;c);</span><br><span class="line">        sum[i].t = sum[i - <span class="number">1</span>].t + t;</span><br><span class="line">        sum[i].c = sum[i - <span class="number">1</span>].c + c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">            f[i] = <span class="built_in">min</span>(f[i], f[j] + sum[i].t * (sum[i].c - sum[j].c) + s * (sum[n].c - sum[j].c));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，康康这个——<a href="https://www.luogu.com.cn/problem/P5785">P5785 SDOI2012任务安排</a><br>令人惋惜的是，在数据加强后， $O(n^2)$ 的时间复杂度似乎确凿过不了，为此，我们<del>看题解后</del>想到救星——</p><h2 id="斜率优化"><a href="#斜率优化" class="headerlink" title="斜率优化"></a>斜率优化</h2><p>我们先假设所有的 $t$ 都大于0。<br>我们来康康转移方程：<br>$f_i=min(f_j+sumt_i*(sumc_i-sumc_j)+s*(sumc_n-sunc_j),f_i)$<br>不妨去掉 $min$ 看成：<br>$f_i=f_j+sumt_i*(sumc_i-sumc_j)+s*(sumc_n-sunc_j)$<br>它等价于：<br>$f_i=f_j-(sumt_i+s) * sumc_j+sumt_i* sumc_i+s* sumc_n$<br>设 $f_j=y,sumc_j=x$ （这是所有的关于 $j$ 的变量），然后化为直线表达式 $y=kx+b$ 的形式：<br>$f_j=(sumt_i+s)* sumc_j+f_i-sumt_i* sumc_i-s* umc_n$<br>不难发现 ：</p><ol><li><p>$k=sumt_i+s$ ，故 $0&lt;k&lt;\infty$ 。</p></li><li><p>且 $0 \le j \le i-1,j \in Z$  </p></li><li><p>而直线上的点为：$(f_0,sumc_0)$ 、 $(f_1,sumc_1)$ 、 … 、 $(f_{i-1},sunc_{i-1})$ </p></li><li><p>我们的目标是让 $f_i$ 最小  </p></li></ol><p>我们带着目标，看看图像：<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/u8nbza21.png" alt="xoy"><br>对于一个已知的 $i$ ， $k=sumt_i+s$ 是固定的，而若点 $(x_0,y_0)$在 $y=kx+b$ 上，那么截距 $b$ 是可以算出来的，又因 $b=f_i-sumt_i* sumc_i-s* umc_n$ ，故 $b$ 最小时 $f_i$ 最小。<br>那么，我们康康下图：<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/14w4y6tp.png" alt="xoy2"><br>图中绿色的点是所有可能的 $(x_0,y_0)$ ,红色的线是 $y=kx+b$ （只有 $k$ 确定，所以在从下往上平移）。<br>不难发现，凸包（绿线）内部的点对于 $b$ 的最小值毫无意义。换句话说，<strong>最小值的点只会在凸包上</strong>。<br>那么在凸包上哪一点呢？<br>还是上图，令构成凸包的三条直线斜率为 $k_1,k_2,k_3$ ，由凸包性质可得 $k_1&lt;k_2&lt;k_3$ 。再看看上图中我们要找的那个点（不妨设它为点 $A$ ）， $A$ 所在的两条直线斜率为 $k_2,k_3$ ,且 $k_2&lt;k&lt;k_3$ 也就是说，<strong>对于一个给定斜率为的直线 $y=kx+b$ 让它的截距 $b$ 取得最小值的点就是凸包上第一个斜率大于 $k$ 的线段的下端点</strong>。<br>由此，我们想到在单调队列中维护第一个大于某个数的点。<br>我们又发现，因为 $t$ 大于0，所以：<br>斜率是单调递增的，且新加的点的横坐标也单调递增。<br>所以：<br>在查询的时候，可以将队头小于当前斜率的点全删除掉。<br>在插入的时候，可以将队尾所有不在凸包上的点全删除掉。<br>我们便得到以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll t, c;</span><br><span class="line">&#125; sum[N];</span><br><span class="line">ll n, s;</span><br><span class="line">ll f[N];</span><br><span class="line">ll q[N], hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//除法会损失精度，故改成乘法</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_slopeh</span><span class="params">(ll x, ll y, ll o)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (f[y] - sum[y].c * s - f[x] + sum[x].c * s) &lt;= sum[o].t * (sum[y].c - sum[x].c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_slopet</span><span class="params">(ll x, ll y, ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (f[y] - sum[y].c - f[x] + sum[x].c) * (sum[b].c - sum[a].c) &gt;= (f[b] - sum[b].c - f[a] + sum[a].c) * (sum[y].c - sum[x].c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;s);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ll t, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;t, &amp;c);</span><br><span class="line">        sum[i].t = sum[i - <span class="number">1</span>].t + t;</span><br><span class="line">        sum[i].c = sum[i - <span class="number">1</span>].c + c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x7f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">check_slopeh</span>(q[hh], q[hh + <span class="number">1</span>], i))</span><br><span class="line">            hh++;</span><br><span class="line">        ll j = q[hh];</span><br><span class="line">        f[i] = f[j] + sum[i].t * (sum[i].c - sum[j].c) + s * (sum[n].c - sum[j].c);</span><br><span class="line">        <span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">check_slopet</span>(q[tt - <span class="number">1</span>], q[tt], q[tt], i))</span><br><span class="line">            tt--;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是——60分！哦可恶！题目中的 $t$ 可以为负数，咋办？</p><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><p>我们来看看 $t$ 可以为负数的情况：</p><ol><li><p>$k=sumt_i+s$ ，但 $sumt_i$ 可能小于0，故 $ -\infty &lt;k&lt; \infty$ 。</p></li><li><p>$0 \le j \le i-1,j \in Z$  </p></li><li><p>而直线上的点为：$(f_0,sumc_0)$ 、 $(f_1,sumc_1)$ 、 … 、 $(f_{i-1},sunc_{i-1})$ </p></li><li><p>我们的目标是让 $f_i$ 最小 </p></li></ol><p>其实只有 $k$ 的范围变了， $k$ 可以小于0了，所以：<br>斜率不再具有单调性，但新加的点的横坐标仍然单调递增。<br>所以：<br>在查询的时候，只能用二分来查找了。<br>但在插入的时候，仍可以将队尾所有不在凸包上的点全删除掉。<br>终于，正解如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//P5785</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll t, c;</span><br><span class="line">&#125; sum[N];</span><br><span class="line">ll n, s;</span><br><span class="line">ll f[N];</span><br><span class="line">ll q[N], hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//除法会损失精度，故改成乘法</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_slopeh</span><span class="params">(ll x, ll y, ll o)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (f[y] - sum[y].c * s - f[x] + sum[x].c * s) &lt;= sum[o].t * (sum[y].c - sum[x].c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_slopet</span><span class="params">(ll x, ll y, ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (f[y] - sum[y].c - f[x] + sum[x].c) * (sum[b].c - sum[a].c) &gt;= (f[b] - sum[b].c - f[a] + sum[a].c) * (sum[y].c - sum[x].c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">work</span><span class="params">(ll o)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll l = hh, r = tt;</span><br><span class="line">    <span class="keyword">int</span> ans = l;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        ll mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">check_slopeh</span>(q[mid], q[mid + <span class="number">1</span>], o))</span><br><span class="line">            r = mid - <span class="number">1</span>, ans = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q[ans];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;s);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ll t, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;t, &amp;c);</span><br><span class="line">        sum[i].t = sum[i - <span class="number">1</span>].t + t;</span><br><span class="line">        sum[i].c = sum[i - <span class="number">1</span>].c + c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x7f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ll j = <span class="built_in">work</span>(i);</span><br><span class="line">        f[i] = f[j] + sum[i].t * (sum[i].c - sum[j].c) + s * (sum[n].c - sum[j].c);</span><br><span class="line">        <span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">check_slopet</span>(q[tt - <span class="number">1</span>], q[tt], q[tt], i))</span><br><span class="line">            tt--;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 斜率优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树</title>
      <link href="/2021/11/22/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2021/11/22/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>有点久远了，有点丑</p><span id="more"></span><h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>对于一个区间 $[x,y]$  , 我们将其分为两个区间 :  $[x,mid]$ 和 $[mid+1,y]$  , 在对这两个区间进行同样操作 , 直到无法继续 , 如图 :<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/yiorodlt.png" alt="例子"><br>不难发现 , 线段树除去最后一层后 , 一定是一颗满二叉树 , 深度为 $O(\log{}{N})$  。 所以我们用<strong>父子二倍</strong>的节点编号法:</p><ol><li><p> $root=1$ </p></li><li><p> $x$ 的左节点编号为 $x * 2$  ， 右节点编号为 $x * 2+1$ </p></li></ol><p>一个 $N$ 个叶节点线段数最多有 $4N$ 个节点 , 所以数组要开 $4$ 倍 。  </p><h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><ul><li> $sum$ ：当前区间的总和</li><li> $add$ ：懒标记，表示给以当前节点为根的子树中的每一个节点都加上 $add$ 。不难发现，为维护 $add$ ，我们用一个 $push_down()$ 来下传 $add$ 。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ST</span>&#123;</span></span><br><span class="line">ll sum,add;</span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line">&#125;tr[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[u].add)&#123;</span><br><span class="line">tr[u&lt;&lt;<span class="number">1</span>].add+=tr[u].add;</span><br><span class="line">tr[u&lt;&lt;<span class="number">1</span>].sum+=(ll)(tr[u&lt;&lt;<span class="number">1</span>].r-tr[u&lt;&lt;<span class="number">1</span>].l+<span class="number">1</span>)*tr[u].add;</span><br><span class="line">tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].add+=tr[u].add;</span><br><span class="line">tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum+=(ll)(tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].r-tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].l+<span class="number">1</span>)*tr[u].add;</span><br><span class="line">tr[u].add=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">tr[u].sum=tr[u&lt;&lt;<span class="number">1</span>].sum+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tr[u].l=l,tr[u].r=r;</span><br><span class="line">tr[u].sum=a[r];</span><br><span class="line">tr[u].add=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">tr[u].l=l,tr[u].r=r;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">push_up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)&#123;</span><br><span class="line">tr[u].sum+=(ll)(tr[u].r-tr[u].l+<span class="number">1</span>)*d;</span><br><span class="line">tr[u].add+=d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">push_down</span>(u);</span><br><span class="line"><span class="keyword">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>,l,r,d);</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid) <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,d);</span><br><span class="line"><span class="built_in">push_up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line"><span class="built_in">push_down</span>(u);</span><br><span class="line"><span class="keyword">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">ll as=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) as+=<span class="built_in">ask</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid) as+=<span class="built_in">ask</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">return</span> as;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> l,r,d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;d);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,l,r,d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">ask</span>(<span class="number">1</span>,l,r));</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用1——扫描线"><a href="#应用1——扫描线" class="headerlink" title="应用1——扫描线"></a>应用1——扫描线</h2><p><a href="https://www.luogu.com.cn/problem/P5490">P5490 【模板】扫描线</a>  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line">ll n;</span><br><span class="line">vector&lt;ll&gt;ys;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment</span>&#123;</span></span><br><span class="line">ll k;</span><br><span class="line">ll x,yl,yr;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Segment &amp;t) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&lt;t.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ll _x,ll _yl,ll _yr,ll _k)</span></span>&#123;</span><br><span class="line">x=_x;</span><br><span class="line">yl=_yl;</span><br><span class="line">yr=_yr;</span><br><span class="line">k=_k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;seg[N*<span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LineTree</span>&#123;</span></span><br><span class="line">ll l,r;</span><br><span class="line">ll cnt;</span><br><span class="line">ll len;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ll _l,ll _r,ll _cnt,ll _len)</span></span>&#123;</span><br><span class="line">l=_l;</span><br><span class="line">r=_r;</span><br><span class="line">cnt=_cnt;</span><br><span class="line">len=_len;</span><br><span class="line">&#125;</span><br><span class="line">&#125;tr[N*<span class="number">8</span>];</span><br><span class="line"><span class="function">ll <span class="title">find</span><span class="params">(ll y)</span></span>&#123;</span><br><span class="line"><span class="comment">//lower_bound()函数用于在指定区域内查找不小于目标值的第一个元素。</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">lower_bound</span>(ys.<span class="built_in">begin</span>(),ys.<span class="built_in">end</span>(),y)-ys.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(ll u)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[u].cnt) tr[u].len=ys[tr[u].r+<span class="number">1</span>]-ys[tr[u].l];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(tr[u].l!=tr[u].r)</span><br><span class="line">tr[u].len=tr[u&lt;&lt;<span class="number">1</span>].len+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].len;</span><br><span class="line"><span class="keyword">else</span> tr[u].len=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll u,ll l,ll r)</span></span>&#123;</span><br><span class="line">tr[u].<span class="built_in">init</span>(l,r,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(l!=r)&#123;</span><br><span class="line">ll mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(ll u,ll l,ll r,ll k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)&#123;</span><br><span class="line">tr[u].cnt+=k;</span><br><span class="line"><span class="built_in">push_up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">ll mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid) <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">        <span class="built_in">push_up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">ys.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">ll xr,xl,yr,yl;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld&quot;</span>,&amp;xl,&amp;yl,&amp;xr,&amp;yr);</span><br><span class="line">seg[j++].<span class="built_in">init</span>(xl,yl,yr,<span class="number">1</span>);</span><br><span class="line">seg[j++].<span class="built_in">init</span>(xr,yl,yr,<span class="number">-1</span>);</span><br><span class="line">ys.<span class="built_in">push_back</span>(yl),ys.<span class="built_in">push_back</span>(yr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(ys.<span class="built_in">begin</span>(),ys.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//unique函数功能是去除相邻的重复元素</span></span><br><span class="line"><span class="comment">//它并不真正把重复的元素删除,而是将无重复的元素复制到序列的前段,</span></span><br><span class="line"><span class="comment">//从而覆盖相邻的重复元素.unique返回的迭代器指向超出无重复的元素范围末端的下一个位置.</span></span><br><span class="line"><span class="comment">//erase:删除</span></span><br><span class="line">ys.<span class="built_in">erase</span>(<span class="built_in">unique</span>(ys.<span class="built_in">begin</span>(),ys.<span class="built_in">end</span>()),ys.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">0</span>,ys.<span class="built_in">size</span>()<span class="number">-2</span>);</span><br><span class="line"><span class="built_in">sort</span>(seg,seg+n*<span class="number">2</span>);</span><br><span class="line">ll res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n*<span class="number">2</span>;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;<span class="number">0</span>) res+=tr[<span class="number">1</span>].len*(seg[i].x-seg[i<span class="number">-1</span>].x);</span><br><span class="line"><span class="built_in">modify</span>(<span class="number">1</span>,<span class="built_in">find</span>(seg[i].yl),<span class="built_in">find</span>(seg[i].yr)<span class="number">-1</span>,seg[i].k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>以下是一个维护最值的线段树的修改操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//单点修改,将[x,x]的值改为z</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l[p]==r[p]) dmax[p]=z,<span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> mid=(l[p]+r[p])&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) <span class="built_in">Modify</span>(p&lt;&lt;<span class="number">1</span>,x,z);</span><br><span class="line"><span class="keyword">if</span>(y&gt;mid) <span class="built_in">Modify</span>(p&lt;&lt;|<span class="number">1</span>,x,z);</span><br><span class="line"><span class="comment">//从下往上跟新信息,也叫push_up </span></span><br><span class="line">dmax[p]=<span class="built_in">max</span>(dmax[p&lt;&lt;<span class="number">1</span>],dmax[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125; </span><br><span class="line">   <span class="comment">//调用入口: st.Modify(1,x,z);</span></span><br></pre></td></tr></table></figure><p>以下是一个维护区间和的线段树，支持区间增加，区间乘法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//洛谷P3373 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[N],mod;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ST</span>&#123;</span><span class="comment">//SegmentTree</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dat[N*<span class="number">4</span>];<span class="comment">//维护区间和</span></span><br><span class="line"><span class="keyword">int</span> l[N*<span class="number">4</span>],r[N*<span class="number">4</span>];<span class="comment">//区间 </span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> add[N*<span class="number">4</span>],mul[N*<span class="number">4</span>];<span class="comment">//懒惰标记(lazytag) </span></span><br><span class="line"><span class="comment">//建立区间ll-rr,编号为p </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> ll,<span class="keyword">int</span> rr)</span></span>&#123;</span><br><span class="line"><span class="comment">//初始化lazytag </span></span><br><span class="line">add[p]=<span class="number">0</span>;</span><br><span class="line">mul[p]=<span class="number">1</span>; </span><br><span class="line">l[p]=ll;r[p]=rr;<span class="comment">//以p为编号的节点维护的区间为ll到rr</span></span><br><span class="line"><span class="comment">//ll==rr的话,这个区间就只有一个数,直接让区间维护的值等于a[ll]</span></span><br><span class="line"><span class="keyword">if</span>(ll==rr)</span><br><span class="line">dat[p]=a[ll];</span><br><span class="line"><span class="comment">//否则维护的值等于左儿子加右儿子</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(ll+rr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">Build</span>(p&lt;&lt;<span class="number">1</span>,ll,mid);</span><br><span class="line"><span class="built_in">Build</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,rr);</span><br><span class="line">dat[p]=dat[p&lt;&lt;<span class="number">1</span>]+dat[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];<span class="comment">//当然,具体的维护视题目而定</span></span><br><span class="line">&#125;</span><br><span class="line">dat[p]%=mod; </span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//懒惰标记,规定乘法优先</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Spread</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="comment">//如果懒标记不为0,就将其下传,修改左右儿子维护的值 </span></span><br><span class="line"><span class="keyword">if</span>(add[p]!=<span class="number">0</span>||mul[p]!=<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//根据我们规定的优先度,儿子的值=</span></span><br><span class="line"><span class="comment">//此刻儿子的值*爸爸的乘法lazytag+</span></span><br><span class="line"><span class="comment">//儿子的区间长度*爸爸的加法lazytag</span></span><br><span class="line">dat[p&lt;&lt;<span class="number">1</span>]=(dat[p&lt;&lt;<span class="number">1</span>]*mul[p]+add[p]*(r[p&lt;&lt;<span class="number">1</span>]-l[p&lt;&lt;<span class="number">1</span>]+<span class="number">1</span>))%mod;</span><br><span class="line">dat[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(dat[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]*mul[p]+add[p]*(r[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]-l[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1</span>))%mod;</span><br><span class="line"><span class="comment">//为该节点的左右儿子打上标记,</span></span><br><span class="line">mul[p&lt;&lt;<span class="number">1</span>]=(mul[p&lt;&lt;<span class="number">1</span>]*mul[p])%mod;</span><br><span class="line">mul[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(mul[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]*mul[p])%mod; </span><br><span class="line"><span class="comment">//由于乘法优先,加法打标记时要先乘一下 </span></span><br><span class="line">add[p&lt;&lt;<span class="number">1</span>]=(add[p&lt;&lt;<span class="number">1</span>]*mul[p]+add[p])%mod;</span><br><span class="line">add[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(add[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]*mul[p]+add[p])%mod;</span><br><span class="line"><span class="comment">//下传之后将父节点的懒标记清0</span></span><br><span class="line">mul[p]=<span class="number">1</span>;</span><br><span class="line">add[p]=<span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//区间修改,将区间[x,y]都加上z </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Change_add</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=l[p]&amp;&amp;y&gt;=r[p])&#123;<span class="comment">//被覆盖的话,就对其进行修改</span></span><br><span class="line">dat[p]+=(<span class="keyword">long</span> <span class="keyword">long</span>)z*(r[p]-l[p]+<span class="number">1</span>);</span><br><span class="line">dat[p]%=mod;</span><br><span class="line">add[p]=(add[p]+z)%mod;<span class="comment">//打上懒标记</span></span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果没有被覆盖,就继续向下找,但儿子所维护的区间可能因为</span></span><br><span class="line"><span class="comment">//懒标记的存在而没有修改,因此将懒标记下放</span></span><br><span class="line"><span class="built_in">Spread</span>(p);</span><br><span class="line"><span class="keyword">int</span> mid=(l[p]+r[p])&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) <span class="built_in">Change_add</span>(p&lt;&lt;<span class="number">1</span>,x,y,z);<span class="comment">//如果要修改的区间覆盖了左儿子</span></span><br><span class="line"><span class="keyword">if</span>(y&gt;mid) <span class="built_in">Change_add</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,y,z);<span class="comment">//右儿子同理</span></span><br><span class="line"><span class="comment">//维护值</span></span><br><span class="line">dat[p]=(dat[p&lt;&lt;<span class="number">1</span>]+dat[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])%mod;</span><br><span class="line"><span class="keyword">return</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//区间修改,将区间[x,y]都乘上z</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Change_mul</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=l[p]&amp;&amp;y&gt;=r[p])&#123;</span><br><span class="line">dat[p]=(dat[p]*z)%mod;</span><br><span class="line">mul[p]=(mul[p]*z)%mod;</span><br><span class="line"><span class="comment">//乘法优先,故加法标记也要乘</span></span><br><span class="line">add[p]=(add[p]*z)%mod;</span><br><span class="line"><span class="keyword">return</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//否则同加法,向下找</span></span><br><span class="line"><span class="built_in">Spread</span>(p);</span><br><span class="line"><span class="keyword">int</span> mid=(l[p]+r[p])&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) <span class="built_in">Change_mul</span>(p&lt;&lt;<span class="number">1</span>,x,y,z);</span><br><span class="line"><span class="keyword">if</span>(y&gt;mid) <span class="built_in">Change_mul</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,y,z);</span><br><span class="line">dat[p]=(dat[p&lt;&lt;<span class="number">1</span>]+dat[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])%mod;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//区间查询,查询[x,y]的和 </span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=l[p]&amp;&amp;y&gt;=r[p]) <span class="keyword">return</span> dat[p];<span class="comment">//如果被覆盖，就返回维护的值</span></span><br><span class="line"><span class="comment">//下传懒标记，并查询左右儿子</span></span><br><span class="line"><span class="built_in">Spread</span>(p);</span><br><span class="line"><span class="keyword">int</span> mid=(l[p]+r[p])&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) ans=(ans+<span class="built_in">Ask</span>(p&lt;&lt;<span class="number">1</span>,x,y))%mod;</span><br><span class="line"><span class="keyword">if</span>(y&gt;mid) ans=(ans+<span class="built_in">Ask</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,y));</span><br><span class="line"><span class="keyword">return</span> ans%mod;</span><br><span class="line">&#125; </span><br><span class="line">&#125;st;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;mod);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">st.<span class="built_in">Build</span>(<span class="number">1</span>,<span class="number">1</span>,n); </span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="keyword">int</span> q,x,y,z;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line"><span class="keyword">if</span>(q==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">st.<span class="built_in">Change_mul</span>(<span class="number">1</span>,x,y,z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(q==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">st.<span class="built_in">Change_add</span>(<span class="number">1</span>,x,y,z);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,st.<span class="built_in">Ask</span>(<span class="number">1</span>,x,y));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注：打线段树的时候一定要注意两端取等 </span></span><br><span class="line"><span class="comment">//如51行两端取等，61、62行单边取等 </span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络流</title>
      <link href="/2021/11/22/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
      <url>/2021/11/22/%E7%BD%91%E7%BB%9C%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<p>老有用了</p><span id="more"></span><h2 id="网络流的基本概念："><a href="#网络流的基本概念：" class="headerlink" title="网络流的基本概念："></a>网络流的基本概念：</h2><p>一个有向图 $G=(V,E)$ ，每条有向边 $(x,y)$ 都有一个给定的<strong>容量</strong>记为 $c(x,y)$ （若 $c(x,y)=0$ ，就说明不存在边 $(x,y)$ ），图中还有两个特殊节点<strong>源点</strong>、<strong>汇点</strong>分别记为 $S$ 、 $T$ 。 $S$ 会源源不断地流出无穷的水流，但每条边只能通过 $c(x,y)$ 的水流， $T$ 可以容纳无穷的水流，而其余个点无法容纳水流（即流入就必须全部流出）。<br>任意一种满足条件的流水方法（即让水流从 $S$ 流到 $T$ ）叫做<strong>流函数</strong>，记为 $f(x,y)$ （表示从点 $x$ 流向 $y$ 的水流），明显，流函数具有如下性质：</p><ul><li><p>$0 \le f(x,y) \le c(x,y)$</p></li><li><p>$f(x,y)=-f(y,x)$ （即从 $x$ 流向 $y$ 的流量也就是从 $y$ 流向 $x$ 的流量的相反数）</p></li><li><p>$\forall x \ne S,T, \sum\limits_{u,x\in     E}^{}f(u,x)= \sum\limits_{x,v\in     E}^{}f(x,v)$ （即除 $S$ ， $T$ 外其余点流入流量等于流出流量，流量守恒）</p></li></ul><h2 id="残量网络"><a href="#残量网络" class="headerlink" title="残量网络"></a>残量网络</h2><p>对于任意合法的流函数 $f$ ，都可构建一个新图 $G2$ （其实应该记做 $G’$ 但这里为了方便记为 $G2$ ），构建方法如下：</p><ol><li>将原图每条边容量变为 $c(x,y)-f(x,y)$ （即减掉已经用掉的流量）</li><li>对于每条边 $(x,y)$ ，创建它的反向边 $(y,x)$ 并令 $c(y,x)=f(x,y)$ （即以流的流量让它可以反悔再流回来）</li></ol><p>该图G2被我们叫做<strong>残量网络</strong><br>需要注意的是,反向边是我们新加的,原图中并不存在,若原图中本就有边 $(x,y)$ 和边 $(y,x)$ （即原图就有反向边），应在构建原图 $G$ 时就新建一点 $z$ ，使得 $(y,x)$ 变为 $(y,z)$ ， $(z,x)$ 。<br>如图（画的丑求你憋着吧！）<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/2fzwiq9k.png" alt="输入"><br> $\uparrow$ 这是输入的有向图。<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/qp8a10w5.png" alt="G"><br> $\uparrow$ 这是去掉反向边的原图 $G$ 。<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/eri7qydk.png" alt="f"><br> $\uparrow$ 这是一个合法的流函数，图中绿色代表 $f(x,y)$ 。<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/pq7ur9ym.png" alt="G2"><br> $\uparrow$ 这是该流函数的残量网络，蓝色为原图边容量（已改变），紫色为加入的反向边。</p><h2 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h2><p>给定一个网络 $G$ ,对于所有合法的 $f$ ,从 $S$ 流出的流量最大的记为该网络的最大流，如上图中最大流为 $7$ （即是绿色的流函数）<br>最大流的求法很多,但基本思路大体相同：</p><ol><li><p>先找到任意的一个流函数 $f$ ，并构建它的残量网络 $G2$ </p></li><li><p>在 $G2$ 中寻找 $G2$ 的合法流函数（我们一般记其为 $f’$ ，文中称其为 $f2$ ， $f2$ 也叫做<strong>增广路</strong>）</p></li><li><p>将找到的增广路加上原图的流函数构成新的流函（即 $f_{now}=f+f2$ 并将 $G2$ 更新成为 $f_{now}$ 的残量网络）</p></li><li><p>重复第 $2$ ， $3$ 步直到无增广路，此时的 $f$ 即是最大流</p></li></ol><p>该思路的证明比较简单，想了解的可以自己百度，下面放两种算法（都已通过<a href="https://www.luogu.com.cn/problem/P3376">P3376</a>）：</p><h3 id="一-Edmonds-Karp-EK算法"><a href="#一-Edmonds-Karp-EK算法" class="headerlink" title="一.Edmonds-Karp(EK算法)"></a>一.Edmonds-Karp(EK算法)</h3><p>该算法就是以上思路的直接实现，（未优化版）几乎不会用，仅了解即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Edmonds-Karp    O(nm^2)</span></span><br><span class="line"><span class="comment">//n+m = 10^3~10^4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000</span>+<span class="number">5</span>,M=<span class="number">20000</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,S,T;</span><br><span class="line"><span class="keyword">int</span> q[N],incf[N],pre[N];<span class="comment">//q队列,incf残留网络流量,pre前驱边 </span></span><br><span class="line"><span class="keyword">bool</span> vis[N]; </span><br><span class="line"><span class="keyword">int</span> h[N],e[M],f[M],ne[M],idx=<span class="number">0</span>;<span class="comment">//e目标编号,f该边流量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> c)</span></span>&#123;<span class="comment">//使用成对储存的技巧i^1及是i的反向边,不懂的请看第二大部分</span></span><br><span class="line">e[idx]=y,f[idx]=c;</span><br><span class="line">ne[idx]=h[x],h[x]=idx++;</span><br><span class="line"></span><br><span class="line">e[idx]=x,f[idx]=<span class="number">0</span>;</span><br><span class="line">ne[idx]=h[y],h[y]=idx++;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;<span class="comment">//寻找增广路 </span></span><br><span class="line"><span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">q[<span class="number">0</span>]=S,vis[S]=<span class="literal">true</span>,incf[S]=INF;<span class="comment">//初始化,把S的出流量定为无穷大 </span></span><br><span class="line"><span class="keyword">while</span>(hh&lt;=tt)&#123;</span><br><span class="line"><span class="keyword">int</span> t=q[hh++];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i])&#123;</span><br><span class="line"><span class="keyword">int</span> ver=e[i];</span><br><span class="line"><span class="keyword">if</span>(!vis[ver]&amp;&amp;f[i])&#123;<span class="comment">//未到过且还有流量 </span></span><br><span class="line">vis[ver]=<span class="literal">true</span>;</span><br><span class="line">incf[ver]=<span class="built_in">min</span>(incf[t],f[i]);<span class="comment">//最大流量为各边流量最小值 </span></span><br><span class="line">pre[ver]=i;<span class="comment">//记录前驱边 </span></span><br><span class="line"><span class="keyword">if</span>(ver==T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">q[++tt]=ver;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">EK</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> maxflow=<span class="number">0</span>;<span class="comment">//这里仅是本人习惯开了long long</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;<span class="comment">//若存在增广路 </span></span><br><span class="line">maxflow+=incf[T]; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=T;i!=S;i=e[pre[i]^<span class="number">1</span>])&#123;<span class="comment">//pre[i]为前驱边-&gt;pre[i]^1为前驱边的反向边 </span></span><br><span class="line">                                                        <span class="comment">//-&gt;e[pre[i]^]为该反向边的目标点,即是前一个点</span></span><br><span class="line"><span class="comment">//更改残留网络 </span></span><br><span class="line">f[pre[i]]-=incf[T];</span><br><span class="line">f[pre[i]^<span class="number">1</span>]+=incf[T];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;S,&amp;T);</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line"><span class="keyword">int</span> x,y,c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;c);</span><br><span class="line"><span class="built_in">add</span>(x,y,c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld&quot;</span>,<span class="built_in">EK</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二-Di-nic算法"><a href="#二-Di-nic算法" class="headerlink" title="二.Di#nic算法"></a>二.Di#nic算法</h3><p>通过构建<strong>分层图</strong>来使增广时一次性增广多条增广路,是以上思路的优化,本人较为偏爱该算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dinic   O(n^2m)</span></span><br><span class="line"><span class="comment">//n+m = 10^4~10^5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll; </span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1000</span>+<span class="number">5</span>,M=<span class="number">20000</span>+<span class="number">5</span>;<span class="comment">//有方向边M要开2倍 </span></span><br><span class="line"><span class="keyword">const</span> ll INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">ll n,m,S,T;</span><br><span class="line">ll q[N],d[N],cur[N];<span class="comment">//q队列,d高度,cur当前弧优化 </span></span><br><span class="line">ll h[N],e[M],f[M],ne[M],idx=<span class="number">0</span>;<span class="comment">//h,e,ne,idx邻接表,f流量 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll x,ll y,ll c)</span></span>&#123; </span><br><span class="line">e[idx]=y,f[idx]=c;</span><br><span class="line">ne[idx]=h[x],h[x]=idx++;</span><br><span class="line"></span><br><span class="line">e[idx]=x,f[idx]=<span class="number">0</span>;</span><br><span class="line">ne[idx]=h[y],h[y]=idx++;</span><br><span class="line"><span class="keyword">return</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;<span class="comment">//寻找有无增广路并建立分层图 </span></span><br><span class="line">ll hh=<span class="number">0</span>,tt=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">q[<span class="number">0</span>]=S,d[S]=<span class="number">0</span>,cur[S]=h[S]; <span class="comment">//S初始高度为0,当前弧初始为第一条出边 </span></span><br><span class="line"><span class="keyword">while</span>(hh&lt;=tt)&#123;</span><br><span class="line">ll t=q[hh++];</span><br><span class="line"><span class="keyword">for</span>(ll i=h[t];i!=<span class="number">-1</span>;i=ne[i])&#123;</span><br><span class="line">ll ver=e[i];</span><br><span class="line"><span class="keyword">if</span>(d[ver]==<span class="number">-1</span> &amp;&amp;f[i])&#123;<span class="comment">//一定要判断容量大于0 </span></span><br><span class="line">d[ver]=d[t]+<span class="number">1</span>;<span class="comment">//层数 </span></span><br><span class="line">cur[ver]=h[ver];<span class="comment">//当前弧初始为第一条出边 </span></span><br><span class="line"><span class="keyword">if</span>(ver==T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">q[++tt]=ver;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">find</span><span class="params">(ll u,ll limit)</span></span>&#123;<span class="comment">//找到增广路,find(u,limit)表示从点u开始,</span></span><br><span class="line"><span class="comment">//从S到u的最大容量为limit </span></span><br><span class="line"><span class="keyword">if</span>(u==T) <span class="keyword">return</span> limit;</span><br><span class="line">ll flow=<span class="number">0</span>;<span class="comment">//flow表示从u向T流的最大流量 </span></span><br><span class="line"><span class="keyword">for</span>(ll i=cur[u];i!=<span class="number">-1</span>&amp;&amp;flow&lt;limit;i=ne[i])&#123;<span class="comment">//从未满的路径开始搜</span></span><br><span class="line"><span class="comment">//flow&lt;limit是很重要的优化! </span></span><br><span class="line">cur[u]=i;<span class="comment">//当前弧优化,搜到i就意味着i前的边已用完,将当前弧更新 </span></span><br><span class="line">ll ver=e[i];</span><br><span class="line"><span class="keyword">if</span>(d[ver]==d[u]+<span class="number">1</span>&amp;&amp;f[i])&#123;<span class="comment">//保证当前点在上一点的下一层,同样要注意f&gt;0 </span></span><br><span class="line">ll t=<span class="built_in">find</span>(ver,<span class="built_in">min</span>(f[i],limit-flow));</span><br><span class="line"><span class="keyword">if</span>(!t) d[ver]=<span class="number">-1</span>;<span class="comment">//若t到终点无增广路径,就删去点ver(把ver高度定为-1) </span></span><br><span class="line"></span><br><span class="line">f[i]-=t;</span><br><span class="line">f[i^<span class="number">1</span>]+=t;</span><br><span class="line">flow+=t; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">ll maxflow=<span class="number">0</span>,flow;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">bfs</span>())<span class="comment">//若存在增广路 </span></span><br><span class="line"><span class="keyword">while</span>(flow=<span class="built_in">find</span>(S,INF)) <span class="comment">//找出当前图上所有增广路 </span></span><br><span class="line">maxflow+=flow;</span><br><span class="line"><span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld&quot;</span>,&amp;n,&amp;m,&amp;S,&amp;T);</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">ll x,y,c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;x,&amp;y,&amp;c);</span><br><span class="line"><span class="built_in">add</span>(x,y,c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="built_in">Dinic</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="无源汇上下界可行流"><a href="#无源汇上下界可行流" class="headerlink" title="无源汇上下界可行流"></a>无源汇上下界可行流</h2><p>在这类问题中不在仅存在容量上界 $c$ ，还存在下界（不妨记为 $l$ ），并且不存在 $S$ ， $T$ 两点。<br>对于此类问题，我们可以用如下操作变为网络最大流：</p><ol><li><p>新建源点和汇点</p></li><li><p>为满足性质1（忘了的上去看），将 $c$ 变为 $c-l$ ，即原来 $(x,y) \le f(x,y) \le c(x,y)$ 变为 $0 \le f(x,y) \le c(x,y)-l(x,y)$ </p></li><li><p>经过第2步后我们发现流量不守恒，故用一个数组 $ve$ （Virtual Edge）储存每个点的流量变化量，即对于边 $(x,y)$ ，经第2步变化后， $x$ 的出流量少了 $l(x,y)$ ， $y$ 的入流量少了 $l(x,y)$ ，故 $ve(x)-=l(x,y)$ ， $ve(y)+=l(x,y)$ </p></li><li><p>利用第3步统计的 $ve$ 数组，新建虚拟边使流量守恒，即若 $ve(x)&gt;0$ ，新建边 $(S,x)$ 并令 $c(S,x)=ve(x)$ ；若 $ve(x)&lt;0$ ，新建边 $(x,T)$ 并令 $c(x,T)=-ve(x)$ ；</p></li><li><p>跑一遍 $S$ 到 $T$ 的最大流，若 $S$ （或 $T$ ）的所有边都可以流满，就说明存在可行流</p></li></ol><p>经过如上操作，就将其变为一个基本的最大流问题，我们把这样建成的图称作虚拟图（仅是本人习惯），记为 $G3$ 。</p><h2 id="有源汇上下界可行流"><a href="#有源汇上下界可行流" class="headerlink" title="有源汇上下界可行流"></a>有源汇上下界可行流</h2><p>终于步入正题了<br>此类问题相比于上一类区别在于原题中就存在源点和汇点（为以示区别记为 $s$ 、 $t$ ）。<br>而解决方式与上类问题类似，区别仅在于我们要将点 $s$ 、 $t$ 这两个不满足流量守恒的点变为普通点，再用新建的 $S$ 、 $T$ 当为源点。<br>而使其守恒的方式即是新建一条边 $(t,s)$ 并令<br> $c(t,s)= \infty$ （正无穷）。</p><h2 id="有源汇上下界最大流"><a href="#有源汇上下界最大流" class="headerlink" title="有源汇上下界最大流"></a>有源汇上下界最大流</h2><p>好，现在问题来了，我们求解可行流时就是求的 $G3$ 的最大流，那么如果我们现在要求原图 $G$ 的可行流中的最大流我们该怎么办？<br>仔细思考，发现我们还有一个图没用——原图的残量网络 $G2$ ！辣么，我们可否使用这三个图求出答案呢？<br>当然是可以的，<del>不然我讲个屁啊</del>，而方法如下： </p><ol><li>同上类问题跑出 $G3$ 的最大流记为 $flow3$ ，并将此时原图中的流函数记为 $f3$ 。</li><li>构建原图 $G$ 关于 $f3$ 的残量网络 $G2$ ，求出 $G2$ 中的曾广路，我们发现这就等价于求出 $G$ 的最大流 $flow$ （注意此时用的是原图 $G$ ，故应删去边 $(t,s)$ ）</li><li>最后答案即是 $flow+flow3$ </li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有 $n$ 天， $m$ 位少女，至少为她们每人拍 $G(i)$ 张照片，每天总的最多拍 $D(i)$ 张，且每天只能为特定的少女拍照，张数为 $x \in [L,R]$ 。</p><h3 id="建立模型"><a href="#建立模型" class="headerlink" title="建立模型"></a>建立模型</h3><p>我们可以很轻松的<del>由题目标题</del>得出应使用网络流，并在稍微，<del>指3天</del>，思考后得出如下方法：</p><ul><li>建立原图 $G$ ：<ol><li>建立源点 $s=1$ ，汇点 $t=m+n+2$ ，并将少女建为点 $2 \sim  m+1$ ，天数建为点 $m+2 \sim n+m+1$ </li><li>将少女至少要拍的照片数 $G(i)$ 定为下界，无穷大定为上界，让少女 $x$ 与源点 $s$ 相连，即建立边 $(s,x)$ （ $x \in [2,m+1]$ ）并使 $c(s,x)=\infty -G(i)$ </li><li>将每天的最大拍照量定为上界， $0$ 为下界，让天数 $y$ 与汇点 $t$ 相连，即建边 $(y,t)$ （ $y \in [m+2,m+n+1]$ ）并使 $c(y,t)=D(i)-0$ </li><li>将少女与天相连，定上下界为 $[L,R]$ ，即建边 $(x,y)$ （ $x \in [2,m+1],y \in [m+2,m+n+1]$ ）并使 $c(x,y)=R-L$ </li><li>在构建原图的同时维护 $ve$ 数组</li></ol></li><li>构建虚拟图 $G3$ ：<ol><li>建立源点 $S=0$ ， $T=n+m+3$ </li><li>用 $ve$ 数组建立连接 $S$ ， $T$ 与其他点的边</li><li>增加边 $(t,s)$ ，并使 $c(t,s)=\infty$ </li><li>并同时维护 $outflow$ （记录从S流出的流量,用于判定是否满流）</li></ol></li><li>求解 $G3$ 的最大流<ol><li>直接用Dinic求解</li><li>判断 $Dinic()$ 是否等于 $outflow$ ，若不等，则说明原图无可行流（原题无解）</li><li>若相等，用 $res$ 记录此时 $s$ 到 $t$ 的流量，并进入下一步</li></ol></li><li>求解 $G$ 的最大流（即是 $G2$ 中的曾广路）<ol><li>删去边 $(t,s)$ </li><li>使 $S=s$ ， $T=t$ （即将 $G3$ 变为 $G$ ）</li><li>Dinic求解最大流，答案即为 $Dinic()+res$ </li></ol></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000000</span>+<span class="number">5</span>,M=<span class="number">1000000</span>+<span class="number">5</span>,INF=<span class="number">2147483647</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;<span class="comment">//如题意 </span></span><br><span class="line"><span class="keyword">int</span> nn,s,t,S,T;<span class="comment">//nn:原图中的点数,s:原图的源点,S虚拟图的源点,t,T同理 </span></span><br><span class="line"><span class="keyword">int</span> q[N],d[N],cur[N],ve[N];<span class="comment">//q:队列,d:高度,cur:当前弧优化,ve(Virtual Edge):虚拟边 </span></span><br><span class="line"><span class="keyword">int</span> h[N],e[N],f[N],ne[N],idx=<span class="number">0</span>;<span class="comment">//h,e,ne,idx:邻接表,f:流量 </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">e[idx]=y,f[idx]=c,ne[idx]=h[x],h[x]=idx++;</span><br><span class="line">e[idx]=x,f[idx]=<span class="number">0</span>,ne[idx]=h[y],h[y]=idx++;<span class="comment">//使用成对储存的技巧 </span></span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&lt;b? a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;<span class="comment">//寻找有无增广路并建立分层图 </span></span><br><span class="line"><span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">q[hh]=S,d[S]=<span class="number">0</span>,cur[S]=h[S];<span class="comment">//S初始高度为0,当前弧初始为第一条出边 </span></span><br><span class="line"><span class="keyword">while</span>(hh&lt;=tt)&#123;</span><br><span class="line"><span class="keyword">int</span> p=q[hh++];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[p];i!=<span class="number">-1</span>;i=ne[i])&#123;</span><br><span class="line"><span class="keyword">int</span> ver=e[i];</span><br><span class="line"><span class="keyword">if</span>(d[ver]==<span class="number">-1</span>&amp;&amp;f[i])&#123;<span class="comment">//一定要判断容量大于0 </span></span><br><span class="line">d[ver]=d[p]+<span class="number">1</span>;<span class="comment">//层数  </span></span><br><span class="line">cur[ver]=h[ver];<span class="comment">//当前弧初始为第一条出边 </span></span><br><span class="line"><span class="keyword">if</span>(ver==T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">q[++tt]=ver;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> limit)</span></span>&#123;<span class="comment">//找到增广路,find(u,limit)表示从点u开始,</span></span><br><span class="line"><span class="comment">//从S到u的最大容量为limit </span></span><br><span class="line"><span class="keyword">if</span>(u==T) <span class="keyword">return</span> limit;</span><br><span class="line"><span class="keyword">int</span> nowflow=<span class="number">0</span>;<span class="comment">//nowflow表示从u向T流的最大流量 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=cur[u];i!=<span class="number">-1</span>&amp;&amp;nowflow&lt;limit;i=ne[i])&#123;<span class="comment">//从未满的路径开始搜</span></span><br><span class="line"><span class="comment">//nowflow&lt;limit是很重要的优化! </span></span><br><span class="line">cur[u]=i;<span class="comment">//当前弧优化,搜到i就意味着i前的边已用完,将当前弧更新 </span></span><br><span class="line"><span class="keyword">int</span> ver=e[i];</span><br><span class="line"><span class="keyword">if</span>(d[ver]==d[u]+<span class="number">1</span>&amp;&amp;f[i])&#123;<span class="comment">//保证当前点在上一点的下一层,同样要注意f&gt;0 </span></span><br><span class="line"><span class="keyword">int</span> tflow=<span class="built_in">find</span>(ver,<span class="built_in">min</span>(f[i],limit-nowflow));</span><br><span class="line"><span class="keyword">if</span>(!tflow) d[ver]=<span class="number">-1</span>;<span class="comment">//若t到终点无增广路径,就删去点ver(把ver高度定为-1) </span></span><br><span class="line">f[i]-=tflow,f[i^<span class="number">1</span>]+=tflow,nowflow+=tflow;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nowflow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> maxflow=<span class="number">0</span>,inflow;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">bfs</span>())<span class="comment">//若存在增广路 </span></span><br><span class="line"><span class="keyword">while</span>(inflow=<span class="built_in">find</span>(S,INF))  maxflow+=inflow;<span class="comment">//找出当前图上所有增广路 </span></span><br><span class="line"><span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m))&#123;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="built_in">memset</span>(ve,<span class="number">0</span>,<span class="keyword">sizeof</span> ve);</span><br><span class="line"><span class="comment">//构建原图 </span></span><br><span class="line">s=<span class="number">1</span>,t=n+m+<span class="number">2</span>;<span class="comment">//原图中s=1为源点,t=n+m+2为汇点 </span></span><br><span class="line">nn=n+m+<span class="number">2</span>;<span class="comment">//nn:原图的点数 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m+<span class="number">1</span>;++i)&#123;<span class="comment">//将少女编号为2~m+1,并和源点连通 </span></span><br><span class="line"><span class="keyword">int</span> G;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;G);</span><br><span class="line"><span class="built_in">add</span>(s,i,INF-G);</span><br><span class="line">ve[i]+=G;</span><br><span class="line">ve[s]-=G;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=m+<span class="number">2</span>;i&lt;=m+n+<span class="number">1</span>;++i)&#123;<span class="comment">//将天数编号为m+2~m+n+1,并和汇点连通 </span></span><br><span class="line"><span class="keyword">int</span> C,D;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;C,&amp;D);</span><br><span class="line"><span class="built_in">add</span>(i,t,D);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=C;++j)&#123;<span class="comment">//将天与少女连通 </span></span><br><span class="line"><span class="keyword">int</span> TT,L,R;<span class="comment">//TT即为题中的T</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;TT,&amp;L,&amp;R);</span><br><span class="line">TT+=<span class="number">2</span>;<span class="comment">//注意输入中的少女是从0编号的</span></span><br><span class="line"><span class="built_in">add</span>(TT,i,R-L);</span><br><span class="line">ve[TT]-=L;<span class="comment">//一定要减L,别减R！ </span></span><br><span class="line">ve[i]+=L; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构建虚拟图 </span></span><br><span class="line">S=<span class="number">0</span>,T=n+m+<span class="number">3</span>;<span class="comment">//S=0为虚拟图源点,T=n+m+3为虚拟图汇点 </span></span><br><span class="line"><span class="keyword">int</span> outflow=<span class="number">0</span>;<span class="comment">//记录从虚拟源点出流量,用于判断是否是满流 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nn;++i)&#123;<span class="comment">//创建虚拟边保证虚拟图中流量守恒 </span></span><br><span class="line"><span class="keyword">if</span>(ve[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">add</span>(S,i,ve[i]);</span><br><span class="line">outflow+=ve[i]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ve[i]&lt;<span class="number">0</span>) <span class="built_in">add</span>(i,T,-ve[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">add</span>(t,s,INF);<span class="comment">//增加一条从t到s的边,保证流量守恒 </span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Dinic</span>()&lt;outflow) <span class="built_in">printf</span>(<span class="string">&quot;-1\n\n&quot;</span>);<span class="comment">//务必两个\n </span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=f[idx<span class="number">-1</span>];<span class="comment">//最后加的边的反向边的流量</span></span><br><span class="line"><span class="comment">//即是当前(虚拟图的)满流中s-&gt;t的流量</span></span><br><span class="line">f[idx<span class="number">-1</span>]=f[idx<span class="number">-2</span>]=<span class="number">0</span>;<span class="comment">//删除该边</span></span><br><span class="line">S=s,T=t;<span class="comment">//因为现在求的是s-&gt;t的最大流量,</span></span><br><span class="line"><span class="comment">//所以重新初始化源点和汇点 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n\n&quot;</span>,res+<span class="built_in">Dinic</span>()); <span class="comment">//ans即为虚拟图中s-&gt;t的流量+</span></span><br><span class="line"><span class="comment">//新增加的可行流量 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="网络流二"><a href="#网络流二" class="headerlink" title="网络流二"></a>网络流二</h1><p>临时复习一下网络流，顺便学习一点新东西</p><h2 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h2><p>不多说，以前的模板太丑了，这里给一个符合我现在（2021/11/16）码风的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200</span> + <span class="number">5</span>, M = <span class="number">5000</span> + <span class="number">5</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> S, T, n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ne, ver, w;</span><br><span class="line">&#125; e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> h[N], idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> dep[N], cur[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx].ver = y, e[idx].w = z, e[idx].ne = h[x], h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> <span class="comment">//add-double</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(x, y, z), <span class="built_in">add</span>(y, x, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">dep[i] = <span class="number">-1</span>;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(S);</span><br><span class="line">dep[S] = <span class="number">0</span>;</span><br><span class="line">cur[S] = h[S];</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">x = q.<span class="built_in">front</span>(), q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (dep[y] == <span class="number">-1</span> &amp;&amp; e[i].w)</span><br><span class="line">&#123;</span><br><span class="line">dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">cur[y] = h[y];</span><br><span class="line"><span class="keyword">if</span> (y == T)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">q.<span class="built_in">push</span>(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == T)</span><br><span class="line"><span class="keyword">return</span> limit;</span><br><span class="line"><span class="keyword">int</span> flow = <span class="number">0</span>, y, t;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = cur[x]; i != <span class="number">-1</span> &amp;&amp; flow &lt; limit; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">cur[x] = i;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (dep[y] == dep[x] + <span class="number">1</span> &amp;&amp; e[i].w)</span><br><span class="line">&#123;</span><br><span class="line">t = <span class="built_in">find</span>(y, <span class="built_in">min</span>(limit - flow, e[i].w));</span><br><span class="line"><span class="keyword">if</span> (!t)</span><br><span class="line">dep[t] = <span class="number">-1</span>;</span><br><span class="line">e[i].w -= t;</span><br><span class="line">e[i ^ <span class="number">1</span>].w += t;</span><br><span class="line">flow += t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL maxflow = <span class="number">0</span>, flow;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">bfs</span>())</span><br><span class="line"><span class="keyword">while</span> (flow = <span class="built_in">find</span>(S, INF))</span><br><span class="line">maxflow += flow;</span><br><span class="line"><span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;S, &amp;T);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">h[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, w; i &lt;= m; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line"><span class="built_in">addd</span>(u, v, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">dinic</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="费用流"><a href="#费用流" class="headerlink" title="费用流"></a>费用流</h2><p>我们已经解决了网络最大流的问题，但是，如果边不仅有容量限制，还有“价格”，也就是说，流单位容量的流还要付出一定代价该怎么办呢？</p><p><strong>最小费用最大流(mcmf)<strong>简称</strong>费用流</strong>就可以解决这样一个问题：给定一张网络，有源点和汇点，网络上的每条边 $(u,v)$ 都有一个流量限制 $w(u,v)$ 和单位流量的费用 $c(u,v)$ ，在满足流量守恒的前提下，求出<strong>使流量最大的最小费用</strong></p><p>其实非常简单，考虑我们Dinic的过程，其实就是不断一个寻找增广路的过程，那么我们在每次寻找增广路的时候，贪心的寻找<strong>单位费用最小</strong>的增广路，正确性显然，考虑具体实现，只需将每条边 $(u,v)$ 的反向边的费用定为 $-c(u,v)$ ，每次寻找增广路的bfs换成一个最短路即可</p><h3 id="spfa实现"><a href="#spfa实现" class="headerlink" title="spfa实现"></a>spfa实现</h3><p>使用spfa可以简单，高效（<del>前提是spfa没死</del>）的实现费用流，但需要注意的是，费用流的时间复杂度是 $O(nmf)$ ，其中 $f$ 代表最大流量，这个复杂度是<strong>伪多项式</strong>的，因为 $f_{max}=2^{\frac{n}{2}},m_{max}=n^2$ ，所以最坏为 $O(n^32^{\frac{n}{2}})$ ，当然实际上远远达不到这个上界</p><p>这里用Dinic+spfa实现了一个费用流：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5000</span> + <span class="number">5</span>, M = <span class="number">50000</span> + <span class="number">5</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> S, T, n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ne, ver, w, c;</span><br><span class="line">&#125; e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> h[N], idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> dis[N], cur[N];</span><br><span class="line"><span class="keyword">bool</span> v[N];</span><br><span class="line"><span class="keyword">int</span> maxflow, mincost;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx].ver = y, e[idx].w = z, e[idx].c = c, e[idx].ne = h[x], h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z, <span class="keyword">int</span> c)</span> <span class="comment">//add-double</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(x, y, z, c), <span class="built_in">add</span>(y, x, <span class="number">0</span>, -c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">dis[i] = INF, cur[i] = h[i];</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(S);</span><br><span class="line">dis[S] = <span class="number">0</span>;</span><br><span class="line">v[S] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">x = q.<span class="built_in">front</span>(), q.<span class="built_in">pop</span>();</span><br><span class="line">v[x] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (dis[y] &gt; dis[x] + e[i].c &amp;&amp; e[i].w)</span><br><span class="line">&#123;</span><br><span class="line">dis[y] = dis[x] + e[i].c;</span><br><span class="line"><span class="keyword">if</span> (!v[y])</span><br><span class="line">&#123;</span><br><span class="line">v[y] = <span class="literal">true</span>;</span><br><span class="line">q.<span class="built_in">push</span>(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dis[T] != INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == T)</span><br><span class="line"><span class="keyword">return</span> limit;</span><br><span class="line">v[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> flow = <span class="number">0</span>, y, t;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = cur[x]; i != <span class="number">-1</span> &amp;&amp; flow &lt; limit; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">cur[x] = i;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (!v[y] &amp;&amp; dis[y] == dis[x] + e[i].c &amp;&amp; e[i].w)</span><br><span class="line">&#123;</span><br><span class="line">t = <span class="built_in">find</span>(y, <span class="built_in">min</span>(limit - flow, e[i].w));</span><br><span class="line"><span class="keyword">if</span> (!t)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">e[i].w -= t;</span><br><span class="line">e[i ^ <span class="number">1</span>].w += t;</span><br><span class="line">flow += t;</span><br><span class="line">mincost += t * e[i].c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">v[x] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mcmf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">maxflow = mincost = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> flow;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">spfa</span>())</span><br><span class="line"><span class="keyword">while</span> (flow = <span class="built_in">find</span>(S, INF))</span><br><span class="line">maxflow += flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;S, &amp;T);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">h[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, w, c; i &lt;= m; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w, &amp;c);</span><br><span class="line"><span class="built_in">addd</span>(u, v, w, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">mcmf</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, maxflow, mincost);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dijkstra实现"><a href="#Dijkstra实现" class="headerlink" title="Dijkstra实现"></a>Dijkstra实现</h3><p>由于dij不能处理负全，必须像Johns全源最短路一样用一个势能来转换为正权</p><p>首先跑一次最短路，求出源点到每个点的最短距离 $h_i$ （也是该点的初始势能），接下来和Johnson算法一样，对于一条从 $u$ 到 $v$ ，单位费用为 $w$ 的边，将其边权重置为 $w+h_u-h_v$          </p><p>可以发现，这样设置势能后新网络上的最短路径和原网络上的最短路径一定对应，不妨设一条从 $S$ 到 $T$ 的路径为 $S\rightarrow p_1\rightarrow p_2\rightarrow…\rightarrow p_k\rightarrow T$ ，则其重表权值后，路径权值和为<br>$$<br>\begin{align}<br>&amp;(w(S,p_1)+ h_S-h_{p_1})+ (w(p_1,p_2)+ h_{p_1}- h_{p_2}) + … + (w(p_k,T) + h_{p_k}-h_T)\\<br>=&amp;w(S,p_1) + w(p_1,p_2) + … + w(p_k,T) + h_S - h_T<br>\end{align}<br>$$<br>可以发现 $S$ 到 $T$ 的所有路径的相对大小不变</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5000</span> + <span class="number">5</span>, M = <span class="number">50000</span> + <span class="number">5</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> S, T, n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ne, ver, w, c;</span><br><span class="line">&#125; e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> dis, id;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;t) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> dis &gt; t.dis;</span><br><span class="line">&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">int</span> h[N], idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> dis[N], cur[N];</span><br><span class="line"><span class="keyword">bool</span> v[N], vfind[N]; <span class="comment">//为find单独开一个v</span></span><br><span class="line"><span class="keyword">int</span> pe[N]; <span class="comment">//potential energy,势能</span></span><br><span class="line"><span class="keyword">int</span> maxflow, mincost;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx].ver = y, e[idx].w = z, e[idx].c = c, e[idx].ne = h[x], h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z, <span class="keyword">int</span> c)</span> <span class="comment">//add-double</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">add</span>(x, y, z, c), <span class="built_in">add</span>(y, x, <span class="number">0</span>, -c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">pe[i] = INF;</span><br><span class="line">q.<span class="built_in">push</span>(S);</span><br><span class="line">pe[S] = <span class="number">0</span>;</span><br><span class="line">v[S] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">x = q.<span class="built_in">front</span>(), q.<span class="built_in">pop</span>();</span><br><span class="line">v[x] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (pe[y] &gt; pe[x] + e[i].c &amp;&amp; e[i].w)</span><br><span class="line">&#123;</span><br><span class="line">pe[y] = pe[x] + e[i].c;</span><br><span class="line"><span class="keyword">if</span> (!v[y])</span><br><span class="line">&#123;</span><br><span class="line">v[y] = <span class="literal">true</span>;</span><br><span class="line">q.<span class="built_in">push</span>(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dij</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">priority_queue&lt;Node&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">dis[i] = INF, v[i] = <span class="literal">false</span>, cur[i] = h[i];</span><br><span class="line">dis[S] = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push</span>((Node)&#123;<span class="number">0</span>, S&#125;);</span><br><span class="line"><span class="keyword">int</span> x, y, nc;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">x = q.<span class="built_in">top</span>().id, q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span> (v[x])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">v[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver, nc = e[i].c + pe[x] - pe[y];</span><br><span class="line"><span class="keyword">if</span> (dis[y] &gt; dis[x] + nc &amp;&amp; e[i].w)</span><br><span class="line">&#123;</span><br><span class="line">dis[y] = dis[x] + nc;</span><br><span class="line"><span class="keyword">if</span> (!v[y])</span><br><span class="line">q.<span class="built_in">push</span>((Node)&#123;dis[y], y&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dis[T] != INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == T)</span><br><span class="line"><span class="keyword">return</span> limit;</span><br><span class="line">vfind[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> flow = <span class="number">0</span>, y, t, nc;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = cur[x]; i != <span class="number">-1</span> &amp;&amp; flow &lt; limit; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">cur[x] = i;</span><br><span class="line">y = e[i].ver, nc = e[i].c + pe[x] - pe[y];</span><br><span class="line"><span class="keyword">if</span> (!vfind[y] &amp;&amp; dis[y] == dis[x] + nc &amp;&amp; e[i].w)</span><br><span class="line">&#123;</span><br><span class="line">t = <span class="built_in">find</span>(y, <span class="built_in">min</span>(limit - flow, e[i].w));</span><br><span class="line"><span class="keyword">if</span> (!t)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">e[i].w -= t;</span><br><span class="line">e[i ^ <span class="number">1</span>].w += t;</span><br><span class="line">flow += t;</span><br><span class="line">mincost += t * e[i].c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">vfind[x] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mcmf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">maxflow = mincost = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> flow;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">dij</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (flow = <span class="built_in">find</span>(S, INF))</span><br><span class="line">maxflow += flow;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="comment">//记得每次更新势能</span></span><br><span class="line">pe[i] += dis[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;S, &amp;T);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">h[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, w, c; i &lt;= m; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w, &amp;c);</span><br><span class="line"><span class="built_in">addd</span>(u, v, w, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">spfa</span>();</span><br><span class="line"><span class="built_in">mcmf</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, maxflow, mincost);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>然鹅实测spfa不被卡的话和Dijkstra差不多，反而是开了O2两个都快的飞起</del></p><h2 id="最高标号预流推进"><a href="#最高标号预流推进" class="headerlink" title="最高标号预流推进"></a>最高标号预流推进</h2><p>最高标号预流推进（High Level Preflow Push，即HLPP）是另一种网络流算法，该算法较Dinic更为高效，<del>然而常数更大</del></p><p>HLPP并不是像Dinic和EK一样基于增广路的算法，它用另外一种更直观的方法求最大流</p><h3 id="预流推进"><a href="#预流推进" class="headerlink" title="预流推进"></a>预流推进</h3><p>想象一下，如果给到一个网络流让你手算，你咋办？当然是贪心地从源点开始往死里流，尽可能的把每条边流满，如果超过容量就减掉超过部分，一直推到汇点（应该很好理解，可以自己手推试试）</p><p>PP也是基于以上思想，用一个队列储存待维护的点（初始时只有 $S$ ），对于每一个当前点，把它有的流量尽可能地推往与之相连的点，然后将相连的点也加入队列</p><p>但这样明显有一个问题：可能出现两个点一个推过来一个推回去，结果就死循环了，为了不死循环，我们类似Dinic，引入一个<strong>高度</strong> $hi$ ， $hi[S]=n,hi[T]=0$ 规定只能由高为 $hight$ 的点流向高为 $hight-1$ 的点，如果遇到一个点有多余的流量无法流出，就尝试将其抬高一个高度（我们把这个操作叫做<strong>重贴标签</strong>），直到最后高为 $n+1$ 流回 $S$ </p><h3 id="最高标号"><a href="#最高标号" class="headerlink" title="最高标号"></a>最高标号</h3><p><del>令人讨厌的、让人无奈的、使人疯魔的</del><strong>Tarjan</strong>和他的同事Goldberg在1986年提出了最高标号（HL）预留推进算法，即把普通队列换成<strong>优先队列</strong>，每次取出高度最高的那个来推进，可以理解为先将高处的点的水移到低处，那么给低处节点推流时可以顺便带走，Cheriyan和Maheshwari在1988年证明了这样做的复杂度为 $O(n^2\sqrt{m})$ </p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>虽然上述的算法是正确的，并且复杂度是稳定的（<del>不像某玄学Dinic</del>），但是因为缺少一些优化，使得其上界比较紧，因此在随机数据下可能不如增广路算法，所以下面介绍一些优化</p><p>首先是喜闻乐见的gap优化：如果我们发现在给一个点抬高一的高度的时候，这个点原来的高度已经没有点了（出现断层），那么我们直接把大于这个高度的点的高度全部设 $n+1$ ，让他们回流到源点去，因为有了断层，他们无法再有机会把水推到汇点（为什么不能有下面一个点抬上来形成路径呢？因为一个点的高度是所有相邻点高度最小值加一，所以不可能出现这种情况）</p><p>其次，我们发现将所有非源点的高度设置为0是有些浪费的。我们不妨通过一遍bfs将每个点的初始高度设置为它到汇点 $T$ 的最短距离，这样就节省了大量重贴标签操作。当然，源点 $S$ 的高度还是应该设置为 $n$ </p><p>然后，我们发现完全没有必要用优先队列的 $O(\log{n})$ 来求最高点，因为高度最大也就 $n+1$ ，完全可以用一个桶存下所有高度的节点，$O(1)$ 得到最高点</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><a href="https://www.luogu.com.cn/problem/P4722">模板</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1200</span> + <span class="number">5</span>, M = <span class="number">120000</span> + <span class="number">5</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, S, T;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ne, ver, w;</span><br><span class="line">&#125; e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> h[N], idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> hi[N], ex[N], gap[N]; <span class="comment">//hi:高度,ex:超额流,gap[i]:高度为i的节点的数量</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; B[N]; <span class="comment">// 桶B[i]中记录所有hi[x]=i的x</span></span><br><span class="line"><span class="keyword">int</span> level = <span class="number">0</span>; <span class="comment">//溢出节点的最高高度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx] = (Edge)&#123;h[x], y, z&#125;, h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(x, y, z), <span class="built_in">add</span>(y, x, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">hi[i] = INF;</span><br><span class="line">hi[T] = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push</span>(T);</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">x = q.<span class="built_in">front</span>(), q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (e[i ^ <span class="number">1</span>].w &amp;&amp; hi[y] &gt; hi[x] + <span class="number">1</span>) <span class="comment">//从T倒着搜回去走的是反向边,^1以后就变回正向边</span></span><br><span class="line">hi[y] = hi[x] + <span class="number">1</span>, q.<span class="built_in">push</span>(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> hi[S] != INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//尽可能通过能够推送的边推送超额流</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> init = x == S;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y, k; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (!e[i].w || (init == <span class="literal">false</span> &amp;&amp; hi[x] != hi[y] + <span class="number">1</span>)) <span class="comment">//初始化时不考虑高度差为1</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">k = init ? e[i].w : <span class="built_in">min</span>(e[i].w, ex[x]); <span class="comment">//取到剩余容量和超额流的最小值初始化时可以使源的溢出量为负数</span></span><br><span class="line"><span class="keyword">if</span> (y != S &amp;&amp; y != T &amp;&amp; !ex[y])</span><br><span class="line">B[hi[y]].<span class="built_in">push_back</span>(y), level = <span class="built_in">max</span>(level, hi[y]);</span><br><span class="line">ex[x] -= k, ex[y] += k, e[i].w -=k, e[i ^ <span class="number">1</span>].w += k;</span><br><span class="line"><span class="keyword">if</span> (!ex[x]) <span class="comment">//如果已经推送完就返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">relabel</span><span class="params">(<span class="keyword">int</span> x)</span>  <span class="comment">//重贴标签(高度)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  hi[x] = INF;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">    <span class="keyword">if</span> (e[i].w)</span><br><span class="line">hi[x] = <span class="built_in">min</span>(hi[x], hi[e[i].ver]);</span><br><span class="line">  <span class="keyword">if</span> (++hi[x] &lt; n) <span class="comment">//只处理高度小于n的节点</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="comment">//新的高度,更新gap</span></span><br><span class="line">  B[hi[x]].<span class="built_in">push_back</span>(x);</span><br><span class="line">  level = <span class="built_in">max</span>(level, hi[x]);</span><br><span class="line">  ++gap[hi[x]];  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_max</span><span class="params">()</span> <span class="comment">//选出当前高度最大的节点之一,如果已经没有溢出节点返回0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (B[level].<span class="built_in">empty</span>() &amp;&amp; level &gt; <span class="number">-1</span>)</span><br><span class="line">--level;</span><br><span class="line"><span class="keyword">return</span> level == <span class="number">-1</span> ? <span class="number">0</span> : B[level].<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hlpp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">bfs</span>())</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i)</span><br><span class="line">gap[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">if</span> (hi[i] != INF)</span><br><span class="line">++gap[hi[i]];</span><br><span class="line">hi[S] = n;</span><br><span class="line"><span class="built_in">push</span>(S); <span class="comment">//初始化预流</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">while</span> (x = <span class="built_in">find_max</span>())</span><br><span class="line">&#123;</span><br><span class="line">B[level].<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">push</span>(x)) <span class="comment">//仍然溢出</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!--gap[hi[x]])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">if</span> (i != S &amp;&amp; i != T &amp;&amp; hi[i] &gt; hi[x] &amp;&amp; hi[i] &lt; n + <span class="number">1</span>)</span><br><span class="line">hi[i] = n + <span class="number">1</span>;  <span class="comment">// 这里重贴成 n+1 的节点都不是溢出节点</span></span><br><span class="line">      <span class="built_in">relabel</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ex[T];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;S, &amp;T);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">h[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, w, c; i &lt;= m; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line"><span class="built_in">addd</span>(u, v, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">hlpp</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>一般来说好用又好打的Dinic已经足够，但HLPP在加上优化后完虐Dinic，但不管是哪个，需要注意有可能的最大流炸int的情况</p>]]></content>
      
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 网络流 </tag>
            
            <tag> Dinic </tag>
            
            <tag> HLPP </tag>
            
            <tag> 费用流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拓展欧几里得</title>
      <link href="/2021/11/22/%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
      <url>/2021/11/22/%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<p>拓欧</p><span id="more"></span><h1 id="欧几里德算法（辗转相除法）"><a href="#欧几里德算法（辗转相除法）" class="headerlink" title="欧几里德算法（辗转相除法）"></a>欧几里德算法（辗转相除法）</h1><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p> $\forall a,b \in \mathbb{N},b \ne 0,$ 有 $gcd(a,b)=gcd(b,a \bmod b)$</p><p>证明：</p><ul><li>若 $a&lt;b$ ，则 $gcd(b,a \bmod b)=gcd(b,a)=gcd(a,b)$</li><li>若 $a \ge b$ 设 $a=q \times b +r$ ,其中 $0 \le r &lt;b$ ,则 $gcd(b,a \bmod b)=gcd(b,r)$ 。对于 $a,b$ 的任何公约数 $d$ ，必有 $d|a,d|b$ ，故 $d|q \times b$ ，故 $d|(a-(q \times b))$ ，即 $d|r$ 。因此， $d$ 也是 $r,b$　的公约数，于是 $gcd(a,b)=gcd(r,b)$</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为 $O(\log{(a+b)})$ </p><h1 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h1><h2 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h2><p>$\forall a,b,c \in \mathbb{Z}$ 关于 $x,y$ 的不定方程 $ax+by=c$ 有整数解当且仅当 $gcd(a,b)|c$ ，且一定存在 $x,y$ 使 $c=gcd(a,b)$</p><p>该定理的正确性初中就学过了，这里再简要证明一下：</p><p>设 $d=gcd(a,b)$ ，则 $d|a,d|b$ ，故 $d|(ax+by)$ 。<br>再设 $s$ 为 $ax+by$ 当 $x,y\in \mathbb{Z}$ 时能取得的最小正值。设 $r=a \bmod s=a-\left \lfloor \frac{a}{s} \right \rfloor \times s=a-\left \lfloor \frac{a}{(ax+by)} \right \rfloor \times (ax+by) =a(1-\left \lfloor \frac{a}{ax+by} \right \rfloor x)+b(-\left \lfloor \frac{a}{ax+by} \right \rfloor y)$ ，这里的 $x,y$ 是常量，使 $ax+by=s$ 。<br>可见 $r$ 是 $a,b$ 的线性组合，由于 $r= a \bmod s$ ，故 $0 \le r&lt; s$ 。<br>而 $s=ax+by$ 是 $a,b$ 线性组合的最小正值，故 $r=0$ 。因此 $s|a$ 。<br>同理， $s|b$ 。<br>故 $s$  是 $a,b$　的公约数，故 $s|d$ 。<br>又因为 $d|(ax+by)$ ，故有 $d|s$ ，那么只能 $d=s$ ，命题得证。</p><h2 id="特解"><a href="#特解" class="headerlink" title="特解"></a>特解</h2><p>有了裴蜀定理，我们就可以解出 $ax+by=gcd(a,b)$ ，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span>&amp; x,<span class="keyword">int</span>&amp; y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!b)&#123;</span><br><span class="line">   x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> a;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">int</span> d=<span class="built_in">exgcd</span>(b,a%b,y,x);<span class="comment">//这里交换了x和y</span></span><br><span class="line">   y-=(a/b)*x;</span><br><span class="line">   <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们调用函数 $d=exgcd(a,b,x_0,y_0)$ 时，由于 $x,y$ 是实参，结束后 $x_0,y_0$ 即为一组特解， $d$ 为 $gcd(a,b)$ 。</p><p>那么，由于 $d|c$ , $ax+by=c$ 的通解为：</p><p>$$<br>\begin{align}<br>x=\frac{c}{d}x_0+k\frac{b}{d} \\<br>y=\frac{c}{d}y_0-k\frac{a}{d}<br>\end{align}<br>$$</p><p>其中 $k$ 取遍 $\mathbb{Z}$ ，$d=gcd(a,b)$ ，$x_0,y_0$ 是方程 $ax+by=gcd(a,b)$ 的一组特解</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><a href="https://www.luogu.com.cn/problem/P1082">P1082</a><br>我们发现 $ax \equiv 1 \pmod{b}$ ，就等价于 $ax=by+1$ 移项得 $ax-by=1$ 。</p><p>代码如下：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line">LL a,m; </span><br><span class="line">LL exgcd(LL a,LL b,LL&amp; x,LL&amp; y)<span class="comment">&#123;</span></span><br><span class="line"><span class="comment">if(!b)&#123;</span></span><br><span class="line"><span class="comment">x=1,y=0;</span></span><br><span class="line"><span class="comment">return a;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line">LL d=exgcd(b,a%b,y,x); </span><br><span class="line">y-=a/b*x;</span><br><span class="line">return d;</span><br><span class="line">&#125;</span><br><span class="line">int main()<span class="comment">&#123;</span></span><br><span class="line"><span class="comment">scanf(&quot;%lld%lld&quot;,&amp;a,&amp;m);</span></span><br><span class="line"><span class="comment">LL x,y;</span></span><br><span class="line"><span class="comment">exgcd(a,m,x,y);</span></span><br><span class="line"><span class="comment">x=(x%m+m)%m; </span></span><br><span class="line"><span class="comment">printf(&quot;%lld&quot;,x);</span></span><br><span class="line"><span class="comment">return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数论,数学 </tag>
            
            <tag> 拓展欧几里得 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数位dp</title>
      <link href="/2021/11/22/%E6%95%B0%E4%BD%8Ddp/"/>
      <url>/2021/11/22/%E6%95%B0%E4%BD%8Ddp/</url>
      
        <content type="html"><![CDATA[<p>简单写写</p><span id="more"></span><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>思考以下问题：<br>对于给定范围的整数 $x \in [a,b]$ ，有多少个 $x$ 满足性质 $p$ （ $p$ 与数的各个位都有关，如“该数中有3个1”）。<br>对于此类问题，我们可以考虑如下方法：  </p><ol><li><p>用 $f[i]$ 表示对于所有的整数 $x \in [0,i]$ 中，满足性质 $p$ 的数的个数</p></li><li><p>则 $ans \ge f[b]-f[a-1]$ </p></li></ol><p>那么，我们来考虑如何去求 $f[N]$ 。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>设数 $N$ 是一个 $n$ 位数，且 $N=\overline{a_{n-1}a_{n-2}a_{n-3}…a_0} (a_<br>{n-1} \ne 0)$ 。<br>辣么，对于 $\forall x \in [0,N],x=\overline{b_{n-1}b_{n-2}b_{n-3}…b_0}$ ，有两种情况：</p><ol><li><p>$b_{n-1}=a_{n-1}$ </p></li><li><p>$0 \le b_{n-1} &lt; a_{n-1}$ </p></li></ol><p>我们发现，对于第二种情况，当 $b_{n-1}$ 确定时，方案数可以直接计算。如当 $N=7654321$ ， $p$ 为“该数中有3个1” 时，若 $0 \le b_6 &lt; 7$ 那么 $b_6=1$ 时，有 $C_{6}^{2}$ 种方案，而当 $b_6 \ne 1$ 时，有 $C_{6}^{3}$ 种方案。<br>对于第一种情况，我们只需继续讨论 $b_{n-2}$ 。<br>如图：<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/6zh87oc2.png" alt="dp顺序"></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/w0g1xgw3.png" alt="题"><br>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">35</span>;</span><br><span class="line"><span class="keyword">int</span> k, B; <span class="comment">//B进制数</span></span><br><span class="line"><span class="keyword">int</span> C[N][N];</span><br><span class="line"><span class="comment">//预处理组合数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j)</span><br><span class="line">            <span class="keyword">if</span> (!j)</span><br><span class="line">                C[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                C[i][j] = C[i - <span class="number">1</span>][j] + C[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算0到n中的数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">        nums.<span class="built_in">push_back</span>(n % B), n /= B;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = nums[i];</span><br><span class="line">        <span class="comment">//求左边分支</span></span><br><span class="line">        <span class="keyword">if</span> (x)</span><br><span class="line">        &#123;</span><br><span class="line">            res += C[i][k - last];</span><br><span class="line">            <span class="keyword">if</span> (x &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (k &gt; last)</span><br><span class="line">                    res += C[i][k - last - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                last++;</span><br><span class="line">                <span class="keyword">if</span> (last &gt; k)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加上最右侧分支上的方案</span></span><br><span class="line">        <span class="keyword">if</span> (!i &amp;&amp; last == k)</span><br><span class="line">            res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r &gt;&gt; k &gt;&gt; B;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dp</span>(r) - <span class="built_in">dp</span>(l - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数论,数学 </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树状数组（BIT）</title>
      <link href="/2021/11/22/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%88BIT%EF%BC%89/"/>
      <url>/2021/11/22/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%88BIT%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>BIT常数小！（<del>然并卵</del>）</p><span id="more"></span><h2 id="思想铺垫"><a href="#思想铺垫" class="headerlink" title="思想铺垫:"></a>思想铺垫:</h2><p>将一个数$x$化为二进制数$(\overline{a_{k-1}a_{k-2}…a_1a_0})<em>2$ , 并设其中等于1的位是${a</em>{i_1},a_{i_2}…a_{i_m}}$ , 则$x=2^{i_1}+2^{i_2}+…+2^{i_m}$ , 不妨设$i_1&gt;i_2&gt;…&gt;i_m$ , 那么区间$[1,x]$可以拆分成$O(\log_{}{x})$个小区间:  </p><ol><li><p>长度为$2^{i_1}$的小区间$[1,2^{i_1}]$</p></li><li><p>长度为$2^{i_2}$的小区间$[2^{i_1}+1,2^{i_1}+2^{i_2}]$</p></li><li><p>长度为$2^{i_3}$的小区间$[2^{i_1}+2^{i_2}+1,2^{i_1}+2^{i_2}+2^{i_3}]$; </p><p>……</p></li><li><p>长度为$2^{i_m}$的小区间$[2^{i_1}+2^{i_2}+…+2^{i_{m-1}}+1,2^{i_1}+2^{i_2}+…+2^{i_m}]$ </p></li></ol><p>而这些小区间的共同特点是:对于$\forall[x,y ]$ , 其区间长度(记为$|[x,y]|$)就等于”y的二进制拆分下的最小的2的次幂” , 即$lowbit(y)$ .<br>例如大区间$[1,7]$ , 因为$7=2^{2}+2^{1}+2^{0}$ , 所以被分为三个小区间 : $[1,4]$、$[5,6]$、$[7,7]$ . 而其长度分别是$lowbit(4)=4$、$lowbit(4)=4$、$lowbit(4)=4$<br>补充——$lowbit()$:<br>$lowbit(n)$定义为”非负整数$n$在而进制表示下最低位的1及其后的0构成的数的值”. 如$n=22=(10110)_2$ , 则$lowbit(22)=(10)_2=2$<br>则其代码实现如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本思路："><a href="#基本思路：" class="headerlink" title="基本思路："></a>基本思路：</h2><p>对于给定的原序列$a$ , 我们建立一个数组$c$ , 其中$c[x]$保存<strong>原序列$a$的区间$[x-lowbit(x)+1,x]$中所有数的和</strong> , 即$\textstyle\sum_{i=x-lowbit(x)+1}^{x}a[i]$<br>不难发现 , 数组$c$可以看作一个树形结构 , 且满足如下性质:</p><ol><li>每个节点$c[x]$保存以它为根的子树中所有叶节点的和.</li><li>每个节点$c[x]$的子节点个数等于$lowbit(x)$的位数 , 如$lowbit(4)=(100)_2$ , 其位数为$3$ , 故$c[4]有3个子节点$.</li><li>除树根外 , 每个节点$c[x]$的父节点就是$c[x+lowbit(x)]$.</li><li>树的深度为$O(\log_{}{N})$.</li></ol><p>如果$n$不是$2$的整数次幂 , 那么树状数组就是一个具有同样性质的森林.<br>如图:<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/4yowzx8l.png" alt="树状数组"><br>而树状数组支持的操作有两个:<br> <strong>查询前缀和</strong> : 即找到序列$a$第$1 \sim x$个数的和.  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;x;x-=x&amp;-x) ans+=c[x];<span class="comment">//x&amp;-x即为lowbit(x)</span></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若要查询$a$的区间$[l,r]$ , 只需计算$ask(r)-ask(l-1)$.<br><strong>单点增加</strong> : 给序列中一个数$a[x]$加上y , 不难发现至多只有$\log{}{N}$个节点包含$a[x]$ , 故时间复杂度为$O(\log{}{N})$.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(;x&lt;=N;x+=x&amp;-x) c[x]+=y;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在执行操作前 , 我们先要构造出$c$数组.<br>简单方法是 , 先让$c$全为$0$ , 然后对每个$x$执行$add(x,a[x])$ , 时间复杂度为$O(N\log{}{N})$ , 通常用这种方法就已足够.<br>更高效的方法是 , 从小到大依次考虑节点$x$ , 借助$lowbit$运算扫描它的子节点求和.若采用这种办法 , 上面树形结构的每条边只会被遍历一次 , 时间复杂度为 $O(\sum_{k = 1} ^ {\log{N}}k * N / 2 ^ {k}) = O(N)$<br>另外 , 若是题目需要<strong>区间增加</strong> , 可以改存$a$的差分数组.</p><p><a href="https://www.luogu.com.cn/problem/P3374">树状数组1</a><br><a href="https://www.luogu.com.cn/problem/P3368">树状数组2</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树套树</title>
      <link href="/2021/11/22/%E6%A0%91%E5%A5%97%E6%A0%91/"/>
      <url>/2021/11/22/%E6%A0%91%E5%A5%97%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>禁止套娃！</p><span id="more"></span><h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p>顾名思义，树套树就是用一个树套进另一个树，即一个外层的树、一个内层的树。</p><h1 id="简单版"><a href="#简单版" class="headerlink" title="简单版"></a>简单版</h1><p>思考如下问题：<br>维护一个长度为 $n$ 的序列，数列中的位置从左到右依次标号为 $1∼n$ ,其中需要提供以下操作：  </p><ol><li><p>$1\ pos\ x$ ，将 $pos$ 位置的数修改为 $x$ 。</p></li><li><p>$1\ a\ b\ x$ ，查询整数 $x$ 在区间 $[a,b]$ 内的前驱(前驱定义为小于 $x$ ，且最大的数)。  </p></li></ol><p>这个问题发现，第二个操作可以用 $set$ 完成，但 $set$ 仅支持查询整个区间，无法完成在区间 $[a,b]$ 上查询，所以我们考虑用一个线段树套在 $set$ 外层。  </p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50000</span> + <span class="number">5</span>, M = N * <span class="number">4</span>; <span class="comment">//线段树空间开4倍</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="comment">//multiset是&lt;set&gt;库中一个类型,可以看成一个序列,</span></span><br><span class="line">    <span class="comment">//插入删除数都能够在O(logn)的时间内完成,</span></span><br><span class="line">    <span class="comment">//而且能保证序列中的数是有序的,而且序列中可以存在重复的数。</span></span><br><span class="line">    multiset&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inint</span><span class="params">(<span class="keyword">int</span> _l, <span class="keyword">int</span> _r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        l = _l;</span><br><span class="line">        r = _r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; tr[M];</span><br><span class="line"><span class="keyword">int</span> w[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].<span class="built_in">inint</span>(l, r);</span><br><span class="line">    tr[u].s.<span class="built_in">insert</span>(-INF), tr[u].s.<span class="built_in">insert</span>(INF); <span class="comment">//防止越界</span></span><br><span class="line">    <span class="comment">//将线段树该节点(即该段)内的所有点插入该节点下套的set中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i)</span><br><span class="line">        tr[u].s.<span class="built_in">insert</span>(w[i]);</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//删除w[p],注意不能写erase(w[p]),否则会把所有值为w[p]的都删除</span></span><br><span class="line">    tr[u].s.<span class="built_in">erase</span>(tr[u].s.<span class="built_in">find</span>(w[p]));</span><br><span class="line">    tr[u].s.<span class="built_in">insert</span>(x);</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l == tr[u].r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (tr[u].l + tr[u].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= mid)</span><br><span class="line">        <span class="built_in">change</span>(u &lt;&lt; <span class="number">1</span>, p, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">change</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, p, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//若tr[u]在完全在区间[a,b]内</span></span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= a &amp;&amp; tr[u].r &lt;= b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//注意it的类型,it是地址,类型得记</span></span><br><span class="line">        std::multiset&lt;<span class="keyword">int</span>&gt;::iterator it = tr[u].s.<span class="built_in">lower_bound</span>(x);</span><br><span class="line">        <span class="comment">//it是&quot;大于等于x的最小数&quot;,减一后就是&quot;小于x的最大数&quot;</span></span><br><span class="line">        --it;</span><br><span class="line">        <span class="keyword">return</span> *it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (tr[u].l + tr[u].r) &gt;&gt; <span class="number">1</span>, res = -INF;</span><br><span class="line">    <span class="keyword">if</span> (a &lt;= mid)</span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, a, b, x));</span><br><span class="line">    <span class="keyword">if</span> (b &gt; mid)</span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, a, b, x));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m); <span class="comment">//数列长度以及操作次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> op, a, b, c, ans;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>, a, b);</span><br><span class="line">            w[a] = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">            ans = <span class="built_in">query</span>(<span class="number">1</span>, a, b, c);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (ans &gt; -INF &amp;&amp; ans &lt; INF) ? ans : <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="正常版"><a href="#正常版" class="headerlink" title="正常版"></a>正常版</h1><h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>问题加强如下（也可见<a href="https://www.luogu.com.cn/problem/P3380">P3380</a>）：<br>维护一个长度为 $n$ 的序列，数列中的位置从左到右依次标号为 $1∼n$ ,其中需要提供以下操作：  </p><ol><li><p> $1\ l\ r\ x$ ，查询整数 $x$ 在区间 $[l,r]$ 内的排名。</p></li><li><p> $2\ l\ r\ k$ ，查询区间 $[l,r]$ 内排名为 $k$ 的值。</p></li><li><p> $3\ pos\ x$ ，将 $pos$ 位置的数修改为 $x$ 。</p></li><li><p> $4\ l\ r\ x$ ，查询整数 $x$ 在区间 $[l,r]$ 内的前驱(前驱定义为小于 $x$ ，且最大的数)。</p></li><li><p> $5\ l\ r\ x$ ，查询整数 $x$ 在区间 $[l,r]$ 内的后继(后继定义为大于 $x$ ，且最小的数)。</p></li></ol><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>本题的四、五操作与简单版类似，可以用 $set$ 完成，但对于操作一、二， $set$ 却不支持排名，因为它不记录子树大小，so——我们只好手打平衡树。</p><p>而手打的平衡树可以完成操作一，但对于操作二，因为线段树会把区间 $[l,r]$ 分成最多 $\log N$ 个区间，每个区间内的平衡树互不联通，且通过简单的计算每个区间的答案并不能得到最终答案，所以我们思考其他方法——二分。<br>对于每个 $mid$ 用操作一找出它的排名，若排名小于等于 $k$ ，则答案小于等于 $mid$ ，反之则大于等于 $mid$ 。</p><p>由此，操作一、三、四、五的时间复杂度为 $\log^2 N$ ，操作二的时间复杂度为 $\log^3 N$ ,总时间复杂度为 $O(m\log^3 n)$ ，空间复杂度为 $O(N* 4* 2+N\log N)$ ,故空间约需 $50000* 4* 2+50000* 18 \le 1500000 $ 。</p><p>另外，一定要注意，有几个函数传的是实参！（ $update$ 、 $splay$ 和 $insert$）。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">15e5</span> + <span class="number">5</span>, INF = <span class="number">2147483647</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Splay</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s[<span class="number">2</span>], fa, size, v;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inint</span><span class="params">(<span class="keyword">int</span> _v, <span class="keyword">int</span> _fa)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        v = _v;</span><br><span class="line">        fa = _fa;</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; tr[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Seg_Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> rt;        <span class="comment">//root,对应的Splay的根</span></span><br><span class="line">&#125; ttr[N];          <span class="comment">//ttr表示外层树</span></span><br><span class="line"><span class="keyword">int</span> n, m, idx = <span class="number">0</span>; <span class="comment">//idx:记录Splay的节点</span></span><br><span class="line"><span class="keyword">int</span> w[N];</span><br><span class="line"><span class="comment">/*------------------------Splay------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].size = tr[tr[x].s[<span class="number">0</span>]].size + tr[tr[x].s[<span class="number">1</span>]].size + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = tr[x].fa;</span><br><span class="line">    <span class="keyword">int</span> z = tr[y].fa;</span><br><span class="line">    <span class="keyword">int</span> k = tr[y].s[<span class="number">1</span>] == x;</span><br><span class="line">    tr[z].s[tr[z].s[<span class="number">1</span>] == y] = x, tr[x].fa = z;</span><br><span class="line">    tr[y].s[k] = tr[x].s[k ^ <span class="number">1</span>], tr[tr[x].s[k ^ <span class="number">1</span>]].fa = y;</span><br><span class="line">    tr[x].s[k ^ <span class="number">1</span>] = y, tr[y].fa = x;</span><br><span class="line">    <span class="built_in">push_up</span>(y), <span class="built_in">push_up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> &amp;root, <span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> <span class="comment">//一定注意这里传实参</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (tr[x].fa != k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y = tr[x].fa;</span><br><span class="line">        <span class="keyword">int</span> z = tr[y].fa;</span><br><span class="line">        <span class="keyword">if</span> (z != k)</span><br><span class="line">            (tr[y].s[<span class="number">1</span>] == x) ^ (tr[z].s[<span class="number">1</span>] == y) ? <span class="built_in">rotate</span>(x) : <span class="built_in">rotate</span>(y);</span><br><span class="line">        <span class="built_in">rotate</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!k)</span><br><span class="line">        root = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在splay中插入v</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;root, <span class="keyword">int</span> v)</span> <span class="comment">//实参!</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = root, p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (u)</span><br><span class="line">        p = u, u = tr[u].s[v &gt; tr[u].v];</span><br><span class="line">    u = ++idx;</span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">        tr[p].s[v &gt; tr[p].v] = u;</span><br><span class="line">    tr[u].<span class="built_in">inint</span>(v, p);</span><br><span class="line">    <span class="built_in">splay</span>(root, u, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在该splay中找到比v小的数的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_k</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = root, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (u)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tr[u].v &lt; v)</span><br><span class="line">            res += tr[tr[u].s[<span class="number">0</span>]].size + <span class="number">1</span>, u = tr[u].s[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            u = tr[u].s[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在该splay中更新x为y</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;root, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">//实参!</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//删除x(忘了去看Splay)</span></span><br><span class="line">    <span class="keyword">int</span> u = root;</span><br><span class="line">    <span class="keyword">while</span> (u)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tr[u].v == x)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (tr[u].v &lt; x)</span><br><span class="line">            u = tr[u].s[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            u = tr[u].s[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">splay</span>(root, u, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> l = tr[u].s[<span class="number">0</span>], r = tr[u].s[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (tr[l].s[<span class="number">1</span>])</span><br><span class="line">        l = tr[l].s[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (tr[r].s[<span class="number">0</span>])</span><br><span class="line">        r = tr[r].s[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">splay</span>(root, l, <span class="number">0</span>), <span class="built_in">splay</span>(root, r, l);</span><br><span class="line">    tr[r].s[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">push_up</span>(r), <span class="built_in">push_up</span>(l);</span><br><span class="line">    <span class="comment">//插入y</span></span><br><span class="line">    <span class="built_in">insert</span>(root, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在该splay中找到比v小的数中最大的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_pre</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = root, res = -INF;</span><br><span class="line">    <span class="keyword">while</span> (u)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tr[u].v &lt; v)</span><br><span class="line">            res = <span class="built_in">max</span>(res, tr[u].v), u = tr[u].s[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            u = tr[u].s[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在该splay中找到比v大的数中最小的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_suc</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = root, res = INF;</span><br><span class="line">    <span class="keyword">while</span> (u)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tr[u].v &gt; v)</span><br><span class="line">            res = <span class="built_in">min</span>(res, tr[u].v), u = tr[u].s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            u = tr[u].s[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*------------------------Segment tree------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ttr[u].l = l, ttr[u].r = r;</span><br><span class="line">    <span class="built_in">insert</span>(ttr[u].rt, -INF), <span class="built_in">insert</span>(ttr[u].rt, INF); <span class="comment">//防止越界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i)</span><br><span class="line">        <span class="built_in">insert</span>(ttr[u].rt, w[i]);</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到比x小的数的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ttr[u].l &gt;= l &amp;&amp; ttr[u].r &lt;= r)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_k</span>(ttr[u].rt, x) - <span class="number">1</span>; <span class="comment">//因为多插入了-INF</span></span><br><span class="line">    <span class="keyword">int</span> mid = (ttr[u].l + ttr[u].r) &gt;&gt; <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">        res += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r, x);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">        res += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, x);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将w[p]变为x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">update</span>(ttr[u].rt, w[p], x);</span><br><span class="line">    <span class="keyword">if</span> (ttr[u].l == ttr[u].r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (ttr[u].l + ttr[u].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= mid)</span><br><span class="line">        <span class="built_in">change</span>(u &lt;&lt; <span class="number">1</span>, p, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">change</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, p, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到比x小的数中最大的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query_pre</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ttr[u].l &gt;= l &amp;&amp; ttr[u].r &lt;= r)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_pre</span>(ttr[u].rt, x);</span><br><span class="line">    <span class="keyword">int</span> mid = (ttr[u].l + ttr[u].r) &gt;&gt; <span class="number">1</span>, res = -INF;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="built_in">query_pre</span>(u &lt;&lt; <span class="number">1</span>, l, r, x));</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="built_in">query_pre</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, x));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到比v大的数中最小的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query_suc</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ttr[u].l &gt;= l &amp;&amp; ttr[u].r &lt;= r)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_suc</span>(ttr[u].rt, x);</span><br><span class="line">    <span class="keyword">int</span> mid = (ttr[u].l + ttr[u].r) &gt;&gt; <span class="number">1</span>, res = INF;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">        res = <span class="built_in">min</span>(res, <span class="built_in">query_suc</span>(u &lt;&lt; <span class="number">1</span>, l, r, x));</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">        res = <span class="built_in">min</span>(res, <span class="built_in">query_suc</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, x));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> op, a, b, x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;x);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(<span class="number">1</span>, a, b, x) + <span class="number">1</span>); <span class="comment">//query是&quot;比x小的数的个数&quot;,加1为x的排名</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;x);</span><br><span class="line">            <span class="comment">//二分答案</span></span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">1e8</span>, ans;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">query</span>(<span class="number">1</span>, a, b, mid) + <span class="number">1</span> &lt;= x)</span><br><span class="line">                    ans = mid, l = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;x);</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>, a, x);</span><br><span class="line">            w[a] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;x);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query_pre</span>(<span class="number">1</span>, a, b, x));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;x);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query_suc</span>(<span class="number">1</span>, a, b, x));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="变式"><a href="#变式" class="headerlink" title="变式"></a>变式</h1><h2 id="问题：-1"><a href="#问题：-1" class="headerlink" title="问题："></a>问题：</h2><p><a href="https://www.acwing.com/problem/content/2308/">AcWing2306</a>：<br>你需要维护 $n$ 个可重整数集，集合的编号从1到 $n$ 。<br>这些集合初始都是空集，有 $m$ 个操作:</p><ol><li><p>$1\ l\ r\ c$ ：表示将 $c$ 加入到编号在 $[l,r]$ 内的集合中</p></li><li><p>$2\ l\ r\ c$ ：表示查询编号在 $[l,r]$ 内的集合的并集中，第 $c$ 大的数是多少。</p></li></ol><p>注意可重集的并是不去除重复元素的，如 ${1,1,4} \cup {5,1,4}={1,1,4,5,1,4}$ 。</p><h2 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h2><p>先尝试上题思路：外层树线段树，套内层平衡树。<br>但很快啊，啪的一下，我们就发现，这样的话区间修改非常麻烦，操作一（在区间 $[l,r]$ 中的每一个集合里加一个数 $c$ ）的实现过于复杂。<br>于是，我们（听别人说）可以用权值线段树。</p><h2 id="权值线段树："><a href="#权值线段树：" class="headerlink" title="权值线段树："></a>权值线段树：</h2><ol><li><p>将数值离散化</p></li><li><p>以数值（即权值）为节点建立线段树</p></li><li><p>线段数的每一个节点上，再用一棵线段树来维护权值在该节点内的所有数的下标</p></li><li><p>对于操作一，我们在外层数上找到包含 $c$ 的节点，最多有 $\log n$ 个，然后再个节点内层的线段树上找到区间 $[l,r]$ ，打上懒标记</p></li><li><p>对于操作二，我们用类似二分的思想，每次找一半区间（即外层线段数左右节点中的一个），求该区间下套的内层树上 $[l,r]$ 的和 $k$ ，若 $k \ge c$ 就进入（外层树的）右节点，否则进入左节点</p></li></ol><p>时间复杂度为 $O(\log^2 N)$</p><h2 id="标记持久化："><a href="#标记持久化：" class="headerlink" title="标记持久化："></a>标记持久化：</h2><p>我们发现的区间增加也好、区间求和也好，都是在内层树上，而且只有这两个<strong>同类型</strong>（必须同类，例如有加有乘就不行）的操作，所以我们考虑更改 $sum$ 和 $add$ 的含义，使这些标记不必向下传（即省略 $push_down$）。<br>（以下定义都是针对内层树）<br> $sum$ ：定义 $sum$ 为“只考虑本节点及以下节点懒标记的情况下的区间和”。<br> $add$ ：定义 $add$ 为“本节点的所有子节点都要加上一个 $add$ ”。<br>对于区间求和，只需用本节点的 $sum$ 加上所有祖宗节点的 $add$ 和与区间长度的积即可，具体实现的话，只需在递归时顺便累加 $add$ 即可。</p><h2 id="线段树的动态开点："><a href="#线段树的动态开点：" class="headerlink" title="线段树的动态开点："></a>线段树的动态开点：</h2><p>我们发现，直接开线段树套线段树，空间复杂度为 $O(N^2)$ ，对于本题来说无法接受，因此，我们自然想到，只开出用到的节点，即动态开点，空间复杂度为 $O(M\log N)$ </p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50000</span> + <span class="number">5</span>, Nn = N * <span class="number">17</span> * <span class="number">17</span>, M = N * <span class="number">4</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Seg_Tree1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LL l, r, rt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(u) tr[u].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(u) tr[u].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rt(u) tr[u].rt</span></span><br><span class="line">&#125; tr[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Seg_Tree2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LL l, r, sum, add; <span class="comment">//由于动态开点,内层数的l、r表示的是节点下标</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll(u) ttr[u].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr(u) ttr[u].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(u) ttr[u].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> add(u) ttr[u].add</span></span><br><span class="line">&#125; ttr[Nn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Question</span> //为了离散化,需要保存问题</span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    LL op, a, b, c;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> op(u) q[i].op</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> a(u) q[i].a</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> b(u) q[i].b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> c(u) q[i].c</span></span><br><span class="line">&#125; q[N];</span><br><span class="line">vector&lt;LL&gt; que;</span><br><span class="line">LL n, m;</span><br><span class="line">LL idx = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//离散化的对应</span></span><br><span class="line"><span class="function">LL <span class="title">get</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(que.<span class="built_in">begin</span>(), que.<span class="built_in">end</span>(), x) - que.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//intersection,求两区间的交集</span></span><br><span class="line"><span class="function">LL <span class="title">inter</span><span class="params">(LL l1, LL r1, LL l2, LL r2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(r1, r2) - <span class="built_in">max</span>(l1, l2) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更新内层树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(LL u, LL l, LL r, LL pl, LL pr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sum</span>(u) += <span class="built_in">inter</span>(l, r, pl, pr);</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= pl &amp;&amp; r &lt;= pr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add</span>(u)++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pl &lt;= mid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">ll</span>(u))</span><br><span class="line">            <span class="built_in">ll</span>(u) = ++idx; <span class="comment">//动态开点</span></span><br><span class="line">        <span class="built_in">update</span>(<span class="built_in">ll</span>(u), l, mid, pl, pr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pr &gt; mid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">rr</span>(u))</span><br><span class="line">            <span class="built_in">rr</span>(u) = ++idx;</span><br><span class="line">        <span class="built_in">update</span>(<span class="built_in">rr</span>(u), mid + <span class="number">1</span>, r, pl, pr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">get_sum</span><span class="params">(LL u, LL l, LL r, LL pl, LL pr, LL add)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= pl &amp;&amp; r &lt;= pr)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(u) + (r - l + <span class="number">1</span>) * add;</span><br><span class="line">    LL mid = (l + r) &gt;&gt; <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    add += <span class="built_in">add</span>(u);</span><br><span class="line">    <span class="keyword">if</span> (pl &lt;= mid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ll</span>(u))</span><br><span class="line">            res += <span class="built_in">get_sum</span>(<span class="built_in">ll</span>(u), l, mid, pl, pr, add);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            res += <span class="built_in">inter</span>(l, mid, pl, pr) * add; <span class="comment">//如果未开ll(u),说明它未修改过</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pr &gt; mid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">rr</span>(u))</span><br><span class="line">            res += <span class="built_in">get_sum</span>(<span class="built_in">rr</span>(u), mid + <span class="number">1</span>, r, pl, pr, add);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            res += <span class="built_in">inter</span>(mid + <span class="number">1</span>, r, pl, pr) * add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(LL u, LL l, LL r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">l</span>(u) = l, <span class="built_in">r</span>(u) = r, <span class="built_in">rt</span>(u) = ++idx;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    LL mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(LL u, LL l, LL r, LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">update</span>(<span class="built_in">rt</span>(u), <span class="number">1</span>, n, l, r);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">l</span>(u) == <span class="built_in">r</span>(u))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (<span class="built_in">l</span>(u) + <span class="built_in">r</span>(u)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid)</span><br><span class="line">        <span class="built_in">change</span>(u &lt;&lt; <span class="number">1</span>, l, r, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">change</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(LL u, LL l, LL r, LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">l</span>(u) == <span class="built_in">r</span>(u))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">r</span>(u);</span><br><span class="line">    LL mid = (<span class="built_in">l</span>(u) + <span class="built_in">r</span>(u)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    LL k = <span class="built_in">get_sum</span>(<span class="built_in">rt</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>), <span class="number">1</span>, n, l, r, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= x)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r, x - k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (LL i = <span class="number">0</span>; i &lt; m; ++i) <span class="comment">//为了配合vector,循环也都从0开始</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld&quot;</span>, &amp;<span class="built_in">op</span>(i), &amp;<span class="built_in">a</span>(i), &amp;<span class="built_in">b</span>(i), &amp;<span class="built_in">c</span>(i));</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">op</span>(i) == <span class="number">1</span>)</span><br><span class="line">            que.<span class="built_in">push_back</span>(<span class="built_in">c</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//排序,去重</span></span><br><span class="line">    <span class="built_in">sort</span>(que.<span class="built_in">begin</span>(), que.<span class="built_in">end</span>());</span><br><span class="line">    que.<span class="built_in">erase</span>(<span class="built_in">unique</span>(que.<span class="built_in">begin</span>(), que.<span class="built_in">end</span>()), que.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, que.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (LL i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">op</span>(i) == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>, <span class="built_in">a</span>(i), <span class="built_in">b</span>(i), <span class="built_in">get</span>(<span class="built_in">c</span>(i)));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, que[<span class="built_in">query</span>(<span class="number">1</span>, <span class="built_in">a</span>(i), <span class="built_in">b</span>(i), <span class="built_in">c</span>(i))]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 平衡树 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
            <tag> 树套树 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树链剖分</title>
      <link href="/2021/11/22/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
      <url>/2021/11/22/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>线段树进化！</p><span id="more"></span><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>线段树，DFS序</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>树链剖分的核心思想是将一棵树的节点重新排序，再将树转换为一个序列，使得树上的任意一条路径可以被最多 $\log{n}$ 段区间表示出来，由此我们可以将树上的路径操作化为区间操作。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li><p>重儿子（节点）：子树结点数目最多的结点</p></li><li><p>轻儿子（节点）：除了重儿子以外的结点</p></li><li><p>重边：父亲结点和重儿子连成的边</p></li><li><p>轻边：父亲节点和轻儿子连成的边</p></li><li><p>重链：由多条重边连接而成的路径，如果一个点没连接重边，那该节点也可以是一条重链</p></li><li><p>轻链：由多条轻边连接而成的路径</p></li></ul><p>如图：<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/7g3wqit1.png" alt="例子"><br>可以看到：对于节点1，节点4的子树的节点比2,3的多，所以4是重儿子，对于4节点9的子树的节点比8,9的多，所以9是重儿子，以此类推，图中黑色的节点是重儿子，其余的节点是轻儿子。  </p><p>红边是重边，黑边是轻边</p><p>1 - 4 - 9 - 13 - 14；<br>8；<br>10；<br>3 - 7；<br>2 - 6 - 11；<br>5；都是重链</p><p>我们发现：叶节点没有重儿子，非叶节点有且只有1个重儿子</p><p>但要注意，并不是轻儿子之后全是轻儿子，比如2后面就有6和11两个重儿子，也就是说，<strong>当一个节点选了他的重儿子之后，我们并不能保证它的轻儿子就是叶节点，所以我们就以这个轻儿子为根，再去选这个轻儿子的轻重儿子</strong></p><h2 id="化树为列"><a href="#化树为列" class="headerlink" title="化树为列"></a>化树为列</h2><p>我们先用dfs序来实现将树化为序列，但dfs时我们优先搜索重儿子，这样的好处是可以保证一段重链在区间上是连续的，如上面的图上，dfs序应为：1-4-9-13-14-8-10-3-7-2-6-11-5</p><p>那么一条路径就可以拆分成最多 $\log{n}$ 条重链，对应到序列上是最多 $\log{n}$ 个区间。</p><p>现在，问题就是如何找到一条路径对应的区间。</p><h2 id="寻找区间"><a href="#寻找区间" class="headerlink" title="寻找区间"></a>寻找区间</h2><p>对于节点 $x,y$ 若要求 $x$ 到 $y$ 的路径对应的区间，可以用如下方法： </p><ol><li><p>找到 $x,y$ 中所在重链的顶点较低的点（即层数较深的点），不妨设为 $x$ ，并设 $x$ 所在重链顶点为 $z$   </p></li><li><p>对区间 $[z,x]$ 操作，更新 $x$ 为 $z$ 的父节点</p></li><li><p>重复2、3步，直到 $x,y$ 在同一条重链上（这条重链一定是它们的最近公共祖先所在重链）  </p></li><li><p>对区间 $[x,y]$ （或 $[y,x]$ ）操作即可</p></li></ol><p>如上面的图中，要找节点13到节点5的路径，可以让 $x=13$ , $y=5$ 过程如下：  </p><ol><li><p>第一步后，找到较低的点是 $y=5$ ，顶点 $z=5$ </p></li><li><p>第二步，操作区间 $[z,y]=[5,5]$ ，更新 $y=2$</p></li><li><p>第三步，重复，操作区间 $[z,y]=[2,2]$ ，更新 $y=1$ </p></li><li><p>第五步, $x,y$ 已在一条重链上，操作区间 $[y,x]=[1,13]$</p></li></ol><p>一般来说，对于每个区间，我们用线段树、分块等方式去维护，最多有 $\log{n}$ 个区间，故一般时间复杂度为 $O(log^2{n})$ </p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.com.cn/problem/P3384">P3384</a><br>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> n,m,root,p;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ver,ne;</span><br><span class="line">&#125;e[N*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> h[N],idx=<span class="number">0</span>,w[N];</span><br><span class="line"><span class="keyword">int</span> id[N],nw[N],cnt=<span class="number">0</span>; <span class="comment">//id:节点在dfs序中的编号,nw:dfs序列每个编号对应的权值</span></span><br><span class="line"><span class="keyword">int</span> dep[N],size[N],top[N],fa[N],h_son[N]; <span class="comment">//dep:节点深度,size:节点为根的子</span></span><br><span class="line">                                          <span class="comment">//树的大小,top:节点所在重链的顶点</span></span><br><span class="line">                                          <span class="comment">//fa:父节点,h_son:重儿子</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ST</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    LL add,sum;</span><br><span class="line">&#125;tr[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    e[idx].ver=y,e[idx].ne=h[x],h[x]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> father,<span class="keyword">int</span> depth)</span></span>&#123; <span class="comment">//求每个的重儿子</span></span><br><span class="line">    dep[x]=depth;</span><br><span class="line">    fa[x]=father;</span><br><span class="line">    size[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[x];i!=<span class="number">-1</span>;i=e[i].ne)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=e[i].ver;</span><br><span class="line">        <span class="keyword">if</span>(y==father) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(y,x,depth+<span class="number">1</span>);</span><br><span class="line">        size[x]+=size[y];</span><br><span class="line">        <span class="keyword">if</span>(size[h_son[x]]&lt;size[y]) h_son[x]=y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> t)</span></span>&#123; <span class="comment">//求dfs序,t:当前节点所在重链的顶点</span></span><br><span class="line">    id[x]=++cnt;</span><br><span class="line">    nw[cnt]=w[x];</span><br><span class="line">    top[x]=t;</span><br><span class="line">    <span class="keyword">if</span>(!h_son[x]) <span class="keyword">return</span> ; <span class="comment">//若是叶节点,直接返回</span></span><br><span class="line">    <span class="built_in">dfs2</span>(h_son[x],t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[x];i!=<span class="number">-1</span>;i=e[i].ne)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=e[i].ver;</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x]||y==h_son[x]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(y,y); <span class="comment">//轻儿子一定是其所在重链的顶点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    tr[u].sum=tr[u&lt;&lt;<span class="number">1</span>].sum+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">    tr[u].sum%=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].add)&#123;</span><br><span class="line">        tr[u&lt;&lt;<span class="number">1</span>].add+=tr[u].add;</span><br><span class="line">        tr[u&lt;&lt;<span class="number">1</span>].add%=p;</span><br><span class="line">        tr[u&lt;&lt;<span class="number">1</span>].sum+=tr[u].add*(tr[u&lt;&lt;<span class="number">1</span>].r-tr[u&lt;&lt;<span class="number">1</span>].l+<span class="number">1</span>);</span><br><span class="line">        tr[u&lt;&lt;<span class="number">1</span>].sum%=p;</span><br><span class="line">        tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].add+=tr[u].add;</span><br><span class="line">        tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].add%=p;</span><br><span class="line">        tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum+=tr[u].add*(tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].r-tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].l+<span class="number">1</span>);</span><br><span class="line">        tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum%=p;</span><br><span class="line">        tr[u].add=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    tr[u].l=l;</span><br><span class="line">    tr[u].r=r;</span><br><span class="line">    tr[u].add=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tr[u].sum=nw[r];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">push_up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)&#123;</span><br><span class="line">        tr[u].add+=k;</span><br><span class="line">        tr[u].add%=p;</span><br><span class="line">        tr[u].sum+=k*(tr[u].r-tr[u].l+<span class="number">1</span>);</span><br><span class="line">        tr[u].sum%=p;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">push_down</span>(u);</span><br><span class="line">    <span class="keyword">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="built_in">push_up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">ask</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line">    <span class="built_in">push_down</span>(u);</span><br><span class="line">    <span class="keyword">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    LL res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) res+=<span class="built_in">ask</span>(u&lt;&lt;<span class="number">1</span>,l,r),res%=p;</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) res+=<span class="built_in">ask</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r),res%=p;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify_path</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[u]!=top[v])&#123;  <span class="comment">//当这两个点不在同一重链</span></span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>,id[top[u]],id[u],k); <span class="comment">//注意在dfs序中top[u]在u前面</span></span><br><span class="line">        u=fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&lt;dep[v]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">    <span class="built_in">modify</span>(<span class="number">1</span>,id[v],id[u],k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">ask_path</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    LL res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">        res+=<span class="built_in">ask</span>(<span class="number">1</span>,id[top[u]],id[u]);</span><br><span class="line">        res%=p;</span><br><span class="line">        u=fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&lt;dep[v]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">    res+=<span class="built_in">ask</span>(<span class="number">1</span>,id[v],id[u]);</span><br><span class="line">    <span class="keyword">return</span> res%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify_tree</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="built_in">modify</span>(<span class="number">1</span>,id[u],id[u]+size[u]<span class="number">-1</span>,k); <span class="comment">//在dfs序中,以一个节点为根的子树一定</span></span><br><span class="line">                                       <span class="comment">//跟在这个节点后面</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">ask_tree</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ask</span>(<span class="number">1</span>,id[u],id[u]+size[u]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;root,&amp;p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line">        w[i]%=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="built_in">add</span>(x,y);</span><br><span class="line">        <span class="built_in">add</span>(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(root,<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(root,root);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,cnt);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> op,u,v,k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;op,&amp;u);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;v,&amp;k);</span><br><span class="line">            <span class="built_in">modify_path</span>(u,v,k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;v);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">ask_path</span>(u,v));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line">            <span class="built_in">modify_tree</span>(u,k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">ask_tree</span>(u));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 树链剖分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>期望DP和概率DP</title>
      <link href="/2021/11/22/%E6%9C%9F%E6%9C%9BDP%E5%92%8C%E6%A6%82%E7%8E%87DP/"/>
      <url>/2021/11/22/%E6%9C%9F%E6%9C%9BDP%E5%92%8C%E6%A6%82%E7%8E%87DP/</url>
      
        <content type="html"><![CDATA[<p>${\color{red} 快跑啊}$</p><span id="more"></span><h1 id="期望DP和概率DP"><a href="#期望DP和概率DP" class="headerlink" title="期望DP和概率DP"></a>期望DP和概率DP</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><p>随机变量：有多种可能值的变量，一般记为 $X$</p></li><li><p>概率：一个事件发生的可能性，一般记为 $P(A)$ ，以下简记 $P(X==x_i)$ 为 $P(x_i)$ </p></li><li><p>期望：一个事件发生的概率乘上权值，记为 $E(X)$ </p></li><li><p>方差：用于描述一组数据的波动程度，记为 $Var(X)$ ，有<br>$$<br>Var(X)=\frac{\sum(x_i-\bar{x})}{n}<br>$$</p></li><li><p>依赖：一个随机变量 $X$ 的取值取决（或有关）于变量 $Y$ ，或者说在保证 $Y$ 发生的情况下发生 $X$ ，记为 $X|Y$ ，一下简记 $P(X==x_i|Y==y_i)$ 为 $P(x_i|y_i)$</p></li><li><p>并：两个事件同时发生（即“且”），记为 $A\cap B$（也可以记为 $AB$ ）</p></li><li><p>交：两个事件分别发生（即“或”），记为 $A\cup B$</p></li><li><p>区分下列概念：</p><p>$E(X)$ ：一个数，是 $x_i$ 的<strong>加权平均值</strong>；</p><p>$E(X|Y)$ ：随机变量，关于 $Y$ 的函数，没有固定的 $y$ 值；</p><p>$E(X|Y==y)$ ：一个数，是局限在 $\omega\in{\omega|Y(\omega)==y}$ 时， $X(\omega)$ 的取值的<strong>局部加权平均值</strong></p></li></ul><h2 id="定理-公式"><a href="#定理-公式" class="headerlink" title="定理/公式"></a>定理/公式</h2><ul><li><p>对于两个独立事件 $A,B$ ，有：<br>$$<br>\begin{align}<br>P(AB)=P(A)P(B)\\<br>E(AB)=E(A)E(B)<br>\end{align}<br>$$<br>正确性显然</p></li><li><p>期望的线性性：</p><p>（1）对于两个随机变量 $X,Y$ （可以相关），有：</p><p>$$<br>E(X+Y)=E(X)+E(X)<br>$$</p><p>证明：</p><p>$$<br>\begin{align}<br>E(X+Y)<br>&amp;=\sum_{i}\sum_{j}P(X==i\wedge Y==j)\times(i+j)\\<br>&amp;=\sum_{i}\sum_{j}P(X==i\wedge Y==j)\times i+\sum_{i}\sum_{j}P(X==i\wedge Y==j)\times j\\<br>&amp;=\sum_{i}i\sum_{j}P(X==i\wedge Y==j)+\sum_{j}j\sum_{i}P(X==i\wedge Y==j)\\<br>&amp;=\sum_{i}iP(X==i)+\sum_{j}jP(Y==j)\\<br>&amp;=E(X)+E(Y)<br>\end{align}<br>$$</p></li></ul><p>  （2）对于一个常量 $C$ 有：<br>$$<br>  E(CX)=CE(X)<br>$$</p><ul><li><p>前缀和技巧：对于离散变量（取值只有整数） $X$ ，有<br>$$<br>P(X==k)=P(X\le k)-P(X\le k-1)<br>$$</p></li><li><p>关于方差的性质:：</p><p>（1）概率与方差的关系：<br>$$<br>\begin{align}<br>Var(X)<br>&amp;=\frac{\sum_{i}(x_i-\bar{x})}{n}\\<br>&amp;=\sum_{i}\frac{(x_i-\bar{x})}{n}\\<br>&amp;=\sum_{x_k\in X}(x_k-\bar{x})P(x_k)<br>\end{align}<br>$$<br>因为一个值出现的次数除以 $n$ 就是选它的概率</p><p>（2）期望与方差的关系：</p><p>首先，明显有 $\bar{x}=E(X)$ ，然后，我们再考虑对于一组数据 $X$ ，令 $y_i=(x_i-E(X))^2$ ，那么明显概率不变，有 $P(y_i)=P(x_i)$ ，则：<br>$$<br>\begin{align}<br>E(Y)<br>&amp;=\sum_{y_k\in Y}y_kP(y_k)\\<br>&amp;=\sum_{x_k\in X}(x_k-E(X))^2P(x_k)\\<br>&amp;=Var(X)<br>\end{align}<br>$$<br>故有：</p><p>$$<br>Var(X)=E((X-E(X))^2)<br>$$</p><p>（3）比较常用的一个性质：</p><p>$$<br>Var(X)=E(X^2)-E(X)^2<br>$$</p><p>需要注意 $E(X)=\bar{x}$ 是一个常数，故  $\sum2E(X)xP(x)=2E(X)\sum xP(x)=2E(X)^2$ ，另外谨记 $\sum P(x)=1$ ，则上述性质证明如下：<br>$$<br>\begin{align}<br>Var(X)<br>&amp;=E((X-E(X))^2)\\<br>&amp;=E(X^2-2XE(X)+E(X)^2)\\<br>&amp;=E(X^2)-E(2XE(X))+E(E(X)^2)\\<br>&amp;=E(X^2)-\sum2E(X)xP(x)+\sum E(X)^2P(x)\\<br>&amp;=E(X^2)-2E(X)^2+E(X)^2\sum P(x)\\<br>&amp;=E(X^2)-2E(X)^2+E(X)^2\\<br>&amp;=E(X^2)-E(X)^2<br>\end{align}<br>$$</p></li><li><p>全期望公式：<br>$$<br>E(E(X|Y))=E(X)<br>$$<br>证明如下：<br>$$<br>\begin{align}<br>E(E(X|Y))<br>&amp;=\sum_{y}E(X|Y==y)P(y)\\<br>&amp;=\sum_{y}{\huge(}\sum_{x}xP(x|y){\huge)}P(y)\\<br>&amp;=\sum_{y}\sum_{x}xP(x|y)P(y)\\<br>&amp;=\sum_{y}\sum_{x}xP(y|x)P(x)\\<br>&amp;=\sum_{x}\sum_{y}xP(y|x)P(x)\\<br>&amp;=\sum_{x}xP(x){\huge(}\sum_{y}P(y|x){\huge)}\\<br>&amp;=\sum_{x}xP(x)\\<br>&amp;=E(X)<br>\end{align}<br>$$</p></li><li><p>全概率公式：<br>$$<br>P(B)=\sum_{a_i\in A}P(a_i)P(B|a_i)<br>$$</p></li></ul><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>对于一些比较难找到递推关系的数学期望问题，可以利用期望的定义式，根据实际情况以概率或者方案数（也就是概率乘总方案数）作为一种状态，而下标直接或间接对应了这个概率下的变量值，将问题变成比较一般的统计方案数问题或者利用全概率公式计算概率的递推问题</p><p>一般来说，概率DP找到正确的状态定义后，转移是比较容易想到的。但状态一定是“可数”的，把有范围的整数作为数组下标。事实上，将问题直接作为状态是最好的。如问“ $n$ 人做 $X$ 事的期望次数”，则设计状态为 $f[i]$ 表示 $i$ 个人做完事的期望。转移一般是递推，即从上一个状态转移得（填表）或转移向下一个状态（刷表），后者更为常用</p><p>有时期望DP需以最终状态为初始状态转移，即逆推。如 $f[i]$ 表示期望还要走 $f[i]$ 步到达终点，这种状态的转移是刷表法，形如 $f[i]=\sum p[i\rightarrow j]f[j]+w[i\rightarrow j]$ ，其中 $p[\ ]$ 表示转移的概率， $w[\ ]$ 表示转移对答案的贡献，一般来说，初始状态确定时可用顺推，终止状态确定时可用逆推</p><p>还有些时候，要结合高斯消元来考虑</p><h2 id="例题一"><a href="#例题一" class="headerlink" title="例题一"></a>例题一</h2><p><a href="https://www.luogu.com.cn/problem/P4284">概率充电器</a></p><p>考虑算出每个点充电的概率 $P(i)$ ，利用期望的线性性， $\sum P(i)$ 就是答案</p><p>利用树形DP，考虑先求出每个点通过自己或是子树冲上电的概率，定为 $f[\ ]$ ，转移为<br>$$<br>\forall v\in son(u)\\<br>f[u]= f[u]+f[v]* P(v\rightarrow u)-f[u]* f[v]* P(v\rightarrow u)<br>$$<br>这里用了一个容斥：<br>$$<br>\begin{align}<br>P(A\cup B)\\<br>=P(A)+P(B)-P(AB)\\<br>=P(A)+P(B)-P(A)P(B)<br>\end{align}<br>$$<br>正确性显然：两个事件至少发生一个的概率就是分别发生的概率减去都发生的概率 </p><p>然后再来考虑 $u$ 如何从父节点转移，转移方程类似于上面，但此时我们需要的是父节点不通过 $u$ 充上电的概率，令 $A$ 为“父节点不通过 $u$ 充上电”， $B$ 为“父节点通过 $u$ 充上电”，利用 $P(A)=\frac{P(A\cup B)-P(B)}{1-P(B)}$ 计算，注意特判 $P(B)==1$ 的情况</p><p>事时间复杂度 $O(n)$ </p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IL inline</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> E = <span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ne, ver;</span><br><span class="line">    <span class="keyword">double</span> p;</span><br><span class="line">&#125;e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> h[N], idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> f[N], ans = <span class="number">0</span>;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">double</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx].ver = y, e[idx].p = z, e[idx].ne = h[x], h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">    &#123;</span><br><span class="line">        y = e[i].ver;</span><br><span class="line">        <span class="keyword">if</span> (y == fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dp</span>(y, x);</span><br><span class="line">        f[x] = f[x] + f[y] * e[i].p - f[x] * f[y] *e[i].p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">dp2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (e[i].ver == fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">double</span> pa, pb;</span><br><span class="line">        pb = f[e[i].ver] * e[i].p;</span><br><span class="line">        <span class="keyword">if</span> (pb + E &gt; <span class="number">1</span> &amp;&amp; pb - E &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">dp2</span>(e[i].ver, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pa = (f[x] - pb) / (<span class="number">1</span> - pb);</span><br><span class="line">            f[e[i].ver] = f[e[i].ver] + pa * e[i].p - f[e[i].ver] * pa *e[i].p;</span><br><span class="line">            <span class="built_in">dp2</span>(e[i].ver, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">        h[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y, z; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">        <span class="built_in">add</span>(x, y, (<span class="keyword">double</span>)z / <span class="number">100.0</span>), <span class="built_in">add</span>(y, x, (<span class="keyword">double</span>)z / <span class="number">100.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, q; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q), f[i] = (<span class="keyword">double</span>)q / <span class="number">100.0</span>;</span><br><span class="line">    <span class="built_in">dp</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">dp2</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        ans += f[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.6lf\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题二"><a href="#例题二" class="headerlink" title="例题二"></a>例题二</h2><p><a href="https://www.luogu.com.cn/problem/P3239">亚瑟王</a></p><p>依旧利用期望的线性性，考虑求出每张卡被出掉的概率，不难发现，一张卡被出的概率与被经过的次数有关，于是设 $f[i][j]$ 表示 $r$ 轮后，前 $i$ 张卡被选了 $j$ 张的概率，那么 $f[i-1][j]$ 就是 $i$ 被考虑 $r-j$ 次的概率（因为还有 $r-j$ 张在 $i$ 及以后的牌中选），于是 $i$ 被选到的概率为 $\sum_{j&gt;0}f[i-1][j]\times(1-(1-p[i])^{r-j})$ ，则转移就是枚举选不选 $i+1$<br>$$<br>\begin{align}<br>&amp;\text{选：}\\<br>&amp;f[i + 1][j + 1]+=f[i][j]* (1-(1-p[i+1])^{r-j})\\<br>&amp;\text{不选：}\\<br>&amp;f[i + 1][j]+=f[i][j]* (1-p[i+1])^{r-j}\\<br>\end{align}<br>$$<br>时间复杂度 $O(Tnr)$ </p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IL inline</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">220</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Card</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> p, d;</span><br><span class="line">&#125; a[N];</span><br><span class="line"><span class="keyword">double</span> f[N][N], ans;</span><br><span class="line"><span class="function">IL <span class="keyword">double</span> <span class="title">qpow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">            res = res * x;</span><br><span class="line">        x = x * x;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">int</span> n, r;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;r);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>, &amp;a[i].p, &amp;a[i].d);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= r; ++j)</span><br><span class="line">                f[i][j] = <span class="number">0</span>;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> <span class="keyword">_t</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="built_in">min</span>(i, r); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">_t</span> = <span class="built_in">qpow</span>(<span class="number">1</span> - a[i + <span class="number">1</span>].p, r - j);</span><br><span class="line">                f[i + <span class="number">1</span>][j] += f[i][j] * <span class="keyword">_t</span>;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; r)</span><br><span class="line">                &#123;</span><br><span class="line">                    f[i + <span class="number">1</span>][j + <span class="number">1</span>] += f[i][j] * (<span class="number">1</span> - <span class="keyword">_t</span>);</span><br><span class="line">                    ans += f[i][j] * (<span class="number">1</span> - <span class="keyword">_t</span>) * a[i + <span class="number">1</span>].d;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.10lf\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题三"><a href="#例题三" class="headerlink" title="例题三"></a>例题三</h2><p><a href="https://www.luogu.com.cn/problem/P3232">游走</a></p><p>明显，被经过次数多的边编号要小，这启发我们去求每条边期望被经过的次数，但 $m$ 的范围过大，直接求时间复杂度无法接受，于是考虑将边的期望转换为点的期望</p><p>设 $du[i]$ 表示第 $i$ 个点的度， $f[i]$ 表示它的期望经过次数，则有<del>有个鬼啊，我想不到啊！！！</del> ：</p><p>$$<br>f[i]=<br>\begin{cases}<br>&amp;\sum_{(i,j)\in E,j\ne n}\frac{f[j]}{du[j]}+1&amp;i=1\\<br>&amp;\sum_{(i,j)\in E,j\ne n}\frac{f[j]}{du[j]}&amp;1&lt;i&lt;n<br>\end{cases}<br>$$</p><p>需要注意：到 $n$ 点就停止了，所以不考虑从 $n$ 转移过来</p><p>那么第 $i$ 条边的期望经过次数 $g[i]$ 就是<br>$$<br>\begin{align}<br>&amp;g[i]=\frac{f[u]}{du[u]}+\frac{f[v]}{du[v]}&amp;E_i=(u,v),u\ne n,v\ne n<br>\end{align}<br>$$<br>那么只需求出 $f$ 就好了，然鹅，由于是DAG，转移的顺序无法解决（怎么转都有后效性），所以，高斯消元解决<del>不会就和我一样愣着吧</del></p><p>超级毒瘤的代码<del>我尽量标准化了</del>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IL inline</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500</span> + <span class="number">5</span>, M = <span class="number">125000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-12</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x[N][N];</span><br><span class="line">&#125; a;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ne, from, ver;</span><br><span class="line">&#125; e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> h[N], idx = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> du[N];</span><br><span class="line"><span class="keyword">double</span> g[M], ans = <span class="number">0</span>;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx].from = x, e[idx].ver = y, e[idx].ne = h[x], h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">int</span> <span class="title">gauss</span><span class="params">(Matrix &amp;x, <span class="keyword">int</span> _n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c, r, <span class="keyword">_t</span>;</span><br><span class="line">    <span class="keyword">for</span> (c = <span class="number">1</span>, r = <span class="number">1</span>; c &lt;= _n; ++c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">_t</span> = r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &lt;= _n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(x.x[i][c]) &gt; <span class="built_in">fabs</span>(x.x[<span class="keyword">_t</span>][c]))</span><br><span class="line">                <span class="keyword">_t</span> = i;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(x.x[<span class="keyword">_t</span>][c]) &lt; eps)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = c; i &lt;= _n + <span class="number">1</span>; ++i)</span><br><span class="line">            <span class="built_in">swap</span>(x.x[<span class="keyword">_t</span>][i], x.x[r][i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = _n + <span class="number">1</span>; i &gt;= c; --i)</span><br><span class="line">            x.x[r][i] /= x.x[r][c];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r + <span class="number">1</span>; i &lt;= _n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(x.x[i][c]) &gt; eps)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = _n + <span class="number">1</span>; j &gt;= c; --j)</span><br><span class="line">                    x.x[i][j] -= x.x[r][j] * x.x[i][c];</span><br><span class="line">        ++r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= _n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &lt;= _n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(x.x[i][_n + <span class="number">1</span>]) &gt; eps)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = _n; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= _n; ++j)</span><br><span class="line">            x.x[i][_n + <span class="number">1</span>] -= x.x[i][j] * x.x[j][_n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">        h[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u, v), <span class="built_in">add</span>(v, u);</span><br><span class="line">        ++du[u], ++du[v];</span><br><span class="line">    &#125;</span><br><span class="line">    --n; <span class="comment">// 构建矩阵时注意第n个点不转移,所以只有n-1个点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n + <span class="number">1</span>; ++j)</span><br><span class="line">            a.x[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        a.x[i][i] = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = h[i], k; j != <span class="number">-1</span>; j = e[j].ne)</span><br><span class="line">        &#123;</span><br><span class="line">            k = e[j].ver;</span><br><span class="line">            <span class="keyword">if</span> (k == n + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            a.x[i][k] = <span class="number">-1.0</span> / du[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a.x[<span class="number">1</span>][n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">gauss</span>(a, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        u = e[i &lt;&lt; <span class="number">1</span>].from;</span><br><span class="line">        v = e[i &lt;&lt; <span class="number">1</span>].ver;</span><br><span class="line">        g[i] = a.x[u][n + <span class="number">1</span>] / du[u] + a.x[v][n + <span class="number">1</span>] / du[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(g + <span class="number">1</span>, g + <span class="number">1</span> + m);</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        ans += g[i] * (m - i + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.3lf&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题四"><a href="#例题四" class="headerlink" title="例题四"></a>例题四</h2><p>最后来看一道毒瘤题</p><p><a href="https://www.luogu.com.cn/problem/P5299">Slay the Spire</a></p><h3 id="贪心策略"><a href="#贪心策略" class="headerlink" title="贪心策略"></a>贪心策略</h3><p>明显，得排个序，由于强化卡的数字至少为 $2$ ，在可以打出的 $k$ 张牌中，尽可能多的打强化卡可以使伤害最大化（当然，至少得剩下一张攻击牌，不然没伤害）</p><p>另一个方面，根据期望的线性性（<del>又是它</del>），期望造成的伤害等于<strong>强化牌的期望乘积</strong>乘上<strong>攻击牌的期望和</strong>（<del>好乱</del>），而答案乘了一个奇奇怪怪的东西后分母没了，分子的化其实就是方案数乘价值</p><h3 id="dp方程设计"><a href="#dp方程设计" class="headerlink" title="dp方程设计"></a>dp方程设计</h3><p>如此，答案就跟强化牌和攻击牌分别独立相关，这启发我们分开计算：令 $f[i][j][0]$ 表示在前 $i$ 张强化牌中取 $j$ 张且第 $i$ 张<strong>被选</strong>的选法的<strong>乘积之和</strong>， $f[i][j][1]$ 表示前 $i$ 张强化牌中取 $j$ 张（不管选没选 $i$ ）的<strong>乘积之和</strong>，令 $g[i][j][0]$ 表示在前 $i$ 张攻击牌中取 $j$ 张且第 $i$ 张<strong>被选</strong>的选法的<strong>和之和</strong>， $f[i][j][1]$ 表示前 $i$ 张强化牌中取 $j$ 张（不管选没选 $i$ ）的<strong>和之和</strong></p><p>可以看到上面的定义非常的痛苦，所以好心的我在这里写点提示：</p><ol><li>为什么要强迫选第 $i$ 张呢？这是因为<del>讨厌的</del>九条可怜是随机选的卡，若不保证选了第 $i$ 张，统计答案时会有重复（或者不好统计）</li><li>为啥都是个<strong>…之和</strong>呢？这是因为最后算的是期望（当然，它乘了个玄学的东西把分母弄没了），期望本身就该算和</li><li>那为啥还要定一个不管选没选 $i$ 的情况呢？其实是为了方便求出强迫选的情况，换句话说，是当辅助的，而在统计答案时我们也靠它们可以去掉一个循环</li></ol><p>如果理解了以上定义（没理解就看看下面的转移和统计答案辅助理解一下），则可以发现转移方程如下（ $a$  是强化牌， $b$ 是攻击牌）：<br>$$<br>\begin{align}<br>&amp;f[i][j][0]=a[i]\times f[i-1][j-1][1]\\<br>&amp;f[i][j][1]=f[i][j][0]+f[i-1][j][1]\\<br>&amp;g[i][j][0]=b[i]\times \binom{i-1}{j-1}+g[i-1][j-1][1]\\<br>&amp;g[i][j][1]=g[i][j][0]+g[i-1][j][1]<br>\end{align}<br>$$<br>需要注意的是， $g[i][j][0]$ 的转移中， $\binom{i-1}{j-1}$ 表示在 $i-1$ 个数中选择 $j-1$ 个数的方案，即从 $g[i-1][j-1][1]$ 转移到 $g[i][j][0]$ 共有 $\binom{i-1}{j-1}$ 种情况，而每种情况卡牌权值和加上了 $b[i]$ </p><p>预处理组合数，推得 $f,g$ 都可以在 $O(n^2)$ 内解决</p><h3 id="统计答案"><a href="#统计答案" class="headerlink" title="统计答案"></a>统计答案</h3><p>来看看如何计算答案！分类讨论！</p><ul><li><p>若抽出来的 $m$ 张牌中，强化牌的数量少于 $k-1$ </p><p>此时当然是把强化牌全出了，然后攻击牌从大到小依次出，可以枚举 $i,j$ 表示被选中的强化牌<strong>有</strong> $i$ 张，最后一张被选中的攻击牌<strong>是</strong>第 $j$ 张</p><p>在强化牌中选择 $i$ 张的所有合法情况下的乘积之和，其实就是 $f[n][i][1]$ </p><p>而强化牌中选择 $i$ 张，攻击牌中就要选择 $k-i$ 张，又由于最后被选中的攻击牌是第 $j$ 张，所以所有合法情况下攻击牌的和之和，其实就是 $g[j][k-i][0]$ </p><p>但不要忘了，九条她的 $m$ 张牌是随机选的！为了保证最后打出的 $k$ 张牌是我们要的 $k$ 张牌，则剩余的 $m-k$ 张牌要满足不存在强化牌且攻击牌都要排在第 $j$ 张牌的后面（这也是我们必须要枚举 $j$ 的原因），因此共有 $\binom{n-j}{m-k}$ 种方案</p><p>总之，对于这种情况，我们枚举 $i,j$ ，每次答案加 $f[n][i][1]\times g[j][k-i][0]\times\binom{n-j}{m-k}$ </p></li><li><p>若抽出来的 $m$ 张牌中，强化牌的数量大于等于 $k-1$ </p><p>此时我们选则出积最大的 $k-1$ 张强化牌，再乘上一张最大的攻击牌，可以枚举 $i,j$ 表示最后一张被选中的强化牌<strong>是</strong>第 $i$ 张，被选中的攻击牌<strong>是</strong>第 $j$ 张</p><p>在前 $i$ 张强化牌中选 $k-1$ 张，且必选第 $i$ 张，其实就是 $f[i][k-1][0]$ </p><p>在攻击牌中选了第 $j$ 张，权值就是 $g[j][1][0]=b[j]$ </p><p>和上面一样，由于是随机选牌，剩余的 $m-k$ 张牌要满足强化牌都要排在第 $i$ 张牌的后面且攻击牌都要排在第 $j$ 张牌的后面，有 $\binom{2n-i-j}{m-k}$ 种方案</p><p>总之，对于这种情况，我们枚举 $i,j$ ，每次答案加 $f[i][k-1][0]\times b[j]\times\binom{2n-i-j}{m-k}$ </p></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IL inline</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3000</span> + <span class="number">5</span>, P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"><span class="keyword">int</span> C[N][N];</span><br><span class="line"><span class="keyword">int</span> f[N][N][<span class="number">2</span>], g[N][N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function">IL <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">pred</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">            C[i][j] = (C[i - <span class="number">1</span>][j - <span class="number">1</span>] + C[i - <span class="number">1</span>][j]) % P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pred</span>(); <span class="comment">//处理C</span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line">        <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n, cmp), <span class="built_in">sort</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + n, cmp);</span><br><span class="line">        <span class="comment">//处理f</span></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j][<span class="number">0</span>] = (LL)a[i] * f[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">1</span>] % P;</span><br><span class="line">                f[i][j][<span class="number">1</span>] = (f[i][j][<span class="number">0</span>] + f[i - <span class="number">1</span>][j][<span class="number">1</span>]) % P;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理g</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                g[i][j][<span class="number">0</span>] = ((LL)b[i] * C[i - <span class="number">1</span>][j - <span class="number">1</span>] + g[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">1</span>]) % P;</span><br><span class="line">                g[i][j][<span class="number">1</span>] = (g[i][j][<span class="number">0</span>] + g[i - <span class="number">1</span>][j][<span class="number">1</span>]) % P;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//情况1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">                ans = ((LL)f[n][i][<span class="number">1</span>] * g[j][k - i][<span class="number">0</span>] % P * C[n - j][m - k] + ans) % P;</span><br><span class="line">        <span class="comment">//情况2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">                ans = ((LL)f[i][k - <span class="number">1</span>][<span class="number">0</span>] * b[j] % P * C[<span class="number">2</span> * n - i - j][m - k] + ans) % P;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="废话"><a href="#废话" class="headerlink" title="废话"></a>废话</h2><p>啊啊啊我太弱了！同机房的 <a href="https://www.luogu.com.cn/user/342891"> ${\Huge{\color{Red}\mathfrak{dalao}}}$ </a>天天嘲笑我/(ㄒoㄒ)/~~</p><p>啊啊啊啊怎么办要被自己菜死了！┏┛墓┗┓…(((m -__-)m</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论,数学 </tag>
            
            <tag> dp </tag>
            
            <tag> 期望 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>莫队</title>
      <link href="/2021/11/22/%E8%8E%AB%E9%98%9F/"/>
      <url>/2021/11/22/%E8%8E%AB%E9%98%9F/</url>
      
        <content type="html"><![CDATA[<p>然而还没写完（不想填了）</p><span id="more"></span><p>莫队其实是一种基于<strong>分块</strong>的<strong>暴力</strong>思想，是一种<strong>离线算法</strong>，下面用例题来讲</p><h1 id="例题一"><a href="#例题一" class="headerlink" title="例题一"></a>例题一</h1><p><a href="https://www.luogu.com.cn/problem/P1972">P1972</a><br>（本题正解不是莫队，但我们可以用莫队<del>玄学艹掉</del>得86分）<br>抽象出下面一个问题：</p><p>有一个长为 $n$ 的数列 $A$ 和 $m$ 个询问，每个询问格式为 $l,r$ ，表示查询区间 $[l,r]$ 中不同的数有多少个。</p><p>本题的暴力做法灰常简单——对于每一个询问，扫描一遍数列，用一个 $cnt$ 数组统计每个数出现的次数，再扫描一遍 $cnt$ ，统计有多少个非零。时间复杂度为 $O(m（n+S))$ （其中 $S$ 表示 $cnt$ 数组的长度，即数据范围）。</p><p>一个简单的优化可以把 $S$ 去掉：<br>在统计时 $a_i$ 出现，判定 $cnt[a_i]$ 若为0， $ans++,cnt[a_i]++$ ,否则只是 $cnt[a_i]++$ 。则时间复杂度优化为 $O(mn)$</p><p>可是时间复杂度还是太大了，为此，我们用一个类似双指针的优化。</p><h2 id="优化一"><a href="#优化一" class="headerlink" title="优化一"></a>优化一</h2><p>思考下面一种情况，上一个询问我们已经求出 $[i,j]$ （这里 $i,j$ 是两个指针）中不同的数的个数，储存在 $ans$ 中，并且 $cnt$ 已经跟新好了，现在我们要求 $[l,r]$ 。<br>求法当然是移动指针，具体如下：  </p><ol><li><p>将 $j$ 一步步向后走直到 $j=r$ ，并将 $cnt[a_j]++$ ，如果 $a_j$ 是新出现的，则 $res++$ 。</p></li><li><p>将 $i$ 一步步向后走直到 $i=l$ ，并将 $cnt[a_j]–$ ，如果 $cnt[a_j]=0$ ，则 $res–$ 。</p></li></ol><p>以上方法<strong>最坏情况下</strong>的时间复杂度仍为 $O(mn)$ ，可恶啊，<del>我们优化了个寂寞！</del></p><h2 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h2><p>像我一样的蒟蒻们可能到这里就放弃了，但<del>某国国家队的某莫涛队员</del>dalao们却开始思考起来：为啥这个优化<del>优化了个寂寞</del>会到最坏情况呢？当然是因为查询的问题不确定，本个查询和上个查询的区间可能完全没有交集，甚至相隔甚远，这使得指针移动耗费了大量时间。于是，dalao们提出了解决方法——<br>既然查询的顺序会影响时间复杂度，那么我们调整一下查询顺序不就好了！</p><h2 id="优化二"><a href="#优化二" class="headerlink" title="优化二"></a>优化二</h2><p>优化一的时间复杂度在 $O(n^2)$ ，而用了dalao的思路后可以优化为 $O(n\sqrt{n})$ 。  </p><p>先读入所有查询，将二元组 $(l_i,r_i)$ 以 $r_i$ （也可以 $l_i$ ）为关键字排序，完成后以 $r_i$ 有序来查询，这样指针 $j$ 的跳转次数不超过 $n$ 次（因为不会来回跳转）。但指针 $i$ 怎么办呢？dalao也给出方法——不会就分块呗。</p><p>我们在排序时加入第二个关键字——分块的编号。我们以 $l_i$ 所在块的编号为第一关键字， $r_i$ 为第二关键字来从小到大排序。</p><p>综上，我们将所有的查询操作分成长度为 $\sqrt{n}$ 的 $\sqrt{n}$ 块，每一块内的 $r_i$ 是单调递增的。则每一块内部 $j$ 的跳转次数不超过 $n$ 次，共 $\sqrt{n}$ 块；在块内时 $i$ 的移动次数不超过块的长度，即 $\sqrt{n}$ ，而在跨块时移动次数不超过两块的长度，即 $2\sqrt{n}$。那么时间总复杂度为 $O(n\sqrt{n})$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, len;</span><br><span class="line"><span class="keyword">int</span> w[N], ans[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Question</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, l, r;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> id(i) q[i].id</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(i) q[i].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(i) q[i].r</span></span><br><span class="line">&#125; q[N];</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            f = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x / len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Question &amp;a, <span class="keyword">const</span> Question &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="built_in">get</span>(a.l), j = <span class="built_in">get</span>(b.l);</span><br><span class="line">    <span class="keyword">if</span> (i != j)</span><br><span class="line">        <span class="keyword">return</span> i &lt; j;</span><br><span class="line">    <span class="keyword">return</span> a.r &lt; b.r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cnt[x])</span><br><span class="line">        res++;</span><br><span class="line">    cnt[x]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt[x]--;</span><br><span class="line">    <span class="keyword">if</span> (!cnt[x])</span><br><span class="line">        res--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        w[i] = <span class="built_in">read</span>();</span><br><span class="line">    m = <span class="built_in">read</span>();</span><br><span class="line">    len = <span class="built_in">sqrt</span>((<span class="keyword">double</span>)n * n / m); <span class="comment">//len的长度很玄学,会直接影响时间复杂度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        q[i].id = i;</span><br><span class="line">        q[i].l = <span class="built_in">read</span>();</span><br><span class="line">        q[i].r = <span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q, q + m, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>, j = <span class="number">0</span>, i = <span class="number">1</span>, res = <span class="number">0</span>; k &lt; m; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; <span class="built_in">r</span>(k))</span><br><span class="line">            <span class="built_in">add</span>(w[++j], res);</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="built_in">r</span>(k))</span><br><span class="line">            <span class="built_in">del</span>(w[j--], res);</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="built_in">l</span>(k))</span><br><span class="line">            <span class="built_in">del</span>(w[i++], res);</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="built_in">l</span>(k))</span><br><span class="line">            <span class="built_in">add</span>(w[--i], res);</span><br><span class="line">        ans[<span class="built_in">id</span>(k)] = res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="例题二（带修改的莫队）"><a href="#例题二（带修改的莫队）" class="headerlink" title="例题二（带修改的莫队）"></a>例题二（带修改的莫队）</h1><p><a href="https://www.luogu.com.cn/problem/P1903">P1903</a>  </p><h2 id="新指针"><a href="#新指针" class="headerlink" title="新指针"></a>新指针</h2><p>本题多了一种操作，即可以修改数列 $A$ 的元素。<br>为了解决该问题，我们给询问加一维 $k$ ，即询问 $l\ r\ k$ 表示“在第 $k$ 次修改后 $[l,r]$ 中不同的数的个数”，那么我们用三个指针（ $i,j,k$ ）来跳转。</p><p>指针 $i,j$ 都很好跳转，但 $k$ 的跳转我们必须认真分析一下了：<br>当 $k$ 从 $t-1$ 跳转到 $t$ 时，由于每次操作只会修改一个数的值（设为 $a_x$ ），那么如果 $x\in[l,r]$ 那么我们就必须更新 $cnt$ 和 $res$ 否则我们就不管它。跳转一次的时间复杂度为 $O(1)$ 。</p><p>但是，问题又双叒叕来了——重 $t$ 跳转会 $t-1$ 咋办？询问里面可没存原数列啊！不过，dalao有dalao的解决办法：设操作 $t$ 的修改是“把 $a_x$ 重 $y$ 修改为 $z$ ”，我们在修改完后交换 $y,z$ ，即让操作 $t$ 的修改变为“把 $a_x$ 重 $z$ 修改为 $y$ ”，这样，不管是加还是减，只要经过操作 $t$ 就执行即可。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>解决完新指针 $k$ 的问题后，聪明的dalao又开始思考新的问题了——该如何排序呢？</p><p>我们发现，只要以某一个指针为关键字，即让该指针单调，那么该扫描该指针的时间复杂度就会从 $O(n^2)$ 变成 $O(n)$ 。so，our思路还是让一个指针单调，其他指针分块。</p><p>所以排序变成一个三关键字排序：  </p><ol><li><p> $l$ 所在块的编号</p></li><li><p> $r$ 所在块的编号</p></li><li><p> $t$</p></li></ol><h2 id="块的大小"><a href="#块的大小" class="headerlink" title="块的大小"></a>块的大小</h2><p>然后，我们就来到了莫队里最玄学的地方——每一块该有多大呢？<br>像我一样的蒟蒻随便取个 $\sqrt{n}$ 或某个常数就可以了。<br>但总有像 <del>xyc</del> 一样的dalao喜欢<del>秀智商</del>严谨计算：</p><p>设每一块的大小为 $b$ ，则块的数量为 $\frac{n}{b}$ 。<br>那么，指针 $i$ （对应 $l$ ） 在块内移动的次数最大为 $b$ 有 $m$ 个问题，跨块的话每次最多移动 $2b$ （两个块的长度），有 $\frac{n}{b}$ 块，所以总的时间复杂度为 $O(b\times m+2b\times \frac{n}{b})=O(bm+n)$ 。  </p><p>指针 $j$ 的情况有点复杂。 $j$ 在块内和 $i$ 一样，最多为 $am$ 。但块间移动时，对于 $i$ 的每一个块， $j$ 最坏都会从第1块移动到第 $\frac{n}{b}$ 块，每次块间移动为 $O(2b \times \frac{n}{b})=O(n)$ ， $i$ 共有 $\frac{n}{b}$ 块，所以共为 $\frac{n^2}{b}$ ，总的时间复杂度为 $O(bm+\frac{n^2}{b})$</p><p>指针 $k$ 的在 $l,r$ 确定的情况下是单调的，最多移动 $t$ 次。而 $l,r$ 各有 $\frac{n}{b}$ 种情况，故总时间复杂度为 $O(\frac{n^2}{b^2}t)$</p><p>那么，如何取 $b$ 使 $max(O(bm+n),O(bm+\frac{n^2}{b}),O(\frac{n^2}{b^2}t))$ 最小呢？<br>由于 $m=n,bm&gt;n$ ，不妨化简为 $O(bn),O(bn+\frac{n^2}{b}),O(\frac{n^2}{b^2}t)$ 。<br>如果 $b\le \sqrt{n}$ ，则 $\frac{n^2}{b^2}t \ge nt$ 时间复杂度为 $O(n^2)$ 级别，过大，故必须保证 $b \ge \sqrt{n}$ 。<br>那么就有 $\frac{n^2}{b} \le bn$ ，故 $O(bn+\frac{n^2}{b})$ 可化为 $O(bn)$ 。<br>现在只需要比较 $bn$ 和 $\frac{n^2}{b^2}t$ ，使二者的最大值最小，只需解一个方程 $bn=\frac{n^2}{b^2}t$ ，解得 $b=\sqrt[3]{nt}$ 。</p><p>综上，当 $b=\sqrt[3]{nt}$ 时，时间复杂度最优为 $O(\sqrt[3]{n^4t})\approx 10^6\sim10^7$ 。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">133333</span> + <span class="number">5</span>, S = <span class="number">1000000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, mq, mc, len;</span><br><span class="line"><span class="keyword">int</span> w[N], cnt[S], ans[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Question</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, l, r, t;</span><br><span class="line">&#125; q[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Modify</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> p, c;</span><br><span class="line">&#125; c[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x / len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Question &amp;a, <span class="keyword">const</span> Question &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> al = <span class="built_in">get</span>(a.l), ar = <span class="built_in">get</span>(a.r);</span><br><span class="line">    <span class="keyword">int</span> bl = <span class="built_in">get</span>(b.l), br = <span class="built_in">get</span>(b.r);</span><br><span class="line">    <span class="keyword">if</span> (al != bl)</span><br><span class="line">        <span class="keyword">return</span> al &lt; bl;</span><br><span class="line">    <span class="keyword">if</span> (ar != br)</span><br><span class="line">        <span class="keyword">return</span> ar &lt; br;</span><br><span class="line">    <span class="keyword">return</span> a.t &lt; b.t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cnt[x])</span><br><span class="line">        res++;</span><br><span class="line">    cnt[x]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt[x]--;</span><br><span class="line">    <span class="keyword">if</span> (!cnt[x])</span><br><span class="line">        res--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span> (*op == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">            mq++, q[mq] = &#123;mq, a, b, mc&#125;;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            c[++mc] = &#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    len = <span class="built_in">cbrt</span>((<span class="keyword">double</span>)n * <span class="built_in">max</span>(mc, n));</span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + mq + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>, t = <span class="number">0</span>, k = <span class="number">1</span>, res = <span class="number">0</span>; k &lt;= mq; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> id = q[k].id, l = q[k].l, r = q[k].r, tm = q[k].t;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; r)</span><br><span class="line">            <span class="built_in">add</span>(w[++i], res);</span><br><span class="line">        <span class="keyword">while</span> (i &gt; r)</span><br><span class="line">            <span class="built_in">del</span>(w[i--], res);</span><br><span class="line">        <span class="keyword">while</span> (j &lt; l)</span><br><span class="line">            <span class="built_in">del</span>(w[j++], res);</span><br><span class="line">        <span class="keyword">while</span> (j &gt; l)</span><br><span class="line">            <span class="built_in">add</span>(w[--j], res);</span><br><span class="line">        <span class="keyword">while</span> (t &lt; tm)</span><br><span class="line">        &#123;</span><br><span class="line">            t++;</span><br><span class="line">            <span class="keyword">if</span> (c[t].p &gt;= j &amp;&amp; c[t].p &lt;= i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">del</span>(w[c[t].p], res);</span><br><span class="line">                <span class="built_in">add</span>(c[t].c, res);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(w[c[t].p], c[t].c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (t &gt; tm)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (c[t].p &gt;= j &amp;&amp; c[t].p &lt;= i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">del</span>(w[c[t].p], res);</span><br><span class="line">                <span class="built_in">add</span>(c[t].c, res);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(w[c[t].p], c[t].c);</span><br><span class="line">            t--;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[id] = res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= mq; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="例题三（回滚莫队）"><a href="#例题三（回滚莫队）" class="headerlink" title="例题三（回滚莫队）"></a>例题三（回滚莫队）</h1><p>看看下题<br><a href="https://www.luogu.com.cn/problem/AT1219">AT1219</a><br>本题中区间伸长的时候很好维护信息但区间缩短的时候不太好维护信息<br>于是我们遇到莫队的一个常见问题：当询问的不再是简单的计数，而是最值或其他带有比较性质的信息时，如何在指针移动时用可接受的时间实现答案的跟新（即“当前区间”的插入和删除时如何快速跟新答案）？<br>就本题而言，我们发现插入一个新数的跟新非常简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cnt[i]++;</span><br><span class="line"><span class="keyword">if</span>(cnt[i]*i&gt;res) res=cnt[i]*i;</span><br></pre></td></tr></table></figure><p>但是，删除操作会变得十分麻烦：原来 $res=cnt[i]$ ，但当 $cnt[i]-=i$ 后， $res$ 就必须要把整个 $cnt$ 数组扫描一遍才能确定。<br>当然，dalao可以用二叉堆来解决这个问题，但其实莫队有一种 <del>虽然时间慢些</del> 更好写的办法。</p><h2 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h2><p> 首先分块，把询问区间先按左端点（ $l$ ）的块排序，相同按右端点（ $r$ ）从小到大排序</p><p>若询问的左右端点在同一个块内，暴力解决， $O(\sqrt{n})$<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/a1h168qt.png" alt="同块暴力"></p><p>剩下的询问必然是跨块的，如图：<img src="https://cdn.luogu.com.cn/upload/image_hosting/5iuj9rtn.png" alt="跨块暴力"><br>由于排序，对于 $l$ 同块的询问 $r$ 一定是递增的，其指针在转移时不必考虑删除操作（如图中 $r_{i+1}$ 一定在 $r_i$ 右方），只需单独定一个 $cnt2$ 来记录即可；而 $l_{i+1}$ 有可能在 $l_i$ 左侧，但它们一定在同一块，即使涉及删除也不会多次使用。但，到底还是要删除，咋办？</p><p>想想你在玩 $galgame$ 玩出最坏的 $BE$的时候，你是不是会选择回档？想想为毛这东西要叫回滚莫队？想想到底是 $cnt$ 难删除还是 $res$ 那维护？于是，我们 <del>在dalao的提示下</del> 发现，我们也可以让莫队“回档”。<br>综上，操作如下：  </p><ol><li><p>先将指针移动到 $l$ 所在块的末尾（具体来讲，设块尾为 $q$ 则 $i=q+1,j=q$ ，保证初始为空）</p></li><li><p>将 $res$ 备份存档</p></li><li><p>每遇到一个询问，我们先移动 $j$ （对应 $r$ ），这里只会涉及添加操作,移动时跟新 $cnt$ 和 $res$ </p></li><li><p>移动 $i$ ，由于 $i$ 最初一定在 $l$ 右边，故只有添加操作，移动完毕后跟新询问的答案</p></li><li><p>将 $res$ 回复，将 $i$ 归位到 $i=q+1$ ，过程中回复 $cnt$ </p></li></ol><p>最后，如果我们当前这个询问的块是上一个询问的下一个块，即我们跨过了一个块，就直接清空 $cnt$ ，重新再来，重复上面的操作，只是块变成了下一个而已（有dalao说：“就相当于我们对于每一个块做一次莫队”）</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> n, m, len;</span><br><span class="line"><span class="keyword">int</span> w[N], cnt[N];</span><br><span class="line">LL ans[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Question</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, l, r;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> id(k) q[k].id</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(k) q[k].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(k) q[k].r</span></span><br><span class="line">&#125; q[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; nums; <span class="comment">//离散化用</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x / len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Question x, Question y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="built_in">get</span>(x.l), j = <span class="built_in">get</span>(y.l);</span><br><span class="line">    <span class="keyword">if</span> (i != j)</span><br><span class="line">        <span class="keyword">return</span> i &lt; j;</span><br><span class="line">    <span class="keyword">return</span> x.r &lt; y.r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, LL &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt[x]++;</span><br><span class="line">    res = <span class="built_in">max</span>(res, (LL)cnt[x] * nums[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    len = <span class="built_in">sqrt</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//离散化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        w[i] = <span class="built_in">read</span>(), nums.<span class="built_in">push_back</span>(w[i]);</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    nums.<span class="built_in">erase</span>(<span class="built_in">unique</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        w[i] = <span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), w[i]) - nums.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="built_in">read</span>(), b = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">id</span>(i) = i, <span class="built_in">l</span>(i) = a, <span class="built_in">r</span>(i) = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q, q + m, cmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; m;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y = x;</span><br><span class="line">        <span class="keyword">while</span> (y &lt; m &amp;&amp; <span class="built_in">get</span>(<span class="built_in">l</span>(y)) == <span class="built_in">get</span>(<span class="built_in">l</span>(x))) <span class="comment">//完成后x~y就是同块的</span></span><br><span class="line">            ++y;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="built_in">get</span>(<span class="built_in">l</span>(x)) * len + len - <span class="number">1</span>; <span class="comment">//本块右端点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//暴力求块内</span></span><br><span class="line">        <span class="keyword">while</span> (x &lt; y &amp;&amp; <span class="built_in">r</span>(x) &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            LL res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="built_in">l</span>(x); k &lt;= <span class="built_in">r</span>(x); ++k)</span><br><span class="line">                <span class="built_in">add</span>(w[k], res);</span><br><span class="line">            ans[<span class="built_in">id</span>(x)] = res;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="built_in">l</span>(x); k &lt;= <span class="built_in">r</span>(x); ++k) <span class="comment">//回复</span></span><br><span class="line">                cnt[w[k]]--;</span><br><span class="line"></span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求跨块</span></span><br><span class="line">        LL res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = right, i = right + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &lt; y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; <span class="built_in">r</span>(x)) <span class="comment">//右指针只增不删</span></span><br><span class="line">                <span class="built_in">add</span>(w[++j], res);</span><br><span class="line"></span><br><span class="line">            LL b_res = res; <span class="comment">//存档</span></span><br><span class="line">            <span class="keyword">while</span> (i &gt; <span class="built_in">l</span>(x))</span><br><span class="line">                <span class="built_in">add</span>(w[--i], res);</span><br><span class="line"></span><br><span class="line">            ans[<span class="built_in">id</span>(x)] = res;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//回复</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; right + <span class="number">1</span>)</span><br><span class="line">                cnt[w[i++]]--;</span><br><span class="line">            res = b_res;</span><br><span class="line"></span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt); <span class="comment">//换块,清空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="例四（树上莫队）有完没完"><a href="#例四（树上莫队）有完没完" class="headerlink" title="例四（树上莫队）有完没完"></a>例四（树上莫队）<del>有完没完</del></h1><p><a href="https://www.acwing.com/problem/content/2536/">AcWing2536</a><br>与例一类似，只是区间变成了树上的一个路径。<br>那要是可以把树变成一个序列，并且路径就对应一个区间，那该有多好啊！（好假，一看就是dalao告诉的）</p><p>于是 <del>dalao告诉</del> 我们想到，可以用<strong>欧拉序列</strong>！（那系个啥？）</p><h2 id="欧拉序列"><a href="#欧拉序列" class="headerlink" title="欧拉序列"></a>欧拉序列</h2><p>名字挺高级的，其实就是一个DFS遍历，遍历时经过的节点顺序就是欧拉序列。<br>for example：<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/zyak8ug3.png" alt="欧拉路径"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 暴力 </tag>
            
            <tag> 分块 </tag>
            
            <tag> 莫队 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>莫比乌斯反演</title>
      <link href="/2021/11/22/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
      <url>/2021/11/22/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</url>
      
        <content type="html"><![CDATA[<p>数学的恶魔</p><span id="more"></span><h1 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h1><h2 id="前置知识：数论分块"><a href="#前置知识：数论分块" class="headerlink" title="前置知识：数论分块"></a>前置知识：数论分块</h2><h3 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h3><p>数论分块可以快速计算一些含有除法向下取整的和式（即形如 $\sum_{i=1}^{n} f(i)g( \lfloor \frac{n}{i} \rfloor)$ 的式子），只要可以在 $O(1)$ 内计算 $f(r)-f(l)$ 或已经预处理出 $f$ 的前缀和时，可以用数论分块在 $O(\sqrt{n})$ 的时间内计算答案。</p><p>它主要利用<strong>富比尼定理（Fubini’s theorem）</strong>（<del>听起来很厉害但其实没啥</del>）：我们注意到，有很多的 $i$ 它们的 $\lfloor \frac{n}{i} \rfloor$ 是相等的，这启发我们分段打包计算。</p><p>举个例子，如果我们要求 $\sum_{i=1}^{n} \lfloor \frac{n}{i} \rfloor$ ，我们发现很多 $i$ 都对应同一个 $\lfloor \frac{n}{i} \rfloor$ ，它们呈块状分布，在<del>打个表</del>仔细观察（<a href="https://oi-wiki.org/math/number-theory/sqrt-decomposition/">证明</a>），发现对于每一个块，它的最后一个数是 $n/(n/i)$ （ $c++$ 自带下取整，一般我们称其这个式子的值为 $g(i)$ ），如对于 $\sum_{i=1}^{10} \lfloor \frac{10}{i} \rfloor$ ，分成： $(1)(2)(3)(4,5)(6,7,8,9,10)$ ，其中 $1=10/(10/1),2=10/(10/2),3=10/(10/3),5=10/(10/5),10=10/(10/10)$ ，于是，求解上述问题的代码如下（常用）：</p><p><a href="https://www.luogu.com.cn/problem/UVA11526">UVA11526 H(n)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">    r=n/(n/l);</span><br><span class="line">    ans+=(r-l+<span class="number">1</span>)*(n/l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的，我们可以用 $O(\sqrt{n})$ 计算 $g(\lfloor \frac{n}{i} \rfloor)$ 那么只要 $f$ 好求我们就能算了！</p><p>一般而言，我们可以统计一个前缀和（积），因为每当我们使用分块跳过一个区间的时候，其所对应的函数值也跳过了一个区间。所以此时，就需要乘上那一个区间的函数值（可以自己举个例子理解一下）。</p><p>但要是不一般（比如 $O(n)$ 的前缀和都会TLE），那……去死吧！（dalao可以用<strong>杜教筛</strong>试一试）</p><h3 id="引理一"><a href="#引理一" class="headerlink" title="引理一"></a>引理一</h3><p>$$<br>\forall a,b,c \in \mathbb{Z},\lfloor \frac{a}{bc} \rfloor=\lfloor \frac{\lfloor \frac{a}{b} \rfloor}{c} \rfloor<br>$$</p><p>证明：<br>$$<br>\frac{a}{b}=\lfloor\frac{a}{b}\rfloor+r(0\le r&lt;1)<br>\Rightarrow\lfloor\frac{a}{bc}\rfloor=\lfloor\frac{1}{c}(\lfloor\frac{a}{b}\rfloor+r)\rfloor=\lfloor\frac{\lfloor\frac{a}{b}\rfloor}{c}+\frac{r}{c}\rfloor=\lfloor \frac{\lfloor \frac{a}{b} \rfloor}{c} \rfloor<br>$$</p><h3 id="引理二"><a href="#引理二" class="headerlink" title="引理二"></a>引理二</h3><p>$$<br>\forall n\in\mathbb{N_+},{\LARGE|}{\lfloor \frac{n}{d}\rfloor|d\in\mathbb{N_+}\wedge d\le n}{\LARGE|}\le\lfloor2\sqrt{n}\rfloor<br>$$</p><p>其中 $|V|$ 表示集合 $V$ 的元素个数</p><p>该引理是时间复杂度的保证</p><p>证明：</p><p>对于 $d\le\lfloor\sqrt{n}\rfloor$ ，由于 $d$ 最多有 $\lfloor\sqrt{n}\rfloor$ 种不同取值， $\lfloor\frac{n}{d}\rfloor$ 也只有 $\lfloor\sqrt{n}\rfloor$ 种取值</p><p>对于 $d&gt;\lfloor\sqrt{n}\rfloor$ ，则 $\lfloor\frac{n}{d}\rfloor\le\lfloor\sqrt{n}\rfloor$ ，也只有 $\lfloor\sqrt{n}\rfloor$ 种取值</p><h2 id="前置知识：积性函数"><a href="#前置知识：积性函数" class="headerlink" title="前置知识：积性函数"></a>前置知识：积性函数</h2><p>若函数 $f(x)$ 为积性函数，则有 $\forall gcd(a,b)=1,f(ab)=f(a)f(b)$ </p><p>可以证明以下函数全是积性函数：</p><ul><li>$\varphi(n)$ －欧拉函数</li><li>$\mu(n)$ －莫比乌斯函数</li><li>$gcd(n,k)$ －最大公因子，当k固定的情况</li><li>$d(n)$ －正因子数目</li><li>$\sigma(n)$ －所有正因子之和</li><li>$\sigma k(n)$ －因子函数， $n$ 的所有正因子的 $k$ 次幂之和，当中 $k$ 可为任何复数</li><li>$1(n)$ －不变的函数，定义为 $1(n)=1$ （完全积性）</li><li>$Id(n)$ －单位函数，定义为 $Id(n)=n$ （完全积性）</li><li>$Idk(n)$ －幂函数，对于任何复数、实数 $k$ ，定义为 $Idk(n)=n^k$ （完全积性）</li><li>$\varepsilon(n)$ －定义为：若 $n=1$ ， $\varepsilon(n)=1$ ；若 $n&gt;1$ ， $\varepsilon(n)=0$ 。别称为“对于狄利克雷卷积的乘法单位”（完全积性）</li><li>$\lambda(n)$ －<a href="https://baike.baidu.com/item/%E5%88%98%E7%BB%B4%E5%B0%94%E5%87%BD%E6%95%B0">刘维尔函数</a>，关于能整除 $n$ 的质因子的数目</li><li>$\gamma(n)$ ，定义为 $\gamma(n)=(-1)^{\omega(n)}$，在此加性函数 $\omega(n)$ 是不同能整除<em>n</em>的质数的数目</li><li>另外，所有<a href="https://baike.baidu.com/item/%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E7%89%B9%E5%BE%81">狄利克雷特征</a>均是完全积性的</li></ul><p>积性函数一般可以用线性筛筛得</p><h2 id="前置知识：狄利克雷卷积"><a href="#前置知识：狄利克雷卷积" class="headerlink" title="前置知识：狄利克雷卷积"></a>前置知识：狄利克雷卷积</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>狄利克雷（ $Dirichlet$ ）卷积定义为：</p><p>对于两个<a href="https://baike.baidu.com/item/%E6%95%B0%E8%AE%BA%E5%87%BD%E6%95%B0">数论函数</a> $f,g$ ，有：<br>$$<br>(f*g)(n)=\sum_{d|n}f(d)g(\frac{n}{d})<br>$$</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>狄利克雷卷积满足以下运算律：</p><ul><li>交换律： $(f* g)=(g* f)$ </li><li>结合律： $((f* g)* h)=(f* (g* h))$ </li><li>分配律： $(f* (g+h))=((f* g)+(f* h))$ </li><li>$(f*\varepsilon)=f$ ，其中 $\varepsilon$ 为狄利克雷卷积的单位元 </li></ul><p>for example：</p><ul><li> $\varepsilon=(\mu*1)\Leftrightarrow\varepsilon(n)=\sum_{d|n}\mu(d)1(\frac{n}{d})=\sum_{d|n}\mu(d)$</li><li> $d=(1*1)\Leftrightarrow d(n)=\sum_{d|n}1(d)1(\frac{n}{d})=\sum_{d|n}1$ </li><li> $Id=(\varphi*1)\Leftrightarrow Id(n)=n=\sum_{d|n}\varphi(n)$ </li><li> $\varphi=(\mu*Id)\Leftrightarrow\varphi(n)=\sum_{d|n}d\mu(\frac{n}{d})$ </li></ul><h3 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h3><p>对于卷积的第 $n$ 项可以直接枚举约数，在 $O(\sqrt{n})$ 的时间内计算</p><p>但是对于狄利克雷卷积的前 $n$ 项<br>$$<br>h[i]=\sum_{d|i}f[d]g[i/d]<br>$$<br>如果一项一项算的话就需要 $O(n\sqrt{n})$ ，但实际上可以优化</p><p>设 $x=d,y=\frac{i}{d}$ 分别枚举 $x,y$ 对于 $h[xy]+=f[x]g[y]$ 即可。<br> 时间复杂度 $O(n\log{n})$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) h[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j*i&lt;=n;++j) h[i*j]=(h[i*j]+f[i]*g[j]%P)%P;</span><br></pre></td></tr></table></figure><p>对于 $k$ 次卷积，还可以快速幂优化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HanShu</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> f[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inint</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) f[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HanShu <span class="keyword">operator</span>*(<span class="keyword">const</span> HanShu <span class="keyword">_t</span>)&#123;</span><br><span class="line">    HanShu h;</span><br><span class="line">h.<span class="built_in">inint</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j*i&lt;=n;++j) h.f[i*j]=(h.f[i*j]+f[i]*<span class="keyword">_t</span>.f[j]%P)%P;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> HanShu <span class="keyword">_t</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) f[i]=<span class="keyword">_t</span>.f[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">HanShu <span class="title">H_qpow</span><span class="params">(HanShu x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    HanShu res;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">_t</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">    <span class="keyword">if</span>(y&amp;<span class="number">1</span>)&#123;</span><br><span class="line">    ++<span class="keyword">_t</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">_t</span>==<span class="number">1</span>) res=x;</span><br><span class="line">    <span class="keyword">else</span> res=res*x;</span><br><span class="line">    &#125;</span><br><span class="line">    x=x*x;</span><br><span class="line">    y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前置知识：莫比乌斯函数"><a href="#前置知识：莫比乌斯函数" class="headerlink" title="前置知识：莫比乌斯函数"></a>前置知识：莫比乌斯函数</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>设正整数 $N$ 分解质因数为 $N=p_1^{c_1}p_2^{c_2}…p_m^{c_m}$ ，定义函数<br>$$<br>\mu(N)=\left{\begin{matrix}<br> 0&amp;\exists i\in[1,m],c_i&gt;1\<br> 1&amp;m\equiv0(mod\ 2),\forall i\in[1,m],c_i=1\<br>-1&amp;m\equiv1(mod\ 2),\forall i\in[1,m],c_i=1<br>\end{matrix}\right.<br>$$<br>我们称 $\mu$ 为莫比乌斯（ $M\ddot{o}bius$ ）函数。</p><h3 id="性质和结论"><a href="#性质和结论" class="headerlink" title="性质和结论"></a>性质和结论</h3><ul><li><p>莫比乌斯函数是积性函数</p></li><li><p>$\sum_{d|n}\mu(d)=[n==1]$ ，其中 $[p]$ 表示 $p$ 为真时取 $1$ 其他时候取 $0$ ，该式也可表示为 $\sum_{d|n}\mu(d)=\varepsilon(n)$ ，也就是 $\mu*1=\varepsilon$</p><p>证明：</p><p>设 $n=\prod_{i=1}^{k}p_i^{c_i},n’=\prod_{i=1}^{k}p_i$ </p><p>那么 $\sum_{d|n}\mu(d)=\sum_{d|n’}\mu(d)=\sum_{i=0}^{k}C_k^i(-1)^i$ </p><p>又因为二项式定理： $(a+b)^k=\sum_{i=0}^{k}C_k^i a^i b^{k-i}$ </p><p>有： $\sum_{i=0}^{k}C_k^i(-1)^i=\sum_{i=0}^{k}C_k^i(-1)^i 1^{k-i}=((-1)+1)^k$</p><p>当且仅当 $k=0$ ，即 $n=1$ 时原式为 $1$ ，其余时候都为 $0$ </p></li><li><p>$[gcd(i,j)==1]=\sum_{d|gcd(i,j)}\mu(d)$ 该结论在反演中十分常用，正确性显然</p></li></ul><h3 id="筛法"><a href="#筛法" class="headerlink" title="筛法"></a>筛法</h3><p>若只求一项莫比乌斯函数，分解质因数即可；</p><p>若要求多项可以在线性筛素数时一并求出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> primes[N],mu[N],cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> v[N];</span><br><span class="line">mu[<span class="number">1</span>]=<span class="number">1</span>; <span class="comment">//1特判</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!v[i]) primes[++cnt]=i,mu[i]=<span class="number">-1</span>; <span class="comment">//质数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;primes[j]*i&lt;=n;++j)&#123;</span><br><span class="line">v[primes[j]*i]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i%primes[j]==<span class="number">0</span>)&#123; <span class="comment">//若有一个质因数指数大于1</span></span><br><span class="line">            mu[i*primes[j]]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mu[i*primes[j]]=-mu[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="正题：莫比乌斯反演"><a href="#正题：莫比乌斯反演" class="headerlink" title="正题：莫比乌斯反演"></a>正题：莫比乌斯反演</h2><h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><p>若 $F(n)$ 和 $f(n)$ 是定义在 $\mathbb{N}$ 上的函数，且有<br>$$<br>F(n)=\sum_{d|n}f(d)<br>$$<br>则：<br>$$<br>f(n)=\sum_{d|n}\mu(d)F(\frac{n}{d})<br>$$<br>我们称该定理为<strong>莫比乌斯反演定理</strong>（原来是用 $f$ 表示 $F$ ，现在反过来了）。</p><p>证明如下：<br>$$<br>\begin{align}<br>\sum_{d|n}\mu(d)F(\frac{n}{d})<br>&amp;=\sum_{d|n}\mu(d)\sum_{i|\frac{n}{d}}f(i)\\<br>&amp;=\sum_{i|n}f(i)\sum_{d|\frac{n}{i}}\mu(d)\\<br>&amp;=\sum_{i|n}f(i)[\frac{n}{i}==1]\\<br>&amp;=f(n)<br>\end{align}<br>$$<br>当然，不难发现，狄利克雷卷积也可以证明：</p><p>$$<br>\begin{align}<br>&amp;F(n)=\sum_{d|n}f(d)\\<br>&amp;\Rightarrow F=f* 1\\<br>&amp;\Rightarrow F* \mu=f* 1* \mu\\<br>\text{又}\because&amp;\mu* 1=\varepsilon\\<br>&amp;\Rightarrow F* \mu=f* (1* \mu)=f\\<br>&amp;\Rightarrow f=\mu* F<br>\end{align}<br>$$</p><p>然而，在莫比乌斯反演中更常用的是这个式子：</p><p>当 $F(n)$ 和 $f(n)$ 满足：<br>$$<br>F(n)=\sum_{n|d}f(d)<br>$$<br>则有：<br>$$<br>f(n)=\sum_{n|d}\mu(\frac{d}{n})F(d)<br>$$<br>其实就是枚举约数变成了枚举倍数，若用卷积证明，过程都一样，下面用定义证明：<br>$$<br>\begin{align}<br>\sum_{n|d}\mu(\frac{d}{n})F(d)<br>&amp;=\sum_{n|d}\mu(\frac{d}{n})\sum_{d|i}f(i)\\<br>\text{不妨设}d’=\frac{d}{n}\\<br>\text{原式}<br>&amp;=\sum_{n|i}f(i)\sum_{d’|\frac{i}{n}}\mu(d’)\\<br>&amp;=\sum_{n|i}f(i)[\frac{i}{n}==1]\\<br>&amp;=f(n)<br>\end{align}<br>$$<br>以上就是莫比乌斯反演的常用形式（要记住）</p><h3 id="例题一"><a href="#例题一" class="headerlink" title="例题一"></a>例题一</h3><p><a href="https://www.luogu.com.cn/problem/P2522">Problem b</a></p><p>分析：</p><p>若我们将数对 $(x,y)$ 对应到坐标系内，其实是要求在左下角为 $(a,c)$ 右上角为 $(b,d)$ 的矩形中有多少个点 $(x,y)$ 满足 $gcd(x,y)==k$ </p><p>由矩形考虑二维前缀和，设 $S(x,y)$ 表示以 $(x,y)$ 为右上角， $(0,0)$ 为左下角的矩形中满足要求的点的个数，则 $Ans=S(b,d)-S(a-1,d)-S(b,c-1)+S(a-1,c-1)$ </p><p>考虑用莫比乌斯反演，我们需要定义 $F,f$ 且让 $F(n)=\sum_{n|d}f(d)$ （即满足反演条件），要注意的是， $F$ 应该是比较好计算的函数（至少要比 $f$ 好计算，不然你反演用 $F$ 表示 $f$ 干嘛），还有就是 $f$ 要与答案有关系（不然求出 $f$ 干嘛）</p><p>那么，不妨令 $f(n)=\sum_{x=1}^{N}\sum_{y=1}^{M}[gcd(x,y)==n]$ 则我们要求的 $S(N,M)$ 就是 $f(k)$ </p><p>又因为 $F(n)=\sum_{n|d}f(d)$ ，故定义 $F(n)=\sum_{x=1}^{N}\sum_{y=1}^{M}[n|gcd(x,y)]$ </p><p>反演得： $f(n)=\sum_{n|d}\mu(\frac{d}{n})F(d)$ </p><p>又因为由 $F$ 的定义， $n|gcd(x,y)\Leftrightarrow n|x\wedge n|y$ ，故 $F(d)=\lfloor\frac{N}{d}\rfloor\lfloor\frac{M}{d}\rfloor$</p><p>所以 $f(n)=\sum_{n|d}\mu(\frac{d}{n})\lfloor\frac{N}{d}\rfloor\lfloor\frac{M}{d}\rfloor$ </p><p>枚举倍数比枚举因数要简单，所以我们令 $d’=\frac{d}{n},N’=\frac{N}{n},M’=\frac{M}{n}$ ，原式化为 $f(n)=\sum_{d’}\mu(d’)\lfloor\frac{N’}{d}\rfloor\lfloor\frac{M’}{d}\rfloor$ 预处理 $\mu$ 的前缀和后用数论分块可以求</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">50000</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> pri[N],cnt,mu[N];</span><br><span class="line"><span class="keyword">bool</span> v[N];</span><br><span class="line">LL sum[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pred</span><span class="params">()</span></span>&#123;</span><br><span class="line">mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i]) pri[++cnt]=i,mu[i]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;pri[j]*i&lt;N;++j)&#123;</span><br><span class="line">v[pri[j]*i]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>)&#123;</span><br><span class="line">mu[i*pri[j]]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">mu[i*pri[j]]=-mu[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sum[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i) sum[i]=sum[i<span class="number">-1</span>]+mu[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>&#123; <span class="comment">//得到(k/x)中x所在块的右端点</span></span><br><span class="line"><span class="keyword">return</span> k/(k/x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">S</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">LL res=<span class="number">0</span>;</span><br><span class="line">x=x/k,y=y/k;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">_t</span>=<span class="built_in">min</span>(x,y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=<span class="keyword">_t</span>;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">r=<span class="built_in">min</span>(<span class="keyword">_t</span>,<span class="built_in">min</span>(<span class="built_in">g</span>(x,l),<span class="built_in">g</span>(y,l))); <span class="comment">//每次在两个取整中找小的,注意不能超过_t</span></span><br><span class="line">res+=(sum[r]-sum[l<span class="number">-1</span>])*(x/l)*(y/l);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a,b,c,d,k;</span><br><span class="line"><span class="built_in">pred</span>();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c,&amp;d,&amp;k);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">S</span>(b,d,k)-<span class="built_in">S</span>(a<span class="number">-1</span>,d,k)-<span class="built_in">S</span>(b,c<span class="number">-1</span>,k)+<span class="built_in">S</span>(a<span class="number">-1</span>,c<span class="number">-1</span>,k));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题二"><a href="#例题二" class="headerlink" title="例题二"></a>例题二</h3><p><a href="https://www.luogu.com.cn/problem/P3327">约数个数和</a></p><p>分析：</p><p>先看原题给我们的函数，由于 $d$ 是积性函数（忘了的上去翻），所以有 $d(ij)=\sum_{x|i}\sum_{y|j}[gcd(x,y)==1]$ （<del>呃呃呃，鬼想的到啊！</del>）</p><p>简单证明：</p><p>设 $i=p_1^{\alpha_1}p_2^{\alpha_2}…p_k^{\alpha_k},j=p_1^{\beta_1}p_2^{\beta_2}…p_k^{\beta_k}$ ，则 $ij=i=p_1^{\alpha_1+\beta_1}p_2^{\alpha_2+\beta_2}…p_k^{\alpha_k+\beta_k}$ ，由约数个数定理 $d(ij)=(\alpha_1+\beta_1+1)(\alpha_2+\beta_2+1)…(\alpha_k+\beta_k+1)$ </p><p>再看等式右边， $x,y$ 的因数也一定是在 $p_1,p_2,…,p_k$ 中，对于质因子 $p_1$ ，若 $x$ 含 $p_1^t,(t\ne 0)$ ，则有意义的 $y$ 一定不含 $p_1$ ，此时 $t$ 有 $\alpha_1$ 种取值，同理，若 $y$ 含 $p_1^t,(t\ne 0)$ 有 $\beta_1$ 种取值，加上一种 $x,y$ 都不含 $p_1$ ，共 $\alpha_1+\beta_1+1$ 种有意义的取值，类似的，讨论其它质因数，乘法原理得左式等于右式</p><p> QED</p><p>我们发现 $Ans=\sum_{i=1}^{N}\sum_{j=1}^{M}\sum_{x|i}\sum_{y|j}[gcd(x,y)==1]$ ，类似与上题，令： $f(n)=\sum_{i=1}^{N}\sum_{j=1}^{M}\sum_{x|i}\sum_{y|j}[gcd(x,y)==n],F(n)=\sum_{i=1}^{N}\sum_{j=1}^{M}\sum_{x|i}\sum_{y|j}[n|gcd(x,y)]$ 那么 $Ans=f(1)$ </p><p>则 $F(n)=\sum_{n|d}f(d)$ ，反演得 $f(n)=\sum_{n|d}\mu(\frac{d}{n})F(d)$ </p><p>故 $f(1)=\sum_{d=1}^{N}\mu(d)F(d)$ ，为了求出 $f(1)$ ，我们来看 $F(n)$ ，由于 $[n|gcd(x,y)]$ 与 $i,j$ 无关，我们可以枚举 $x,y$ 计算有多少 $i,j$ 符合要求， $F(n)=\sum_{x=1}^{N}\sum_{y=1}^{M}\lfloor\frac{N}{x}\rfloor\lfloor\frac{M}{y}\rfloor[n|gcd(x,y)]$ </p><p>同上题一样，可设 $x’=\frac{x}{n},y’=\frac{y}{n},N’=\frac{N}{n},M’=\frac{M}{n}$ ，得 $F(n)=\sum_{x’=1}^{N’}\sum_{y’=1}^{M’}\lfloor\frac{N’}{x’}\rfloor\lfloor\frac{M’}{y’}\rfloor$ </p><p>调换循环顺序得 $F(n)=(\sum_{x’=1}^{N’}\lfloor\frac{N’}{x’}\rfloor)(\sum_{y’=1}^{M’}\lfloor\frac{M’}{y’}\rfloor)$ </p><p>令 $h(k)=\sum_{i=1}^{k}\lfloor\frac{k}{i}\rfloor$ ，有 $F(n)=h(N’)h(M’)$ ，故 $f(1)=\sum_{d=1}^{N}\mu(d)h(\frac{N}{d})h(\frac{M}{d})$ ，预处理所有的 $h(x)$ ，数论分块解决</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">50000</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> pri[N],cnt,mu[N];</span><br><span class="line">LL sum[N],h[N];</span><br><span class="line"><span class="keyword">bool</span> v[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> k/(k/x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pred</span><span class="params">()</span></span>&#123;</span><br><span class="line">mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i]) pri[++cnt]=i,mu[i]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;pri[j]*i&lt;N;++j)&#123;</span><br><span class="line">v[pri[j]*i]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>)&#123;</span><br><span class="line">mu[i*pri[j]]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">mu[i*pri[j]]=-mu[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sum[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i) sum[i]=sum[i<span class="number">-1</span>]+mu[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=i;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">r=<span class="built_in">min</span>(i,<span class="built_in">g</span>(i,l));</span><br><span class="line">h[i]+=(r-l+<span class="number">1</span>)*(i/l);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">pred</span>();</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">LL ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">_t</span>=<span class="built_in">min</span>(n,m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=<span class="keyword">_t</span>;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">r=<span class="built_in">min</span>(<span class="keyword">_t</span>,<span class="built_in">min</span>(<span class="built_in">g</span>(n,l),<span class="built_in">g</span>(m,l)));</span><br><span class="line">ans+=(sum[r]-sum[l<span class="number">-1</span>])*h[n/l]*h[m/l];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题三"><a href="#例题三" class="headerlink" title="例题三"></a>例题三</h3><p><a href="https://www.luogu.com.cn/problem/P2303">龙哥的问题</a></p><p>本题比较简单，甚至不用莫反</p><p>考虑答案：<br>$$<br>\begin{align}<br>Ans<br>&amp;=\sum_{i=1}^{n}gcd(i,n)\\<br>&amp;=\sum_{d|n}(d\times\sum_{i=1}^{n}[gcd(i,n)==d])\\<br>&amp;=\sum_{d|n}(d\times\sum_{i=1}^{n}[gcd(\frac{i}{d},\frac{n}{d})==1])\\<br>&amp;=\sum_{d|n}d\times\varphi(\frac{n}{d})<br>\end{align}<br>$$<br>对于每一个 $n$ 枚举约数（ $int$ 范围内最多的一个数约数只有 $1600$ 多个） ，再 $\sqrt{n}$ 求 $\varphi$ ，本题的范围可以通过</p><p>那可否继续优化呢？令 $k=\frac{n}{d}$ ，再继续化一下：<br>$$<br>\begin{align}<br>Ans<br>&amp;=\sum_{d|n}d\times\varphi(\frac{n}{d})\\<br>&amp;=\sum_{k|n}\frac{n}{k}\times\varphi(k)\\<br>&amp;=\sum_{k|n}\frac{n}{k}\times k\prod(1-\frac{1}{p_i})\\<br>&amp;=n\sum_{k|n}\prod(1-\frac{1}{p_i})<br>\end{align}<br>$$<br>其中 $k_t=\prod p_i^{c_{i,t}}$ ，又因为 $k|n$ ，不妨设 $n=\prod p_i^{\alpha_i}$  ，下面的变化比较常用，要记住：<br>$$<br>\begin{align}<br>&amp;k|d\\<br>\Rightarrow&amp;\forall k_t,0\le c_{i,t}\le\alpha_i\\<br>\Rightarrow&amp;\sum_{k|n}k=\sum_{t}\prod_{i} p_i^{c_{i,t}}=\prod_{t}\sum_{i} p_i^{c_{i,t}}\\<br>&amp;=(p_1^0+p_1^2+…+p_1^{\alpha_1})(p_2^0+p_2^2+…+p_2^{\alpha_2})…<br>\end{align}<br>$$</p><p>如果不理解的话可以这样想：每个括号里取一项作 $p_i^{c_{i,t}}$ 乘起来刚好对应一个 $k_t$ </p><p>那么考虑上式对答案的贡献，我们发现对于所有的 $k$ ，若取第 $i$ 个质因子的指数为 $0$ （即取 $p_i^0$ ）对答案贡献为 $1$ ，其他情况（即 $p_i^c,c\ne0$ ）对答案的贡献都是 $1-\frac{1}{p_i}$ ，故答案可化为：<br>$$<br>\begin{align}<br>Ans<br>&amp;=n\prod_{i}(1+(1-\frac{1}{p_i})+(1-\frac{1}{p_i})+…+(1-\frac{1}{p_i}))\\<br>&amp;=n\prod_{i}(1+a(1-\frac{1}{p_i}))<br>\end{align}<br>$$<br>分解 $n$ 的质因子，可以在 $O(\sqrt{n})$ 时间求解，但注意，本题对 $long\ long$ 卡的非常死，甚至在计算 $ans$ 时先乘再除都会炸 $long\ long$ </p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">LL n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">LL ans=n; <span class="comment">//最初的n </span></span><br><span class="line"><span class="keyword">for</span>(LL i=<span class="number">2</span>;i*i&lt;=n;++i)</span><br><span class="line"><span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">LL a=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n%i==<span class="number">0</span>) ++a,n/=i;</span><br><span class="line">ans/=i,ans*=i+a*i-a; <span class="comment">//一定要先除 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n&gt;<span class="number">1</span>) ans/=n,ans*=n+n<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题四"><a href="#例题四" class="headerlink" title="例题四"></a>例题四</h3><p>来看一道难题：</p><p><a href="https://www.luogu.com.cn/problem/P3704">数字表格</a></p><p>这道题要点很杂很多，我们慢慢看：</p><p>首先明确<br>$$<br>Ans=\prod_{i=1}^{n}\prod_{j=1}^{m}fb(gcd(i,j))<br>$$<br>其中 $fb(x)$ 表示Fibonacci数列第 $x$ 项</p><p>由于 $\prod$ 不好处理，考虑枚举 $gcd$ ：<br>$$<br>Ans=\prod_{d=1}^{N}[fb(d)]^{f(d)}<br>$$<br>其中 $N=\min(n,m)$ ， $f(d)=\sum_{i=1}^{m}\sum_{j=1}^{n}[gcd(i,j)==d]$</p><p>发现这个 $f$ 的定义我们非常熟悉，于是一通莫反：<br>$$<br>\begin{align}<br>\text{令}&amp;F(d)=\sum_{i=1}^{m}\sum_{j=1}^{n}[d|gcd(i,j)]\\<br>\text{则有}&amp;F(d)=\sum_{r|d}f(r)\\<br>\text{反演得}&amp;f(d)=\sum_{d|r}\mu(\frac{r}{d})F(r)\\<br>\text{又有}&amp;d|gcd(i,j)\Leftrightarrow d|i,d|j\\<br>\text{故}&amp;F(d)=\lfloor\frac{n}{d}\rfloor\lfloor\frac{m}{d}\rfloor\\<br>\text{带入得}&amp;f(d)=\sum_{d|r}\mu(\frac{r}{d})\lfloor\frac{n}{r}\rfloor\lfloor\frac{m}{r}\rfloor\\<br>\text{令}w=\frac{r}{d},\text{有}&amp;f(d)=\sum_{w=1}^{\lfloor\frac{N}{d}\rfloor}\mu(w)\lfloor\frac{n}{wd}\rfloor\lfloor\frac{m}{wd}\rfloor<br>\end{align}<br>$$<br>此时我们发现在莫反后， $f(d)$ 可以在 $O(\sqrt{n})$ 内计算，但是，我们观察 $Ans$ ，对于每个 $d$ ， $f(d)$ 都必须重新计算（因为 $f$ 与 $n,m,d$ 都有关），这样的时间负责度为 $O(Tn(\sqrt{n}+\log{n}))$ 直接爆炸好吧</p><p>必须考虑优化，但 $fb$ 和 $\prod$ 都太不好搞了， $f$ 也不好在变形（我在这里卡了好久），既然两个都不好搞，我们不妨把它们一起来看看：<br>$$<br>Ans=\prod_{d=1}^{N}[fb(d)]^{\sum_{w=1}^{\lfloor\frac{N}{d}\rfloor}\mu(w)\lfloor\frac{n}{wd}\rfloor\lfloor\frac{m}{wd}\rfloor}<br>$$<br>我们发现一个关键点：每次询问只修改 $n,m$ 而 $d,w$ 对于每次询问来说是一样的，这启发我们把几个与 $n,m$ 无关的项拿出来预处理：</p><p>$$<br>\begin{align}<br>Ans=\prod_{d=1}^{N}[fb(d)]^{\sum_{w=1}^{\lfloor\frac{N}{d}\rfloor}\mu(w)\lfloor\frac{n}{wd}\rfloor\lfloor\frac{m}{wd}\rfloor}\\<br>=\prod_{d=1}^{N}{[fb(d)]^{\sum_{w=1}^{\lfloor\frac{N}{d}\rfloor}\mu(w)}}^{\lfloor\frac{n}{wd}\rfloor\lfloor\frac{m}{wd}\rfloor}\\<br>\text{令}p=wd,\text{有}Ans<br>=\prod_{p=1}^{N}{[\prod_{d|p}fb(d)]^{\mu(\frac{p}{d})}}^{\lfloor\frac{n}{p}\rfloor\lfloor\frac{m}{p}\rfloor}\\<br>\text{令}h(p)=\prod_{d|p}fb(d)^{\mu(\frac{p}{d})},\text{有}Ans<br>=\prod_{p=1}^{N}h(p)^{\lfloor\frac{n}{p}\rfloor\lfloor\frac{m}{p}\rfloor}<br>\end{align}<br>$$</p><p>发现指数位置的 $\lfloor\frac{n}{p}\rfloor\lfloor\frac{m}{p}\rfloor$ 可以数论分块，而 $h$ 可以提前预处理出前缀积，如此，回答询问的总时间变为 $O(T\sqrt{n}\log{n})$ </p><p>下面考虑如何计算 $h$ ，由于因数不好枚举，我们改为枚举倍数：<br>$$<br>\begin{align}<br>h(p)<br>&amp;=\prod_{d|p}fb(d)^{\mu(\frac{p}{d})}\\<br>&amp;=\prod_{i=1}^{N}fb(\frac{p}{i})^{\mu(i)}\\<br>\text{变形得}h(ij)<br>&amp;=\prod_{i=1}^{N}\prod_{j=1}^{\lfloor\frac{N}{i}\rfloor}fb(j)^{\mu(i)}<br>\end{align}<br>$$<br>预处理时间为 $O(n\log{n})$ </p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000000</span>+<span class="number">5</span>,P=<span class="number">1000000000</span>+<span class="number">7</span>;</span><br><span class="line">LL pri[N],cnt,mu[N],fb[N],h[N],inv_fb[N],mul[N];</span><br><span class="line"><span class="keyword">bool</span> v[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> k/(k/x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">qpow</span><span class="params">(LL x,LL y)</span></span>&#123;</span><br><span class="line">LL res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(y)&#123;</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=(res*x)%P;</span><br><span class="line">x=(x*x)%P;</span><br><span class="line">y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pred</span><span class="params">()</span></span>&#123;</span><br><span class="line">mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i]) pri[++cnt]=i,mu[i]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;pri[j]*i&lt;N;++j)&#123;</span><br><span class="line">v[pri[j]*i]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>)&#123;</span><br><span class="line">mu[i*pri[j]]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">mu[i*pri[j]]=-mu[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fb[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">fb[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">inv_fb[<span class="number">1</span>]=<span class="number">1</span>; <span class="comment">//特殊处理</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i) fb[i]=(fb[i<span class="number">-1</span>]+fb[i<span class="number">-2</span>])%P,inv_fb[i]=<span class="built_in">qpow</span>(fb[i],P<span class="number">-2</span>); <span class="comment">//求逆元</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i) h[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!mu[i])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j*i&lt;N;++j)</span><br><span class="line">        h[j*i]=h[j*i]*(mu[i]==<span class="number">1</span>?fb[j]:inv_fb[j])%P; <span class="comment">//注意mu可能为负一</span></span><br><span class="line">    &#125;</span><br><span class="line">mul[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i) mul[i]=(mul[i<span class="number">-1</span>]*h[i])%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">get_ans</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">LL res=<span class="number">1</span>,as;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">_t</span>=<span class="built_in">min</span>(x,y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=<span class="keyword">_t</span>;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">r=<span class="built_in">min</span>(<span class="keyword">_t</span>,<span class="built_in">min</span>(<span class="built_in">g</span>(x,l),<span class="built_in">g</span>(y,l)));</span><br><span class="line">as=mul[r]*<span class="built_in">qpow</span>(mul[l<span class="number">-1</span>],P<span class="number">-2</span>)%P; <span class="comment">//前缀积得底数</span></span><br><span class="line">res=res*<span class="built_in">qpow</span>(as,<span class="number">1ll</span>*(x/l)*(y/l)%(P<span class="number">-1</span>))%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">pred</span>();</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">get_ans</span>(n,m));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="补充：变换方法"><a href="#补充：变换方法" class="headerlink" title="补充：变换方法"></a>补充：变换方法</h2><p>下面记录一些常见的变换方法：</p><ul><li><p>$$<br>gcd(i,j)==1\Leftrightarrow\sum_{d|i\wedge d|j}\mu(d)<br>$$</p></li><li><p>像例题四一样的完全展开预处理无关项</p></li><li><p>像例题二一样 $d(ij)=\sum_{x|i}\sum_{y|j}[gcd(x,y)==1]$ </p></li><li><p>改变未知数使得两个 $\sum$ 分离，预处理其中一个（也可以看作将两数积设出，继续化简）</p><p>如<a href="https://www.luogu.com.cn/problem/P2257">YY的GCD</a>，莫反后得<br>$$<br>\sum_{k\in prime}\sum_{d=1}^{\lfloor\frac{min(N,M)}{k}\rfloor}\mu(d)\lfloor\frac{N}{kd}\rfloor\lfloor\frac{M}{kd}\rfloor<br>$$<br>若直接计算，对于每个询问，最坏时间复杂度为 $O(n)$ 会TLE，可以变化如下：</p><p>$$<br>\begin{align}<br>\text{设}T<br>&amp;=kd\\<br>\text{则原式}<br>&amp;=\sum_{k\in primes}\sum_{d=1}^{\lfloor\frac{min(N,M)}{k}\rfloor}\mu(d)\lfloor\frac{N}{T}\rfloor\lfloor\frac{M}{T}\rfloor\\<br>&amp;=\sum_{T=1}^{min(N,M)}\sum_{k|T \wedge k\in prime}\mu(\frac{T}{k})\lfloor\frac{N}{T}\rfloor\lfloor\frac{M}{T}\rfloor\\<br>&amp;=\sum_{T=1}^{min(N,M)}\lfloor\frac{N}{T}\rfloor\lfloor\frac{M}{T}\rfloor\sum_{k|T\wedge k\in prime}\mu(\frac{T}{k})\\<br>\end{align}<br>$$</p><p>后面的 $\sum$ 与询问无关，可以预处理</p></li><li><p>注意卷积中的一些常用等式，如 $Id*\mu=\varphi$ ：</p><p>$$<br>\begin{align}<br>Ans<br>&amp;=\sum_{i=1}^{n}\sum_{j=1}^{n}gcd(i,j)\\<br>\text{莫反得}Ans<br>&amp;=\sum_{r=1}^{n}\lfloor\frac{n}{r}\rfloor\lfloor\frac{n}{r}\rfloor\sum_{d|r}d*\mu(\frac{r}{d})\\<br>&amp;=\sum_{r=1}^{n}\lfloor\frac{n}{r}\rfloor\lfloor\frac{n}{r}\rfloor\varphi(r)<br>\end{align}<br>$$</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数论,数学 </tag>
            
            <tag> 莫比乌斯反演 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟退火和爬山法</title>
      <link href="/2021/11/22/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E5%92%8C%E7%88%AC%E5%B1%B1%E6%B3%95/"/>
      <url>/2021/11/22/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E5%92%8C%E7%88%AC%E5%B1%B1%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>暴搜能过样例了！</p><span id="more"></span><h1 id="模拟退火（Simulated-Annealing）"><a href="#模拟退火（Simulated-Annealing）" class="headerlink" title="模拟退火（Simulated Annealing）"></a>模拟退火（Simulated Annealing）</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>模拟退火是一种启发式的随机暴力算法，主要用于解决最优化问题。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>温度：决定每次随机时我们随机的范围，温度越大，下一个点的随机区间越大，在模拟退火中，温度总是不断减小，一般把温度记为 $T$ ；</li><li>初始温度：最初的温度值；</li><li>终止温度：结束时的温度；</li><li>衰减方式：每次温度的变化，可以是一次（如 $T_i=T_{i-1}-c$ )，也可以是指数级（如 $T_i=T_{i-1}*c,c\in (0,1)$ )等，根据实际情况而定，但一般要保证 $T_i&lt;T_{i-1}$ ；</li><li>能量值：当前答案的“权值”，或者说“优秀程度”，能量值越小，答案越优，个人喜欢记答案 $x$ 的能量值为 $E(X)$ ；</li></ul><h2 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h2><ol><li>确定初始点（初始答案），初始温度为 $T_0$ (一般保证足够大)，终止温度 $T_e$ （一般保证足够小）,衰减方式；</li><li>在当前点（设为 $now$ ）温度范围内随机选择一个值 $np$ ，计算答案 $E(np)$ ，记 $E(np)-E(now)=\Delta E$  ；</li><li>若 $\Delta E &lt; 0$ ，说明 $np$ 比 $now$ 优，则跳转到 $np$ ;</li><li>若 $\Delta E &gt; 0$ ，则以一定的概率跳转到 $np$ ，一般来说，这个概率取成 $e^{-\frac{\Delta E}{T}}$ ，这样取的好处是 $np$ 比 $now$ 越差，我们跳转过去的概率越小 ;</li></ol><h2 id="例题一"><a href="#例题一" class="headerlink" title="例题一"></a>例题一</h2><p><a href="https://www.luogu.com.cn/problem/UVA10228">A Star not a Tree?</a></p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100</span>+<span class="number">5</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> T0=<span class="number">10000</span>+<span class="number">5</span>,TE=<span class="number">1e-4</span>,C=<span class="number">0.99</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">double</span> x,y;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inint</span><span class="params">(<span class="keyword">double</span> _x,<span class="keyword">double</span> _y)</span></span>&#123;</span><br><span class="line">x=_x;</span><br><span class="line">y=_y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line"><span class="keyword">double</span> ans=INF;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">rand_d</span><span class="params">(<span class="keyword">double</span> l,<span class="keyword">double</span> r)</span></span>&#123; <span class="comment">//随机得到一个[l,r)的浮点数 </span></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">double</span>)<span class="built_in">rand</span>()/RAND_MAX*(r-l)+l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_dist</span><span class="params">(Node x,Node y)</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> dx=x.x-y.x;</span><br><span class="line"><span class="keyword">double</span> dy=x.y-y.y;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>(dx*dx+dy*dy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">E</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) res+=<span class="built_in">get_dist</span>(x,q[i]);</span><br><span class="line">ans=<span class="built_in">min</span>(ans,res); <span class="comment">//记得更新ans</span></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simulate_anneal</span><span class="params">()</span></span>&#123;</span><br><span class="line">Node now;</span><br><span class="line">now.<span class="built_in">inint</span>(<span class="built_in">rand_d</span>(<span class="number">0</span>,T0),<span class="built_in">rand_d</span>(<span class="number">0</span>,T0));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">double</span> t=T0;t&gt;TE;t*=C)&#123;</span><br><span class="line">Node np;</span><br><span class="line">np.<span class="built_in">inint</span>(<span class="built_in">rand_d</span>(now.x-t,now.x+t),<span class="built_in">rand_d</span>(now.y-t,now.y+t));</span><br><span class="line"><span class="keyword">double</span> dt=<span class="built_in">E</span>(np)-<span class="built_in">E</span>(now);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">exp</span>(-dt/t)&gt;<span class="built_in">rand_d</span>(<span class="number">0</span>,<span class="number">1</span>)) now=np;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里exp(-dt/t)是求e的(-dt/t)次方,当dt&lt;0时,其值恒大于1,一定会跳转到np</span></span><br><span class="line"><span class="comment">当dt&gt;0时,其值恒小于1,且dt越小,其值越大,跳转的概率也就越大 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line">ans=INF;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>,&amp;q[i].x,&amp;q[i].y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;++i) <span class="built_in">simulate_anneal</span>(); <span class="comment">//多次模拟退火使答案正确的概率变大</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.0lf\n&quot;</span>,ans);</span><br><span class="line"><span class="keyword">if</span>(T!=<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题二"><a href="#例题二" class="headerlink" title="例题二"></a>例题二</h2><p>模拟退火不只能解决那些数学模型非常明显的题目，也可以解决一些其他最优化问题，只要保证答案具有“连续性”（即设 $\gamma$ 是大于 $0$ 且足够小的实数， $\forall x$ ，有 $|E(x)-E(x+ \gamma)|$ 足够小）。</p><p>看看这题<a href="https://www.luogu.com.cn/problem/P4044">保龄球</a></p><p>对于这种给数列 $A$ ，求 $A$ 的某种最优排列的问题，我们可以思考如何使用模拟退火：</p><ol><li>温度可以直接像上题一样设置，衰减也可以自设；</li><li>初始点（初始排列）就用题目给的原排列，每次转移时在原排列上随机两个位置交换，得到下一个排列；</li><li>依题意打估价函数 $E(x)$ ，估价并概率转移；</li></ol><p>由上，我们发现本题可以轻松用退火解决。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">50</span>+<span class="number">5</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> T0=<span class="number">1e4</span>+<span class="number">5</span>,TE=<span class="number">1e-4</span>,C=<span class="number">0.99</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> ans=-INF;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Try</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">&#125;q[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">E</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">res+=q[i].x+q[i].y;</span><br><span class="line"><span class="keyword">if</span>(i&lt;=n)&#123;</span><br><span class="line"><span class="keyword">if</span>(q[i].x==<span class="number">10</span>) res+=q[i+<span class="number">1</span>].x+q[i+<span class="number">1</span>].y;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(q[i].x+q[i].y==<span class="number">10</span>) res+=q[i+<span class="number">1</span>].x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans=<span class="built_in">max</span>(ans,res);</span><br><span class="line"><span class="keyword">return</span> -res;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&quot;优&quot;的答案,能量反而低</span></span><br><span class="line"><span class="comment">当然也可以返回res,在simulate_anneal里使dt=x-y </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simulate_anneal</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">double</span> t=T0;t&gt;TE;t*=C)&#123;</span><br><span class="line"><span class="keyword">int</span> a=<span class="built_in">rand</span>()%m+<span class="number">1</span>,b=<span class="built_in">rand</span>()%m+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> now=<span class="built_in">E</span>();</span><br><span class="line"><span class="built_in">swap</span>(q[a],q[b]);</span><br><span class="line"><span class="keyword">if</span>(n+(q[n].x==<span class="number">10</span>)==m)&#123;</span><br><span class="line"><span class="keyword">int</span> np=<span class="built_in">E</span>();</span><br><span class="line"><span class="keyword">int</span> dt=np-now;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">exp</span>(-dt/t)&lt;(<span class="keyword">double</span>)<span class="built_in">rand</span>()/RAND_MAX) <span class="built_in">swap</span>(q[a],q[b]);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里用小于号,代表若不跳转至np,就把a、b复原</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">swap</span>(q[a],q[b]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;q[i].x,&amp;q[i].y);</span><br><span class="line"><span class="keyword">if</span>(q[n].x==<span class="number">10</span>) m=n+<span class="number">1</span>,<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;q[m].x,&amp;q[m].y);</span><br><span class="line"><span class="keyword">else</span> m=n;</span><br><span class="line"><span class="keyword">while</span>((<span class="keyword">double</span>)<span class="built_in">clock</span>()/CLOCKS_PER_SEC&lt;<span class="number">0.8</span>) <span class="built_in">simulate_anneal</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题三"><a href="#例题三" class="headerlink" title="例题三"></a>例题三</h2><p>一道类似于上题的排列退火，但加入一定的优化</p><p><a href="https://www.luogu.com.cn/problem/P2503">均分数据</a></p><p>这道题直接模拟退火也能过，但略显的有点过于暴力，我们可以考虑模拟退火加一点贪心（当然也可以加DP，但那样还不如直接用DP，<del>我就是做不出DP才模拟退火的好吧</del>）：</p><p>先用退火得到数列的排列，计算当前答案时，对于当前数 $a_i$ ,我们每次都将 $a_i$ 放到当前和最小的集合中，贪心计算。可以证明，<del>虽然我不会证</del>，这样贪心是不会漏掉最优解的。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">20</span>+<span class="number">5</span>,M=<span class="number">10</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> T0=<span class="number">1e4</span>+<span class="number">5</span>,TE=<span class="number">1e-6</span>,C=<span class="number">0.99</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> w[N],s[M];</span><br><span class="line"><span class="keyword">double</span> ans=INF;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">E</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) s[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,k=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j) <span class="keyword">if</span>(s[j]&lt;s[k]) k=j;</span><br><span class="line">s[k]+=w[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> avg=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) avg+=(<span class="keyword">double</span>)s[i]/m;</span><br><span class="line"><span class="keyword">double</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) res+=(s[i]-avg)*(s[i]-avg);</span><br><span class="line">res=<span class="built_in">sqrt</span>(res/m);</span><br><span class="line">ans=<span class="built_in">min</span>(ans,res);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simulate_anneal</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">random_shuffle</span>(w+<span class="number">1</span>,w+<span class="number">1</span>+n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">double</span> t=T0;t&gt;TE;t*=C)&#123;</span><br><span class="line"><span class="keyword">int</span> a=<span class="built_in">rand</span>()%n+<span class="number">1</span>,b=<span class="built_in">rand</span>()%n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> x=<span class="built_in">E</span>();</span><br><span class="line"><span class="built_in">swap</span>(w[a],w[b]);</span><br><span class="line"><span class="keyword">double</span> y=<span class="built_in">E</span>();</span><br><span class="line"><span class="keyword">double</span> dt=y-x;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">exp</span>(-dt/t)&lt;(<span class="keyword">double</span>)<span class="built_in">rand</span>()/RAND_MAX) <span class="built_in">swap</span>(w[a],w[b]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line"><span class="keyword">while</span>((<span class="keyword">double</span>)<span class="built_in">clock</span>()/CLOCKS_PER_SEC&lt;<span class="number">0.8</span>) <span class="built_in">simulate_anneal</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上两个题都用了 $while((double)clock()/CLOCKS_PER_SEC&lt;0.8)$ 来控制退火次数，在实际做题时，一般计算好循环次数的代码会更稳定一些，但如果不好估算循环次数，这样也不失为一种选择。</p><h1 id="爬山法"><a href="#爬山法" class="headerlink" title="爬山法"></a>爬山法</h1><p>对于一个凸函数（单峰函数），我们可以用爬山法解决（当然，和退火一样，不是要求题目有明确的函数模型，只是需要答案对于每一维自变量你能感觉到一个单峰函数即可，<del>有点玄学</del>）。</p><p>爬山法的思路大体如图：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/v5q77sd9.png" alt="爬山"></p><p>对于点 $now$ 我们并不关心它对应的具体值是多少，我们只关心它去向答案的“方向”（如图中应该是蓝色箭头方向），然后我们只需要向着“方向”走即可，图中是一个维度，而多个维度就分每个维度单独计算“方向”即可。当然，走的“距离”视具体情况而定。</p><p>需要注意的是，爬山法局限较多，不太常用，但仍不失为一种很好的启发式算法。</p><h2 id="例题一-1"><a href="#例题一-1" class="headerlink" title="例题一"></a>例题一</h2><p><a href="https://www.luogu.com.cn/problem/P4035">球形空间产生器</a></p><p>本题正解是高斯消元，建立方程联立求解即可，但如果你和我一样高斯消元和矩阵学的不好，也可以用爬山法搞定。</p><p>我们发现对于 $n$ 维坐标的每一维，都是一个单峰函数（球心到各点距离相等），所以对于一个可能答案的一维，求它到各点的距离的平均值，距离大于平均值的点表现出拉力，反之为推力，将所有力合成即可。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">20</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> d[N][N];</span><br><span class="line"><span class="keyword">double</span> ans[N],dis[N],delta[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> avg=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;++i)&#123;</span><br><span class="line">dis[i]=delta[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">dis[i]+=(d[i][j]-ans[j])*(d[i][j]-ans[j]);</span><br><span class="line">dis[i]=<span class="built_in">sqrt</span>(dis[i]);</span><br><span class="line">avg+=dis[i]/(n+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;++j)</span><br><span class="line">delta[j]+=(dis[i]-avg)*(d[i][j]-ans[j])/avg;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;d[i][j]);</span><br><span class="line">ans[j]+=d[i][j]/(n+<span class="number">1</span>); <span class="comment">//先将初始答案定为重心 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">double</span> t=<span class="number">1e4</span>;t&gt;<span class="number">1e-6</span>;t*=<span class="number">0.99997</span>)&#123;</span><br><span class="line"><span class="built_in">calc</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) ans[i]+=delta[i]*t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%.3lf &quot;</span>,ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，此题用模拟退火也行，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10</span>+<span class="number">5</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> T0=<span class="number">1e4</span>+<span class="number">5</span>,TE=<span class="number">1e-6</span>,C=<span class="number">0.99995</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">double</span> x[N];</span><br><span class="line">Node <span class="keyword">operator</span>+(<span class="keyword">const</span> Node &amp;<span class="keyword">_t</span>) &#123;</span><br><span class="line">    Node res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) res.x[i]=x[i]+<span class="keyword">_t</span>.x[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;q[N],ans;</span><br><span class="line"><span class="keyword">double</span> as=INF;</span><br><span class="line"><span class="keyword">double</span> s[N];</span><br><span class="line">Node now,np;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">rand_d</span><span class="params">(<span class="keyword">double</span> l,<span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">double</span>)<span class="built_in">rand</span>()/RAND_MAX*(r-l)+l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_dist</span><span class="params">(Node x,Node y)</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) res+=(x.x[i]-y.x[i])*(x.x[i]-y.x[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>(res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">E</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> avg=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;++i)&#123;</span><br><span class="line">s[i]=<span class="built_in">get_dist</span>(x,q[i]);</span><br><span class="line">avg+=s[i];</span><br><span class="line">&#125;</span><br><span class="line">avg=avg/(n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">double</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;++i) res+=(s[i]-avg)*(s[i]-avg);</span><br><span class="line">res*=avg;</span><br><span class="line"><span class="keyword">if</span>(res&lt;as)&#123;</span><br><span class="line">as=res;</span><br><span class="line">ans=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simulate_anneal</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;++i) now=now+q[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) now.x[i]=now.x[i]/(n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">double</span> t=T0;t&gt;TE;t*=C)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) np.x[i]=now.x[i]+<span class="built_in">rand_d</span>(-t,t);</span><br><span class="line"><span class="keyword">double</span> dt=<span class="built_in">E</span>(np)-<span class="built_in">E</span>(now);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">exp</span>(-dt/t)&gt;<span class="built_in">rand_d</span>(<span class="number">0</span>,<span class="number">1</span>)) now=np;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;q[i].x[j]);</span><br><span class="line"><span class="built_in">simulate_anneal</span>(); </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">时间有限,且答案对C要求较高,我们只退火一次,</span></span><br><span class="line"><span class="comment">对应的,C调高</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%.3lf &quot;</span>,ans.x[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h2><p>对于维度少的单峰函数，除了用三分法求最值外，也可用牛顿迭代法（又名牛顿爬山法）</p><p>牛顿迭代法的核心公式是<br>$$<br>x_{i+1}=x_i-\frac{f(x_i)}{f’(x_i)}<br>$$<br>但牛顿迭代法有一个巨大的缺陷——我这么弱根本求不出导函数来，<del>笑死</del>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 暴力 </tag>
            
            <tag> 模拟退火 </tag>
            
            <tag> 爬山法 </tag>
            
            <tag> 随机数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速傅里叶变换</title>
      <link href="/2021/11/22/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
      <url>/2021/11/22/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>FFT常数比NTT大！</p><span id="more"></span><h1 id="快速傅里叶变换"><a href="#快速傅里叶变换" class="headerlink" title="快速傅里叶变换"></a>快速傅里叶变换</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>快速傅里叶变换（FFT）是一种快速求解两个多项式的乘积（或者称之为两个函数的卷积，但注意，这个卷积不是狄拉克雷卷积）的方法</p><p>例如已知<br>$$<br>\begin{align}<br>A(x)=a_0+a_1x+a_2x^2+…+a_nx^n\\<br>B(x)=b_0+b_1x+b_2x^2+…+b_nx^n<br>\end{align}<br>$$<br>求 $A*B$ </p><p>如果直接计算，复杂度显然为 $O(\sqrt{n})$ ，而FFT可以在 $O(n\log{n})$ 的时间求出答案</p><h2 id="前置知识：复数"><a href="#前置知识：复数" class="headerlink" title="前置知识：复数"></a>前置知识：复数</h2><p>任意一个复数可以表示为 $a+bi$ 的形式，其中 $a$ 被称为<strong>实部</strong>， $b$ 被称为<strong>虚部</strong>， $i=\sqrt{-1}$ 是<strong>虚数单位</strong></p><p>类似于实数可以对应到数轴上，复数可以对应到坐标轴上 </p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/k3uo7b61.png" alt="复数"></p><p>如上图， $X$ 轴表示实部， $Y$ 轴表示虚部，则 $a+bi$ 可对应到唯一的一个点，而 $a+bi$ 也就有了几何意义：一条从原点指向 $(a,b)$ 的向量 ，而该向量与 $X$ 轴的夹角 $\theta$ 被称为该复数的<strong>辐角</strong></p><p>则复数的运算有以下法则：</p><ul><li><p>$(a+bi)+(c+di)=(a+c)+(b+d)i$ </p><p>复数加法的几何意义就是向量加法</p></li><li><p>$(a+bi)(c+di)=ac+adi+cbi+bdi^2=(ac-bd)+(ad+cb)i$  </p><p>复数乘法有很好的几何意义，两个向量 $\vec{a},\vec{b}$ 的积 $\vec{c}$ 的长度（模）就是两个向量的长度和，即 $|\vec{c}|=|\vec{a}|+|\vec{b}|$ ，积的辐角就是两个向量辐角的和，即 $\theta_c=\theta_a+\theta_b$ </p></li></ul><p>在平面直角坐标系 $X0Y$ 中，画一个单位圆，将其等分为 $n$ 份，取其中的 $k$ 份，将原点于 $k$ 份的点连接形成一个向量，记为 $\omega_n^k$ ，我们称 $\omega_n^k$ 为复数域上的 $n$ 次<strong>单位根</strong>（即方程 $z^n=1$ 的根）</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/72t9f57x.png" alt="单位根"></p><p>单位根有以下性质：</p><ul><li> $\forall i\not\equiv j\pmod n,\omega_n^i\ne\omega_n^j,\forall i\equiv j\pmod n,\omega_n^i=\omega_n^j$ </li><li> $\omega_n^k=\cos{\frac{2k\pi}{n}}+i\sin{\frac{2k\pi}{n}}$ </li><li> $\omega_n^0=\omega_n^n=1$ </li><li> $\omega_{rn}^{rk}=\omega_n^k$ </li><li> $\omega_n^{k+\frac{n}{2}}=-\omega_n^k,\omega_n^{k+n}=\omega_n^k$ </li><li> $\omega_n^i*\omega_n^j=\omega_n^{i+j}$ （相乘等于辐角相加）</li></ul><h2 id="前置知识：小性质"><a href="#前置知识：小性质" class="headerlink" title="前置知识：小性质"></a>前置知识：小性质</h2><p>我们明确一个性质（在拉格朗日插值中也用到了该性质）：</p><ul><li>任意 $n+1$ 个不同的点（可以含复数）可以唯一确定一个 $n$ 次多项式（或者称其为 $n$ 次函数）</li></ul><p>证明：</p><p>把每个点带人列得 $n+1$ 个 $n+1$ 元（因为下标从 $0$ 到 $n$ ）一次方程，明显可解，则每一项的系数唯一确定，原多项式确定</p><h2 id="快速傅里叶正变换"><a href="#快速傅里叶正变换" class="headerlink" title="快速傅里叶正变换"></a>快速傅里叶正变换</h2><p>有了以上性质，我们可以把一个 $n$ 次多项式用 $n+1$ 个点表示（也叫函数的点表示法），则答案推演如下：<br>$$<br>\begin{align}<br>&amp;A(x)=a_0+a_1x+a_2x^2+…+a_nx^n\\<br>\text{可表示为}&amp;A:{(x_1,A(x_1)),(x_2,A(x_2)),…,(x_{n+1},A(x_{n+1}))}\\<br>\text{同理}&amp;B:{(x_1,B(x_1)),(x_2,B(x_2)),…,(x_{n+1},B(x_{n+1}))}\\<br>\text{则}C=A*&amp;B:{(x_1,A(x_1)B(x_1)),(x_2,A(x_2)B(x_2)),…,(x_{n+1},A(x_{n+1})B(x_{n+1}))}<br>\end{align}<br>$$<br>我们发现在点表示法下求 $A*B$ 是 $O(n)$ 的，那么问题其实就变成了如何快速的实现点表示法和系数表示法的互相转换</p><p>我们观察性质，<strong>任意</strong>两个字是关键——我们可否通过取一些特殊的点来使求解变得简单呢？当然是可以的，FFT通过取<strong>复数域上的单位根</strong>来加上运算，也就是说，我们取 $\omega_{n+1}^0\sim\omega_{n+1}^n$ </p><p>那么FFT如何利用这些点来将系数表示法转换为点表示法呢？先变形：<br>$$<br>\begin{align}<br>A(x)<br>&amp;=a_0+a_1x+a_2x^2+…+a_nx^n\\<br>\text{分奇数项和偶数项，令}A_1(x)<br>&amp;=a_0+a_2x+a_4x^2+a_6x^3+…\\<br>A_2(x)<br>&amp;=a_1+a_3x+a_5x^2+a_7x^3+…\\<br>\text{明显，}A_1,A_2&amp;\text{都是}\lfloor\frac{n}{2}\rfloor\text{次多项式}\\<br>\text{则}A(x)<br>&amp;=A_1(x^2)+xA_2(x^2)\\<br>\text{遍历}k\in[0,\frac{n-1}{2}]\text{有}A(\omega_{n+1}^k)<br>&amp;=A_1(\omega_{n+1}^{2k})+\omega_{n+1}^kA_2(\omega_{n+1}^{2k})\\<br>&amp;=A_1(\omega_\frac{n+1}{2}^k)+\omega_{n+1}^kA_2(\omega_\frac{n+1}{2}^k)\\<br>\text{同样，有}A(\omega_{n+1}^{k+\frac{n+1}{2}})<br>&amp;=A_1(\omega_{n+1}^{2k+n+1})+\omega_{n+1}^{k+\frac{n+1}{2}}A_2(\omega_{n+1}^{2k+n+1})\\<br>&amp;=A_1(\omega_{n+1}^{2k})-\omega_{n+1}^{k}A_2(\omega_{n+1}^{2k})\\<br>&amp;=A_1(\omega_\frac{n+1}{2}^k)-\omega_{n+1}^{k}A_2(\omega_\frac{n+1}{2}^k)\\<br>\text{我们发现只要我们求出}<br>&amp;k\in[0,\frac{n-1}{2}]\text{时的所有}A_1(\omega_\frac{n+1}{2}^k)\text{和}\omega_{n+1}^{k}A_2(\omega_\frac{n+1}{2}^k)\\<br>\text{就可以计算出}<br>&amp;k\in[0，n]\text{时的所有}A(\omega_{n+1}^k)<br>\end{align}<br>$$<br>由此，可以每次把区间分半，将系数多项式转换为点表示法，时间复杂度为 $O(n\log{n})$   </p><h2 id="快速傅里叶逆变换"><a href="#快速傅里叶逆变换" class="headerlink" title="快速傅里叶逆变换"></a>快速傅里叶逆变换</h2><p>现在已经解决了正变换，我们来看逆变换：<br>$$<br>\text{已知}A:{(\omega_{n+1}^k,A(\omega_{n+1}^k)),k\in[0,n]}\\<br>\text{设}A(x)=a_0+a_1x+a_2x^2+…+a_nx^n,y_k=A(\omega_{n+1}^k)\\<br>\text{则有}a_k(n+1)=\sum_{i=0}^{n}y_i(\omega_{n+1}^{-k})^i<br>$$<br>证明如下：</p><p>$$<br>\begin{align}<br>\sum_{i = 0} ^ {n} y_i (\omega_{n + 1} ^ {- k}) ^ i<br>&amp;=\sum_{i=0}^{n} A(\omega_{n+1}^i) (\omega_{n+1}^{-k}) ^ i\\<br>&amp;=\sum_{i=0}^{n} (\sum_{j=0}^{n} a_j (\omega_{n+1} ^ i ) ^ j ) (\omega_{n+1}^{-k}) ^ i\\<br>&amp;=\sum_{i=0}^{n}(\sum_{j=0}^{n} a_j (\omega_{n+1}^j) ^ i (\omega_{n+1}^{-k}) ^ i)\\<br>&amp;=\sum_{i=0}^{n}\sum_{j=0}^{n} a_j (\omega_{n+1}^{j-k}) ^ i\\<br>&amp;=\sum_{j=0}^{n}\sum_{i=0}^{n} a_j (\omega_{n+1}^{j-k}) ^ i\\<br>&amp;=\sum_{j=0}^{n}a_j (\sum_{i=0}^{n} (\omega_{n+1}^{j-k}) ^ i)\\<br>&amp;\text{令}S(x)=\sum_{j=0}^{n}x^i\\<br>&amp;\text{则} S(\omega_{n+1}^k)=\omega_{n+1}^0+\omega_{n+1}^k+\omega_{n+1}^{2k}+…+\omega_{n+1}^{nk}\\<br>&amp;\omega_{n+1}^k S(\omega_{n+1}^k) =\omega_{n+1}^k+\omega_{n+1}^{2k}+\omega_{n+1}^{3k}+…+\omega_{n+1}^{(n+1)k}\\<br>\text{又}<br>&amp;\because \omega_{n+1}^{(n+1)k}= \omega_{n+1}^0=1\\<br>&amp;\therefore S(\omega_{n+1}^k)=\omega_{n+1}^k S(\omega_{n+1}^k)\\<br>&amp;\therefore (1-\omega_{n+1}^k) S(\omega_{n+1}^k)=0\\<br>&amp;\text{若}k=0\text{，即}1- \omega_{n+1}^k=0\\<br>&amp;\text{则} S(\omega_{n+1}^k) = S(1) = n+1\\<br>&amp;\text{若}k\ne0\text{，即} 1-\omega_{n+1}^k\ne0\\<br>&amp;\text{则} S(\omega_{n+1}^k)=0\\<br>\text{总上所述} S(\omega_{n+1}^k)<br>&amp;=[k==0] (n+1)\\<br>\text{故}\sum_{i=0}^{n} y_i (\omega_{n+1}^{-k})^i<br>&amp;=\sum_{j=0}^{n} a_j S(\omega_{n+1}^{j-k})\\<br>&amp;=\sum_{j=0}^{n} a_j [j==k] (n+1)\\<br>&amp;=a_k(n+1)\\<br>\end{align}<br>$$</p><p>那么现在，有了 $a_k(n+1)=\sum_{i=0}^{n}y_i(\omega_{n+1}^{-k})^i$ ，不妨令 $A’(x)=\sum_{i=0}^{n}y_ix^i$ ，则 $a_k(n+1)=A’(\omega_{n+1}^{-k})$ </p><p>我们只需要快速求出 $A’(\omega_{n+1}^{0})\sim A’(\omega_{n+1}^{-n})$ ——这正好就是快速傅里叶正变换！</p><h2 id="递归化迭代"><a href="#递归化迭代" class="headerlink" title="递归化迭代"></a>递归化迭代</h2><p>由于用递归实现FFT常数过大，我们考虑用迭代的方式实现FFT（其实常数也挺大的），观察下面的图：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/rc07p4no.png" alt="迭代"></p><p>计算每一个数时都要用到下方被横线连着的几个数，找找规律<del>找的到个鬼</del>，我们发现下面的每一项都是上面的数的二进制翻转，如 $1=(001)_2$ 对应最下方的 $4=(100)_2$ ，$6=(110)_2$ 对应最下方的 $3=(011)<em>2$ ，不妨设 $i$ 二进制翻转后为 $r_i$ ，则有 $r_i=(r</em>{\frac{i}{2}}&gt;&gt;1){\Large|}(i&amp;1)&lt;&lt;(bit-1)$ </p><p>为了好算，我们保证项数为 $2$ 的整次幂（不足就补）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://www.luogu.com.cn/problem/P3803">模板</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3000000</span>+<span class="number">5</span>; <span class="comment">//注意N要大于二倍n </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span>&#123;</span> <span class="comment">//定义复数 </span></span><br><span class="line"><span class="keyword">double</span> a,b;</span><br><span class="line"><span class="function">Complex <span class="title">make_C</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> _a,<span class="keyword">const</span> <span class="keyword">double</span> _b)</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">Complex res;</span><br><span class="line">res.a=_a,res.b=_b;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;<span class="keyword">_t</span>)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make_C</span>(a+<span class="keyword">_t</span>.a,b+<span class="keyword">_t</span>.b);</span><br><span class="line">&#125;</span><br><span class="line">Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp;<span class="keyword">_t</span>)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make_C</span>(a-<span class="keyword">_t</span>.a,b-<span class="keyword">_t</span>.b);</span><br><span class="line">&#125;</span><br><span class="line">Complex <span class="keyword">operator</span>*(<span class="keyword">const</span> Complex &amp;<span class="keyword">_t</span>)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make_C</span>(a*<span class="keyword">_t</span>.a-b*<span class="keyword">_t</span>.b,a*<span class="keyword">_t</span>.b+b*<span class="keyword">_t</span>.a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;a[N],b[N];</span><br><span class="line"><span class="keyword">int</span> r[N],bit,tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(Complex x[],<span class="keyword">int</span> inv)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;++i)</span><br><span class="line"><span class="keyword">if</span>(i&lt;r[i]) <span class="built_in">swap</span>(x[i],x[r[i]]);</span><br><span class="line">Complex w1,wk,a1,a2;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> mid=<span class="number">1</span>;mid&lt;tot;mid&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">w1=w1.<span class="built_in">make_C</span>(<span class="built_in">cos</span>(PI/mid),inv*<span class="built_in">sin</span>(PI/mid)); ; <span class="comment">//由于cos正负相同,不必乘inv </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;i+=(mid&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">wk=wk.<span class="built_in">make_C</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;mid;++j,wk=wk*w1)&#123;</span><br><span class="line">a1=x[i+j],a2=wk*x[i+j+mid];</span><br><span class="line">x[i+j]=a1+a2,x[i+j+mid]=a1-a2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m; <span class="comment">//建议将n,m定义为局部变量,防止与tot混淆 </span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;a[i].a);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;b[i].a);</span><br><span class="line"><span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;bit)&lt;n+m+<span class="number">1</span>) ++bit;</span><br><span class="line">tot=<span class="number">1</span>&lt;&lt;bit;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;++i) r[i]=(r[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(bit<span class="number">-1</span>)); </span><br><span class="line"><span class="built_in">fft</span>(a,<span class="number">1</span>),<span class="built_in">fft</span>(b,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;++i) a[i]=a[i]*b[i];</span><br><span class="line"><span class="built_in">fft</span>(a,<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n+m;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,(<span class="keyword">int</span>)(a[i].a/tot+<span class="number">0.5</span>)); <span class="comment">//加0.5来四舍五入 </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>FFT的题一般都转化成两个多项式（函数）的乘积，是来看一道题：</p><p><a href="https://www.luogu.com.cn/problem/P1919">A*B</a></p><p>题目要求我们求一个高精乘高精，若直接求，显然 $O(n^2)$ ，考虑FFT优化：<br>$$<br>\begin{align}<br>A<br>&amp;={a_{n-1} a_{n-2} …a_0}\\<br>B<br>&amp;={b_{n-1} b_{n-2} …b_0}\\<br>\text{不妨设} f_A(x)<br>&amp;=a_{n-1} x^{n-1} + a_{n-2} x^{n-2} +…+ a_0x^0\\<br>f_B(x)<br>&amp;=b_{n-1} x^{n-1} + b_{n-2} x^{n-2} +…+ b_0x^0\\<br>\text{则} Ans<br>&amp;=A* B\\<br>\end{align}<br>$$<br>那么问题就转化为求函数 $f_C=f_A*f_B$ 答案就是 $f_C$ 的系数 </p><p>用FFT求 $f_C$ 时间复杂度 $O(n\log{n})$ </p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3000000</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">double</span> a,b;</span><br><span class="line"><span class="function">Complex <span class="title">make_C</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> _a,<span class="keyword">const</span> <span class="keyword">double</span> _b)</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">Complex res;</span><br><span class="line">res.a=_a,res.b=_b;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;<span class="keyword">_t</span>)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make_C</span>(a+<span class="keyword">_t</span>.a,b+<span class="keyword">_t</span>.b);</span><br><span class="line">&#125;</span><br><span class="line">Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp;<span class="keyword">_t</span>)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make_C</span>(a-<span class="keyword">_t</span>.a,b-<span class="keyword">_t</span>.b);</span><br><span class="line">&#125;</span><br><span class="line">Complex <span class="keyword">operator</span>*(<span class="keyword">const</span> Complex &amp;<span class="keyword">_t</span>)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make_C</span>(a*<span class="keyword">_t</span>.a-b*<span class="keyword">_t</span>.b,a*<span class="keyword">_t</span>.b+b*<span class="keyword">_t</span>.a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;a[N],b[N];</span><br><span class="line"><span class="keyword">char</span> s1[N],s2[N];</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="keyword">int</span> r[N],bit=<span class="number">0</span>,tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(Complex x[],<span class="keyword">int</span> inv)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;++i)</span><br><span class="line"><span class="keyword">if</span>(i&lt;r[i]) <span class="built_in">swap</span>(x[i],x[r[i]]);</span><br><span class="line">Complex w1,wk,a1,a2;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> mid=<span class="number">1</span>;mid&lt;tot;mid&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">w1=w1.<span class="built_in">make_C</span>(<span class="built_in">cos</span>(PI/mid),inv*<span class="built_in">sin</span>(PI/mid));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;i+=(mid&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">wk=wk.<span class="built_in">make_C</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;mid;++j,wk=wk*w1)&#123;</span><br><span class="line">a1=x[i+j],a2=wk*x[i+j+mid];</span><br><span class="line">x[i+j]=a1+a2,x[i+j+mid]=a1-a2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,s1,s2);</span><br><span class="line">n=<span class="built_in">strlen</span>(s1)<span class="number">-1</span>,m=<span class="built_in">strlen</span>(s2)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i) a[i].a=s1[n-i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;++i) b[i].a=s2[m-i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;bit)&lt;n+m+<span class="number">1</span>) ++bit;</span><br><span class="line">tot=<span class="number">1</span>&lt;&lt;bit;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;++i)</span><br><span class="line">r[i]=(r[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(bit<span class="number">-1</span>));</span><br><span class="line"><span class="built_in">fft</span>(a,<span class="number">1</span>),<span class="built_in">fft</span>(b,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;++i) a[i]=a[i]*b[i];</span><br><span class="line"><span class="built_in">fft</span>(a,<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,<span class="keyword">_t</span>=<span class="number">0</span>;i&lt;tot||<span class="keyword">_t</span>;++i)&#123;</span><br><span class="line"><span class="keyword">_t</span>+=a[i].a/tot+<span class="number">0.5</span>;</span><br><span class="line">ans[k++]=<span class="keyword">_t</span>%<span class="number">10</span>;</span><br><span class="line"><span class="keyword">_t</span>/=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(k&gt;<span class="number">1</span>&amp;&amp;ans[k<span class="number">-1</span>]==<span class="number">0</span>) --k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=k<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数论,数学 </tag>
            
            <tag> 快速傅里叶变换,FFT </tag>
            
            <tag> 多项式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基环树DP</title>
      <link href="/2021/11/22/%E5%9F%BA%E7%8E%AF%E6%A0%91DP/"/>
      <url>/2021/11/22/%E5%9F%BA%E7%8E%AF%E6%A0%91DP/</url>
      
        <content type="html"><![CDATA[<p>仙人掌的特殊情况</p><span id="more"></span><h1 id="基环树DP"><a href="#基环树DP" class="headerlink" title="基环树DP"></a>基环树DP</h1><h2 id="前置知识：基环树"><a href="#前置知识：基环树" class="headerlink" title="前置知识：基环树"></a>前置知识：基环树</h2><p>包含 $n$ 个点 $n$​ 条边的联通图叫做<strong>基环树</strong>，可以看作一棵树上添加一条边（可重边和自环），这样会形成一个<strong>只有一个环</strong>的图，可以把环看成一个广义上的根节点，环上的每一个点为根都挂着一棵树（可以为空），所以叫做基环树，当然，很多棵基环树构成一个<strong>基环树森林</strong>，明显，基环树森林也是点数等于边数的</p><p>对于基环树，关键点是处理环</p><h2 id="例题一"><a href="#例题一" class="headerlink" title="例题一"></a>例题一</h2><p><a href="https://www.acwing.com/problem/content/360/">岛屿</a></p><p>本题大意是要求一个基环树森林中每个基环树的直径，这就是一个非常经典的基环树dp：</p><p>考虑某一棵基环树的直径（设为 $u$ 到 $v$ ），若直径不经过环，即 $u,v$ 属于同一棵树，树形dp即可求出直径；若直径经过环，即 $u,v$ 分属于两棵树，两棵树的根节点通过环联通，可以计算出 $u,v$ 各自到根的距离，再计算出环上两根的距离，求和即可</p><p>以上是我们知道直径的情况，但实际上，我们并不知道直径是哪两个点，所以必须两种情况都计算：先树形dp处理情况1，再枚举环上的点 $x,y$ （这两个节点必然是某棵树的根），计算情况2，总的时间复杂度 $O(n^2)$ ，必须考虑优化</p><p>我们发现树形dp是 $O(n)$ 的，时间主要耗费在情况2的枚举上了</p><p>不妨设 $d[x]$ 表示 $x$ 所在树上离 $x$ 最远的点到 $x$ 的距离， $d[y]$ 同理，设 $S(x,y)$ 表示环上从 $x$ 顺时针走到 $y$ 的距离（这样的好处是 $S(x,y)$ 是唯一确定的，并且这样也一定不会漏答案，因为 $x$ 逆时针走到 $y$ 的情况就是 $y$ 顺时针走到 $x$ ），那么对于每一个 $x$ ，我们要在环上找到一个 $y$  ， 使 $d[x] + d[y] + S(x, y)$ 最大</p><p>明显， $S(x,y)$ 可以转化为前缀和，则原式变为 $d[x] + d[y] + sum[x] - sum[y]$ ，对于确定的 $x$ ，只需要求一个 $d[y] - sum[y]$  的最大值，考虑经典的把环二倍成链的方法，破环成链，这就是一个典型的滑动窗口问题，单调队列解决，时间复杂度 $O(n)$ </p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ne, ver, w;</span><br><span class="line">&#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> h[N], idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> fa[N], fw[N]; <span class="comment">//父节点和到父节点的距离</span></span><br><span class="line"><span class="keyword">int</span> q[N], l, r; <span class="comment">//单调队列</span></span><br><span class="line">LL s[N], d[N &lt;&lt; <span class="number">1</span>], sum[N &lt;&lt; <span class="number">1</span>]; <span class="comment">//s:环上前缀和,sum:成链二倍后的前缀和</span></span><br><span class="line">LL ans, as;</span><br><span class="line"><span class="keyword">bool</span> v[N], ins[N];</span><br><span class="line"><span class="keyword">int</span> cir[N], ed[N], cnt = <span class="number">0</span>; <span class="comment">//cir:所有的环成的链(未二倍),ed:每个环的终点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx].ver = y, e[idx].w = z, e[idx].ne = h[x], h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_c</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> in_e)</span> <span class="comment">//找环</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">v[x] = ins[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i == (in_e ^ <span class="number">1</span>))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">y = e[i].ver;</span><br><span class="line">fa[y] = x, fw[y] = e[i].w;</span><br><span class="line"><span class="keyword">if</span> (!v[y])</span><br><span class="line"><span class="built_in">dfs_c</span>(y, i);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ins[y])</span><br><span class="line">&#123;</span><br><span class="line">++cnt;</span><br><span class="line">ed[cnt] = ed[cnt - <span class="number">1</span>];</span><br><span class="line">LL _sum = e[i].w;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> z = x; z != y; z = fa[z])</span><br><span class="line">&#123;</span><br><span class="line">s[z] = _sum;</span><br><span class="line">cir[++ed[cnt]] = z;</span><br><span class="line">_sum += fw[z];</span><br><span class="line">&#125;</span><br><span class="line">s[y] = _sum;</span><br><span class="line">cir[++ed[cnt]] = y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ins[x] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//树形dp</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">v[x] = <span class="literal">true</span>;</span><br><span class="line">LL d1 = <span class="number">0</span>, d2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (v[y])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">LL _d = <span class="built_in">dp</span>(y) + e[i].w;</span><br><span class="line"><span class="keyword">if</span> (_d &gt;= d1)</span><br><span class="line">d2 = d1, d1 = _d;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_d &gt; d2)</span><br><span class="line">d2 = _d;</span><br><span class="line">&#125;</span><br><span class="line">as = <span class="built_in">max</span>(as, d1 + d2); <span class="comment">//统计不过环的情况</span></span><br><span class="line"><span class="keyword">return</span> d1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">h[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j, w; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;j, &amp;w);</span><br><span class="line"><span class="built_in">add</span>(i, j, w), <span class="built_in">add</span>(j, i, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">if</span> (!v[i])</span><br><span class="line"><span class="built_in">dfs_c</span>(i, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">v[i] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ed[cnt]; ++i)</span><br><span class="line">v[cir[i]] = <span class="literal">true</span>;</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, si; i &lt;= cnt; ++i)</span><br><span class="line">&#123;</span><br><span class="line">as = si = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = ed[i - <span class="number">1</span>] + <span class="number">1</span>; j &lt;= ed[i]; ++j)</span><br><span class="line">&#123;</span><br><span class="line">d[++si] = <span class="built_in">dp</span>(cir[j]);</span><br><span class="line">sum[si] = s[cir[j]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= si; ++j)</span><br><span class="line">d[si + j] = d[j], sum[si + j] = sum[j] + sum[si];</span><br><span class="line">l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= si * <span class="number">2</span>; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r &amp;&amp; j - q[l] &gt;= si)</span><br><span class="line">++l;</span><br><span class="line"><span class="keyword">if</span> (l &lt;= r)</span><br><span class="line">as = <span class="built_in">max</span>(as, d[j] + sum[j] + d[q[l]] - sum[q[l]]);</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r &amp;&amp; d[q[r]] - sum[q[r]] &lt;= d[j] - sum[j])</span><br><span class="line">--r;</span><br><span class="line">q[++r] = j;</span><br><span class="line">&#125;</span><br><span class="line">ans += as;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题二"><a href="#例题二" class="headerlink" title="例题二"></a>例题二</h2><p><a href="https://www.luogu.com.cn/problem/P2607">骑士</a></p><p>给定一个内向基环树森林，要求一个点集，在满足集合中任意两点没有公共边的前提下最大化点权和</p><p>这道题和树形dp中<a href="https://www.luogu.com.cn/problem/P1352">没有上司的舞会</a>非常像，区别是本题是基环树，而那道题是树，这样，就有一个明显的方法：删掉环上的一条边 $(x,y)$ ，就转化为没有上司的舞会，设 $f[i][0/1]$ 表示在以 $i$ 为根的子树中不选/选了 $i$ 的最大点权和，以 $x$ 为根做树形dp即可</p><p>思考该方法的正确性：若最终答案没有选 $x$ ，那么 $(x,y)$ 没有意义，删去也没有关系， $f[x][0]$ 就是答案；但如果最终答案选了 $x$ 就必然不能选 $y$ 可以再做第二次树形dp，这次强迫不选 $y$ ，答案就是 $f[x][1]$ ，总的时间复杂度为 $O(n)$</p><p>像本题这样<strong>删去一条环上的边后考虑删去造成的影响，通过强行限定一些条件多次dp求解</strong>也是解决基环树dp的常用方法</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ne, ver;</span><br><span class="line">&#125; e[N];</span><br><span class="line"><span class="keyword">int</span> h[N], idx = <span class="number">0</span>;</span><br><span class="line">LL f1[N][<span class="number">2</span>], f2[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> w[N];</span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> v[N], ins[N], rme[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx].ver = y, e[idx].ne = h[x], h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> rmn, LL f[][<span class="number">2</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (rme[i])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="built_in">dp</span>(y, rmn, f);</span><br><span class="line">f[x][<span class="number">0</span>] += <span class="built_in">max</span>(f[y][<span class="number">0</span>], f[y][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">f[x][<span class="number">1</span>] = -INF;</span><br><span class="line"><span class="keyword">if</span> (x != rmn)</span><br><span class="line">&#123;</span><br><span class="line">f[x][<span class="number">1</span>] = w[x];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (rme[i])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">y = e[i].ver; </span><br><span class="line">f[x][<span class="number">1</span>] += f[y][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_c</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">v[x] = ins[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (!v[y])</span><br><span class="line"><span class="built_in">dfs_c</span>(y);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ins[y])</span><br><span class="line">&#123;</span><br><span class="line">rme[i] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">dp</span>(y, <span class="number">-1</span>, f1);</span><br><span class="line"><span class="built_in">dp</span>(y, x, f2);</span><br><span class="line">ans += <span class="built_in">max</span>(f1[y][<span class="number">0</span>], f2[y][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ins[x] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">h[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j, _w; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;_w, &amp;j);</span><br><span class="line"><span class="built_in">add</span>(j, i);</span><br><span class="line">w[i] = _w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">if</span> (!v[i])</span><br><span class="line"><span class="built_in">dfs_c</span>(i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题三"><a href="#例题三" class="headerlink" title="例题三"></a>例题三</h2><p>在来看看最后一题</p><p><a href="https://www.acwing.com/problem/content/361/">创世纪</a></p><p>和上题类似，考虑断开一条环上的边 $(x,y)$ ，设 $f[i][0/1]$ 表示在以 $i$ 为根的子树中不选/选了 $i$ 最多能选多少个点，转移如下：<br>$$<br>f[i][0]=\sum_{j\in son(i)}\max(f[k][0],f[k][1])\<br>f[i][1]=\max_{j\in son(i)}(f[i][0]-\max(f[j][0],f[j][1])+f[j][0])+1<br>$$<br>同样的，做两遍dp，一遍强迫不选 $(x,y)$ ，不必做任何处理， $Ans=\max(f[x][0],f[x][1])$ ；另一遍必选 $(x,y)$ 则一定用 $x$ 去限制 $y$ ，则必不选 $x$ ，必选 $y$， $Ans=f[x][0]$ </p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ne, ver;</span><br><span class="line">&#125; e[N];</span><br><span class="line"><span class="keyword">int</span> h[N], idx = <span class="number">0</span>;</span><br><span class="line">LL f1[N][<span class="number">2</span>], f2[N][<span class="number">2</span>];</span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> v[N], ins[N], rme[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx].ver = y, e[idx].ne = h[x], h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> must, LL f[][<span class="number">2</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (rme[i])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="built_in">dp</span>(y, must, f);</span><br><span class="line">f[x][<span class="number">0</span>] += <span class="built_in">max</span>(f[y][<span class="number">0</span>], f[y][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x == must)</span><br><span class="line">&#123;</span><br><span class="line">f[x][<span class="number">1</span>] = f[x][<span class="number">0</span>] + <span class="number">1</span>; <span class="comment">//若必选,则该点以被限制,其字节点可选可不选,加本身一个点</span></span><br><span class="line">f[x][<span class="number">0</span>] = -INF; <span class="comment">//必须就没有不选的情况</span></span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">f[x][<span class="number">1</span>] = -INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (rme[i])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">y = e[i].ver; </span><br><span class="line">f[x][<span class="number">1</span>] = <span class="built_in">max</span>(f[x][<span class="number">0</span>] - <span class="built_in">max</span>(f[y][<span class="number">1</span>], f[y][<span class="number">0</span>]) + f[y][<span class="number">0</span>] + <span class="number">1</span>, f[x][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_c</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">v[x] = ins[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (!v[y])</span><br><span class="line"><span class="built_in">dfs_c</span>(y);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ins[y])</span><br><span class="line">&#123;</span><br><span class="line">rme[i] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">dp</span>(y, <span class="number">-1</span>, f1);</span><br><span class="line"><span class="built_in">dp</span>(y, x, f2);</span><br><span class="line">ans += <span class="built_in">max</span>(<span class="built_in">max</span>(f1[y][<span class="number">0</span>], f1[y][<span class="number">1</span>]), f2[y][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ins[x] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">h[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;j);</span><br><span class="line"><span class="built_in">add</span>(j, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">if</span> (!v[i])</span><br><span class="line"><span class="built_in">dfs_c</span>(i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> 图论 </tag>
            
            <tag> dp </tag>
            
            <tag> 基环树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分块和块状链表</title>
      <link href="/2021/11/22/%E5%88%86%E5%9D%97%E5%92%8C%E5%9D%97%E7%8A%B6%E9%93%BE%E8%A1%A8/"/>
      <url>/2021/11/22/%E5%88%86%E5%9D%97%E5%92%8C%E5%9D%97%E7%8A%B6%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>暴力真的出了奇迹</p><span id="more"></span><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>对于一个长为 $n$ 的序列，把它分为 $\sqrt{n}$ 个“块”，“块”内的操作暴力求解，跨“块”的操作用“块”中的信息计算。 </p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>由于分块是一种思想，我们用一道例题具体分析。<br><a href="https://www.acwing.com/problem/content/244/">AcWing243一个简单的整数问题2</a><br>本题标程是线段树求解，用分块虽然效率不如，但思路和代码难度较之间单不少。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ol><li><p>把序列分为 $\sqrt{n}$ 个“块” </p></li><li><p>对于操作一，区间 $[l,r]$ 被分为若干个完整“块”和至多两个不完整“块”，不妨在完整“块”上打一个懒标记，定义 $add$ 为“本‘块’中的所有数都要加上 $add$ ”，而不完整块暴力解决</p></li><li><p>对于操作二，区间 $[l,r]$ 被分为若干个完整“块”和至多两个不完整“块”，同上可定义 $sum$ 为“本‘块’中所有数的真实的，即算了 $add$ 的和”，而不完整块暴力解决</p></li></ol><p>总的来说，就是“整‘块’懒标记，‘块’内打暴力”。修改和查询的时间复杂度都为 $O(\sqrt{n})$ ，大于线段树的 $O(\log n)$ （当 $n=10^5$ 时， $\sqrt{n} \approx 317$ 而 $\log n \approx 17$ ），但分块的思路和代码难度都简单不少。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, M = <span class="number">350</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, len;</span><br><span class="line"><span class="keyword">int</span> w[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LL add, sum;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> add(i) b[i].add</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(i) b[i].sum</span></span><br><span class="line">&#125; b[M];</span><br><span class="line"><span class="comment">//判断x对应第几块</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x - <span class="number">1</span>) / len; <span class="comment">//减一可以保证第0块一定有len个</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">get</span>(l) == <span class="built_in">get</span>(r))</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i)</span><br><span class="line">            w[i] += d, <span class="built_in">sum</span>(<span class="built_in">get</span>(i)) += d;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">int</span> i = l, j = r;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">get</span>(i) == <span class="built_in">get</span>(l))</span><br><span class="line">            w[i] += d, <span class="built_in">sum</span>(<span class="built_in">get</span>(i)) += d, ++i;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">get</span>(j) == <span class="built_in">get</span>(r))</span><br><span class="line">            w[j] += d, <span class="built_in">sum</span>(<span class="built_in">get</span>(j)) += d, --j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="built_in">get</span>(i); k &lt;= <span class="built_in">get</span>(j); ++k)</span><br><span class="line">            <span class="built_in">sum</span>(k) += len * d, <span class="built_in">add</span>(k) += d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">get</span>(l) == <span class="built_in">get</span>(r))</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i)</span><br><span class="line">            res += w[i] + <span class="built_in">add</span>(<span class="built_in">get</span>(i));</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">int</span> i = l, j = r;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">get</span>(i) == <span class="built_in">get</span>(l))</span><br><span class="line">            res += w[i] + <span class="built_in">add</span>(<span class="built_in">get</span>(i)), ++i;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">get</span>(j) == <span class="built_in">get</span>(r))</span><br><span class="line">            res += w[j] + <span class="built_in">add</span>(<span class="built_in">get</span>(j)), --j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="built_in">get</span>(i); k &lt;= <span class="built_in">get</span>(j); ++k)</span><br><span class="line">            res += <span class="built_in">sum</span>(k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    len = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">        <span class="built_in">sum</span>(<span class="built_in">get</span>(i)) += w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">2</span>];<span class="number">1.</span> </span><br><span class="line">    <span class="keyword">int</span> l, r, d;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line"> &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">if</span> (*op == <span class="string">&#x27;C&#x27;</span>) </span><br><span class="line">&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line">            <span class="built_in">change</span>(l, r, d);</span><br><span class="line">        &#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">query</span>(l, r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="块状链表"><a href="#块状链表" class="headerlink" title="块状链表"></a>块状链表</h2><p>我们已经用分块的思想实现了修改和查询操作，但是，如何实现插入、删除操作呢？<br>我们发现，对于一个序列，插入新数后，其分块方式就变了，必须更新每一块！每一块都要重新计算，太过麻烦，且时间复杂度过大。<br>为此，我们只好换一种分块方式——用链表的形式储存块，相邻两块之间用指针相连。<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/euwvrafj.png" alt="块状链表"></p><h3 id="插入-删除"><a href="#插入-删除" class="headerlink" title="插入/删除"></a>插入/删除</h3><p>进行插入操作（如在块 $[l,r]$ 中插入一段 $[a,b]$ ）时，我们如下操作：</p><ol><li><p>把 $[l,r]$ 断开，并把断开后的两段用指针相连<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/zy0alq1a.png" alt="分段"></p></li><li><p>把 $[a,b]$ 构建成一个块状链表<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/eosmzh6y.png" alt="构造"></p></li><li><p>把断开的两段间的指针指向 $[a,b]$<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/fjs4u4cr.png" alt="插入"></p></li></ol><p>同理，删除操作：</p><ol><li><p>删除开头块中被区间覆盖的部分，具体方法为：把本块被覆盖前的点后移，覆盖掉需要被删除的点，并更新长度<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/cvevijkv.png" alt="删除前"></p></li><li><p>删除中间的完整块，具体方法为：调整两端指针，回收中间指针<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/qot7oa22.png" alt="删除中"></p></li><li><p>删除结尾块被覆盖的部分，具体方法为：把本块被覆盖的点后的点前移，覆盖掉需要被删除的点，并更新长度<img src="https://cdn.luogu.com.cn/upload/image_hosting/a7uqipax.png" alt="删除后"></p></li></ol><p>但是聪明的人已经发现了，这样做的一个问题——无法保证每个块的长度均匀，甚至会有块中只有1、2个数，这样会导致块非常多，严重影响我们的效率。</p><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>为了解决那些长度很小的块，我们需要定期合并一些块。合并方法如下：</p><ol><li><p>遍历每个块</p></li><li><p>对于每个块，若下一个块可以合并在当前块中（即当前块的长度加下一个块的长度小于等于最大长度，即 $\sqrt{n}$ ），就进行合并。具体方法为： 将下一个块复制到当前块，删除下一个块。</p></li></ol><p>进行完如下操作后，剩下的块中任意相邻两块的长度和是一定大于 $\sqrt{n}$ 的，这样平均下来每一段的长度大于 $\frac{\sqrt{n}}{2}$ 总的段数小于 $2\sqrt{n}$ 。</p><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.com.cn/problem/P4008">P4008</a><br>代码：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000</span> + <span class="number">5</span>, M = <span class="number">2000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, x, y; <span class="comment">//n:操作个数,x、y:光标位置</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bolck</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> s[N + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> c;    <span class="comment">//字符个数</span></span><br><span class="line">    <span class="keyword">int</span> l, r; <span class="comment">//左右指针</span></span><br><span class="line">&#125; p[M];</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">20000000</span> + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> q[M], tt; <span class="comment">//内存缓冲区</span></span><br><span class="line"><span class="comment">//光标移动到第k个字符后</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = p[<span class="number">0</span>].r;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; p[x].c)</span><br><span class="line">        k -= p[x].c, x = p[x].r;</span><br><span class="line">    y = k - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将节点v插入到节点u右边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p[v].r = p[u].r, p[p[u].r].l = v;</span><br><span class="line">    p[u].r = v, p[v].l = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除节点u</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p[p[u].l].r = p[u].r;</span><br><span class="line">    p[p[u].r].l = p[u].l;</span><br><span class="line">    p[u].l = p[u].r = p[u].c = <span class="number">0</span>;</span><br><span class="line">    q[++tt] = u; <span class="comment">//回收节点u</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在光标后插入k个字符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//若是在节点内插入,必须先将节点分裂成在节点末尾插入</span></span><br><span class="line">    <span class="keyword">if</span> (y &lt; p[x].c - <span class="number">1</span>)</span><br><span class="line">    &#123;                                        <span class="comment">//从光标处分裂</span></span><br><span class="line">        <span class="keyword">int</span> u = q[tt--];                     <span class="comment">//新建节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = y + <span class="number">1</span>; i &lt; p[x].c; ++i) <span class="comment">//复制后段到新建节点</span></span><br><span class="line">            p[u].s[p[u].c++] = p[x].s[i];</span><br><span class="line">        p[x].c = y + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">add</span>(x, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cur = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q[tt--];            <span class="comment">//新建节点</span></span><br><span class="line">        <span class="keyword">while</span> (p[u].c &lt; N &amp;&amp; i &lt; k) <span class="comment">//在当前节点装满前一直装</span></span><br><span class="line">            p[u].s[p[u].c++] = str[i++];</span><br><span class="line">        <span class="built_in">add</span>(cur, u);</span><br><span class="line">        cur = u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除光标后的k个字符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//若是在节点内删除,只需前后覆盖即可</span></span><br><span class="line">    <span class="keyword">if</span> (p[x].c - <span class="number">1</span> - y &gt;= k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = y + k + <span class="number">1</span>, j = y + <span class="number">1</span>; i &lt; p[x].c; ++i, ++j)</span><br><span class="line">            p[x].s[j] = p[x].s[i];</span><br><span class="line">        p[x].c -= k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则必须分类</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//除去前面节点内部的部分</span></span><br><span class="line">        k -= p[x].c - y - <span class="number">1</span>;</span><br><span class="line">        p[x].c = y + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//把中间整段删除</span></span><br><span class="line">        <span class="keyword">while</span> (p[x].r &amp;&amp; k &gt;= p[p[x].r].c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u = p[x].r;</span><br><span class="line">            k -= p[u].c;</span><br><span class="line">            <span class="built_in">del</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除后面节点内部的部分</span></span><br><span class="line">        <span class="keyword">int</span> u = p[x].r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = k; j &lt; p[u].c; ++i, ++j)</span><br><span class="line">            p[u].s[i] = p[u].s[j];</span><br><span class="line">        p[u].c -= k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出光标后的k个字符(类似删除)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x].c - <span class="number">1</span> - y &gt;= k)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = y + <span class="number">1</span>; i &lt; k; ++i, ++j)</span><br><span class="line">            <span class="built_in">putchar</span>(p[x].s[j]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        k -= p[x].c - y - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = y + <span class="number">1</span>; i &lt; p[x].c; ++i)</span><br><span class="line">            <span class="built_in">putchar</span>(p[x].s[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cur = x;</span><br><span class="line">        <span class="keyword">while</span> (p[cur].r &amp;&amp; k &gt;= p[p[cur].r].c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u = p[cur].r;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p[u].c; ++i)</span><br><span class="line">                <span class="built_in">putchar</span>(p[u].s[i]);</span><br><span class="line">            k -= p[u].c;</span><br><span class="line">            cur = u;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> u = p[cur].r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">            <span class="built_in">putchar</span>(p[u].s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//光标前移</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">front</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!y)</span><br><span class="line">    &#123;</span><br><span class="line">        x = p[x].l;</span><br><span class="line">        y = p[x].c - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//光标后移</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y &lt; p[x].c - <span class="number">1</span>)</span><br><span class="line">        y++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        x = p[x].r;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将相邻节点合并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p[<span class="number">0</span>].r; i; i = p[i].r)</span><br><span class="line">        <span class="keyword">while</span> (p[i].r &amp;&amp; p[i].c + p[p[i].r].c &lt; N)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> r = p[i].r;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = p[i].c, k = <span class="number">0</span>; k &lt; p[r].c; ++j, ++k)</span><br><span class="line">                p[i].s[j] = p[r].s[k];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (x == r)</span><br><span class="line">                x = i, y += p[i].c; <span class="comment">//更新光标位置</span></span><br><span class="line"></span><br><span class="line">            p[i].c += p[r].c;</span><br><span class="line">            <span class="built_in">del</span>(r);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; M; ++i)</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">//插入哨兵,把光标移动到开头</span></span><br><span class="line">    str[<span class="number">0</span>] = <span class="string">&#x27;&gt;&#x27;</span>;</span><br><span class="line">    <span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">move</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(op, <span class="string">&quot;Move&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">            <span class="built_in">move</span>(a + <span class="number">1</span>); <span class="comment">//因为有一个哨兵</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(op, <span class="string">&quot;Insert&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>, k = a;</span><br><span class="line">            <span class="keyword">while</span> (a)</span><br><span class="line">            &#123;</span><br><span class="line">                str[i] = <span class="built_in">getchar</span>();</span><br><span class="line">                <span class="keyword">if</span> (str[i] &gt;= <span class="number">32</span> &amp;&amp; str[i] &lt;= <span class="number">126</span>)</span><br><span class="line">                    i++, a--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">insert</span>(k);</span><br><span class="line">            <span class="built_in">merge</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(op, <span class="string">&quot;Delete&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">            <span class="built_in">remove</span>(a);</span><br><span class="line">            <span class="built_in">merge</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(op, <span class="string">&quot;Get&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">            <span class="built_in">get</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(op, <span class="string">&quot;Prev&quot;</span>))</span><br><span class="line">            <span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">after</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 暴力 </tag>
            
            <tag> 分块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笛卡尔树</title>
      <link href="/2021/11/22/%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91/"/>
      <url>/2021/11/22/%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>老缝合怪了</p><span id="more"></span><h1 id="笛卡尔树"><a href="#笛卡尔树" class="headerlink" title="笛卡尔树"></a>笛卡尔树</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>笛卡尔树是一种二叉树， 每个节点有一个键值二元组 $(k,w)$ ，其中 $k$ 满足二叉搜索树的性质，而 $w$ 满足堆的性质，<del>我知道你和我一样没看懂所以</del>，看图：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/r2jzrc9y.png" alt="笛卡尔树"></p><p>上图是一棵笛卡尔树， $k$ 是下标， $w$ 是权值，则图中的树既满足二叉搜索树的性质（ $r$ 左子树的节点下标小于 $r$ ，右子树的节点下标大于 $r$ ），也满足一个小根堆（父节点的权值小于子节点）</p><p>当然上图是一种特殊的（也是常用的）笛卡尔树，它的键值 $k$ 恰好是数组下标，这使得它有一个性质：一棵子树内的下标是连续的一个区间（这样才能满足二叉搜索树的性质）</p><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>构建一棵笛卡尔树无非就两种思路：</p><h3 id="一、保证堆性质的情况下构造二叉搜索树"><a href="#一、保证堆性质的情况下构造二叉搜索树" class="headerlink" title="一、保证堆性质的情况下构造二叉搜索树"></a>一、保证堆性质的情况下构造二叉搜索树</h3><p>其实<strong>基本不会这么写</strong>……只是提一提</p><p>以小根堆为例，每次找到最小值（记其位置为 $pos$ ）作为当前子树的根，再递归处理左子树 $[l,pos-1]$ ，右子树 $[pos+1,r]$ ，找最小值可以ST表优化，时间复杂度 $O(n\log n)$ <del>显然不能接受</del></p><h3 id="二、保证二叉搜索树性质的情况下构造堆"><a href="#二、保证二叉搜索树性质的情况下构造堆" class="headerlink" title="二、保证二叉搜索树性质的情况下构造堆"></a>二、保证二叉搜索树性质的情况下构造堆</h3><p>这才是正道</p><p>考虑将元素按照键值 $k$ 排序（如果 $k$ 是下标显然不用排序了），然后一个一个插入到当前的笛卡尔树中，则每次我们插入当前节点时，一定是插入到当前树的最右端（一直向右子树走直到无法再走），这样才满足二叉搜索树的性质（我们称根节点到最右端的节点构成的链为<strong>右链</strong>）</p><p>但我们又必须满足堆性质，所以我们执行如下操作：<strong>从下往上</strong>比较比较右链结点（设为 $x$ ）与当前新插入结点（设为 $u$ ）的权值，若找到节点 $x$ 满足 $x_w&lt;u_w$ ，就把 $u$ 接到 $x$ 的<strong>右儿子</strong>上（这样满足了堆性质），然后把原来 $x$ 的右子树变成 $u$ 的<strong>左子树</strong>（这样满足了二叉搜索树性质），具体如图：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/d3lplvvp.png" alt="构建笛卡尔树"></p><p>这样，我们发现我们维护的其实是当前树的右链（图中红色部分），可以用一个单调栈维护，每个节点显然最多进出栈一次，时间复杂度为 $O(n)$ </p><p>代码如下：</p><p><a href="https://www.luogu.com.cn/record/62335984">建树</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CartesianTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> dat, lc, rc;</span><br><span class="line">&#125; tr[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="keyword">int</span> stk[N], top = <span class="number">0</span>; <span class="comment">//数组太大,开在函数里会爆栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">tr[i].dat = a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, k; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">k = top;</span><br><span class="line"><span class="comment">//找到最下面的一个比当前小的,满足小根堆</span></span><br><span class="line"><span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; tr[stk[k]].dat &gt; tr[i].dat)</span><br><span class="line">--k;</span><br><span class="line"><span class="keyword">if</span> (k)</span><br><span class="line">tr[stk[k]].rc = i;</span><br><span class="line"><span class="keyword">if</span> (k &lt; top)</span><br><span class="line">tr[i].lc = stk[k + <span class="number">1</span>];</span><br><span class="line">top = k;</span><br><span class="line">stk[++top] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// freopen(&quot;t.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="comment">// freopen(&quot;t.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"><span class="built_in">build</span>();</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">ans ^= (<span class="keyword">long</span> <span class="keyword">long</span>)i * (tr[i].lc + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, ans);</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">ans ^= (<span class="keyword">long</span> <span class="keyword">long</span>)i * (tr[i].rc + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有些时候我们甚至不必建出树，直接用单调栈即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
            <tag> 笛卡尔树 </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乘法逆元</title>
      <link href="/2021/11/22/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/"/>
      <url>/2021/11/22/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/</url>
      
        <content type="html"><![CDATA[<p>其实比较简单</p><span id="more"></span><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>在数论中，若 $ab \equiv 1\pmod p$ ，我们就称 $a,b$　在模 $p$ 意义下互为乘法逆元，记为 $a=inv(b) \pmod p $ 或 $a=b^{-1} \pmod p$ 。</p><h1 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h1><p>逆元有什么用？我们常常遇到一些题目要求结果对一个大质数 $p$ 取模，这是因为答案很大，出题人为了不麻烦大家写高精，就采取这样的方法。加减法和乘法对取模运算都是封闭的，所以你可以处处取模来避免溢出。如：  </p><ul><li>加法：<br>$12%10=2$<br>$3%10=3$<br>$(12+3) % 10=(2+3)%10=5$</li><li>乘法：<br>$12%10=2$<br>$3%10=3$<br>$(12 \times 3) %10=(2 \times 3) %10=6$</li></ul><p>但遇到除法时，就麻烦了： </p><ul><li>除法：<br> $12%10=2$<br> $3%10=3$<br> $(12/3) %10=4 \ne(2/3)%10$ </li></ul><p>那咋办？逆元啊！看看定义式： $a=inv(b)=b^{-1} \pmod p$ ，这里明白的告诉你了： $a$ 就是模 $p$ 意义下的 $\frac{1}{b}$ 啊！故除法可以这样计算：</p><ul><li>除法：<br> $12%10=2$<br> $3%10=3$<br> $(12/3) %10=(12 \times \frac{1}{3}) %10=(2 \times inv(3))%10=4$ </li></ul><p>妙啊，dalao们的智慧真是无穷的！</p><h1 id="计算逆元"><a href="#计算逆元" class="headerlink" title="计算逆元"></a>计算逆元</h1><h2 id="拓展欧几里得"><a href="#拓展欧几里得" class="headerlink" title="拓展欧几里得"></a>拓展欧几里得</h2><p>这种方法在<a href="https://dydbenren.blog.luogu.org/ta-zhan-ou-ji-li-dei">拓展欧几里得</a>已经介绍了，那道“同余方程”其实就是在求逆元。实际上，这就是最常用的求逆元的方法。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">exgcd</span><span class="params">(LL a,LL b,LL&amp; x,LL&amp; y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!b)&#123;</span><br><span class="line">x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">LL d=<span class="built_in">exgcd</span>(b,a%b,y,x); </span><br><span class="line">y-=a/b*x;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">inv</span><span class="params">(LL a,LL p)</span></span>&#123; <span class="comment">//求a在模p下的逆元 </span></span><br><span class="line">LL x,y;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">exgcd</span>(a,p,x,y)==<span class="number">1</span>?(x%p+p)%p:<span class="number">-1</span>;<span class="comment">//-1表示无解 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h2><p>若 $p$ 为质数 ，则有 $a^p \equiv a \pmod p$ </p><p>证明：<br>费马小定理是<a href="https://dydbenren.blog.luogu.org/ou-la-ding-li">欧拉定理</a>的特殊情况，<br>欧拉定理 $a^{\varphi(n)} \equiv 1 \pmod n$ ，其中 $gcd(a,n)=1$ ，$\varphi(n)$ 为<a href="https://dydbenren.blog.luogu.org/ou-la-han-shuo">欧拉函数</a></p><ul><li>当 $gcd(a,p)=1$ 时，由欧拉定理 $a^{p-1} \equiv 1 \pmod p$ 两边同时乘 $a$ 得 $a^p \equiv a \pmod p$ </li><li>当 $gcd(a,p)\ne 1$ 时， $a$ 只能是 $p$ 的倍数，定理显然成立</li></ul><p>证毕</p><p>那么由逆元的定义推导：<br>$a\times inv(a)\equiv 1 \equiv a^{p-1} \pmod p$ ，这里 $gcd(a,p)=1$<br>于是有 $inv(a) = a^{p-2} \pmod p$<br>So，只要求下快速幂即可，注意这个方法<strong>只对 $p$ 是质数的情形有效</strong>，代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">qpow</span><span class="params">(LL a,LL n,LL p)</span></span>&#123;</span><br><span class="line">    LL ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) ans=ans%p*a%p;</span><br><span class="line">        a=a%p*a%p;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">inv</span><span class="params">(LL a,LL p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">qpow</span>(a,p<span class="number">-2</span>,p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性递推"><a href="#线性递推" class="headerlink" title="线性递推"></a>线性递推</h2><p>以上两种方法都是常用的求逆元方法，但是，洛谷<a href="https://www.luogu.com.cn/problem/P3811">P3811</a>的毒瘤模板题，必须要用特殊的方法</p><p>因为这道题要求一系列的乘法逆元，而且数据范围有点大，常规方法是行不通的。这里介绍逆元的线性递推求法（<strong>需保证 $p$ 是质数</strong>）。</p><p>设 $p=aq+r$ ，且 $q=\left \lfloor \frac{p}{a} \right \rfloor$ ， $r= p \bmod a$<br>在模 $p$ 意义下，有 $(aq+r) \equiv 0 \pmod p$<br>移项得 $aq=-r\pmod p$<br>把 $q$ 换成逆元 $a=-r \times inv(q) \pmod p$<br>再两边变逆元 $inv(a)=-inv(r) \times q\pmod p$<br>即 $inv(a)= -\left \lfloor \frac{p}{a} \right \rfloor \times inv(p \bmod a) \pmod p$</p><p>我们可以用记忆化搜索的方法，减少多次查询的时间复杂度（空间换时间）。（递推亦可，其实就这题而言递推更好）</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3000000</span>+<span class="number">5</span>;</span><br><span class="line">LL inv[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">LL n,p;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;p);</span><br><span class="line">inv[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">inv[i]=p-(p/i)*inv[p%i]%p;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,inv[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="阶乘逆元法"><a href="#阶乘逆元法" class="headerlink" title="阶乘逆元法"></a>阶乘逆元法</h2><p>再补充一张用阶乘求逆元的方法，<strong>只适用于模数为质数的情况</strong></p><p>设 $f(i)=inv(i!),g(i)=i!$<br>则有： $f(i-1)=f(i) \times i$<br>证明： $f(i-1)= \frac{1}{(i-1)!}=\frac{1}{i!} \times i=f(i) \times i$ </p><p>若我们要求 $[1,n]$ 中所有数的的逆元，可以先求 $[1,n]$ 每个数的阶乘的，再用费马小定理求得 $f(n)$ ，之后地推出 $f(1\sim n)$ 但是这还不是我们要的答案啊</p><p>dalao又说： $inv(i)=inv(i!) \times (i-1)!$<br>证明思路同上</p><p>So， $inv(i)=f(i) \times (i-1)!$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论,数学 </tag>
            
            <tag> 逆元 </tag>
            
            <tag> 费马小定理 </tag>
            
            <tag> 拓展欧几里得 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题</title>
      <link href="/2021/11/22/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2021/11/22/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>只写了一点点</p><span id="more"></span><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(f,<span class="number">0xcf</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">ans=-INF;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=v[i];--j)</span><br><span class="line">  f[j]=<span class="built_in">max</span>(f[j-v[i]]+w[i],f[j]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">ans=<span class="built_in">max</span>(ans,f[i]);</span><br></pre></td></tr></table></figure><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(f,<span class="number">0xcf</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">ans=-INF;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=v[i];j&lt;=m;++j)</span><br><span class="line">  f[j]=<span class="built_in">max</span>(f[j-v[i]]+w[i],f[j]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">ans=<span class="built_in">max</span>(ans,f[i]);</span><br></pre></td></tr></table></figure><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p>用二进制优化转换为01背包</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x.p&gt;=p)&#123;</span><br><span class="line">        b[++o].c=x.c*p;</span><br><span class="line">        b[o].t=x.t*p;</span><br><span class="line">        b[o].p=<span class="number">1</span>;</span><br><span class="line">        x.p-=p;</span><br><span class="line">        p&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x.p)&#123;</span><br><span class="line">        b[++o].c=x.c*x.p;</span><br><span class="line">        b[o].t=x.t*x.p;</span><br><span class="line">        b[o].p=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="新知"><a href="#新知" class="headerlink" title="新知"></a>新知</h1><h2 id="单调队列优化的多重背包"><a href="#单调队列优化的多重背包" class="headerlink" title="单调队列优化的多重背包"></a>单调队列优化的多重背包</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>我们考虑多重背包的转移方程（二维），思考，能否像完全背包一样，让 $f[i][j]=max(f[i-1][j],f[i][j-v]+w)$ ，以此来优化呢？<br>观察：<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/cn26sm1f.png" alt="对比"><br>我们会发现和完全背包相同的是，红色方框内的两个表达式一一对应，相差一个 $w$ ，但是， $f[i][j-v]$ ，有一项没有对应上。<br>这是为何呢？原因很简单，完全背包 $f[i][j]$ 在不考虑越界的情况下有无穷多种转移情况，在去掉最前端的 $f[i-1][j]$ 后还有无穷多种，恰好可以与 $f[i][j-v]$ 的无穷多种情况一一对应。<br>但是，变成多重背包后， $f[i][j]$ 只有 $s$ 种，即有限种转移情况，在去掉最前端的 $f[i-1][j]$ 后只有 $s-1$ 种，与 $f[i][j-v]$ 的 $s$ 种一一对应后，还剩一个。<br>但就是这多余的一个，导致我们无法用 $f[i][j]=max(f[i-1][j],f[i][j-v]+w)$ 来转移，因为多余的一个情况无法预料。</p><p>但这仍可以给我们一些启示：<br>在数轴上标出 $x=j+kv,k \in \mathbb{Z}$ ，即， $x \equiv j \pmod v$ 。<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/ghxq7ly8.png" alt="滑动"><br>$j$ 是由它前面 $s$ 个点的最大值<br>转移过来的，即蓝色窗口中标出的点的最大值，而 $j-v$ 也是由其前方 $s$ 个点的最大值转移而来，也就是说，窗口大小不变，窗口在数轴上滑动。<br>需要注意的是，数轴是无限的，但数组的转移是有边界的，所以我们可以把数轴上无意义的点设为负无穷（当然具体视情况而定） ，这样防止越界。<br>在解决了以上问题后，我们就只需要找出一种快速求滑动窗口最值的方法即可，而以前学过的单调队列可以在线性的时间内维护该问题。</p><p>具体来说，我们把“倒序循环 $j$ ”，改为对每个余数 $u \in [0,v_i-1]$ 倒序循环 $p=\left \lfloor (m-u)/v_i \right \rfloor \sim 0$ ，对应的状态就是 $j=u+p * v_i$ ，由于只能选 $c_i$ 个，故状态转移方程为：<br> $$f[u+p * v_i]=\max_{p-c_i \le k \le p-1} (f[u+k * v_i]+(p-k) * w_i)$$<br>我们发现，把 $i,u$ 看做定值，当内层变量 $p$ 减少 $1$ 时，决策 $k$ 的取值范围 $[p-c_i,p-1]$ 均单调减小，所以我们可以维护一个决策点 $k$ 单调递减，数值 $f[u+k * v_i]-k * w_i$ 递减的队列。</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.acwing.com/problem/content/6/">多重背包问题</a></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100000</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> f[N],v[N],w[N],c[N],q[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> u,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> f[u+k*v[i]]-k*w[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0xcf</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;v[i],&amp;w[i],&amp;c[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;v[i];++u)&#123; <span class="comment">//u:余数 </span></span><br><span class="line"><span class="keyword">int</span> hh=<span class="number">1</span>,tt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> maxp=(m-u)/v[i];</span><br><span class="line"><span class="comment">//将初始的候选集合插入队列 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=maxp<span class="number">-1</span>;k&gt;=<span class="built_in">max</span>(maxp-c[i],<span class="number">0</span>);--k)&#123; </span><br><span class="line"><span class="keyword">while</span>(hh&lt;=tt&amp;&amp;<span class="built_in">calc</span>(i,u,q[tt])&lt;=<span class="built_in">calc</span>(i,u,k)) --tt;</span><br><span class="line">q[++tt]=k; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//dp </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> p=maxp;p&gt;=<span class="number">0</span>;p--)&#123; <span class="comment">//循环状态 </span></span><br><span class="line"><span class="comment">//排除过时决策</span></span><br><span class="line"><span class="keyword">while</span>(hh&lt;=tt&amp;&amp;q[hh]&gt;p<span class="number">-1</span>) ++hh;</span><br><span class="line"><span class="comment">//取队头转移</span></span><br><span class="line"><span class="keyword">if</span>(hh&lt;=tt) </span><br><span class="line">f[u+p*v[i]]=<span class="built_in">max</span>(f[u+p*v[i]],<span class="built_in">calc</span>(i,u,q[hh])+p*w[i]);</span><br><span class="line"><span class="comment">//新决策入队,同时维护单调</span></span><br><span class="line"><span class="keyword">if</span>(p-c[i]<span class="number">-1</span>&gt;=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">while</span>(hh&lt;=tt&amp;&amp;<span class="built_in">calc</span>(i,u,q[tt])&lt;=<span class="built_in">calc</span>(i,u,p-c[i]<span class="number">-1</span>)) --tt;</span><br><span class="line">q[++tt]=p-c[i]<span class="number">-1</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) ans=<span class="built_in">max</span>(ans,f[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 背包 </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tarjan缩点</title>
      <link href="/2021/11/22/Tarjan%E7%BC%A9%E7%82%B9/"/>
      <url>/2021/11/22/Tarjan%E7%BC%A9%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>辣个男银太讨厌了！</p><span id="more"></span><h1 id="Tarjan缩点"><a href="#Tarjan缩点" class="headerlink" title="Tarjan缩点"></a>Tarjan缩点</h1><h2 id="割点与桥"><a href="#割点与桥" class="headerlink" title="割点与桥"></a>割点与桥</h2><p>给定无向连通图 $G=(V,E)$ ：<br>若对于 $x \in V$ ，从图中删去节点 $x$ 及其所以连边后， $G$ 分裂成两个及以上不连通的子图，则称 $x$ 为 $G$ 的<strong>割点</strong>；<br>若对与 $e \in E$ ，从图中删去 $e$ 后， $G$ 分裂为两个（也只可能分裂成两个）不连通的子图，则称 $e$ 为 $G$ 的<strong>割边</strong>或<strong>桥</strong>。</p><p>由Robert Tarjan的名字命名的Tarjan算法可以在线性时间内求无向图的割点与桥，进一步可以求出双连通分量。</p><h2 id="时间戳与追溯值"><a href="#时间戳与追溯值" class="headerlink" title="时间戳与追溯值"></a>时间戳与追溯值</h2><p>“时间戳”的概念比较简单，就是在dfs搜索时按搜索顺序对每个节点编号，一般记作 $dfn[x]$<br>在dfs遍历时，经过的边被定义为“搜索树”中的边，如图，红色为“搜索树”中的边，点中的数字为时间戳：<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/vpegwalx.png" alt="搜索树"><br>Tarjan算法又引入了一个”追溯值”，记作 $low[x]$ 。定义 $low[x]=\min (dfn[y])$ ，其中 $y$ 为满足下列两个条件之一的节点:  </p><ol><li><p> $y$ 在 $x$ 的子树中（包括 $x$ 本身）</p></li><li><p> $y$ 通过1条不在搜索树上的边，能够到达 $x$ 的子树（包括 $x$ 本身）</p></li></ol><p>可以感性地将追溯值理解为从点 $x$ 出发，不走先前走过的点，可以到达的时间戳最小的点的时间戳<br>下图用绿色数字标出了每个点的追溯值：<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/kwfnwe8y.png" alt="追溯值"><br>根据定义，可以这样计算计算 $low[x]$ ：</p><ul><li><p>令 $low[x]=dfn[x]$ （因为 $x$ 的时间戳一定是它所在子树中最小的）</p></li><li><p>枚举每条边 $(x,y)$ ：</p></li></ul><ol><li><p>若搜索树上 $x$ 是 $y$ 的父亲， 递归计算 $y$  ，然后令 $low[x]=\min (low[x],low[y])$ </p></li><li><p>若 $(x,y)$ 不在搜索树上，令 $low[x]=\min (low[x],dfn[y])$</p></li></ol><h2 id="桥（割边）的判断"><a href="#桥（割边）的判断" class="headerlink" title="桥（割边）的判断"></a>桥（割边）的判断</h2><p>无向边 $(x,y)$ 是桥，当且仅当 $(x,y)$ 在搜索树上（设 $x$ 为父节点），且满足 $dfn[x]&lt;low[y]$  </p><p>正确性显然：若 $dfn[x]&lt;low[y]$ ，说明从 $y$ 出发，不走 $(x,y)$ ，不管如何走都无法到达比 $x$ 更早遍历的点，所以只要删除 $(x,y)$ ， $y$ 及其子树就与比 $x$ 早遍历的点分隔开了，故 $(x,y)$ 为割边，反之则不是。<br>下图中桥用虚线标出：<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/02xalq39.png" alt="桥"><br>不难发现：桥一定是搜索树中的边，且一个简单环中的边一定不是桥。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ne,ver;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> h[N],idx=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> bridge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    e[idx].ver=y,e[idx].ne=h[x],h[x]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> in_e)</span></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++num;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[x],y;i!=<span class="number">-1</span>;i=e[i].ne)&#123;</span><br><span class="line">        y=e[i].ver;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(y,i);</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">            <span class="keyword">if</span>(low[y]&gt;dfn[x]) bridge[i]=bridge[i^<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i!=(in_e^<span class="number">1</span>)) low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i) h[i]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i]) <span class="built_in">tarjan</span>(i,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;idx;i+=<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span>(bridge[i]) <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,e[i^<span class="number">1</span>].ver,e[i].ver);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="割点的判断"><a href="#割点的判断" class="headerlink" title="割点的判断"></a>割点的判断</h2><p>若 $x$ 不是搜索树的根，则 $x$ 是割点当且仅当存在 $x$ 的一个子节点 $y$ 满足 $dfn[x] \le low[y]$ ，特别的，当 $x$ 为搜索树的根时，需要有至少两个子节点 $y_1,y_2$ 满足条件<br>证明方法同上，下图用蓝色标出了两个割点，它们的时间戳分别是1和6：<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/ej6on0sx.png" alt="割点"><br>值得注意的是，在判断割点时，由于是小于等于号，所以不必像桥一样考虑重边和父节点，但要比桥多判一个自环。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ne,ver;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> h[N],idx=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> cut[N];</span><br><span class="line"><span class="keyword">int</span> root;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    e[idx].ver=y,e[idx].ne=h[x],h[x]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++num;</span><br><span class="line">    <span class="keyword">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[x],y;i!=<span class="number">-1</span>;i=e[i].ne)&#123;</span><br><span class="line">        y=e[i].ver;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(y);</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">            <span class="keyword">if</span>(low[y]&gt;=dfn[x])&#123;</span><br><span class="line">            ++f;</span><br><span class="line">            <span class="keyword">if</span>(x!=root||f&gt;<span class="number">1</span>) cut[x]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i) h[i]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">        <span class="keyword">if</span>(u==v) <span class="keyword">continue</span>; <span class="comment">//判自环 </span></span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i]) root=i,<span class="built_in">tarjan</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span>(cut[i]) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="无向图的双连通分量"><a href="#无向图的双连通分量" class="headerlink" title="无向图的双连通分量"></a>无向图的双连通分量</h2><p>若无向图 $G$ 不存在割点，即其中任意两点间都有至少两条简单路径满足两条路径上的点集的并中只存在起点和终点，则称 $G$ 为“点双连通图”。</p><p>类似的，若无向图 $G$ 不存在桥，即其中任意两点间都有至少两条简单路径满足两条路径上的边集的并为空集，则称 $G$ 为“边双连通图”。</p><p>如图，图一是“点双连通图”而不是“边双连通图”，图二相反：<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/47zj9nti.png" alt="范例"><br>无向图的“极大”点双连通子图称为“点双连通分量”，记作“v-DCC”；无向图的“极大”边双连通子图称为“边双连通分量”，记作“e-DCC”<br>在以上定义中，一个双连通子图 $G$ 定义为“极大”是指不存在一个双连通子图 ${G}’$ 使得 $G$ 是它的子图</p><h2 id="边双连通分量"><a href="#边双连通分量" class="headerlink" title="边双连通分量"></a>边双连通分量</h2><p>e-DCC比较好求，只需删除所有桥，无向图就会分裂成若干e-DCC<br>代码（加到求桥的代码中）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="keyword">int</span> c[N],dcc;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">c[x]=dcc;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[x],y;i!=<span class="number">-1</span>;i=e[i].ne)&#123;</span><br><span class="line">y=e[i].ver;</span><br><span class="line"><span class="keyword">if</span>(c[y]||bridge[i]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs</span>(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="keyword">if</span>(!c[i])&#123;</span><br><span class="line">    ++dcc;</span><br><span class="line">    <span class="built_in">dfs</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the num of e-DCC is %d\n&quot;</span>,dcc);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d blongs to e-DCC %d\n&quot;</span>,i,c[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>e-DCC的缩点就是把每个e-DCC看作一个新的点，用桥将新的点连起来，构成一棵树（或森林），在上面代码中再加入这段代码，可以实现e-DCC缩点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ne,ver;</span><br><span class="line">&#125;ec[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hc[N&lt;&lt;<span class="number">1</span>],idc=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_c</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ec[idc].ver=y,ec[idc].ne=hc[x],hc[x]=idc++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i) hc[i]=<span class="number">-1</span>;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,x,y;i&lt;idx;i+=<span class="number">2</span>)&#123;</span><br><span class="line">x=e[i].ver,y=e[i^<span class="number">1</span>].ver;</span><br><span class="line"><span class="keyword">if</span>(c[x]==c[y]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">add_c</span>(c[x],c[y]);</span><br><span class="line"><span class="built_in">add_c</span>(c[y],c[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;缩点后的森林，点数：%d，边数（可能有重边）：%d\n&quot;</span>,dcc,(idc+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;idc;i+=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,ec[i].ver,ec[i^<span class="number">1</span>].ver);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="点双连通分量"><a href="#点双连通分量" class="headerlink" title="点双连通分量"></a>点双连通分量</h2><p>根据v-DCC的定义，除孤立点外，v-DCC的大小至少为二，且每个割点至少属于两个不同的点双连通分量，在求割点的代码中加入一个栈可以求出v-DCC（下面的代码不用加在之前代码前）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ne,ver;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> h[N],idx=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> cut[N];</span><br><span class="line"><span class="keyword">int</span> root;</span><br><span class="line"><span class="keyword">int</span> stk[N],top=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;dcc[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    e[idx].ver=y,e[idx].ne=h[x],h[x]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++num;</span><br><span class="line">    stk[++top]=x; <span class="comment">//栈记录经过的节点</span></span><br><span class="line"><span class="keyword">if</span>(x==root&amp;&amp;h[x]==<span class="number">-1</span>)&#123; <span class="comment">//孤立点 </span></span><br><span class="line">dcc[++cnt].<span class="built_in">push_back</span>(x);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125; </span><br><span class="line">    <span class="keyword">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[x],y;i!=<span class="number">-1</span>;i=e[i].ne)&#123;</span><br><span class="line">        y=e[i].ver;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(y);</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">            <span class="keyword">if</span>(low[y]&gt;=dfn[x])&#123;</span><br><span class="line">            ++f;</span><br><span class="line">            <span class="keyword">if</span>(x!=root||f&gt;<span class="number">1</span>) cut[x]=<span class="literal">true</span>;</span><br><span class="line">            ++cnt;</span><br><span class="line">            <span class="keyword">int</span> z;</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">            z=stk[top--];</span><br><span class="line">            dcc[cnt].<span class="built_in">push_back</span>(z);</span><br><span class="line">            &#125;<span class="keyword">while</span>(z!=y);</span><br><span class="line">            dcc[cnt].<span class="built_in">push_back</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i) h[i]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">        <span class="keyword">if</span>(u==v) <span class="keyword">continue</span>; <span class="comment">//判自环 </span></span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i]) root=i,<span class="built_in">tarjan</span>(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;++i)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;v-DCC %d: &quot;</span>,i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;dcc[i].<span class="built_in">size</span>();++j) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,dcc[i][j]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与e-DCC不同，由于每一个割点会包含在不同的v-DCC中，所以对于一个有 $p$ 个割点和 $t$ 个v-DCC的图，其缩点后的图包含 $p+t$ 个节点，由 $p$ 个割点将图连通，构成一棵树（或森林），如图：<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/6pv8amuw.png" alt="v-DCC"><br>代码如下（插在上面的代码中）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="keyword">int</span> new_id[N],c[N]; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> ne,ver;</span><br><span class="line">&#125;ec[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hc[N&lt;&lt;<span class="number">1</span>],idc=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_c</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ec[idc].ver=y,ec[idc].ne=hc[x],hc[x]=idc++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i) hc[i]=<span class="number">-1</span>;</span><br><span class="line"><span class="comment">//给每个割点一个编号，从cnt+1开始 </span></span><br><span class="line"><span class="keyword">int</span> id=cnt;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"><span class="keyword">if</span>(cut[i]) new_id[i]=++id; </span><br><span class="line"><span class="comment">//建图，用割点连接v-DCC</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>,x;j&lt;dcc[i].<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">x=dcc[i][j];</span><br><span class="line"><span class="keyword">if</span>(cut[x])&#123;</span><br><span class="line"><span class="built_in">add_c</span>(i,new_id[x]);</span><br><span class="line"><span class="built_in">add_c</span>(new_id[x],i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> c[x]=i; <span class="comment">//割点外的点只属于1个v-DCC </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;缩点后的森林，点数：%d，边数：%d\n&quot;</span>,id,(idc+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;idc;i+=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,ec[i].ver,ec[i^<span class="number">1</span>].ver); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="nice-终于写完了！"><a href="#nice-终于写完了！" class="headerlink" title="nice!终于写完了！"></a>nice!终于写完了！</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 缩点 </tag>
            
            <tag> Tarjan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Splay</title>
      <link href="/2021/11/22/Splay/"/>
      <url>/2021/11/22/Splay/</url>
      
        <content type="html"><![CDATA[<p>真正好打的平衡树</p><span id="more"></span><h1 id="Splay"><a href="#Splay" class="headerlink" title="Splay"></a>Splay</h1><p>首先是Splay的定义，上代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Splay</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> ch[<span class="number">2</span>];<span class="comment">//左右儿子</span></span><br><span class="line"><span class="keyword">int</span> fa;<span class="comment">//父节点</span></span><br><span class="line"><span class="keyword">int</span> v;<span class="comment">//值</span></span><br><span class="line"><span class="keyword">int</span> size;<span class="comment">//儿子数量</span></span><br><span class="line"><span class="keyword">int</span> tag;<span class="comment">//懒标记</span></span><br><span class="line"><span class="keyword">int</span> cnt;<span class="comment">//值等于v的数都建成一个点,故记录数量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _v,<span class="keyword">int</span> _fa)</span></span>&#123;<span class="comment">//初始化</span></span><br><span class="line">ch[<span class="number">0</span>]=ch[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"> v=_v;</span><br><span class="line">fa=_fa;</span><br><span class="line">tag=<span class="number">0</span>;</span><br><span class="line">size=<span class="number">1</span>;</span><br><span class="line">cnt=<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;tr[N];</span><br></pre></td></tr></table></figure><p>Splay的基本操作是旋转，在保证中序遍历不变的情况下，通过旋转将树的结构改变，如下图中 $x$ 、 $y$ 、 $z$ 是三个节点，而 $A$ 、 $B$ 、 $C$ 是三棵子树，在将 $x-y$ 左右旋转后，树的结构发生变化：<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/mye61pp9.png" alt="旋转"><br>如上图中，将 $x-y$ 右旋，那么 $z$ 就完全不动，而旋转后我们发现 $A$ 、 $B$ 、 $y$ 都成了 $x$ 的子节点，这显然不满足BST性质。为了满足BST，我们比较三个子节点（子树），发现由BST性质，有 $A&lt;x&lt;B&lt;y&lt;C$ ，明显，为了BST性质，只能让 $A$ 继续做 $x$ 的左子树，将 $B$ 、 $y$ 、 $C$ 构造成 $x$ 的右子树。<br>具体实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算x的儿子数量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">tr[x].size=tr[tr[x].ch[<span class="number">0</span>]].size+tr[tr[x].ch[<span class="number">1</span>]].size+tr[u].cnt;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//旋转</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> y=tr[x].fa;<span class="keyword">int</span> z=tr[y].fa;</span><br><span class="line">    <span class="comment">//k=0表示x是y的左儿子,k=1表示x是y的右儿子</span></span><br><span class="line"><span class="keyword">int</span> k=tr[y].ch[<span class="number">1</span>]==x;</span><br><span class="line">    <span class="comment">//把x变成z的儿子</span></span><br><span class="line">tr[z].ch[tr[z].ch[<span class="number">1</span>]==y]=x,tr[x].fa=z;</span><br><span class="line">    <span class="comment">//把x的一个儿子改为y的儿子,具体哪个儿子看最初x是y的哪个儿子,就改成相同的儿子</span></span><br><span class="line">tr[y].ch[k]=tr[x].ch[k^<span class="number">1</span>],tr[tr[x].ch[k^<span class="number">1</span>]].fa=y;</span><br><span class="line">    <span class="comment">//把y变成x的儿子,具体哪个儿子看最初x是y的哪个儿子,就改成相反的儿子</span></span><br><span class="line">tr[x].ch[k^<span class="number">1</span>]=y,tr[y].fa=x;</span><br><span class="line">   <span class="comment">//重新计算x、y</span></span><br><span class="line"><span class="built_in">push_up</span>(y),<span class="built_in">push_up</span>(x);</span><br><span class="line"><span class="keyword">return</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在Splay中我们插入、修改、删除任何一个节点的方式就是将该节点转至根节点，再进行操作。<br>为将节点 $x$ 转至根节点，我们定义函数 $Splay(x,k)$ 表示将节点 $x$ 转至节点 $k$ 下方（即 $x$ 是 $k$ 的子节点），通过 $Splay(x,0)$ ，我们可以将 $x$ 转至根节点。<br>而为了实现该函数，我们发现有如下两类情况（以下我们设 $y$ 是 $x$ 的父节点， $z$ 是 $y$ 的父节点）：  </p><ol><li><p> $x$ 、 $y$ 、 $z$ 在同一直线，如图：<img src="https://cdn.luogu.com.cn/upload/image_hosting/2jytcbe1.png" alt="共线"></p></li><li><p> $x$ 、 $y$ 、 $z$ 不在同一直线，如图：<img src="https://cdn.luogu.com.cn/upload/image_hosting/v6dei9f7.png" alt="不共线"></p></li></ol><p>而对于这两种情况，我们也有不同的策略：  </p><ol><li><p>先转一次 $y$ ，再转一次 $x$ （具体方向取决于是左儿子还是右儿子）如图：<img src="https://cdn.luogu.com.cn/upload/image_hosting/kz3xidkx.png" alt="c1"> </p></li><li><p>连转两次 $x$ （具体方向取决于是左儿子还是右儿子）如图：<img src="https://cdn.luogu.com.cn/upload/image_hosting/6i3qhpcp.png" alt="c2"></p></li></ol><p>代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="comment">//if(x==k) return ;</span></span><br><span class="line"> <span class="keyword">while</span>(tr[x].fa!=k)&#123;</span><br><span class="line"><span class="keyword">int</span> y=tr[x].fa;<span class="keyword">int</span> z=tr[y].fa;</span><br><span class="line"><span class="keyword">if</span>(z!=k)</span><br><span class="line">        <span class="comment">//若是折线关系,先转一次x,否则先转一次y</span></span><br><span class="line">(tr[y].ch[<span class="number">1</span>]==x)^(tr[z].ch[<span class="number">1</span>]==y)?<span class="built_in">rotate</span>(x):<span class="built_in">rotate</span>(y); </span><br><span class="line">        <span class="comment">//无论如何第二次都转x</span></span><br><span class="line"><span class="built_in">rotate</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//若k=0,说明x是根节点</span></span><br><span class="line"><span class="keyword">if</span>(!k) root=x;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实现 $Splay()$ 后，我们就可以完成操作。</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>将一个数 $x$ 插入到Splay中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> u=root,ff=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//找到x的位置u和其父节点ff</span></span><br><span class="line"><span class="keyword">while</span>(u&amp;&amp;tr[u].v!=x) ff=u,u=tr[u].ch[x&gt;tr[u].v];</span><br><span class="line">    <span class="comment">//若已存在,个数加1</span></span><br><span class="line"><span class="keyword">if</span>(u) t[u].cnt++;</span><br><span class="line">    <span class="comment">//否则新建节点</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">u=++idx;</span><br><span class="line"><span class="keyword">if</span>(ff) tr[ff].ch[x&gt;tr[ff].v]=u;</span><br><span class="line">tr[u].<span class="built_in">init</span>(x,ff);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//优化:每次都让新加入的点为根</span></span><br><span class="line"><span class="built_in">splay</span>(u,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找第k个数"><a href="#查找第k个数" class="headerlink" title="查找第k个数"></a>查找第k个数</h2><p>找到第 $k$ 大的数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_k</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> u=root;</span><br><span class="line"><span class="keyword">if</span>(tr[u].size&lt;k) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">push_down</span>(u);</span><br><span class="line"><span class="keyword">int</span> y=t[u].ch[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//若k在u的后面,直接减掉u及前面的数,进入右子树</span></span><br><span class="line"><span class="keyword">if</span>(k&gt;tr[y].size+tr[u].cnt) k-=tr[y].size+tr[u].cnt,u=tr[u].ch[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//若u的左子树的节点数大于k,说明k在左子树中</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(tr[y].size&gt;=k) u=y;</span><br><span class="line">        <span class="comment">//否则第k个就是u</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> tr[u].v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找x的位置"><a href="#查找x的位置" class="headerlink" title="查找x的位置"></a>查找x的位置</h2><p>该函数可以把数 $x$ 转到根节点，完成后x的排名就是<br>$tr[tr[root].ch[0]].size+1 \sim tr[tr[root].ch[0]].size+tr[root].cnt$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> u=root;</span><br><span class="line"><span class="keyword">if</span>(!u) <span class="keyword">return</span> ;<span class="comment">//不存在节点</span></span><br><span class="line">    <span class="comment">//找到x所在的位置u</span></span><br><span class="line"><span class="keyword">while</span>(tr[u].ch[x&gt;tr[u].v]&amp;&amp;x!=tr[u].v) u=tr[u].ch[x&gt;tr[u].v];</span><br><span class="line"><span class="built_in">splay</span>(u,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找前驱-后继"><a href="#查找前驱-后继" class="headerlink" title="查找前驱/后继"></a>查找前驱/后继</h2><p>该函数可以找到数 $x$ 的前驱（ $f=0$ ）或后继（ $f=1$ ）（大小关系严格）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">near</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line"><span class="built_in">find</span>(x);</span><br><span class="line"><span class="keyword">int</span> u=root;</span><br><span class="line"><span class="keyword">if</span>((tr[u].v&gt;x&amp;&amp;f)||(tr[u].v&lt;x&amp;&amp;!f)) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="comment">//若不严格，用if((tr[u].v&gt;x&amp;&amp;f)||(tr[u].v&lt;x&amp;&amp;!f)||(tr[u].v==x&amp;&amp;tr[u].cnt&gt;1)) return u;</span></span><br><span class="line">    <span class="comment">//进入左/右子树</span></span><br><span class="line">u=tr[u].ch[f];</span><br><span class="line">    <span class="comment">//找到该子树中的最大/小值,方法是一直向与f相反的方向走</span></span><br><span class="line"><span class="keyword">while</span>(tr[u].ch[f^<span class="number">1</span>]) u=tr[u].ch[f^<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除数x"><a href="#删除数x" class="headerlink" title="删除数x"></a>删除数x</h2><p>在Splay中删除 $x$ ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> last=<span class="built_in">near</span>(x,<span class="number">0</span>);<span class="comment">//前驱</span></span><br><span class="line"><span class="keyword">int</span> next=<span class="built_in">near</span>(x,<span class="number">1</span>);<span class="comment">//后继</span></span><br><span class="line"><span class="built_in">splay</span>(last,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">splay</span>(next,last);</span><br><span class="line">    <span class="comment">//x此时就是next的左儿子</span></span><br><span class="line"><span class="keyword">int</span> rem=tr[next].ch[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span>(tr[rem].cnt&gt;<span class="number">1</span>) tr[rem].cnt--,<span class="built_in">splay</span>(rem,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">else</span> tr[next].ch[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中序输出"><a href="#中序输出" class="headerlink" title="中序输出"></a>中序输出</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">midout</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line"><span class="built_in">push_down</span>(u);</span><br><span class="line"><span class="keyword">if</span>(tr[u].ch[<span class="number">0</span>]) <span class="built_in">midout</span>(tr[u].ch[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span>(tr[u].v&gt;<span class="number">1</span>&amp;&amp;tr[u].v&lt;n+<span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,tr[u].v<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span>(tr[u].ch[<span class="number">1</span>]) <span class="built_in">midout</span>(tr[u].ch[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="下传懒标记"><a href="#下传懒标记" class="headerlink" title="下传懒标记"></a>下传懒标记</h2><p>以下用区间翻转举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[x].tag)&#123;</span><br><span class="line">tr[tr[x].ch[<span class="number">0</span>]].tag^=<span class="number">1</span>;</span><br><span class="line">tr[tr[x].ch[<span class="number">1</span>]].tag^=<span class="number">1</span>;</span><br><span class="line">tr[x].tag=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">swap</span>(tr[x].ch[<span class="number">0</span>],tr[x].ch[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e5</span>+<span class="number">5</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Splay</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> ch[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> fa;</span><br><span class="line"><span class="keyword">int</span> v;</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">int</span> tag;</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _v,<span class="keyword">int</span> _fa)</span></span>&#123;</span><br><span class="line">ch[<span class="number">0</span>]=ch[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"> v=_v;</span><br><span class="line">fa=_fa;</span><br><span class="line">tag=<span class="number">0</span>;</span><br><span class="line">size=<span class="number">1</span>;</span><br><span class="line">cnt=<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"><span class="keyword">int</span> root=<span class="number">0</span>,idx=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[x].tag)&#123;</span><br><span class="line">tr[tr[x].ch[<span class="number">0</span>]].tag^=<span class="number">1</span>;</span><br><span class="line">tr[tr[x].ch[<span class="number">1</span>]].tag^=<span class="number">1</span>;</span><br><span class="line">tr[x].tag=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">swap</span>(tr[x].ch[<span class="number">0</span>],tr[x].ch[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">tr[x].size=tr[tr[x].ch[<span class="number">0</span>]].size+tr[tr[x].ch[<span class="number">1</span>]].size+tr[x].cnt;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> y=tr[x].fa;<span class="keyword">int</span> z=tr[y].fa;</span><br><span class="line"><span class="keyword">int</span> k=tr[y].ch[<span class="number">1</span>]==x;</span><br><span class="line">tr[z].ch[tr[z].ch[<span class="number">1</span>]==y]=x,tr[x].fa=z;</span><br><span class="line">tr[y].ch[k]=tr[x].ch[k^<span class="number">1</span>],tr[tr[x].ch[k^<span class="number">1</span>]].fa=y;</span><br><span class="line">tr[x].ch[k^<span class="number">1</span>]=y,tr[y].fa=x;</span><br><span class="line"><span class="built_in">push_up</span>(y),<span class="built_in">push_up</span>(x);</span><br><span class="line"><span class="keyword">return</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==k) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">while</span>(tr[x].fa!=k)&#123;</span><br><span class="line"><span class="keyword">int</span> y=tr[x].fa;<span class="keyword">int</span> z=tr[y].fa;</span><br><span class="line"><span class="keyword">if</span>(z!=k)</span><br><span class="line">(tr[y].ch[<span class="number">1</span>]==x)^(tr[z].ch[<span class="number">1</span>]==y)?<span class="built_in">rotate</span>(x):<span class="built_in">rotate</span>(y); </span><br><span class="line"><span class="built_in">rotate</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!k) root=x;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> u=root;</span><br><span class="line"><span class="keyword">if</span>(!u) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">while</span>(tr[u].ch[x&gt;tr[u].v]&amp;&amp;x!=tr[u].v) u=tr[u].ch[x&gt;tr[u].v];</span><br><span class="line"><span class="built_in">splay</span>(u,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">near</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">bool</span> f)</span></span>&#123;</span><br><span class="line"><span class="built_in">find</span>(x);</span><br><span class="line"><span class="keyword">int</span> u=root;</span><br><span class="line"><span class="keyword">if</span>((tr[u].v&gt;x&amp;&amp;f)||(tr[u].v&lt;x&amp;&amp;!f)) <span class="keyword">return</span> u;</span><br><span class="line">u=tr[u].ch[f];</span><br><span class="line"><span class="keyword">while</span>(tr[u].ch[f^<span class="number">1</span>]) u=tr[u].ch[f^<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> last=<span class="built_in">near</span>(x,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> next=<span class="built_in">near</span>(x,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">splay</span>(last,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">splay</span>(next,last);</span><br><span class="line"><span class="keyword">int</span> rem=tr[next].ch[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span>(tr[rem].cnt&gt;<span class="number">1</span>) tr[rem].cnt--,<span class="built_in">splay</span>(rem,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">else</span> tr[next].ch[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> u=root,ff=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(u&amp;&amp;tr[u].v!=x) ff=u,u=tr[u].ch[x&gt;tr[u].v];</span><br><span class="line"><span class="keyword">if</span>(u) tr[u].cnt++;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">u=++idx;</span><br><span class="line"><span class="keyword">if</span>(ff) tr[ff].ch[x&gt;tr[ff].v]=u;</span><br><span class="line">tr[u].<span class="built_in">init</span>(x,ff);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">splay</span>(u,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_k</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> u=root;</span><br><span class="line"><span class="keyword">if</span>(tr[u].size&lt;k) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">push_down</span>(u);</span><br><span class="line"><span class="keyword">int</span> y=tr[u].ch[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span>(k&gt;tr[y].size+tr[u].cnt) k-=tr[y].size+tr[u].cnt,u=tr[u].ch[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(tr[y].size&gt;=k) u=y;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> tr[u].v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">midout</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line"><span class="built_in">push_down</span>(u);</span><br><span class="line"><span class="keyword">if</span>(tr[u].ch[<span class="number">0</span>]) <span class="built_in">midout</span>(tr[u].ch[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span>(tr[u].v&gt;<span class="number">1</span>&amp;&amp;tr[u].v&lt;n+<span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,tr[u].v<span class="number">-1</span>);<span class="comment">//视具体情况 </span></span><br><span class="line"><span class="keyword">if</span>(tr[u].ch[<span class="number">1</span>]) <span class="built_in">midout</span>(tr[u].ch[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">insert</span>(x);</span><br><span class="line"><span class="built_in">remove</span>(x);</span><br><span class="line"><span class="built_in">find</span>(x);</span><br><span class="line"><span class="built_in">get_k</span>(x+<span class="number">1</span>);<span class="comment">//编号要加1</span></span><br><span class="line"><span class="built_in">near</span>(x,<span class="number">0</span>); </span><br><span class="line"><span class="built_in">near</span>(x,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">midout</span>(root);</span><br><span class="line"><span class="comment">//P3369</span></span><br><span class="line"><span class="comment">/*scanf(&quot;%d&quot;,&amp;n);</span></span><br><span class="line"><span class="comment">//注意要多插入两个数 </span></span><br><span class="line"><span class="comment">insert(-INF);</span></span><br><span class="line"><span class="comment">insert(INF);</span></span><br><span class="line"><span class="comment">while(n--)&#123;</span></span><br><span class="line"><span class="comment">int op,x;</span></span><br><span class="line"><span class="comment">scanf(&quot;%d%d&quot;,&amp;op,&amp;x);</span></span><br><span class="line"><span class="comment">if(op==1) insert(x);</span></span><br><span class="line"><span class="comment">else if(op==2) remove(x);</span></span><br><span class="line"><span class="comment">else if(op==3) find(x),printf(&quot;%d\n&quot;,tr[tr[root].ch[0]].size);</span></span><br><span class="line"><span class="comment">else if(op==4) printf(&quot;%d\n&quot;,get_k(x+1));</span></span><br><span class="line"><span class="comment">else if(op==5) printf(&quot;%d\n&quot;,tr[near(x,0)].v);</span></span><br><span class="line"><span class="comment">else printf(&quot;%d\n&quot;,tr[near(x,1)].v);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//P3391</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span></span><br><span class="line"><span class="comment">for(int i=1;i&lt;=n+2;++i) insert(i);//增加两个点防止越界 </span></span><br><span class="line"><span class="comment">while(m--)&#123;</span></span><br><span class="line"><span class="comment">int l,r;</span></span><br><span class="line"><span class="comment">scanf(&quot;%d%d&quot;,&amp;l,&amp;r);</span></span><br><span class="line"><span class="comment">l=get_k(l),r=get_k(r+2); </span></span><br><span class="line"><span class="comment">splay(l,0);splay(r,l);</span></span><br><span class="line"><span class="comment">tr[tr[tr[root].ch[1]].ch[0]].tag^=1;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">midout(root);</span></span><br><span class="line"><span class="comment">printf(&quot;\n&quot;);</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 平衡树 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
            <tag> Splay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SBT（Size Balanced Tree）</title>
      <link href="/2021/11/22/SBT%EF%BC%88Size-Balanced-Tree%EF%BC%89/"/>
      <url>/2021/11/22/SBT%EF%BC%88Size-Balanced-Tree%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>cqf大佬智慧的结晶</p><span id="more"></span><h1 id="SBT"><a href="#SBT" class="headerlink" title="SBT"></a>SBT</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>SBT（子树大小平衡树）是一种通过子树大小来维持平衡的平衡树，由cqf大佬发明，是一种非常非常优秀的平衡树（反正比Splay快），与Splay的旋转类似，它通过旋转来平衡，但不同的是，Splay的旋转没有条件，而SBT的旋转是为了维护一个有关子树大小的性质。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SBT</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v; <span class="comment">//价值关键字</span></span><br><span class="line">    <span class="keyword">int</span> size; <span class="comment">//子树大小</span></span><br><span class="line">    <span class="keyword">int</span> l,r; <span class="comment">//左右儿子</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inint</span><span class="params">(<span class="keyword">int</span> _v)</span></span>&#123;</span><br><span class="line">        v=_v;</span><br><span class="line">        size=<span class="number">1</span>;</span><br><span class="line">        l=r=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> v(i) tr[i].v</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> size(i) tr[i].size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(i) tr[i].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(i) tr[i].r</span></span><br><span class="line">&#125;tr[N];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>，root;</span><br></pre></td></tr></table></figure><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>SBT的旋转与Splay类似，但略有不同，主要表现在它不记录父节点，而是通过传实参来更新与 $Z$ 的关系<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/mye61pp9.png" alt="旋转"><br>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r_rotate</span><span class="params">(<span class="keyword">int</span> &amp;t)</span></span>&#123; <span class="comment">//右旋</span></span><br><span class="line">    <span class="keyword">int</span> k=<span class="built_in">l</span>(t);</span><br><span class="line">    <span class="built_in">l</span>(t)=<span class="built_in">r</span>(k);</span><br><span class="line">    <span class="built_in">r</span>(k)=t;</span><br><span class="line">    <span class="comment">//代替Splay的push_up</span></span><br><span class="line">    <span class="built_in">size</span>(k)=<span class="built_in">size</span>(t);</span><br><span class="line">    <span class="built_in">size</span>(t)=<span class="built_in">size</span>(<span class="built_in">l</span>(t))+<span class="built_in">size</span>(<span class="built_in">r</span>(t))+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//更新z的儿子</span></span><br><span class="line">    t=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">l_rotate</span><span class="params">(<span class="keyword">int</span> &amp;t)</span></span>&#123; <span class="comment">//左旋</span></span><br><span class="line">    <span class="keyword">int</span> k=<span class="built_in">r</span>(t);</span><br><span class="line">    <span class="built_in">r</span>(t)=<span class="built_in">l</span>(k);</span><br><span class="line">    <span class="built_in">l</span>(k)=t;</span><br><span class="line">    <span class="built_in">size</span>(k)=<span class="built_in">size</span>(t);</span><br><span class="line">    <span class="built_in">size</span>(t)=<span class="built_in">size</span>(<span class="built_in">l</span>(t))+<span class="built_in">size</span>(<span class="built_in">r</span>(t))+<span class="number">1</span>;</span><br><span class="line">    t=k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>SBT和Splay的主要不同点是SBT维护了两个性质：</p><ol><li><p>$size(r(t)) \ge size(l(l(t)))\ ,\ size(r(l(t)))$  </p></li><li><p>$size(l(t)) \ge size(r(r(t)))\ ,\ size(l(r(t)))$  </p></li></ol><p>如图，就是说：<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/fu20g4nj.png" alt="SBT性质"></p><ol><li><p>$size(R) \ge size(A)\ ,\ size(B)$ </p></li><li><p>$size(L) \ge size(C)\ ,\ size(D)$ </p></li></ol><p>而为了在插入新节点后仍保持该性质，我们需要“机智”地旋转，假设我们用一个函数（命名为 $maintain(t)$ ）可以做到使 $t$ 和它的子树符合以上性质，我们来考虑如何做到，无非有四种情况：<br>一、 $size(l(l(t))) &gt; size(r(t))$ ，即 $size(A) &gt; size(R)$ ，我们操作如下：  </p><ol><li><p>$r_rotate(t)$ ，完成后树的结构如下<br> <img src="https://cdn.luogu.com.cn/upload/image_hosting/3ij9tdws.png" alt="R"></p></li><li><p> 完成后 $t,L,A,R$ 都已满足性质，但仍可能出现 $size(C) &gt; size(B)$ 或 $size(D) &gt; size(B)$ ，所以我们还需调用 $maintain(t)$ ，完成后 $t$ 所在子树满足了性质</p></li><li><p> 此时 $L$ 的右子树可能已经被改变形状，不满足性质，所以必须再次 $maintain(t)$</p></li></ol><p>二、 $size(r(l(t))) &gt; size(r(t))$ ，即 $size(B) &gt; size(R)$ ，此时情况较为复杂，需要考虑 $B$ 的子树：<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/q8b4vsag.png" alt="SBT_2"></p><ol><li><p>$l_rotate(t)$ ，完成后树的结构如下:<br> <img src="https://cdn.luogu.com.cn/upload/image_hosting/vbpiuwzj.png" alt="L"></p></li><li><p>然后  $r_rotate(t)$ ，完成后树的结构如下：<br> <img src="https://cdn.luogu.com.cn/upload/image_hosting/vay5w3i5.png" alt="L_R"></p></li><li><p> 在两次旋转后，满足性质的有 $A,E,F,R$ ，我们调用 $maintain(L)$ 和 $maintain(t)$ 来修复  $B$ 的儿子</p></li><li><p> 现在， $B$ 的儿子都是满足性质的了，只需再调用一次 $maintain(B)$</p></li></ol><p>三、 $size(r(r(t))) &gt; size(l(t))$ ，即 $size(D) &gt; size(L)$ ，与情况一相反</p><p>四、 $size(r(r(t))) &gt; size(l(t))$ ，即 $size(D) &gt; size(L)$ ，与情况二相反</p><p>综上所述，我们可以写出伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">miantain</span>(t)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span>(<span class="built_in">l</span>(<span class="built_in">l</span>(t)))&gt;<span class="built_in">size</span>(<span class="built_in">r</span>(t)))&#123;</span><br><span class="line">        <span class="built_in">r_rotate</span>(t)</span><br><span class="line">        <span class="built_in">miantain</span>(<span class="built_in">r</span>(t))</span><br><span class="line">        <span class="built_in">miantain</span>(t)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span>(<span class="built_in">r</span>(<span class="built_in">l</span>(t)))&gt;<span class="built_in">size</span>(<span class="built_in">r</span>(t)))&#123;</span><br><span class="line">        <span class="built_in">l_rotate</span>(<span class="built_in">l</span>(t))</span><br><span class="line">        <span class="built_in">r_rotate</span>(t)</span><br><span class="line">        <span class="built_in">miantain</span>(<span class="built_in">l</span>(t))</span><br><span class="line">        <span class="built_in">miantain</span>(<span class="built_in">r</span>(t))</span><br><span class="line">        <span class="built_in">miantain</span>(t)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span>(<span class="built_in">r</span>(<span class="built_in">r</span>(t)))&gt;<span class="built_in">size</span>(<span class="built_in">l</span>(t)))&#123;</span><br><span class="line">        <span class="built_in">l_rotate</span>(t)</span><br><span class="line">        <span class="built_in">miantain</span>(<span class="built_in">l</span>(t))</span><br><span class="line">        <span class="built_in">miantain</span>(t)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span>(<span class="built_in">l</span>(<span class="built_in">r</span>(t)))&gt;<span class="built_in">size</span>(<span class="built_in">l</span>(t)))&#123;</span><br><span class="line">        <span class="built_in">r_rotate</span>(<span class="built_in">r</span>(t))</span><br><span class="line">        <span class="built_in">l_rotate</span>(t)</span><br><span class="line">        <span class="built_in">miantain</span>(<span class="built_in">l</span>(t))</span><br><span class="line">        <span class="built_in">miantain</span>(<span class="built_in">r</span>(t))</span><br><span class="line">        <span class="built_in">miantain</span>(t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码有点复杂，在通常情况下，一棵树只会出现情况一、情况二或情况三、情况四，我们不妨多传一个 $bool$ 来简化代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> &amp;t,<span class="keyword">bool</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">size</span>(<span class="built_in">l</span>(<span class="built_in">l</span>(t)))&gt;<span class="built_in">size</span>(<span class="built_in">r</span>(t))) <span class="built_in">r_rotate</span>(t);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">size</span>(<span class="built_in">r</span>(<span class="built_in">l</span>(t)))&gt;<span class="built_in">size</span>(<span class="built_in">r</span>(t)))&#123;</span><br><span class="line">            <span class="built_in">l_rotate</span>(<span class="built_in">l</span>(t));</span><br><span class="line">            <span class="built_in">r_rotate</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">size</span>(<span class="built_in">r</span>(<span class="built_in">r</span>(t)))&gt;<span class="built_in">size</span>(<span class="built_in">l</span>(t))) <span class="built_in">l_rotate</span>(t);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">size</span>(<span class="built_in">l</span>(<span class="built_in">r</span>(t)))&gt;<span class="built_in">size</span>(<span class="built_in">l</span>(t)))&#123;</span><br><span class="line">            <span class="built_in">r_rotate</span>(<span class="built_in">r</span>(t));</span><br><span class="line">            <span class="built_in">l_rotate</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">maintain</span>(<span class="built_in">l</span>(t),<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">maintain</span>(<span class="built_in">r</span>(t),<span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">maintain</span>(t,<span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">maintain</span>(t,<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此我们还有两个问题：为啥 $maintain(l(t),true),maintain(r(t),false)$ 被省略了？而 $maintain(t)$ 的时间复杂度又是多少呢？下面我们来讨论。  </p><p>首先是为何省略：<br>在情况一的图中（即右旋后的图），因为插入后 $size(A)&gt;size(R)$ 所以 $size(B)$ 一定仍和插入前一样，即仍有 $size(B)\le size(R)$ ，故 $B$ 的子节点大小一定小于 $R$ ，即根本不需要 $maintain(r(t),false)$ 。其余情况同理。</p><p>然后我们来分析时间复杂度：<br>我们设 $SD$ 表示所有节点的深度和，明显， $SD$ 越小，BST（二叉搜索树）越优，并设 $T$ 表示 $maintain$ 中的旋转次数。<br>回顾整个 $maintain$ 我们发现在每次旋转后 $SD$ 总是在减小（不妨设减小了 $r$ ），所以，一个高度为 $O(\log{n})$ 的树，其深度和 $SD$ 总是保持在 $O(n\log{n})$ ，而在插入 $SD$ 仅增加 $O(log{n})$ ，故有： $SD=n \times O(\log{n})-T \times r=O(\log{n})$ ,取 $r$ 最小为 $1$ ，则 $T=O(\log{n})$ 。<br>于是，得到 $maintian$ 的平摊时间是：<br>$\frac{O(T)+O(n\log{n})+O(T)}{n\log{n}}=O(1) $ </p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>SBT的基本操作如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;t,<span class="keyword">int</span> v)</span></span>&#123; <span class="comment">//插入</span></span><br><span class="line">    <span class="keyword">if</span>(!t)&#123;</span><br><span class="line">        t=++cnt;</span><br><span class="line">        tr[t].<span class="built_in">inint</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ++<span class="built_in">size</span>(t);</span><br><span class="line">        <span class="keyword">if</span>(v&lt;=<span class="built_in">v</span>(t)) <span class="built_in">insert</span>(<span class="built_in">l</span>(t),v);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">insert</span>(<span class="built_in">r</span>(t),v);</span><br><span class="line">        <span class="built_in">maintain</span>(t,v&gt;<span class="built_in">v</span>(t));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> &amp;t,<span class="keyword">int</span> v)</span></span>&#123; <span class="comment">//删除,返回被删的值</span></span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    --<span class="built_in">size</span>(t);</span><br><span class="line">    <span class="keyword">if</span>((v==<span class="built_in">v</span>(t))||((v&lt;<span class="built_in">v</span>(t))&amp;&amp;!<span class="built_in">l</span>(t))||((v&gt;<span class="built_in">v</span>(t))&amp;&amp;!<span class="built_in">r</span>(t)))&#123; <span class="comment">//若找到或无法继续找</span></span><br><span class="line">        ret=<span class="built_in">v</span>(t);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">l</span>(t)||!<span class="built_in">r</span>(t)) t=<span class="built_in">l</span>(t)+<span class="built_in">r</span>(t); <span class="comment">//若只有一个儿子(或没有),就让儿子代替自己的位置</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">v</span>(t)=<span class="built_in">del</span>(<span class="built_in">l</span>(t),<span class="built_in">v</span>(t)+<span class="number">1</span>); <span class="comment">//否则就把左子树中最大的数移动到自己的位置</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(v&lt;<span class="built_in">v</span>(t)) <span class="keyword">return</span> <span class="built_in">del</span>(<span class="built_in">l</span>(t),v);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">del</span>(<span class="built_in">r</span>(t),v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一个优化？</span></span><br><span class="line">    <span class="comment">// maintain(t,false);</span></span><br><span class="line">    <span class="comment">// maintain(t,true);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> &amp;t,<span class="keyword">int</span> v)</span></span>&#123; <span class="comment">//查找关键字为v的节点</span></span><br><span class="line">    <span class="keyword">if</span>(!t) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(v&lt;<span class="built_in">v</span>(t)) <span class="keyword">return</span> <span class="built_in">find</span>(<span class="built_in">l</span>(t),v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in"><span class="keyword">return</span></span> (<span class="built_in">v</span>(t)==v||<span class="built_in">find</span>(<span class="built_in">r</span>(t),v)); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_rank</span><span class="params">(<span class="keyword">int</span> &amp;t,<span class="keyword">int</span> v)</span></span>&#123; <span class="comment">//返回v在以t为根的树中的排名</span></span><br><span class="line">    <span class="keyword">if</span>(!t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v&lt;=<span class="built_in">v</span>(t)) <span class="keyword">return</span> <span class="built_in">get_rank</span>(<span class="built_in">l</span>(t),v);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">size</span>(<span class="built_in">l</span>(t))+<span class="number">1</span>+<span class="built_in">get_rank</span>(<span class="built_in">r</span>(t),v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> &amp;t,<span class="keyword">int</span> k)</span></span>&#123; <span class="comment">//返回以t为根的树中排名第k的值</span></span><br><span class="line">    <span class="keyword">if</span>(k==<span class="built_in">size</span>(<span class="built_in">l</span>(t))+<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">v</span>(t);</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=<span class="built_in">size</span>(<span class="built_in">l</span>(t))) <span class="keyword">return</span> <span class="built_in">select</span>(<span class="built_in">l</span>(t),k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">select</span>(<span class="built_in">r</span>(t),k<span class="number">-1</span>-<span class="built_in">size</span>(<span class="built_in">l</span>(t)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pred</span><span class="params">(<span class="keyword">int</span> &amp;t,<span class="keyword">int</span> v)</span></span>&#123; <span class="comment">//返回比v小的最大的数</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span>(!t) <span class="keyword">return</span> v;</span><br><span class="line">    <span class="keyword">if</span>(v&lt;=<span class="built_in">v</span>(t)) <span class="keyword">return</span> <span class="built_in">pred</span>(<span class="built_in">l</span>(t),v);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ret=<span class="built_in">pred</span>(<span class="built_in">r</span>(t),v);</span><br><span class="line">        <span class="keyword">if</span>(ret==v) ret=<span class="built_in">v</span>(t);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">succ</span><span class="params">(<span class="keyword">int</span> &amp;t,<span class="keyword">int</span> v)</span></span>&#123; <span class="comment">//返回比v大的最小的数</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span>(!t) <span class="keyword">return</span> v;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">v</span>(t)&lt;=v) <span class="keyword">return</span> <span class="built_in">succ</span>(<span class="built_in">r</span>(t),v);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ret=<span class="built_in">succ</span>(<span class="built_in">l</span>(t),v);</span><br><span class="line">        <span class="keyword">if</span>(ret==v) ret=<span class="built_in">v</span>(t);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：  </p><ol><li><p>在 $insert$ 操作中，如果插入了两个值相同的节点，BST并不会像Splay一样用一个 $cnt$ 来记录，而是直接新建节点，把两个相同的值放在两个不同的节点上</p></li><li><p>在 $del$ 操作中，有一个小优化，即注释掉 $miantain$ ，在删除后不去维护SBT的结构（但性质是一定满足了的）,这样做树的高度变成了 $O(\log{K})$ ，这里 $K$ 表示插入的节点个数</p></li></ol><h2 id="时间分析"><a href="#时间分析" class="headerlink" title="时间分析"></a>时间分析</h2><p>我们来分析SBT的时间复杂度（其实不用分析了，是个人都知道是 $O(log{n})$）:<br>设 $f[h]$ 表示高度为 $h$ 的SBT包含的最少节点数，有：<br>$$<br>f[h]=\begin{cases}<br> 1 &amp; (h=0)\<br> 2 &amp; (h=1)\<br> f[h-1]+f[h-2]+1 &amp; (h&gt;1)<br>\end{cases}<br>$$</p><p>证明如下：<br>我们把一个高度为 $h-1$ 的SBT作为当前高度为 $h$ 的SBT的左子树，目前有 $f[h-1]+1$ 个节点，但为了满足SBT性质，右子树至少应有 $f[h-2]$ 个节点。<br>然后，我们可以由 $fibonacci$ 数列得到 $f[h]$ 计算公式：<br> $$f[h]=\sum_{i=0}^{h} Fibonacci[i]=\left | \frac{\alpha^{h+3}}{\sqrt{5}} \right |$$<br>其中 $\alpha=\frac{1+\sqrt{5}}{2}$</p><p>设 $maxh$ 表示有 n 个节点的SBT的最坏高度，有<br>$$f[maxh]=\left | \frac{\alpha^{h+3}}{\sqrt{5}} \right |-1 \le n \Rightarrow$$<br>$$\frac{\alpha^{h+3}}{\sqrt{5}} \le n+1.5 \Rightarrow$$<br>$$maxh \le \log_{\alpha}{\sqrt{5}(n+1.5)}-3 \Rightarrow$$<br>$$maxh \le 1.44\log_{2}{n+1.5}-1.33$$<br>明显，SBT高度为 $O(\log{n})$。<br>且SBT效率一般优于其他平衡树。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://www.luogu.com.cn/problem/P6136">P6136</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,last=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SBT</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inint</span><span class="params">(<span class="keyword">int</span> _v)</span></span>&#123;</span><br><span class="line">        v=_v;</span><br><span class="line">        size=<span class="number">1</span>;</span><br><span class="line">        l=r=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> v(i) tr[i].v</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> size(i) tr[i].size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(i) tr[i].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(i) tr[i].r</span></span><br><span class="line">&#125;tr[N];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>,root=<span class="number">0</span>;</span><br><span class="line"><span class="comment">/*-----------------------------SBT--------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r_rotate</span><span class="params">(<span class="keyword">int</span> &amp;t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="built_in">l</span>(t);</span><br><span class="line">    <span class="built_in">l</span>(t)=<span class="built_in">r</span>(k);</span><br><span class="line">    <span class="built_in">r</span>(k)=t;</span><br><span class="line">    <span class="built_in">size</span>(k)=<span class="built_in">size</span>(t);</span><br><span class="line">    <span class="built_in">size</span>(t)=<span class="built_in">size</span>(<span class="built_in">l</span>(t))+<span class="built_in">size</span>(<span class="built_in">r</span>(t))+<span class="number">1</span>;</span><br><span class="line">    t=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">l_rotate</span><span class="params">(<span class="keyword">int</span> &amp;t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="built_in">r</span>(t);</span><br><span class="line">    <span class="built_in">r</span>(t)=<span class="built_in">l</span>(k);</span><br><span class="line">    <span class="built_in">l</span>(k)=t;</span><br><span class="line">    <span class="built_in">size</span>(k)=<span class="built_in">size</span>(t);</span><br><span class="line">    <span class="built_in">size</span>(t)=<span class="built_in">size</span>(<span class="built_in">l</span>(t))+<span class="built_in">size</span>(<span class="built_in">r</span>(t))+<span class="number">1</span>;</span><br><span class="line">    t=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> &amp;t,<span class="keyword">bool</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">size</span>(<span class="built_in">l</span>(<span class="built_in">l</span>(t)))&gt;<span class="built_in">size</span>(<span class="built_in">r</span>(t))) <span class="built_in">r_rotate</span>(t);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">size</span>(<span class="built_in">r</span>(<span class="built_in">l</span>(t)))&gt;<span class="built_in">size</span>(<span class="built_in">r</span>(t)))&#123;</span><br><span class="line">            <span class="built_in">l_rotate</span>(<span class="built_in">l</span>(t));</span><br><span class="line">            <span class="built_in">r_rotate</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">size</span>(<span class="built_in">r</span>(<span class="built_in">r</span>(t)))&gt;<span class="built_in">size</span>(<span class="built_in">l</span>(t))) <span class="built_in">l_rotate</span>(t);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">size</span>(<span class="built_in">l</span>(<span class="built_in">r</span>(t)))&gt;<span class="built_in">size</span>(<span class="built_in">l</span>(t)))&#123;</span><br><span class="line">            <span class="built_in">r_rotate</span>(<span class="built_in">r</span>(t));</span><br><span class="line">            <span class="built_in">l_rotate</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">maintain</span>(<span class="built_in">l</span>(t),<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">maintain</span>(<span class="built_in">r</span>(t),<span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">maintain</span>(t,<span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">maintain</span>(t,<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;t,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!t)&#123;</span><br><span class="line">        t=++cnt;</span><br><span class="line">        tr[t].<span class="built_in">inint</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ++<span class="built_in">size</span>(t);</span><br><span class="line">        <span class="keyword">if</span>(v&lt;=<span class="built_in">v</span>(t)) <span class="built_in">insert</span>(<span class="built_in">l</span>(t),v);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">insert</span>(<span class="built_in">r</span>(t),v);</span><br><span class="line">        <span class="built_in">maintain</span>(t,v&gt;<span class="built_in">v</span>(t));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> &amp;t,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    --<span class="built_in">size</span>(t);</span><br><span class="line">    <span class="keyword">if</span>((v==<span class="built_in">v</span>(t))||((v&lt;<span class="built_in">v</span>(t))&amp;&amp;!<span class="built_in">l</span>(t))||((v&gt;<span class="built_in">v</span>(t))&amp;&amp;!<span class="built_in">r</span>(t)))&#123;</span><br><span class="line">        ret=<span class="built_in">v</span>(t);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">l</span>(t)||!<span class="built_in">r</span>(t)) t=<span class="built_in">l</span>(t)+<span class="built_in">r</span>(t);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">v</span>(t)=<span class="built_in">del</span>(<span class="built_in">l</span>(t),<span class="built_in">v</span>(t)+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(v&lt;<span class="built_in">v</span>(t)) <span class="keyword">return</span> <span class="built_in">del</span>(<span class="built_in">l</span>(t),v);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">del</span>(<span class="built_in">r</span>(t),v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> &amp;t,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!t) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(v&lt;<span class="built_in">v</span>(t)) <span class="keyword">return</span> <span class="built_in">find</span>(<span class="built_in">l</span>(t),v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in"><span class="keyword">return</span></span> (<span class="built_in">v</span>(t)==v||<span class="built_in">find</span>(<span class="built_in">r</span>(t),v)); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_rank</span><span class="params">(<span class="keyword">int</span> &amp;t,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v&lt;=<span class="built_in">v</span>(t)) <span class="keyword">return</span> <span class="built_in">get_rank</span>(<span class="built_in">l</span>(t),v);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">size</span>(<span class="built_in">l</span>(t))+<span class="number">1</span>+<span class="built_in">get_rank</span>(<span class="built_in">r</span>(t),v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> &amp;t,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="built_in">size</span>(<span class="built_in">l</span>(t))+<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">v</span>(t);</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=<span class="built_in">size</span>(<span class="built_in">l</span>(t))) <span class="keyword">return</span> <span class="built_in">select</span>(<span class="built_in">l</span>(t),k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">select</span>(<span class="built_in">r</span>(t),k<span class="number">-1</span>-<span class="built_in">size</span>(<span class="built_in">l</span>(t)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pred</span><span class="params">(<span class="keyword">int</span> &amp;t,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span>(!t) <span class="keyword">return</span> v;</span><br><span class="line">    <span class="keyword">if</span>(v&lt;=<span class="built_in">v</span>(t)) <span class="keyword">return</span> <span class="built_in">pred</span>(<span class="built_in">l</span>(t),v);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ret=<span class="built_in">pred</span>(<span class="built_in">r</span>(t),v);</span><br><span class="line">        <span class="keyword">if</span>(ret==v) ret=<span class="built_in">v</span>(t);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">succ</span><span class="params">(<span class="keyword">int</span> &amp;t,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span>(!t) <span class="keyword">return</span> v;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">v</span>(t)&lt;=v) <span class="keyword">return</span> <span class="built_in">succ</span>(<span class="built_in">r</span>(t),v);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ret=<span class="built_in">succ</span>(<span class="built_in">l</span>(t),v);</span><br><span class="line">        <span class="keyword">if</span>(ret==v) ret=<span class="built_in">v</span>(t);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">        <span class="built_in">insert</span>(root,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> op,x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;op,&amp;x);</span><br><span class="line">        x^=last;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">insert</span>(root,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">del</span>(root,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">3</span>)&#123;</span><br><span class="line">            last=<span class="built_in">get_rank</span>(root,x);</span><br><span class="line">            ans^=last;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">4</span>)&#123;</span><br><span class="line">            last=<span class="built_in">select</span>(root,x);</span><br><span class="line">            ans^=last;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">5</span>)&#123;</span><br><span class="line">            last=<span class="built_in">pred</span>(root,x);</span><br><span class="line">            ans^=last;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            last=<span class="built_in">succ</span>(root,x);</span><br><span class="line">            ans^=last;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> SBT </tag>
            
            <tag> 平衡树 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CDQ分治</title>
      <link href="/2021/11/22/CDQ%E5%88%86%E6%B2%BB/"/>
      <url>/2021/11/22/CDQ%E5%88%86%E6%B2%BB/</url>
      
        <content type="html"><![CDATA[<p>cdq，又一个大佬</p><span id="more"></span><h1 id="CDQ分治"><a href="#CDQ分治" class="headerlink" title="CDQ分治"></a>CDQ分治</h1><p>CDQ分治是一种运用广泛的分治思想，主要用于解决偏序问题，尤其是三维偏序，其主要思想是将区间分成两段，段内的信息递归处理，跨段的信息在左右两段都处理好后处理。</p><p>先看模板题吧：</p><h2 id="三维偏序"><a href="#三维偏序" class="headerlink" title="三维偏序"></a><a href="https://www.luogu.com.cn/problem/P3810">三维偏序</a></h2><p>这道题就是一个三维偏序的裸题，不过，在三维前，我们先想想一、二维偏序怎么做。</p><ul><li>一维偏序<br>非常简单，排序即可，时间复杂度为 $O(n\log{n})$</li><li>二维偏序<br>先双关键字排序，完成后就可以不管第一关键字了（只需保证 $i&gt;j$ 就可以使 $a_i \ge a_j$），而对于第二关键字，将其离散化到值域为 $[1,n]$ 建立一棵线段树来维护值 $x$ 的数量，则 $ask(1,1,b_i)$ 就储存了小于 $b_i$ 的值的个数，更新完 $i$ 的答案后让 $b_i$ 这个点 $+1$ 然后继续向后扫描即可。时间复杂度为 $O(n\log{n})$ </li></ul><p>如上，我们可以在 $O(n\log{n})$ 的时间内求解一、二维偏序，那么，我们现在来康康三维。</p><p>首先，类似一、二维偏序，三维偏序的第一维可以通过排序解决，第三维在前两维有序（即 $\forall i&gt;j,a_i \ge a_j,b_i \ge b_j$ ）的情况下可以用线段树解决，问题在于：如何在保证前两维都有序？</p><p>很明显，在对第一维排序后（三关键字排序），若再更改顺序来满足第二维，第一维的单调会被破坏，而CDQ分治解决了这个问题，其过程如下：  </p><ol><li>对于区间 $[l,r]$ （此时第一维仍然单调）,把区间中满足三维偏序的数对 $(i,j)(i&gt;j)$ 以 $mid$ 为界分为三种： $i,j \in [l,mid]$ 、 $i,j \in [mid+1,r]$ 、 $i \in [mid+1,r],j \in [l,mid]$</li><li>对于前两种（ $i,j$ 在同一段的）递归处理</li><li>处理完毕后，只剩下 $i,j$ 分别在 $mid$ 左右的情况，此时，由于 $mid$ 左边的数第一维一定小于右边，我们可以对左右分别以第二维排序，然后双指针枚举 $i,j$ 用线段树求解第三维</li></ol><p>以上就是CDQ分治的主要思路，不难发现，由于每次取 $mid$ ，递归层数不会超过 $\log{n}$ 层，每一层中对左右的分别排序可以用归并在递归中顺带完成，真正消耗时间的是双指针和线段树，第 $x$ 层中 $[1,n]$ 被分为了 $2^{x-1}$ 段，每段时间复杂度为 $O(2^{x-1} \times \frac{n}{2^{x-1}} \times \log{ \frac{n}{2^{x-1}}}) = O(n\log{n})$ ，乘上层数，总时间复杂度为 $O(n \log^2_{}{n})$</p><p>一个要注意的问题是，当出现三维都相等的数时，会导致排在前面的数少算，故应先去重。  </p><p>代码实现（注意代码中的 $m$ 是题目中的 $k$ ）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>,M=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> a,b,c,num,res; <span class="comment">//a,b,c:三维,num:重复的个数,res:三维都比它小的数的个数</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;x) <span class="keyword">const</span>&#123; <span class="comment">//重载三关键字排序</span></span><br><span class="line"><span class="keyword">if</span>(a!=x.a) <span class="keyword">return</span> a&lt;x.a;</span><br><span class="line"><span class="keyword">if</span>(b!=x.b) <span class="keyword">return</span> b&lt;x.b;</span><br><span class="line"><span class="keyword">return</span> c&lt;x.c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> Node &amp;x) <span class="keyword">const</span>&#123; <span class="comment">//重载等于用于判重</span></span><br><span class="line"><span class="keyword">return</span> a==x.a&amp;&amp;b==x.b&amp;&amp;c==x.c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;q[N],w[N]; <span class="comment">//w用于归并排序</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LineTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,dat;</span><br><span class="line">&#125;tr[M*<span class="number">4</span>];</span><br><span class="line"><span class="comment">/*--------------------------LineTree---------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">tr[u].dat=tr[u&lt;&lt;<span class="number">1</span>].dat+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].dat;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">tr[u].l=l;</span><br><span class="line">tr[u].r=r;</span><br><span class="line">tr[u].dat=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line"><span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> pos,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[u].l==tr[u].r)&#123;</span><br><span class="line">tr[u].dat+=d;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(pos&lt;=mid) <span class="built_in">change</span>(u&lt;&lt;<span class="number">1</span>,pos,d);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">change</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,pos,d);</span><br><span class="line"><span class="built_in">push_up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r) <span class="keyword">return</span> tr[u].dat;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) res+=<span class="built_in">ask</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid) res+=<span class="built_in">ask</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*----------------------------CDQ------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">merge_sort</span>(l,mid);</span><br><span class="line"><span class="built_in">merge_sort</span>(mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="keyword">int</span> i=l,j=mid+<span class="number">1</span>,k=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)</span><br><span class="line"><span class="keyword">if</span>(q[i].b&lt;=q[j].b) <span class="built_in">change</span>(<span class="number">1</span>,q[i].c,q[i].num),w[k++]=q[i++];</span><br><span class="line"><span class="keyword">else</span> q[j].res+=<span class="built_in">ask</span>(<span class="number">1</span>,<span class="number">1</span>,q[j].c),w[k++]=q[j++];</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid) <span class="built_in">change</span>(<span class="number">1</span>,q[i].c,q[i].num),w[k++]=q[i++];</span><br><span class="line"><span class="keyword">while</span>(j&lt;=r) q[j].res+=<span class="built_in">ask</span>(<span class="number">1</span>,<span class="number">1</span>,q[j].c),w[k++]=q[j++];</span><br><span class="line"><span class="keyword">for</span>(i=l;i&lt;=mid;++i) <span class="built_in">change</span>(<span class="number">1</span>,q[i].c,-q[i].num); <span class="comment">//还原线段树以备下次使用</span></span><br><span class="line"><span class="keyword">for</span>(i=l,j=<span class="number">1</span>;j&lt;k;++i,++j) q[i]=w[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;q[i].a,&amp;q[i].b,&amp;q[i].c),q[i].num=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">sort</span>(q+<span class="number">1</span>,q+<span class="number">1</span>+n);</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line"><span class="keyword">if</span>(q[i]==q[k<span class="number">-1</span>]) ++q[k<span class="number">-1</span>].num;</span><br><span class="line"><span class="keyword">else</span> q[k++]=q[i];</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,m); <span class="comment">//这里m足够小不必离散化</span></span><br><span class="line"><span class="built_in">merge_sort</span>(<span class="number">1</span>,k<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k;++i)</span><br><span class="line">ans[q[i].num+q[i].res<span class="number">-1</span>]+=q[i].num; <span class="comment">//f(i)=q[i].num+q[i].res-1(去掉自己)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="老C的任务"><a href="#老C的任务" class="headerlink" title="老C的任务"></a><a href="https://www.luogu.com.cn/problem/P3755">老C的任务</a></h3><p>提示：考虑二维前缀和，对于每个询问 $(x1,y1,x2,y2),ans=s(x2,y2)-s(x2,y1-1)-s(x1-1,y2)+s(x1-1,y1-1)$ ，不妨以坐标作为第一、二维，是否是询问为第三维（是为1，不是为0）,把询问拆成四个点（注意保留符号），和不是询问的点一起，对于每个点，求其三维偏序（求出的点就是会对其二维前缀和有贡献的点），最后计算即可，本题第三维只有0、1两中情况，故可以省略线段树，直接用一个 $sum$ 记录为0的数的权值和。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y,z,p,i,sign;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;t) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x!=t.x) <span class="keyword">return</span> x&lt;t.x;</span><br><span class="line"><span class="keyword">if</span>(y!=t.y) <span class="keyword">return</span> y&lt;t.y;</span><br><span class="line"><span class="keyword">return</span> z&lt;t.z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inint</span><span class="params">(<span class="keyword">int</span> _x,<span class="keyword">int</span> _y,<span class="keyword">int</span> _z,<span class="keyword">int</span> _p,<span class="keyword">int</span> _i,<span class="keyword">int</span> _s)</span></span>&#123;</span><br><span class="line">x=_x;</span><br><span class="line">y=_y;</span><br><span class="line">z=_z;</span><br><span class="line">p=_p;</span><br><span class="line">i=_i;</span><br><span class="line">sign=_s;</span><br><span class="line">sum=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;q[N*<span class="number">5</span>],w[N*<span class="number">5</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">merge_sort</span>(l,mid);</span><br><span class="line"><span class="built_in">merge_sort</span>(mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="keyword">int</span> i=l,j=mid+<span class="number">1</span>,k=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)</span><br><span class="line"><span class="keyword">if</span>(q[i].y&lt;=q[j].y) sum+=!q[i].z*q[i].p,w[k++]=q[i++];</span><br><span class="line"><span class="keyword">else</span> q[j].sum+=sum,w[k++]=q[j++];</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid) sum+=!q[i].z*q[i].p,w[k++]=q[i++];</span><br><span class="line"><span class="keyword">while</span>(j&lt;=r) q[j].sum+=sum,w[k++]=q[j++];</span><br><span class="line"><span class="keyword">for</span>(i=l,j=<span class="number">1</span>;j&lt;k;++i,++j) q[i]=w[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;q[i].x,&amp;q[i].y,&amp;q[i].p),q[i].z=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> k=n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line"><span class="keyword">int</span> x_1,y_1,x_2,y_2;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x_1,&amp;y_1,&amp;x_2,&amp;y_2);</span><br><span class="line">q[k++].<span class="built_in">inint</span>(x_2,y_2,<span class="number">1</span>,<span class="number">0</span>,i,<span class="number">1</span>);</span><br><span class="line">q[k++].<span class="built_in">inint</span>(x_1<span class="number">-1</span>,y_2,<span class="number">1</span>,<span class="number">0</span>,i,<span class="number">-1</span>);</span><br><span class="line">q[k++].<span class="built_in">inint</span>(x_2,y_1<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,i,<span class="number">-1</span>);</span><br><span class="line">q[k++].<span class="built_in">inint</span>(x_1<span class="number">-1</span>,y_1<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,i,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(q+<span class="number">1</span>,q+k);</span><br><span class="line"><span class="built_in">merge_sort</span>(<span class="number">1</span>,k<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k;++i)</span><br><span class="line"><span class="keyword">if</span>(q[i].z) ans[q[i].i]+=q[i].sum*q[i].sign;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态逆序对"><a href="#动态逆序对" class="headerlink" title="动态逆序对"></a><a href="https://www.luogu.com.cn/problem/P3157">动态逆序对</a></h3><p>提示：以时间为第三维，对于每个删除，求出该删除会导致此时仍存在的数列减少多少个逆序对即可。注意第三维越大越早删除，注意逆序应分类讨论</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> a,t,res; <span class="comment">//位置关系已经是有序且互不相等的,不必记录和排序 </span></span><br><span class="line">&#125;q[N],w[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LineTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,dat;</span><br><span class="line">&#125;tr[N*<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> pos[N];</span><br><span class="line">LL ans[N];</span><br><span class="line"><span class="comment">/*---------------------------------LineTree--------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">tr[u].dat=tr[u&lt;&lt;<span class="number">1</span>].dat+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].dat;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">tr[u].l=l;</span><br><span class="line">tr[u].r=r;</span><br><span class="line">tr[u].dat=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line"><span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> pos,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[u].l==tr[u].r)&#123;</span><br><span class="line">tr[u].dat+=d;</span><br><span class="line"><span class="keyword">return</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(pos&lt;=mid) <span class="built_in">change</span>(u&lt;&lt;<span class="number">1</span>,pos,d);</span><br><span class="line"><span class="keyword">if</span>(pos &gt; mid) <span class="built_in">change</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,pos,d);</span><br><span class="line"><span class="built_in">push_up</span>(u); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r) <span class="keyword">return</span> tr[u].dat;</span><br><span class="line"><span class="keyword">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) res+=<span class="built_in">ask</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid) res+=<span class="built_in">ask</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*----------------------------------CDQ---------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">merge_sort</span>(l,mid);</span><br><span class="line"><span class="built_in">merge_sort</span>(mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="keyword">int</span> i=mid,j=r,k;</span><br><span class="line"><span class="comment">//j的位置在i后时 </span></span><br><span class="line"><span class="keyword">while</span>(i&gt;=l&amp;&amp;j&gt;mid)</span><br><span class="line"><span class="keyword">if</span>(q[i].a&gt;q[j].a) <span class="built_in">change</span>(<span class="number">1</span>,q[i].t,<span class="number">1</span>),--i;</span><br><span class="line"><span class="keyword">else</span> q[j].res+=<span class="built_in">ask</span>(<span class="number">1</span>,<span class="number">1</span>,q[j].t<span class="number">-1</span>),--j;</span><br><span class="line"><span class="keyword">while</span>(j&gt;mid) q[j].res+=<span class="built_in">ask</span>(<span class="number">1</span>,<span class="number">1</span>,q[j].t<span class="number">-1</span>),--j;</span><br><span class="line"><span class="keyword">for</span>(k=i+<span class="number">1</span>;k&lt;=mid;++k) <span class="built_in">change</span>(<span class="number">1</span>,q[k].t,<span class="number">-1</span>);</span><br><span class="line"><span class="comment">//j的位置在i前时</span></span><br><span class="line">j=l,i=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(j&lt;=mid&amp;&amp;i&lt;=r)</span><br><span class="line"><span class="keyword">if</span>(q[i].a&lt;q[j].a) <span class="built_in">change</span>(<span class="number">1</span>,q[i].t,<span class="number">1</span>),++i;</span><br><span class="line"><span class="keyword">else</span> q[j].res+=<span class="built_in">ask</span>(<span class="number">1</span>,<span class="number">1</span>,q[j].t<span class="number">-1</span>),++j;</span><br><span class="line"><span class="keyword">while</span>(j&lt;=mid) q[j].res+=<span class="built_in">ask</span>(<span class="number">1</span>,<span class="number">1</span>,q[j].t<span class="number">-1</span>),++j;</span><br><span class="line"><span class="keyword">for</span>(k=i<span class="number">-1</span>;k&gt;mid;--k) <span class="built_in">change</span>(<span class="number">1</span>,q[k].t,<span class="number">-1</span>);</span><br><span class="line"><span class="comment">//归并排序可以用sort代替</span></span><br><span class="line">i=l,j=mid+<span class="number">1</span>;</span><br><span class="line">k=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)</span><br><span class="line"><span class="keyword">if</span>(q[i].a&lt;=q[j].a) w[k++]=q[i++];</span><br><span class="line"><span class="keyword">else</span> w[k++]=q[j++];</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid) w[k++]=q[i++];</span><br><span class="line"><span class="keyword">while</span>(j&lt;=r) w[k++]=q[j++];</span><br><span class="line"><span class="keyword">for</span>(i=l,j=<span class="number">1</span>;j&lt;k;++i,++j) q[i]=w[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i].a);</span><br><span class="line">pos[q[i].a]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=n;i&lt;=m;++i)&#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">q[pos[a]].t=j--;</span><br><span class="line">pos[a]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=n-m;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(pos[i]!=<span class="number">-1</span>) q[pos[i]].t=j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="built_in">merge_sort</span>(<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) ans[q[i].t]=q[i].res;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) ans[i]+=ans[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=n;i&lt;=m;++i,--j) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans[j]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> cdq </tag>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BSGS算法</title>
      <link href="/2021/11/22/BSGS%E7%AE%97%E6%B3%95/"/>
      <url>/2021/11/22/BSGS%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>大步小步</p><span id="more"></span><h1 id="BSGS算法"><a href="#BSGS算法" class="headerlink" title="BSGS算法"></a>BSGS算法</h1><h2 id="普通版"><a href="#普通版" class="headerlink" title="普通版"></a>普通版</h2><p>在以前我们学了用拓欧求解线性同余方程 $ax\equiv 1\pmod b$ ，现在我们来思考高次同余方程，考虑如下问题：</p><p>求解关于 $x$ 的方程 $a^x\equiv b\pmod p$ ，其中 $gcd(a,p)=1$  </p><p>不难想到欧拉定理 $a^{\varphi(p)}\equiv 1\pmod p$ ，设 $a^t\equiv a^{x\mod \varphi(p)}\pmod p$ ，易得 $t\in[0,\varphi(p)-1]$ ，我们只需找到 $t$ 使 $x=t$ 时方程成立即可，为了代码简洁（懒得求欧拉函数）不 妨扩大 $t$ 的范围，使 $t\in[0,p]$ </p><p>直接枚举 $t$ 计算显得过于暴力，BSGS算法使用一个“以空间换时间”的思想，用分块加hash表处理：</p><p>令 $k=\lceil\sqrt{p}\rceil$ （代码中为简洁一般是 $k=\sqrt{n}+1$ ），将 $[0,p]$ 每 $k$ 个分为一段，则可以把 $t$ 表示为 $t=kx-y,x\in[1,k],y\in[0,k-1]$ (这里的 $x$ 已经不是上面方程的 $x$ 了，而是新设的未知数，不用 $+y$ 而用 $-y$ 是为了在后面移项后不出现逆元) ，这样， $t$ 可以取遍 $[1,p]$ 中所有值，剩下的 $0$ 特判即可</p><p>那么问题转化为求出一组 $x,y$ 使 $t=kx-y,a^t\equiv b\pmod p$ ，很暴力的思路是，枚举每一个 $x$ 判断是否存在 $y$ ，这里就体现出用 $-y$ 的好处，我们来变个形：<br>$$<br>a^t\equiv b\pmod p\Rightarrow a^{kx-y}\equiv b\pmod p\Rightarrow a^{kx}\equiv b\times a^y\pmod p<br>$$<br>可以提前将 $b\times a^y$ 存到hash表里，枚举 $x$ 判定即可，如果有多个 $y$ 的 $b\times a^y$ 相同，我们保留较大的（这样减了以后 $t$ 最小）</p><p>时间复杂度为 $O(\sqrt{p})$ </p><p><a href="https://www.luogu.com.cn/problem/P3846">BSGS板子</a> </p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">50000</span>+<span class="number">5</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> H=<span class="number">20051221</span>; <span class="comment">//取的质数很玄妙 </span></span><br><span class="line"><span class="comment">//拉链法Hash </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hash</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> key,val,ne;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">2</span>]; </span><br><span class="line"><span class="keyword">int</span> h[H],idx=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;H;++i) h[i]=<span class="number">-1</span>; <span class="comment">//初始化hash表 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> _key=(key%H+H)%H;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[_key];i!=<span class="number">-1</span>;i=e[i].ne)</span><br><span class="line"><span class="keyword">if</span>(e[i].key==key) <span class="keyword">return</span> e[i].val;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> val)</span></span>&#123; <span class="comment">//用后面的覆盖前面 </span></span><br><span class="line"><span class="keyword">int</span> _key=(key%H+H)%H;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[_key];i!=<span class="number">-1</span>;i=e[i].ne)</span><br><span class="line"><span class="keyword">if</span>(e[i].key==key) <span class="keyword">return</span> e[i].val=val;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">change</span>(key,val)!=<span class="number">-1</span>) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> _key=(key%H+H)%H;</span><br><span class="line">e[idx].key=key,e[idx].val=val,e[idx].ne=h[_key],h[_key]=idx++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;ha; <span class="comment">//注意hash会重名 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsgs</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span>%p==b%p) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//特判0的情况 </span></span><br><span class="line"><span class="keyword">int</span> k=<span class="built_in">sqrt</span>(p)+<span class="number">1</span>;</span><br><span class="line">ha.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=b%p;i&lt;k;++i)&#123; <span class="comment">//提交将每个y插入hash表里,</span></span><br><span class="line"><span class="comment">//枚举方法本身保证了保留的是更大的y </span></span><br><span class="line">ha.<span class="built_in">insert</span>(j,i);</span><br><span class="line">j=(LL)j*a%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ak=<span class="number">1</span>; <span class="comment">//处理出a^k </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;++i) ak=(LL)ak*a%p; <span class="comment">//可以用qpow,然而对时间复杂度没有优化 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=ak,_h;i&lt;=k;++i)&#123;</span><br><span class="line">_h=ha.<span class="built_in">find</span>(j);</span><br><span class="line"><span class="keyword">if</span>(_h!=<span class="number">-1</span>) <span class="keyword">return</span> (LL)i*k-_h;</span><br><span class="line">j=(LL)j*ak%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,p,b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;p,&amp;a,&amp;b);</span><br><span class="line"><span class="keyword">int</span> ans=<span class="built_in">bsgs</span>(a,b,p);</span><br><span class="line">ans&lt;<span class="number">0</span>?<span class="built_in">printf</span>(<span class="string">&quot;no solution\n&quot;</span>):<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓展版"><a href="#拓展版" class="headerlink" title="拓展版"></a>拓展版</h2><p>考虑更一般的情况：</p><p> $a^x\equiv b\pmod p$ ，其中 $a,p$ 不一定互质，求解 $x$ ，理所当然想办法转化为普通版，过程如下：</p><ol><li><p>若 $a^0\equiv b\pmod p$ ， $x=0$ ，结束 </p></li><li><p>若 $x\ge1$ 且 $gcd(a,p)==1$ 用普通版BSGS</p></li><li><p>若 $gcd(a,p)=d,d&gt;1$ ，则 $a^x\equiv b\pmod p\Leftrightarrow a^x+kp=b$ </p><p>明显，若 $d\nmid b$ 原方程无解</p><p>否则有 $d|b$ ，可以所有数同时除以 $d$ ，化为  $\frac{a}{d}\times a^{x-1}\equiv\frac{b}{d}\pmod {\frac{p}{d}}$ 此时 $gcd(\frac{a}{d},\frac{p}{d})=1$ ，可以求 $\frac{a}{b}$ 的逆元，于是化为 $a^{x-1}\equiv\frac{b}{d}\times(\frac{a}{d})^{-1}\pmod {\frac{p}{d}}$ ，让 $a’=a,x’=x-1,b’=\frac{b}{d}\times(\frac{a}{d})^{-1},p’=\frac{p}{d}$ ，再次回到第一步求解 $a’^{x’}\equiv b’\pmod {p’}$ </p></li></ol><p><a href="https://www.luogu.com.cn/problem/P4195">拓展BSGS</a></p><p>本题有多组数据，每次清空hash表还不如每次重开一个map快（unordered_map也行）</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">50000</span>+<span class="number">5</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!b)&#123;</span><br><span class="line">x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> d=<span class="built_in">exgcd</span>(b,a%b,y,x);</span><br><span class="line">y-=a/b*x;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsgs</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span>%p==b%p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> k=<span class="built_in">sqrt</span>(p)+<span class="number">1</span>;</span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;ha;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=b%p;i&lt;k;++i)&#123;</span><br><span class="line">ha[j]=i;</span><br><span class="line">j=(LL)j*a%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ak=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;++i) ak=(LL)ak*a%p;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=ak;i&lt;=k;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(ha.<span class="built_in">find</span>(j)!=ha.<span class="built_in">end</span>()) <span class="keyword">return</span> i*k-ha[j];</span><br><span class="line">j=(LL)j*ak%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exbsgs</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">b=(b%p+p)%p; <span class="comment">//保证b为正数 </span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span>%p==b%p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">int</span> d=<span class="built_in">exgcd</span>(a,p,x,y);</span><br><span class="line"><span class="keyword">if</span>(d&gt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(b%d) <span class="keyword">return</span> -INF;</span><br><span class="line"><span class="built_in">exgcd</span>(a/d,p/d,x,y);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">exbsgs</span>(a,(LL)b/d*x%(p/d),p/d)+<span class="number">1</span>; <span class="comment">//注意加1 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">bsgs</span>(a,b,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,p,b;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;p,&amp;b),a||p||b)&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="built_in">exbsgs</span>(a,b,p);</span><br><span class="line">ans&lt;<span class="number">0</span>?<span class="built_in">printf</span>(<span class="string">&quot;No Solution\n&quot;</span>):<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.com.cn/problem/P3306">随机数生成器</a></p><p>本题的特判较多，我们慢慢分析</p><p>首先是 $a,b$ 可以等于 $0$ ，先特判掉，保证 $a,b&gt;0$ </p><p>再将问题转化：给定 $p,a,b,x_1,t$ 和递推公式 $x_{i+1}=a\times x_i+b\pmod p$ 求一个最小的 $n$ 使得 $x_n=t$  </p><p>当然，我们的第一步应该是找到 $x_n$ 的通项公式，<strong>我要开始变形了</strong>（以下均默认 $\mod p$）：<br>$$<br>\begin{align}<br>&amp;\text{设}c\in\mathbb{R}\text{且使得}x_i+c=a(x_{i-1}+c)\\<br>\Rightarrow&amp;x_i=ax_{i-1}+c(a-1)\\<br>&amp;\text{又}\because x_i=ax_{i-1}+b\\<br>\Rightarrow&amp;c=\frac{b}{a-1}(a\ne1)\\<br>\Rightarrow&amp;x_i+\frac{b}{a-1}=a(x_{i-1}+\frac{b}{a-1})(a\ne1)\\<br>&amp;\text{等比数列通项公式得}x_i+\frac{b}{a-1}=a^{i-1}(x_1+\frac{b}{a-1})(a\ne1)\\<br>\Rightarrow&amp;x_n+\frac{b}{a-1}=a^{n-1}(x_1+\frac{b}{a-1})(a\ne1)\\<br>&amp;\text{又}\because x_n=t\\<br>\Rightarrow&amp;t+\frac{b}{a-1}=a^{n-1}(x_1+\frac{b}{a-1})(a\ne1)\\<br>&amp;\text{特判掉}x_1+\frac{b}{a-1}=0\\<br>\Rightarrow&amp;a^{n-1}=\frac{t+\frac{b}{a-1}}{x_1+\frac{b}{a-1}}(a\ne1)<br>\end{align}<br>$$<br>特判 $a=1$ 的情况，然后，由于 $p$ 问题就转化为 $a^x\equiv b\pmod p$ 的形式，解出 $x$ 即是 $n-1$ </p><p>以上，用了三个特判，我们把问题转换为BSGS</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!b)&#123;</span><br><span class="line">x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> d=<span class="built_in">exgcd</span>(b,a%b,y,x);</span><br><span class="line">y-=a/b*x;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inv</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">exgcd</span>(a,p,x,y);</span><br><span class="line"><span class="keyword">return</span> (x+p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsgs</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span>%p==b%p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;ha;</span><br><span class="line"><span class="keyword">int</span> k=<span class="built_in">sqrt</span>(p)+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=b%p;i&lt;k;++i)&#123;</span><br><span class="line">ha[j]=i;</span><br><span class="line">j=(LL)j*a%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ak=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;++i) ak=(LL)ak*a%p;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=ak;i&lt;=k;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(ha.<span class="built_in">find</span>(j)!=ha.<span class="built_in">end</span>()) <span class="keyword">return</span> (LL)i*k-ha[j];</span><br><span class="line">j=(LL)j*ak%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line"><span class="keyword">int</span> p,a,b,x1,t;</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>,&amp;p,&amp;a,&amp;b,&amp;x1,&amp;t);</span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(x1==t) <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(b==t) <span class="built_in">puts</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">0</span>) t==x1?<span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>):<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">x=((LL)<span class="built_in">inv</span>(b,p)*(t-x1)%p+p)%p;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> C=(LL)b*<span class="built_in">inv</span>(a<span class="number">-1</span>,p)%p;</span><br><span class="line"><span class="keyword">int</span> A=(x1+C)%p;</span><br><span class="line"><span class="keyword">if</span>(A==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> u=(-C+p)%p;</span><br><span class="line">t==u?<span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>):<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> B=(t+C)%p;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="built_in">bsgs</span>(a,(LL)B*<span class="built_in">inv</span>(A,p)%p,p);</span><br><span class="line">ans&lt;<span class="number">0</span>?<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>):<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数论,数学 </tag>
            
            <tag> 欧拉定理 </tag>
            
            <tag> hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AC自动机</title>
      <link href="/2021/11/22/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
      <url>/2021/11/22/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>然而AC自动机并不能自动帮你AC</p><span id="more"></span><h2 id="钳制芝士"><a href="#钳制芝士" class="headerlink" title="钳制芝士"></a>钳制芝士</h2><ul><li>KMP<br>对字符串 $A$ 进行自我匹配，求出数组 $ne$ 使 $ne[i]$ 表示“ $A$ 中以 $i$ 结尾的非前缀子串与 $A$ 的前缀子串能匹配的最长长度”，即： $ne[i]=max{j}$ ，其中 $j&lt;i$ 并且 $\forall k \in [i-j+1,i],A[k]=A[k+j-i]$ （ $A[k+j-i]$ 即是 $A[1 \sim j]$ ） ，如图：<img src="https://i.loli.net/2021/12/02/RfbB6x92tagA71D.png" alt="KMP例子"><br>同理我们对字符串 $A$ 与 $B$ 进行匹配，求出数组 $f$ ，使 $f[i]$ 表示“ $B$ 中以 $i$ 结尾的子串与 $A$ 的前缀子串能匹配的最长长度”,即： $f[i]=max{j}$ ，其中 $j \le i$ 并且 $\forall k \in [i-j+1,i],B[k]=A[k+j-i]$<br>代码实现：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求ne数组</span></span><br><span class="line">ne[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=n;++i)&#123;<span class="comment">//&quot;非前缀子串&quot;,故i从2开始 </span></span><br><span class="line"><span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;a[i]!=a[j+<span class="number">1</span>]) j=ne[j];</span><br><span class="line"><span class="keyword">if</span>(a[i]==a[j+<span class="number">1</span>]) ++j;</span><br><span class="line">ne[i]=j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求f数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=m;++i)&#123;</span><br><span class="line"><span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;(j==n||b[i]!=a[j+<span class="number">1</span>])) j=ne[j];</span><br><span class="line"><span class="keyword">if</span>(b[i]==a[j+<span class="number">1</span>]) ++j;</span><br><span class="line">f[i]=j;</span><br><span class="line"><span class="keyword">if</span>(f[i]==n)&#123;</span><br><span class="line"><span class="comment">//此时就是A在B中的一次出现 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;                     </span><br></pre></td></tr></table></figure><ul><li>Trie（字典树）<br>用于统计，排序和保存大量的字符串（但不仅限于字符串），优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较。<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/vcxx8qhd.png" alt="Trie"><br>代码：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> trie[N][<span class="number">26</span>],tot=<span class="number">1</span>;<span class="comment">//设字符串由小写字母构成</span></span><br><span class="line"><span class="keyword">bool</span> end[N];</span><br><span class="line"><span class="comment">//插入一个字符串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span>* s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l=<span class="built_in">strlen</span>(s),p=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;l;++k)&#123;</span><br><span class="line"><span class="keyword">int</span> ch=s[k]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(trie[p][ch]==<span class="number">0</span>) trie[p][ch]=++tot;</span><br><span class="line">p=trie[p][ch];</span><br><span class="line">&#125;</span><br><span class="line">end[p]=<span class="literal">true</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 搜索一个字符串</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="keyword">char</span>* s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l=<span class="built_in">strlen</span>(s),p=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;l;++k)&#123;</span><br><span class="line">p=trie[p][s[k]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(p==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> end[p];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h2><p>大家都知道KMP算法是求单字符串对单字符串的匹配使用的，那么，多个字符串在一个字符串上的匹配怎么办？ 如：<br>求 abab 在 abababbabbaabbabbab 中出现了几次。<br>很明显，求出abab的 $ne$ 数组，然后进行KMP的匹配即可出解。<br>辣么——求 aba 、 aca 、 bab 、 sab 、 sba 在字符串 asabbasbaabbabbacaacbscbs 中总共出现了几次。此时如果再对于每一个需要匹配的串求一次 $ne$ 数组，时间复杂度过大了……<br>辣么，AC自动机是如何解决此问题的呢？ </p><hr><p>开始前，先看看定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>&#123;</span><span class="comment">//字典树 </span></span><br><span class="line"><span class="keyword">int</span> fail;<span class="comment">//失配指针 </span></span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">26</span>];<span class="comment">//子节点位置 </span></span><br><span class="line"><span class="keyword">int</span> end;<span class="comment">//标记结尾</span></span><br><span class="line">&#125;ac[N];</span><br></pre></td></tr></table></figure><p>然后开始吧！<br>首先，将所有的需要匹配的字符串构造成一棵Tire树，如图（灰色节点表示一个单词的结尾）：<img src="https://cdn.luogu.com.cn/upload/image_hosting/vnrb9ian.png" alt="待匹配串"><br>然后，类似于KMP建立失配指针（即 $ne$ 数组），其定义为：当前节点所代表的串中，最长的、能与后缀匹配的，在 Trie 中出现过的前缀所代表的节点。<br>类似的，可以通过跳转来省略重复的检查。<br>如图是已建立好的：<img src="https://cdn.luogu.com.cn/upload/image_hosting/c9lxu68e.png" alt="失配"><br>每次沿着Trie树匹配，匹配到当前位置没有匹配上时，直接跳转到失配指针所指向的位置继续进行匹配。<br>所以，这个Trie树的失配指针要怎么求？<br>我们发现Trie树的失配指针是指向：沿着其父节点的失配指针，一直向上，直到找到拥有当前这个字母为子节点的节点，它的那个子节点就是目标。<br>如上图中 she 中的 e ，它的父节点是 h （ s 下面那个），而 h 的失配指针指向另一个 h （根下面那个），且这个 h 的子节点中有一个 e ，就将 she 中的 e 指向这个 e 。<br>需要注意的是，若找不到符合要求的节点，就将失配指针指向根，不难发现，第二层的所有节点的失配指针，都要直接指向Trie树的根节点。<br>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造fail指针 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get_fail</span><span class="params">()</span></span>&#123;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)<span class="comment">//第二层的fail指针预处理 </span></span><br><span class="line"><span class="keyword">if</span>(ac[<span class="number">0</span>].vis[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">ac[ac[<span class="number">0</span>].vis[i]].fail=<span class="number">0</span>;<span class="comment">//指向根节点 </span></span><br><span class="line">q.<span class="built_in">push</span>(ac[<span class="number">0</span>].vis[i]);<span class="comment">//入队 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;<span class="comment">//BFS求fail指针 </span></span><br><span class="line"><span class="keyword">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)<span class="comment">//枚举子节点 </span></span><br><span class="line"><span class="keyword">if</span>(ac[u].vis[i]!=<span class="number">0</span>)&#123;<span class="comment">//该节点存在 </span></span><br><span class="line">ac[ac[u].vis[i]].fail=ac[ac[u].fail].vis[i];<span class="comment">//子节点的fail指针 指向当前节点的</span></span><br><span class="line"><span class="comment">//fail指针 所指向的节点 的相同子节点 </span></span><br><span class="line">q.<span class="built_in">push</span>(ac[u].vis[i]);<span class="comment">//入队 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//不存在这个子节点 </span></span><br><span class="line">ac[u].vis[i]=ac[ac[u].fail].vis[i]; <span class="comment">//当前节点的这个子节点指向当</span></span><br><span class="line">                      <span class="comment">//前节点fail指针的这个子节点</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们直接匹配即可了！先让指针指向根节点<br>依次读入单词，检查是否存在这个子节点，然后指针跳转到子节点，如果不存在，直接跳转到失配指针即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AC自动机匹配</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Ac_query</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l=s.<span class="built_in">length</span>();</span><br><span class="line"><span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;++i)&#123;</span><br><span class="line">now=ac[now].vis[s[i]-<span class="string">&#x27;a&#x27;</span>];<span class="comment">//向下一层</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> t=now;t;t=ac[t].fail)<span class="comment">//循环求解 </span></span><br><span class="line">ans[ac[t].end].num++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>最后给出总的代码（尝试了一下标准码风）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//P376</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> fail;</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">int</span> end;</span><br><span class="line">&#125; ac[N];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Result</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">int</span> pos;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Result &amp;y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> num != y.num ? num &gt; y.num : pos &lt; y.pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inint</span><span class="params">(<span class="keyword">int</span> _num, <span class="keyword">int</span> _pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">num = _num;</span><br><span class="line">pos = _pos;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; ans[N];</span><br><span class="line">string s[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clean</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(ac[x].vis, <span class="number">0</span>, <span class="keyword">sizeof</span> ac[x].vis);</span><br><span class="line">ac[x].fail = <span class="number">0</span>;</span><br><span class="line">ac[x].end = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_Trie</span><span class="params">(string s, <span class="keyword">int</span> Num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = s.<span class="built_in">length</span>();</span><br><span class="line"><span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ac[now].vis[s[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">ac[now].vis[s[i] - <span class="string">&#x27;a&#x27;</span>] = ++cnt;</span><br><span class="line"><span class="built_in">clean</span>(cnt);</span><br><span class="line">&#125;</span><br><span class="line">now = ac[now].vis[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line">ac[now].end = Num;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_fail</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line"><span class="keyword">if</span> (ac[<span class="number">0</span>].vis[i] != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">ac[ac[<span class="number">0</span>].vis[i]].fail = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push</span>(ac[<span class="number">0</span>].vis[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line"><span class="keyword">if</span> (ac[u].vis[i] != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">ac[ac[u].vis[i]].fail = ac[ac[u].fail].vis[i];</span><br><span class="line">q.<span class="built_in">push</span>(ac[u].vis[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ac[u].vis[i] = ac[ac[u].fail].vis[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AC_query</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = s.<span class="built_in">length</span>();</span><br><span class="line"><span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; ++i)</span><br><span class="line">&#123;</span><br><span class="line">now = ac[now].vis[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> t = now; t; t = ac[t].fail)</span><br><span class="line">ans[ac[t].end].num++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">cnt = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">clean</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; s[i];</span><br><span class="line">ans[i].<span class="built_in">inint</span>(<span class="number">0</span>, i);</span><br><span class="line"><span class="built_in">build_Trie</span>(s[i], i);</span><br><span class="line">&#125;</span><br><span class="line">ac[<span class="number">0</span>].fail = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">get_fail</span>();</span><br><span class="line">cin &gt;&gt; s[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">AC_query</span>(s[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">sort</span>(ans + <span class="number">1</span>, ans + <span class="number">1</span> + n);</span><br><span class="line">cout &lt;&lt; ans[<span class="number">1</span>].num &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s[ans[<span class="number">1</span>].pos] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">if</span> (ans[i].num == ans[i - <span class="number">1</span>].num)</span><br><span class="line">cout &lt;&lt; s[ans[i].pos] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充，可以把搜索过程改为拓扑序，可以过加强版</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//P5357</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> fail;</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">int</span> end;</span><br><span class="line"><span class="keyword">int</span> as;</span><br><span class="line">&#125; ac[N];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> re[N], in[N], ans[N];</span><br><span class="line">string s[N];</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_Trie</span><span class="params">(string s, <span class="keyword">int</span> Num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = s.<span class="built_in">length</span>();</span><br><span class="line"><span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!ac[now].vis[s[i] - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">ac[now].vis[s[i] - <span class="string">&#x27;a&#x27;</span>] = ++cnt;</span><br><span class="line">now = ac[now].vis[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!ac[now].end)</span><br><span class="line">ac[now].end = Num;</span><br><span class="line">re[Num] = ac[now].end;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_fail</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line"><span class="keyword">if</span> (ac[<span class="number">0</span>].vis[i] != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">ac[ac[<span class="number">0</span>].vis[i]].fail = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push</span>(ac[<span class="number">0</span>].vis[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v = ac[u].vis[i];</span><br><span class="line"><span class="keyword">if</span> (v)</span><br><span class="line">&#123;</span><br><span class="line">ac[v].fail = ac[ac[u].fail].vis[i];</span><br><span class="line">in[ac[v].fail]++;</span><br><span class="line">q.<span class="built_in">push</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ac[u].vis[i] = ac[ac[u].fail].vis[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AC_query</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = s.<span class="built_in">length</span>();</span><br><span class="line"><span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; ++i)</span><br><span class="line">&#123;</span><br><span class="line">now = ac[now].vis[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">ac[now].as++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line"><span class="keyword">if</span> (!in[i])</span><br><span class="line">q.<span class="built_in">push</span>(i);</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">ans[ac[u].end] = ac[u].as;</span><br><span class="line"><span class="keyword">int</span> v = ac[u].fail;</span><br><span class="line">in[v]--;</span><br><span class="line">ac[v].as += ac[u].as;</span><br><span class="line"><span class="keyword">if</span> (!in[v])</span><br><span class="line">q.<span class="built_in">push</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; s[i];</span><br><span class="line"><span class="built_in">build_Trie</span>(s[i], i);</span><br><span class="line">&#125;</span><br><span class="line">ac[<span class="number">0</span>].fail = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">get_fail</span>();</span><br><span class="line">cin &gt;&gt; s[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">AC_query</span>(s[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">topu</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">cout &lt;&lt; ans[re[i]] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 自动机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Noip2021游记</title>
      <link href="/2021/11/22/Noip2021%E6%B8%B8%E8%AE%B0/"/>
      <url>/2021/11/22/Noip2021%E6%B8%B8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>Dyd’s stroy of noip2021</p><span id="more"></span><h1 id="NOIP2021游记"><a href="#NOIP2021游记" class="headerlink" title="NOIP2021游记"></a>NOIP2021游记</h1><h2 id="CSP-S"><a href="#CSP-S" class="headerlink" title="CSP-S"></a>CSP-S</h2><p>备考CSP-S时主要靠做题吧，期间学了些东西（基环树、笛卡尔树、<strong>模拟退火</strong>……），考的时候<strong>T1</strong>看错了数据范围，又打线段树又打平衡树的，还是爆0了，心态爆炸，后面三道题随便打了暴力，结果学的东西一个都没用上，从考场出来就知道自己要凉凉，就这样吧</p><h2 id="Day-n"><a href="#Day-n" class="headerlink" title="Day-n"></a>Day-n</h2><h3 id="大概情况"><a href="#大概情况" class="headerlink" title="大概情况"></a>大概情况</h3><p>学倒是学了很多东西，但<strong>漏洞颇多</strong>（很多遗忘、不会运用、看着题目转化不来），感觉是平日里划水划多了，练题练少了，但也就那样混过了CSP-S（考得跟shit一样），备战NOIP期间学了些数学知识，感觉难得一匹（<del>然而考都没考</del>），其它的事都忘得差不多了，但记得天天模拟测试，每天也就那样（感觉自己好佛系，但有点进步吧）</p><h3 id="印象较深的一天"><a href="#印象较深的一天" class="headerlink" title="印象较深的一天"></a>印象较深的一天</h3><p>有一天上上届的银牌巨佬<strong>lhj</strong>（<del>jklover</del>）来给我们又讲了讲数学（莫反、斯特林数……），感觉到后面高二的<strong>龙巨</strong>是唯一听懂他说话的人，平时常常听什么牛B的人的故事，最近的如重庆<strong>wdw</strong>高一就考上五道口职业技术学校（<del>清华</del>），但真正活生生的巨佬（听老师说他不仅竞赛强，高考还考了680+，清华发了通知书的，但专业不满意，复读一年）站在面前才感觉到强大</p><p>讲个冷笑话吧：<strong>wdw</strong>高一就被清华录取、<strong>lxl</strong>的毒瘤名扬luogu、<strong>lhj</strong>竞赛常规双强、<strong>我（Dyd）</strong>做完了青年大学习……我们都有<strong>光明的前途</strong></p><p>笑笑归笑笑，人活一辈子受苦受福都是自己的事，莫管别人如何厉害都玉女无瓜</p><p><strong>lhj</strong>巨佬给我们讲题时上了他的blog，感觉好厉害，自己也（<del>浪费了有一两天的时间</del>）从零开始搭了个（<del>特别拉垮的</del>）blog，好看是挺好看的，但 $LeTaX$ 太拉了，而且github的访问性过差，不是很想维护了，感觉Typora是yyds</p><h3 id="印象较深的一天2"><a href="#印象较深的一天2" class="headerlink" title="印象较深的一天2"></a>印象较深的一天2</h3><p>还有一天，遇到了下一届信息竞赛的人，里面有好多我们认识的，我还教了他们用VScode和firefox插件，机房里的<strong>wfy</strong>大佬还给他们讲了课（讲的Trie），<strong>wfy</strong>大佬说他感觉下一届的人不怎么强，我不是很了解，但作为不大不小的一个前辈，我衷心希望他们会比我们更强，毕竟后浪要推前浪，人类才会进步</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>然后就是复习了，花了较多时间复习<strong>dp</strong>，树上的、区间的等等（<del>然而后面就会知道一点用都没有</del>），网络流也看了看（因为CSP-S时机房里有人用网络流第四题拿了高分）</p><h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day-2"></a>Day-2</h2><p>考前两天，在luogu上AC300祭了，个人感觉要凉凉，因为我CSP-S考前也祭了个啥（具体忘了），结果CSP-S爆炸，A的是一道<strong>退火</strong>的紫题，由于第301题就是（<del>一道很水的</del>）黑题，所以很后悔没用黑题300祭，印象很深，心里有点忐忑，不过我和<strong>龙巨</strong>一起在玩一个很好玩的单机网页游戏，叫“膜拜Siyuan”，虽然就是点点点，但挺有意思的，<strong>龙巨</strong>给了我两个连点器，一个用C++写的（然而中文注释部分在运行时会乱码，不过不影响使用），还有一个用JavaScript写的（这个看不懂，但很好用），<strong>龙巨</strong>玩的比我晚，但凭着连点器和完美的策略，<strong>龙巨</strong>已经比我强了</p><p>除此之外，认真复习了一下<strong>线段树</strong>（<del>然而后面就会知道一点用都没有</del>）</p><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day-1"></a>Day-1</h2><p>考前一天，看了看考场，键盘是个痛，但适应了还好，考试时准备用虚拟机，所以没怎么看windows下的C++（**<del>埋下伏笔</del>**）</p><p>下午和晚上复习了模板，对着书把能想到的模板都过了一遍手（Tarjan打的有点急，不知对错，Dinic是第二天早上打的，当天来不及了），感觉自己图论和数学忘的差不多了，膜拜Siyuan没怎么管，开着连点器挂着的</p><p>机房<strong>张巨</strong>佬在luogu上发了个邀请面基的帖子，没想到真有（<del>除了我们机房以外的</del>）人回了，我们（<del>非常高素质的</del>）通过考号把别人人肉出来了，私信问他是不是xxx中学的xxx，他可能是有点怕，把帖子删了，但和我们机房某位大佬在私信里聊了起来，不知他们聊了什么</p><p>机房的<strong>龙巨</strong>把账号名改成了Tir_JK_LOVER，说是要延续<strong>lhj</strong>巨佬的名号，我本来也想改的，但好像改了就改不回来了（luogu的中文用户名据说绝版了），就没改</p><p>晚上走之前极限发了个rp++的帖子，标题叫“to add or not to add,it’s a problem”</p><h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><p>为了方便以负数代表考前，正数代表考试，所以考试这天是Day1</p><h3 id="考前"><a href="#考前" class="headerlink" title="考前"></a>考前</h3><p>上午打了昨天留下的Dinic模板，然后机房里就开始各自<strong>听歌</strong>，我听了《If We Have Each Other》（最多）、《Salt》、《Boy in the Bubble》和《Next of Kin》，感觉听了后心情挺好的，然后我们就奔赴考场了</p><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>T1看了一眼，第一反应是个类似与<strong>筛质数</strong>的水题，很快打好了，算了一下时间复杂度是 $O(n\log n)$ 一看 $n$ ，1e7，我没想到这个1e7有很多会跳过，<strong>根本跑不满</strong>，只觉得这不是完蛋了（考场上<strong>第一题还是很慌</strong>，毕竟上一次CSP-S也败在第一题上了），于是脑袋一蒙，竟然决定打一个1e7的表！（<del>我就完全没注意我的程序在打表的时候1e7的数据都跑的飞快</del>）好不容易打好了（中间还因为表太大虚拟机挂了一次，<strong>有点炸心态</strong>，为了这个表我打了一个超长的快读快输，不然输出太耗时了），一看代码<strong>3千多k</strong>，这不完蛋，我一看就打了个分段的代码， $O(n\log n)$ 去拿70分，剩下30分玄学（我真的觉的自己这个是脑袋有问题，不分段就能过了的）</p><h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>T2感觉是个<strong>dp</strong>，但那个数据范围太奇怪（我dp题见得少），只想到设<strong>二维</strong>，怎么搞怎么不对，推了5分钟跳了</p><p>T3一看没思路，感觉得暴力，就跳了</p><p>T4先一看：和CSP-S一样又是<strong>网格图</strong>，又是巨长无比的题面，简直离谱，读完题先想<strong>网络流</strong>，想不出来，看了一下数据范围就决定打暴力，但感觉暴力<strong>不好打</strong>（太长），就先去打T3</p><p>回到T3，看到序列变方式感觉像<strong>差分</strong>，一推发现变化 $a_x$ 就是把差分序列 $b_x$ 和 $b_{x + 1}$ 交换，马上来劲了，把差分带回去看能不能求方差，结果没搞出来，果断决定<strong>退火</strong>，大概就是求出差分序列，每次随机交换两个相邻的数，然后 $O(n)$ 求估价并更新答案，第一次只过了样例一，有点慌，怕打错，调了下<strong>精度</strong>过了样例二，感觉好多了，至少正确性是对的，只是精度和时间的问题罢了，又调精度，第三、四个样例要么WA（精度不够）要么TLE（精度太大），感觉遇到瓶颈了，决定去<strong>上个厕所</strong></p><p>回来以后<strong>心态好多了</strong>，开始认真<strong>优化退火</strong>，又鼓捣了不知多久的数学，发现答案就是 $sum2 * n - sum^2$ ，其中 $sum2$ 代表 ${a_i}$ 的平方和， $sum$ 代表 ${a_i}$ 的和，于是思考可否在退火时利用上一次的估价 $O(1)$ 求估价，发现对于同一个数连续操作两次其实就和没操作一样（交换两次就交换回来了），于是状态可以还原了，果断<strong>放弃差分数组</strong>，就对着原数组每次随机选一个数操作， $O(1)$ 估价，调了一下精度和退火次数，过了样例，但估价只能拿个40分的样子，看了数据范围发现 $a_i$ 有很多都<strong>相等</strong>，应该还可以优化，但我还有两题没有代码，不敢再多耗时间，就走了</p><h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>打完T3决定把剩下两题的<strong>暴力</strong>打了，看了看觉得T2的暴力<strong>好打</strong>点，就去打T2，最初想的 $m^n$ 枚举序列 ${a_i}$ ，用map来判重，直接暴力只能过样例一，感觉太悬了，看到样例解释，决定枚举 $S$ 暴力求 ${a_i}$ 中每个数有几个，用<strong>组合数</strong>统计答案，又随便调了一下，样例二太<strong>水</strong>了，竟然优化过了，也不想其他的，就去打T4</p><h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h3><p>打T4暴力的时候<strong>时间已经不多了</strong>，随便想了个暴力，看了看估计能有20 $\sim$ 30分吧，但没调好就有老师提醒说还有半个小时了，叫我们先<strong>检查</strong>一下，我也觉得有道理，毕竟考场上不敢赌博，就<strong>关了虚拟机</strong>去检查一下前面的freopen等等，打算检查完了用windows下的**devc++<strong>调试（</strong><del>伏笔回收</del>**）</p><p>检查完了，打开dev，一调试就<strong>闪退</strong>，连着两、三次，只好放弃调试，用**cout+exit(0)**的组合硬调（感觉再打开虚拟机来不及了），调出了 $opt = 0,1,2$ 的情况， $opt = 3$ 的情况来不及调就结束了，估计是没分了</p><h3 id="考后"><a href="#考后" class="headerlink" title="考后"></a>考后</h3><p>刚从考场出来感觉还行，和同机房的人聊了下情况，T1他们几乎都打的 $O(n\log n)$ ，<strong>wfy</strong>大佬拍着胸口说第一题<strong>不会太卡你</strong>的，我觉得有道理（当然事实证明是真的有道理），有点后悔，T3<strong>wfy</strong>和<strong>l18q</strong>也打的退火，但我们三个退思路的都不一样，感觉自己要凉凉，T4发现暴力的分比T2高，后悔没先打T4，T2好像只有<strong>wfy</strong>大佬打的dp，他说 $O(n^4m)$ 能过，我对这个复杂度想都没想过</p><p>中午出去吃了个汉堡，买了奶茶<strong>散了会儿步</strong>（我比较喜欢一个人散步），散完步心情很好，如释重负的感觉，就像一直被系着的麻雀突然发现绳子变长了一样（<del>奇妙比喻</del>）</p><p>下午和晚上和同学一起玩去了，主要是看番（钢炼09、杀手……）和打文明6（我们打了好久才干掉一个电脑），还行吧，收假就要回归常规了</p><h2 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h2><p>考后第二天，在luogu上自测，T1被分段卡的只有50分，比想象的还惨，T2暴力20分正常吧，T3退火退了44分，T4爆0，总分100来分吧，估价1=是无望了，明年再加油吧！</p><p>机房里最强的是<strong>wfy</strong>大佬，T1过了，T2也应该是过了（luogu上80，小灵通100），T3他的退火也接近满分（他是退差分数组，比我多推出来一个性质： ${b_i}$ 应该是先降后升，呈<strong>单谷型</strong>的），T4他暴力20 $\sim$ 40分，总分300+（<del>艹比我高200多</del>）</p><p>看了题解，T1是真的可惜，T2的dp我估计我是打不出来（dp学的太拉了，加油补吧），T3竟然也是dp，还巨难，要推很多性质和优化，T4是最离谱的，几乎把线段树用到了极致，可我连线段树都没想到</p><p>刚对下来还是有点<strong>失望</strong>，毕竟T1和T4不免有些可惜，但又一想，我犯了低级错误，别人就没犯吗?<strong>wfy</strong>大佬都犯了低价错误，不然T4还要高些分，犯这些错只说明我的<strong>水平还待提高</strong>罢了</p><p>还有一件让人伤心的事是高二的两位巨佬（<strong>龙巨</strong>和<strong>张巨</strong>）考完就<strong>AFO</strong>了，补完常规就分到别的班去了，虽然和两位巨佬相处不足一年，但他们还是<strong>很照顾我们这些后辈</strong>的，给了我们很多帮助，老实说，考完以后他们就早早离开了，还是很不舍的，祝愿他们能进入自己理想的大学吧</p><h2 id="废话"><a href="#废话" class="headerlink" title="废话"></a>废话</h2><p>写完游记感觉心情好多了，可能是因为我比较乐观吧</p><p>不管如何，生活的车轮只会自顾自的碾过时间，命运的道路永远是单向的，愿我们回首时无悔于所有自己做对的事和做错的事</p><p>2021/11/29 成绩出来了，50 + 20 + 56 + 0，一共126，估计是2=了，不过我早就看开了（<del>话说我也太没心没肺了吧</del>）</p><p><strong>the end</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
