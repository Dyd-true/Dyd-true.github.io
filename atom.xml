<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dyd&#39;s Blog</title>
  
  <subtitle>He who has a strong enough why can bear almost any how.</subtitle>
  <link href="https://dyd-true.github.io/atom.xml" rel="self"/>
  
  <link href="https://dyd-true.github.io/"/>
  <updated>2021-12-05T08:44:50.079Z</updated>
  <id>https://dyd-true.github.io/</id>
  
  <author>
    <name>Dyd</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Manacher</title>
    <link href="https://dyd-true.github.io/2021/12/05/Manacher/"/>
    <id>https://dyd-true.github.io/2021/12/05/Manacher/</id>
    <published>2021-12-05T07:34:27.000Z</published>
    <updated>2021-12-05T08:44:50.079Z</updated>
    
    <content type="html"><![CDATA[<p> 马拉车算法</p><span id="more"></span><h1 id="Manacher"><a href="#Manacher" class="headerlink" title="Manacher"></a>Manacher</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>Manacher算法是一中可以在  $O(n)$ 时间内求出最长回文子串的算法（以前的 $O(n \log n)$ hash+二分可以退役了）</p><p>在使用马拉车前，由于马拉车只能求<strong>长度为奇数</strong>的回文串，所有我们首先要有一个转换，把长度为偶数的回文串化为长度为奇数，具体方法为：</p><p>在字符串的头部插入开始符（一般为“\$”），在尾部插入结尾符（一般为“^”），然后每两个字符间都插入一个分隔符（一般为“#”），例如，字符串“abbcac”转化后就是“\$#a#b#b#c#a#c#^”，这样，就可以把原串的每一个回文串都化为一个“由#开头和结尾的长度为奇数的回文串”</p><p>然后，考虑如何求最大的长度为奇数的回文串</p><p>类似kmp我们扫描整个串，记 $p[i]$ 表示“以 $i$ 为中点的最长回文串的长度的一半（包括 $i$ ）”，考虑用已有的信息求出现在的 $p[i]$ </p><p><img src="https://s2.loli.net/2021/12/05/kiKbhwgSEDUZ7YJ.png" alt="马拉车"></p><p>如图，假设现在要求 $p[i]$ ，则  $p[1 \sim i - 1]$ 已知，定义一个回文串的位置为 $[l, r]$ ，则已知的最大的 $r$ 记为 $mr(maxright)$ ，其对应的回文串中点为 $mid$ ，则分类讨论：</p><ul><li><p> $i &gt; mr$ ，此时先令 $p[i] = 1$</p></li><li><p>$i \le mr$ 此时必有 $j = mid * 2 - i$ 与 $i$ 对应，再次分类：</p><ol><li> $p[j] \le mr - i + 1$ ，此时 $j$ 所在的最大回文串全部能和 $i$ 对应（图中蓝色部分），让 $p[i] = p[j]$</li><li> $p[j] &gt; mr - i + 1$ ，此时由于 $mr$ 右边的情况未知，故只能先让 $p[i] = mr - i + 1$ </li></ol></li></ul><p>由上，我们通过已有的信息计算出了“<strong>保证合法但不保证最大</strong>的情况下 $p[i]$ 的值”，其中没有保证最大的原因是 $mr$ 右边的情况不知道，若 $i$ 所在的最大回文串的右边界大于 $mr$ ，就无法统计，解决办法是——暴力！对于分类讨论得到的 $p[i]$ ，我们暴力尝试让它加1，直到不行为止</p><p>最后统计答案时，由于 $p[i]$ 只是长度的一半应该要乘二，但由于我们把原串扩充了一倍，所以实际答案就是 $\max_{i = 1}^{n}(p[i] - 1)$ </p><p>需要注意的是，在具体的代码实现中，常常让 $mr = mr + 1$ ，换句话说，以 $mid$ 为中心的最大回文串不是 $[l, r]$ ，而是 $[l, r)$ ，上面讲成闭区间只是为了方便理解</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://www.luogu.com.cn/problem/P3805">【模板】manacher 算法</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1.1e7</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> a[N], b[N &lt;&lt; <span class="number">1</span>];  <span class="comment">//二倍</span></span><br><span class="line"><span class="keyword">int</span> p[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">b[++k] = <span class="string">&#x27;$&#x27;</span>, b[++k] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">b[++k] = a[i], b[++k] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">b[++k] = <span class="string">&#x27;^&#x27;</span>;</span><br><span class="line">n = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manacher</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mr = <span class="number">0</span>, mid;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; mr)</span><br><span class="line">p[i] = <span class="built_in">min</span>(p[mid * <span class="number">2</span> - i], mr - i);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">p[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (b[i - p[i]] == b[i + p[i]])</span><br><span class="line">++p[i];</span><br><span class="line"><span class="keyword">if</span> (i + p[i] &gt; mr)</span><br><span class="line">mr = i + p[i], mid = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, a + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">n = <span class="built_in">strlen</span>(a + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="built_in">manacher</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">ans = <span class="built_in">max</span>(ans, p[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>和kmp一样，马拉车的两个循环也是“假的”，简证：</p><p>首先，如果 $i$ 所在的最大回文串 $[l, r]$ 的右断点 $r \le mr$ ，while只会执行一次，因为如果此时 $p[i]$ 一定是与 $p[j]$ 对于的，若还可以加1，这与 $p[j]$ 的“最大”矛盾</p><p>其次，若 $r &gt; mr$ ，则一定会跟新 $mr$ ，而 $mr$ 明显是不下降的，当 $mr = n$ 时，就不可能再有 $r &gt; mr$ 了，换句话说， $mr$ 最多遍历一次 $n$ ，之后就不会再跟新 $mr$ 也就不会再有 $r &gt; mr$ 了</p><p>综上，马拉车的时间复杂度为 $O(n)$ </p>]]></content>
    
    
    <summary type="html">&lt;p&gt; 马拉车算法&lt;/p&gt;</summary>
    
    
    
    
    <category term="字符串" scheme="https://dyd-true.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="回文串" scheme="https://dyd-true.github.io/tags/%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    
    <category term="Manacher" scheme="https://dyd-true.github.io/tags/Manacher/"/>
    
  </entry>
  
  <entry>
    <title>启发式合并</title>
    <link href="https://dyd-true.github.io/2021/12/05/%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"/>
    <id>https://dyd-true.github.io/2021/12/05/%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/</id>
    <published>2021-12-05T06:27:53.000Z</published>
    <updated>2021-12-05T08:48:44.563Z</updated>
    
    <content type="html"><![CDATA[<p> 聪明的合并</p><span id="more"></span><h1 id="启发式合并"><a href="#启发式合并" class="headerlink" title="启发式合并"></a>启发式合并</h1><p>其实我们很早就接触过启发式合并了，比如并查集的<strong>按秩合并</strong>就是一种启发式合并（<del>虽然基本没用过</del>），但还是单独提一提</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在解决问题时，我们常常要用到“合并”操作，而该操作是<strong>可以</strong>满足<strong>交换律</strong>的（即可以把 $a$ 合并到 $b$ 里面，也可以把 $b$ 合并到 $a$ 里面），这个时候我们可以通过一些额外的信息（如安秩合并中的秩）来决定合并的顺序，从而降低时间复杂度</p><h2 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h2><p><a href="https://www.luogu.com.cn/problem/P3201">[HNOI2009] 梦幻布丁</a></p><p>对于每种颜色，用一个集合维护其下标，每次操作就是<strong>合并两个集合</strong>，合并完后颜色的段数是<strong>不会增加</strong>的，考虑如何维护段数，设合并颜色 $a$ 和颜色 $b$ ，枚举颜色 $a$ 的所有下标，若它左右的颜色中有  $x(0 \le x \le 2)$ 个颜色是 $b$ ，就让段数减 $x$ </p><p>不难发现暴力合并时间复杂度为 $O(mn)$ ，无法接受，考虑启发式合并，每次让小的集合合并到大的集合中</p><p>要用启发式合并，我们首先要解决一个问题：合并操作是满足交换律的吗？当然没有那么简单，由于操作是“把颜色 $a$ 变成颜色 $b$ ”，交换就成了“把颜色 $b$ 变成颜色 $a$ ”，当然不行</p><p>但是可以通过转化让其满足交换律吗？考虑用链表存储集合，那么只需要将表头映射一下，交换一下颜色即可，总的时间复杂度期望为 $O(n \log n)$ （<del>然而可以被hack，但可以过题</del>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, A = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[A], idx;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ne, ver;</span><br><span class="line">&#125; e[N];</span><br><span class="line"><span class="keyword">int</span> c[N], si[A], p[A];</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx] = (Edge)&#123;h[x], y&#125;, h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == y)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (si[x] &gt; si[y])</span><br><span class="line"><span class="built_in">swap</span>(x, y);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], z; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">z = e[i].ver;</span><br><span class="line">ans -= (c[z + <span class="number">1</span>] == y) + (c[z - <span class="number">1</span>] == y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], z; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">c[e[i].ver] = y;</span><br><span class="line"><span class="keyword">if</span> (e[i].ne == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">e[i].ne = h[y], h[y] = h[x];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">si[y] += si[x];</span><br><span class="line">h[x] = <span class="number">-1</span>, si[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A; ++i)</span><br><span class="line">h[i] = <span class="number">-1</span>, p[i] = i;</span><br><span class="line">idx = ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i]);</span><br><span class="line"><span class="keyword">if</span> (c[i] != c[i - <span class="number">1</span>])</span><br><span class="line">++ans;</span><br><span class="line"><span class="built_in">add</span>(c[i], i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> op, x, y;</span><br><span class="line"><span class="keyword">while</span> (m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line"><span class="keyword">if</span> (op == <span class="number">2</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line"><span class="built_in">merge</span>(p[x], p[y]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h2><p><a href="https://www.luogu.com.cn/problem/CF600E">Lomsat gelral</a></p><p>其实是一道树上并查集，类似树链剖分找出重儿子，暴力计算每一棵子树，但最后再计算重儿子，这样可以把重儿子的信息保留下来，下一次用的时候就不必再算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> h[N], idx;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ne, ver;</span><br><span class="line">&#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> c[N], cnt[N], mx;</span><br><span class="line">LL ans[N], sum;</span><br><span class="line"><span class="keyword">int</span> si[N], h_son[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx] = (Edge)&#123;h[x], y&#125;, h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">si[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (y == fa)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs1</span>(y, x);</span><br><span class="line">si[x] += si[y];</span><br><span class="line"><span class="keyword">if</span> (si[y] &gt; si[h_son[x]])</span><br><span class="line">h_son[x] = y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> dt, <span class="keyword">int</span> pass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> _c = c[x];</span><br><span class="line">cnt[_c] += dt;</span><br><span class="line"><span class="keyword">if</span> (cnt[_c] &gt; mx)</span><br><span class="line">mx = cnt[_c], sum = _c;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cnt[_c] == mx)</span><br><span class="line">sum += _c;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (y == fa || y == pass)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">update</span>(y, x, dt, pass);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (y == fa || y == h_son[x])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs</span>(y, x, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (h_son[x])</span><br><span class="line"><span class="built_in">dfs</span>(h_son[x], x, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">update</span>(x, fa, <span class="number">1</span>, h_son[x]);</span><br><span class="line">ans[x] = sum;</span><br><span class="line"><span class="keyword">if</span> (!op)</span><br><span class="line"><span class="built_in">update</span>(x, fa, <span class="number">-1</span>, <span class="number">0</span>), mx = sum = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">h[i] = <span class="number">-1</span>;</span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line"><span class="built_in">add</span>(u, v), <span class="built_in">add</span>(v, u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 聪明的合并&lt;/p&gt;</summary>
    
    
    
    
    <category term="树" scheme="https://dyd-true.github.io/tags/%E6%A0%91/"/>
    
    <category term="并查集" scheme="https://dyd-true.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="启发式合并" scheme="https://dyd-true.github.io/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"/>
    
  </entry>
  
  <entry>
    <title>点分治</title>
    <link href="https://dyd-true.github.io/2021/12/05/%E7%82%B9%E5%88%86%E6%B2%BB/"/>
    <id>https://dyd-true.github.io/2021/12/05/%E7%82%B9%E5%88%86%E6%B2%BB/</id>
    <published>2021-12-05T00:17:35.000Z</published>
    <updated>2021-12-06T09:21:05.671Z</updated>
    
    <content type="html"><![CDATA[<p> 连分治也变得难了起来……</p><span id="more"></span><h1 id="点分治"><a href="#点分治" class="headerlink" title="点分治"></a>点分治</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>点分治是<strong>树上分治</strong>的种常用方法，主要思想是每次在树上选一个点，将整棵树的问题划分为两类（如图）：三角形的子树内问题和过了点跨子树的问题</p><p><img src="https://s2.loli.net/2021/12/05/mJCZwSPnvaE3W4K.png" alt="点和子树"></p><p>然后每个子树也这样划分，这个点每次取<strong>重心</strong>，可以保证最多划分 $\log n$ 层</p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p><a href="https://www.acwing.com/problem/content/254/">树</a></p><p>题意非常简单：求树上距离不超过 $k$ 的点对数量，点分治的思路也非常简单，每次选重心（记选的节点为 $c$ ），分三类：</p><ol><li>对于两个点都在同一子树内部的情况，递归处理</li><li>对于有一个点恰好是 $c$ 的情况，直接dfs求</li><li>对于跨子树的情况，可以先求出每棵子树内每个点到 $c$ 的距离，然后对于所有距离，记录任选两个距离和小于等于 $k$ 的情况，再删掉同一棵子树内两个点距离和小于等于 $k$ 的情况即可，而求解“一个集合内任取两个数和小于等于 $k$ 的方案数”可以用排序后双指针来解决（也可以排序后二分，麻烦点）</li></ol><p>考虑时间复杂度，最多有 $\log n$ 层，每层 $n$ 个点都要排序，一共是 $O(n \log^2 n)$ </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ne, ver, w;</span><br><span class="line">&#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> h[N], idx;</span><br><span class="line"><span class="keyword">bool</span> del[N];</span><br><span class="line"><span class="keyword">int</span> p[N], q[N], cp, cq;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx] = (Edge)&#123;h[x], y, z&#125;, h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_si</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x])</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line"><span class="keyword">if</span> (e[i].ver != fa)</span><br><span class="line">res += <span class="built_in">get_si</span>(e[i].ver, x);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_wc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> si, <span class="keyword">int</span> &amp;wc)</span> <span class="comment">// 求重心(其实是一个保证删去后子树大小小于n/2的点,不一定是重心)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x])</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">1</span>, mx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y, t; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (y == fa)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">t = <span class="built_in">get_wc</span>(y, x, si, wc);</span><br><span class="line">mx = <span class="built_in">max</span>(mx, t);</span><br><span class="line">sum += t;</span><br><span class="line">&#125;</span><br><span class="line">mx = <span class="built_in">max</span>(mx, si - sum);</span><br><span class="line"><span class="keyword">if</span> (mx &lt;= si / <span class="number">2</span>)</span><br><span class="line">wc = x;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_dis</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> dis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x])</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">q[++cq] = dis;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line"><span class="keyword">if</span> (e[i].ver != fa)</span><br><span class="line"><span class="built_in">get_dis</span>(e[i].ver, x, dis + e[i].w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> c)</span> <span class="comment">//计算集合a中有多少对相加不大于k</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + c);</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = c, j = <span class="number">0</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (j + <span class="number">1</span> &lt; i &amp;&amp; a[j + <span class="number">1</span>] + a[i] &lt;= k)</span><br><span class="line">++j;</span><br><span class="line">j = <span class="built_in">min</span>(j, i - <span class="number">1</span>);</span><br><span class="line">res += j + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x])</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">get_wc</span>(x, <span class="number">-1</span>, <span class="built_in">get_si</span>(x, <span class="number">-1</span>), x);</span><br><span class="line">del[x] = <span class="literal">true</span>;</span><br><span class="line">cp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line">cq = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">get_dis</span>(y, <span class="number">-1</span>, e[i].w);</span><br><span class="line">res -= <span class="built_in">work</span>(q, cq);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cq; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (q[j] &lt;= k)</span><br><span class="line">++res;</span><br><span class="line">p[++cp] = q[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">res += <span class="built_in">work</span>(p, cp);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">res += <span class="built_in">calc</span>(e[i].ver);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k), n || k)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">h[i] = <span class="number">-1</span>, del[i] = <span class="literal">false</span>;;</span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, w; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line"><span class="built_in">add</span>(u + <span class="number">1</span>, v + <span class="number">1</span>, w), <span class="built_in">add</span>(v + <span class="number">1</span>, u + <span class="number">1</span>, w); <span class="comment">//输入的下标是从0开始的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">calc</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.acwing.com/problem/content/266/">权值</a></p><p>类似于模板，看注释吧，时间复杂度 $O(n \log n)$ ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>, S = <span class="number">1e6</span> + <span class="number">5</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, ans = INF;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ne, ver, w;</span><br><span class="line">&#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> dis, num;</span><br><span class="line">&#125; p[N], q[N];</span><br><span class="line"><span class="keyword">int</span> h[N], idx;</span><br><span class="line"><span class="keyword">bool</span> del[N];</span><br><span class="line"><span class="keyword">int</span> cp, cq;</span><br><span class="line"><span class="keyword">int</span> b[S]; <span class="comment">//开一个桶记录到重心距离为i的点的最小边数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx] = (Edge)&#123;h[x], y, z&#125;, h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_si</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x])</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line"><span class="keyword">if</span> (e[i].ver != fa)</span><br><span class="line">res += <span class="built_in">get_si</span>(e[i].ver, x);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_wc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> si, <span class="keyword">int</span> &amp;wc)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x])</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">1</span>, mx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y, t; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (y == fa)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">t = <span class="built_in">get_wc</span>(y, x, si, wc);</span><br><span class="line">mx = <span class="built_in">max</span>(mx, t);</span><br><span class="line">sum += t;</span><br><span class="line">&#125;</span><br><span class="line">mx = <span class="built_in">max</span>(mx, si - sum);</span><br><span class="line"><span class="keyword">if</span> (mx &lt;= si / <span class="number">2</span>)</span><br><span class="line">wc = x;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_dis</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> dis, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x] || dis &gt; k)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">q[++cq] = (Node)&#123;dis, num&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line"><span class="keyword">if</span> (e[i].ver != fa)</span><br><span class="line"><span class="built_in">get_dis</span>(e[i].ver, x, dis + e[i].w, num + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x])</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"><span class="built_in">get_wc</span>(x, <span class="number">-1</span>, <span class="built_in">get_si</span>(x, <span class="number">-1</span>), x);</span><br><span class="line">del[x] = <span class="literal">true</span>;</span><br><span class="line">cp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line">cq = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">get_dis</span>(y, x, e[i].w, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cq; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (q[j].dis == k)</span><br><span class="line">ans = <span class="built_in">min</span>(ans, q[j].num);</span><br><span class="line">ans = <span class="built_in">min</span>(ans, b[k - q[j].dis] + q[j].num);</span><br><span class="line">p[++cp] = q[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cq; ++j)</span><br><span class="line">b[q[j].dis] = <span class="built_in">min</span>(b[q[j].dis], q[j].num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cp; ++j) <span class="comment">//将桶清空</span></span><br><span class="line">b[p[j].dis] = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line"><span class="built_in">calc</span>(e[i].ver);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">h[i] = <span class="number">-1</span>;</span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; ++i)</span><br><span class="line">    b[i] = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, w; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line"><span class="built_in">add</span>(u + <span class="number">1</span>, v + <span class="number">1</span>, w), <span class="built_in">add</span>(v + <span class="number">1</span>, u + <span class="number">1</span>, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">calc</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (ans == INF)</span><br><span class="line">ans = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P3806">【模板】点分治1</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>, K = <span class="number">1e7</span> + <span class="number">5</span>, M = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ne, ver, w;</span><br><span class="line">&#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> h[N], idx;</span><br><span class="line"><span class="keyword">bool</span> del[N];</span><br><span class="line"><span class="keyword">int</span> p[N], q[N], o[N], cp, cq, co;</span><br><span class="line">list&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line"><span class="keyword">int</span> _Q[M];</span><br><span class="line"><span class="keyword">bool</span> b[K], ans[K];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx] = (Edge)&#123;h[x], y, z&#125;, h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_si</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x])</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line"><span class="keyword">if</span> (e[i].ver != fa)</span><br><span class="line">res += <span class="built_in">get_si</span>(e[i].ver, x);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_wc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> si, <span class="keyword">int</span> &amp;wc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x])</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">1</span>, mx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y, t; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (y == fa)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">t = <span class="built_in">get_wc</span>(y, x, si, wc);</span><br><span class="line">mx = <span class="built_in">max</span>(mx, t);</span><br><span class="line">sum += t;</span><br><span class="line">&#125;</span><br><span class="line">mx = <span class="built_in">max</span>(mx, si - sum);</span><br><span class="line"><span class="keyword">if</span> (mx &lt;= si / <span class="number">2</span>)</span><br><span class="line">wc = x;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_dis</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> dis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x] || dis &gt; K)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">q[++cq] = dis;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line"><span class="keyword">if</span> (e[i].ver != fa)</span><br><span class="line"><span class="built_in">get_dis</span>(e[i].ver, x, dis + e[i].w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x])</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">get_wc</span>(x, <span class="number">-1</span>, <span class="built_in">get_si</span>(x, <span class="number">-1</span>), x);</span><br><span class="line">del[x] = <span class="literal">true</span>;</span><br><span class="line">cp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line">cq = co = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">get_dis</span>(y, <span class="number">-1</span>, e[i].w);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cq; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r : Q)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (q[j] == r)</span><br><span class="line">ans[r] = <span class="literal">true</span>, o[++co] = r;</span><br><span class="line"><span class="keyword">if</span> (r &gt;= q[j] &amp;&amp; b[r - q[j]])</span><br><span class="line">ans[r] = <span class="literal">true</span>, o[++co] = r;</span><br><span class="line">&#125;</span><br><span class="line">p[++cp] = q[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cq; ++j)</span><br><span class="line">b[q[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= co; ++j)</span><br><span class="line">Q.<span class="built_in">remove</span>(o[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cp; ++j)</span><br><span class="line">b[p[j]] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line"><span class="built_in">calc</span>(e[i].ver);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">h[i] = <span class="number">-1</span>;</span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, w; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line"><span class="built_in">add</span>(u, v, w), <span class="built_in">add</span>(v, u, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;_Q[i]);</span><br><span class="line">Q.<span class="built_in">push_back</span>(_Q[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">calc</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line"><span class="keyword">if</span> (ans[_Q[i]])</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;AYE\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NAY\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态点分治（点分树）"><a href="#动态点分治（点分树）" class="headerlink" title="动态点分治（点分树）"></a>动态点分治（点分树）</h2><p>还是先看模板题<a href="https://www.luogu.com.cn/problem/P3241">[HNOI2015]开店</a></p><p>既然叫点分树了，当然是要建一棵树，而这棵树要保证<strong>每一棵子树的根节点就是该子树的重心</strong></p><p>建好树后，考虑如何解决询问，不难发现，一个节点 $u$ 最多属于 $\log n$ 棵子树，不妨设当前子树根节点为 $r$ ：</p><ol><li>若  $r \ne u$ ，考虑形如 $u \rightarrow r \rightarrow v$  的路径有多少个，计入答案，然后进入  $u$ 所在子树递归</li><li>若 $u = r$ ，遍历当前子树所有点，计入答案，然后停止递归</li></ol><p>由于每个点的度不大于3，直接在每个重心上开三个vector，记录每个子树的所有年龄和它到重心的距离，排好序后前缀和+二分即可，总的空间复杂度为 $O(n \log n)$ 时间复杂度为 $O(m \log^2 n)$ ， $m$ 是询问的数量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VS vector<span class="meta-string">&lt;Son&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1.5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, A;</span><br><span class="line"><span class="keyword">int</span> h[N], idx;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ne, ver, w;</span><br><span class="line">&#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Father</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x, id;</span><br><span class="line">LL dis;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Son</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">LL dis;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Son &amp;t) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> age &lt; t.age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Father&gt; f[N];</span><br><span class="line">VS s[N][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">bool</span> del[N];</span><br><span class="line"><span class="keyword">int</span> age[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx] = (Edge)&#123;h[x], y, z&#125;, h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_si</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x])</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line"><span class="keyword">if</span> (e[i].ver != fa)</span><br><span class="line">res += <span class="built_in">get_si</span>(e[i].ver, x);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_wc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> si, <span class="keyword">int</span> &amp;wc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x])</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">1</span>, mx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], t; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (e[i].ver == fa)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">t = <span class="built_in">get_wc</span>(e[i].ver, x, si, wc);</span><br><span class="line">mx = <span class="built_in">max</span>(mx, t);</span><br><span class="line">sum += t;</span><br><span class="line">&#125;</span><br><span class="line">mx = <span class="built_in">max</span>(mx, si - sum);</span><br><span class="line"><span class="keyword">if</span> (mx &lt;= si / <span class="number">2</span>)</span><br><span class="line">wc = x;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_dis</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, LL dis, <span class="keyword">int</span> wc, <span class="keyword">int</span> k, VS &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x])</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">f[x].<span class="built_in">push_back</span>((Father)&#123;wc, k, dis&#125;);</span><br><span class="line">p.<span class="built_in">push_back</span>((Son)&#123;age[x], dis&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], t; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line"><span class="keyword">if</span> (e[i].ver != fa)</span><br><span class="line"><span class="built_in">get_dis</span>(e[i].ver, x, dis + e[i].w, wc, k, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x])</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">get_wc</span>(x, <span class="number">-1</span>, <span class="built_in">get_si</span>(x, <span class="number">-1</span>), x);</span><br><span class="line">del[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y, k = <span class="number">0</span>; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (del[y])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">VS &amp;p = s[x][k];</span><br><span class="line">p.<span class="built_in">push_back</span>((Son)&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;), p.<span class="built_in">push_back</span>((Son)&#123;A + <span class="number">1</span>, <span class="number">0</span>&#125;); <span class="comment">//哨兵</span></span><br><span class="line"><span class="built_in">get_dis</span>(y, <span class="number">-1</span>, e[i].w, x, k, p);</span><br><span class="line"><span class="built_in">sort</span>(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; p.<span class="built_in">size</span>(); ++i)</span><br><span class="line">p[i].dis += p[i - <span class="number">1</span>].dis;</span><br><span class="line">++k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line"><span class="built_in">calc</span>(e[i].ver);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Father &amp;i : f[x])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> g = age[i.x];</span><br><span class="line"><span class="keyword">if</span> (g &gt;= l &amp;&amp; g &lt;= r)</span><br><span class="line">res += i.dis;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j == i.id)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">VS &amp;p = s[i.x][j];</span><br><span class="line"><span class="keyword">if</span> (p.<span class="built_in">empty</span>())</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> a = <span class="built_in">lower_bound</span>(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), (Son)&#123;l, <span class="number">-1</span>&#125;) - p.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">int</span> b = <span class="built_in">lower_bound</span>(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), (Son)&#123;r + <span class="number">1</span>, <span class="number">-1</span>&#125;) - p.<span class="built_in">begin</span>();</span><br><span class="line">res += i.dis * (b - a) + p[b - <span class="number">1</span>].dis - p[a - <span class="number">1</span>].dis;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">VS &amp;p = s[x][i];</span><br><span class="line"><span class="keyword">if</span> (p.<span class="built_in">empty</span>())</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> a = <span class="built_in">lower_bound</span>(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), (Son)&#123;l, <span class="number">-1</span>&#125;) - p.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">int</span> b = <span class="built_in">lower_bound</span>(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), (Son)&#123;r + <span class="number">1</span>, <span class="number">-1</span>&#125;) - p.<span class="built_in">begin</span>();</span><br><span class="line">res += p[b - <span class="number">1</span>].dis - p[a - <span class="number">1</span>].dis;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;A);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">h[i] = <span class="number">-1</span>;</span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;age[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, w; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line"><span class="built_in">add</span>(u, v, w), <span class="built_in">add</span>(v, u, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">calc</span>(<span class="number">1</span>);</span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> u, a, b, l, r;</span><br><span class="line"><span class="keyword">while</span> (m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;a, &amp;b);</span><br><span class="line">l = (a + ans) % A, r = (b + ans) % A;</span><br><span class="line"><span class="keyword">if</span> (l &gt; r)</span><br><span class="line"><span class="built_in">swap</span>(l, r);</span><br><span class="line">ans = <span class="built_in">ask</span>(u, l, r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 连分治也变得难了起来……&lt;/p&gt;</summary>
    
    
    
    
    <category term="分治" scheme="https://dyd-true.github.io/tags/%E5%88%86%E6%B2%BB/"/>
    
    <category term="树" scheme="https://dyd-true.github.io/tags/%E6%A0%91/"/>
    
    <category term="dfs" scheme="https://dyd-true.github.io/tags/dfs/"/>
    
    <category term="点分治" scheme="https://dyd-true.github.io/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"/>
    
    <category term="点分树" scheme="https://dyd-true.github.io/tags/%E7%82%B9%E5%88%86%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>kmp和hash（讲）</title>
    <link href="https://dyd-true.github.io/2021/12/03/kmp%E5%92%8Chash%EF%BC%88%E8%AE%B2%EF%BC%89/"/>
    <id>https://dyd-true.github.io/2021/12/03/kmp%E5%92%8Chash%EF%BC%88%E8%AE%B2%EF%BC%89/</id>
    <published>2021-12-03T03:22:20.000Z</published>
    <updated>2021-12-03T04:05:33.024Z</updated>
    
    <content type="html"><![CDATA[<p>​    water</p><span id="more"></span><p>临时准备一下，有点水，就只是当一个提纲用，主要听我讲吧</p><h2 id="前置芝士"><a href="#前置芝士" class="headerlink" title="前置芝士"></a>前置芝士</h2><ul><li><p><a href="https://baike.baidu.com/item/Hash/390310">hash的定义</a>（只要定义即可）</p></li><li><p>char数组存储并使用字符串，尽可能不要使用string，<del>但如果实在没办法就用吧</del></p><p>原因：string的值是不可变的，这就导致每次对string的操作都会生成新的string对象，不仅效率低下，而且大量浪费有限的内存空间，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string a = <span class="string">&quot;1&quot;</span>;  <span class="comment">//假设a指向地址0x0001</span></span><br><span class="line">a = <span class="string">&quot;2&quot;</span>; <span class="comment">//重新赋值后a指向地址0x0002,0x0001地址中保存的&quot;1&quot;依旧存在,但已经不再是a所指向的,a已经指向了其它地址</span></span><br></pre></td></tr></table></figure><p>重新赋值并没有改变地址中保存的”1”，而是直接再申请空间，因此string的操作都是改变赋值地址而不是改变值操作，类似的还有string在函数传参时浪费的空间，并且，时间上讲，string比vector和char都慢</p></li><li><p>一定的抽象思维（我会尽力讲的形象一定）</p></li></ul><p>不管如何，看下去吧</p><h2 id="字符串hash"><a href="#字符串hash" class="headerlink" title="字符串hash"></a>字符串hash</h2><ul><li><p>为何使用</p></li><li><p>正确性如何保证</p></li><li><p>具体如何实现（<a href="https://www.luogu.com.cn/problem/P3370">【模板】字符串哈希</a>）</p></li><li><p> $O(n\log n)$ 最长回文串（没有模板题，看代码吧，重点理解p数组的含义）</p></li></ul>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ULL unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IL inline</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1.1e7</span> + <span class="number">5</span>, H = <span class="number">131</span>;</span><br><span class="line">ULL ha[N], ah[N], p[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function">IL ULL <span class="title">get_ha</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ha[r] - ha[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL ULL <span class="title">get_ah</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ah[l] - ah[r + <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="built_in">min</span>(x - <span class="number">1</span>, n - x), mid, res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line">mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">get_ha</span>(x, x + mid) == <span class="built_in">get_ah</span>(x - mid, x))</span><br><span class="line">&#123;</span><br><span class="line">res = mid;</span><br><span class="line">l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="built_in">min</span>(x - <span class="number">1</span>, n - y), mid, res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line">mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">get_ha</span>(y, y + mid) == <span class="built_in">get_ah</span>(x - mid, x))</span><br><span class="line">&#123;</span><br><span class="line">res = mid;</span><br><span class="line">l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">ha[i] = ha[i - <span class="number">1</span>] * H + s[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">p[i] = p[i - <span class="number">1</span>] * H;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">ah[i] = ah[i + <span class="number">1</span>] * H + s[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">ans = <span class="built_in">max</span>(ans, <span class="built_in">find</span>(i) * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (s[i] == s[i + <span class="number">1</span>])</span><br><span class="line">ans = <span class="built_in">max</span>(ans, <span class="built_in">find</span>(i, i + <span class="number">1</span>) * <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其它应用</li></ul><h2 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a>kmp</h2><ul><li><p>思想：利用已有信息减少枚举</p></li><li><p>实现：ne数组（别取next），重点理解其图形意义和其抽象定义的关系</p><p>对图理解：<img src="https://i.loli.net/2021/12/03/t2A3eYZLdJCqsu6.png" alt="kmp"></p></li><li><p>代码：<a href="https://www.luogu.com.cn/problem/P3375">【模板】KMP字符串匹配</a></p></li><li><p>应用：字符串问题、辅助dp（有点难，不要去掌握）</p></li></ul><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>AC自动机（有blog）、Z函数</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    water&lt;/p&gt;</summary>
    
    
    
    
    <category term="字符串" scheme="https://dyd-true.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="hash" scheme="https://dyd-true.github.io/tags/hash/"/>
    
    <category term="kmp" scheme="https://dyd-true.github.io/tags/kmp/"/>
    
    <category term="备讲" scheme="https://dyd-true.github.io/tags/%E5%A4%87%E8%AE%B2/"/>
    
  </entry>
  
  <entry>
    <title>luoguP4558 [JSOI2018]机器人</title>
    <link href="https://dyd-true.github.io/2021/12/02/luoguP4558-JSOI2018-%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    <id>https://dyd-true.github.io/2021/12/02/luoguP4558-JSOI2018-%E6%9C%BA%E5%99%A8%E4%BA%BA/</id>
    <published>2021-12-02T11:38:39.000Z</published>
    <updated>2021-12-05T01:17:48.680Z</updated>
    
    <content type="html"><![CDATA[<p> 我以为很好打……</p><span id="more"></span><p>一道很难的题，但可以骗点分</p><p>首先第一眼看过去就是dp， $n, m \le 50$ 说明dp并不简单，但看数据范围，反正我是想打分段骗分</p><h2 id="数据1"><a href="#数据1" class="headerlink" title="数据1"></a>数据1</h2><p> $n, m \le 4$ 直接dfs，注意题目求的是<strong>扫地机器人在撞上障碍之前，经过了多少个格子</strong>，换句话说，没撞上障碍，贡献是0</p><p>20分到手</p><h2 id="数据2"><a href="#数据2" class="headerlink" title="数据2"></a>数据2</h2><h3 id="打表"><a href="#打表" class="headerlink" title="打表"></a>打表</h3><p>除了起点外所有格子都是障碍，明显答案就是所有的方案都输入到了扫地机器人里，但 $n, m \le 50$ ，暴力求所有的方案数时间复杂度和数据1是一样的，但是，通过上面的暴力程序打个小表（把dfs能跑出来的全打了）来<strong>找规律</strong>，发现对于 $n, m$ （不妨设 $n \le m$ ），若 $n \mid m$ ，有如下表：</p><table><thead><tr><th align="center">n</th><th align="center">m</th><th align="center">Ans</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">1</td><td align="center">2</td><td align="center">1</td></tr><tr><td align="center">1</td><td align="center">3</td><td align="center">1</td></tr><tr><td align="center">2</td><td align="center">2</td><td align="center">2</td></tr><tr><td align="center">2</td><td align="center">4</td><td align="center">2</td></tr><tr><td align="center">2</td><td align="center">6</td><td align="center">2</td></tr><tr><td align="center">3</td><td align="center">3</td><td align="center">6</td></tr><tr><td align="center">3</td><td align="center">6</td><td align="center">3</td></tr><tr><td align="center">3</td><td align="center">9</td><td align="center">6</td></tr><tr><td align="center">3</td><td align="center">12</td><td align="center">3</td></tr><tr><td align="center">4</td><td align="center">4</td><td align="center">8</td></tr><tr><td align="center">4</td><td align="center">8</td><td align="center">8</td></tr><tr><td align="center">4</td><td align="center">12</td><td align="center">4</td></tr></tbody></table><p>而若 $n \not\mid m$ ，答案为0，找一手规律，信心满满交上去，WA了</p><p> 好吧，看来没有想象的简单，我们发现我们枚举的数都太小了，它们的<strong>合数</strong>只有4，而且4还没枚举完，但这已经提示我们<strong>和gcd或者互质</strong>有关系</p><h3 id="性质1"><a href="#性质1" class="headerlink" title="性质1"></a>性质1</h3><p>再认真看看打出来的表，以及对应的合法方案数</p><p>发现一个性质：对于一个点 $(x, y)$ ，若它走向 $(x + 1, y)$ ，则 $(x, y + 1)$ ，一定是由 $(x - 1, y + 1)$ 走来；同样的，若它走向 $(x, y + 1)$ ，则 $(x + 1, y)$ ，一定是由 $(x + 1, y - 1)$ 走来，正确性显然</p><p>参考下图：</p><p><img src="https://i.loli.net/2021/12/02/ka14GUhuOMKz9Jf.png" alt="对角线"></p><p>若红点向下，则黄点一定是由紫色向下走到（因为红点已经不可能再向右了），绿、蓝、粉点同理，换句话说，红、紫（绿、粉）点的方向一定相同</p><p>再参考样例：</p><p><img src="https://i.loli.net/2021/12/02/oI9YTryJAwOt1G2.png" alt="样例"></p><p>推广到整个图：<strong>一个矩形内任意一条从右上到左下的对角线方向相同</strong>，其中“一条从右上到左下的对角线”是包含了循环的，如图，颜色相同的是“一条对角线”</p><p><img src="https://i.loli.net/2021/12/02/fBTEp2Oxqkjl5uo.png" alt="对角线2"></p><p>这也和我们上面打的表相符合</p><h3 id="性质2"><a href="#性质2" class="headerlink" title="性质2"></a>性质2</h3><p>由于一个点左下和右下的元素属于同一对角线，所以我们下一步无论怎么走都会走到同一个对角线上，则下一步的方向已经确定，推广一下：<strong>机器人的动作自然就是循环的</strong></p><p>循环节很好求，就是看走多少部可以回到原对角线，手玩一下发现是 $gcd(n, m)$ ，这也和打表的猜测相符合</p><p>证明的话（<del>听大佬说是</del>）把这个矩阵复制几份拼在一起，如果循环节不是 $gcd(n, m)$ 那么在两个矩形的交界出会出现副对角线颜色不同的情况，而循环节是 $gcd(n, m)$ 的时候相当于一堆正方形拼在一起自然不会出现问题</p><h3 id="性质3"><a href="#性质3" class="headerlink" title="性质3"></a>性质3</h3><p>设循环节长度为 $d$ ，且其中有 $a$ 步向右， $d - a$ 步向下，则有 $a \perp d$ 且 $a \perp n, (d - a) \perp m$ </p><p>证明：</p><p>若可到节点 $(x, y)$，则有 $1 + ka \equiv x \pmod n$ ，而 $x$ 取遍 $1 \sim n$ ，由裴蜀定理，若 $gcd(a, n) \ne 1$ ，则必有 $x$ 取不到，故 $a \perp n$ </p><p>同理有 $gcd(d - a, m) = 1$ ，又因为 $d = gcd(n, m)$ ，故 $a \perp d$ </p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>有了以上性质，方案数变得可求，考虑枚举 $a$ 即可<br>$$<br>Ans = \sum_{a = 0} ^ {d} [a \perp d] * [a \perp n] * [(d - a) \perp m] * \binom{d}{a}<br>$$<br>期望得分50</p><h2 id="数据3"><a href="#数据3" class="headerlink" title="数据3"></a>数据3</h2><p>现在考虑撞上障碍，明显应该dp，由于 $n, m$ 很小，dp状态几乎可以随便设，反正维数管够，设 $f[i][j][k]$ 表示在 $(i, j)$ 上撞上障碍的路程的最小值为k的方案数</p><p>同数据2，可以枚举 $a$ ，易得，若该次循环从 $(x, y)$ 出发，必然走到 $(x + a, y + b)$ ，所以只要在 $(1, 1)$ 到 $(1 + a, 1 + b)$ 间dp即可</p><p>设格子 $(x, y), (1 \le x \le 1 + a, 1 \le y \le 1 + b)$ 的权值 $w_{x, y}$ 为走到有障碍格子 $(x + ka, y + kb), (k \in \mathbb{N})$ 的最小步数，则方程为<br>$$<br>\begin{align}<br>f[i][j][k] \rightarrow f[i + 1][j][\min (k, w_{i + 1, j})]\\<br>f[i][j][k] \rightarrow f[i][j + 1][\min (k, w_{i, j + 1})]<br>\end{align}<br>$$<br>考虑时间复杂度，求 $w[i][j]$ 需要枚举 $a, i, j, k$ ，$a, i, j \le d$ ，而 $k \le \frac{nm}{d}$ ，总的时间复杂度为 $O(d^2nm) &lt; O(n^4)$ ，而转移 $f$ 时要枚举 $i, j, k$ ，其中 $i \le n, j \le m, k \le nm$ 故为 $O(n^4)$ ，总的时间复杂度为 $O(Tn^4)$ ，大概 $6 \times 10^8$ 的样子，由于有很多条件特判（如 $a$ 的互质），跑不满（实测跑的飞快），加上时限是5s，可以过</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50</span> + <span class="number">5</span>, P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, d;</span><br><span class="line"><span class="keyword">char</span> s[N][N];</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">int</span> f[N][N][N * N], w[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> y == <span class="number">0</span> ? x : <span class="built_in">gcd</span>(y, x % y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (((a == <span class="number">0</span>) &amp;&amp; (n == <span class="number">1</span>)) || ((b == <span class="number">0</span>) &amp;&amp; (m == <span class="number">1</span>)) || ((<span class="built_in">gcd</span>(a, d) == <span class="number">1</span>) &amp;&amp; (<span class="built_in">gcd</span>(b, d) == <span class="number">1</span>) &amp;&amp; (<span class="built_in">gcd</span>(a, n) == <span class="number">1</span>) &amp;&amp; (<span class="built_in">gcd</span>(b, m) == <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// freopen(&quot;t.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="comment">// freopen(&quot;t.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line"><span class="keyword">while</span> (T--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">d = <span class="built_in">gcd</span>(n, m);</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s[i] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span> &amp;&amp; m == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>, b; a &lt;= d; ++a)</span><br><span class="line">&#123;</span><br><span class="line">b = d - a; <span class="comment">//枚举a,b</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">check</span>(a, b))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y, _w; i &lt;= a + <span class="number">1</span>; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b + <span class="number">1</span>; ++j)</span><br><span class="line">&#123;</span><br><span class="line">x = i, y = j, _w = (i - <span class="number">1</span>) + (j - <span class="number">1</span>); <span class="comment">//设障碍点为(x, y)</span></span><br><span class="line">w[i][j] = n * m;  <span class="comment">//先将权值赋为极大值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k * d &lt;= n * m; ++k)  <span class="comment">//其实是k&lt;=n*m/d</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (s[x][y] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">w[i][j] = <span class="built_in">min</span>(w[i][j], _w);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">x += a, y += b, _w += d;</span><br><span class="line"><span class="keyword">if</span> (x &gt; n)</span><br><span class="line">x -= n;</span><br><span class="line"><span class="keyword">if</span> (y &gt; m)</span><br><span class="line">y -= m;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a + <span class="number">1</span>; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b + <span class="number">1</span>; ++j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= n * m; ++k)</span><br><span class="line">f[i][j][k] = <span class="number">0</span>;</span><br><span class="line">f[<span class="number">1</span>][<span class="number">1</span>][w[<span class="number">1</span>][<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a + <span class="number">1</span>; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b + <span class="number">1</span>; ++j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n * m; ++k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">1</span> &lt;= a + <span class="number">1</span>)</span><br><span class="line">f[i + <span class="number">1</span>][j][<span class="built_in">min</span>(k, w[i + <span class="number">1</span>][j])] = (f[i + <span class="number">1</span>][j][<span class="built_in">min</span>(k, w[i + <span class="number">1</span>][j])] + f[i][j][k]) % P;</span><br><span class="line"><span class="keyword">if</span> (j + <span class="number">1</span> &lt;= b + <span class="number">1</span>)</span><br><span class="line">f[i][j + <span class="number">1</span>][<span class="built_in">min</span>(k, w[i][j + <span class="number">1</span>])] = (f[i][j + <span class="number">1</span>][<span class="built_in">min</span>(k, w[i][j + <span class="number">1</span>])] + f[i][j][k]) % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * m; ++i)</span><br><span class="line">ans = (ans + (LL)f[a + <span class="number">1</span>][b + <span class="number">1</span>][i] * i) % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 我以为很好打……&lt;/p&gt;</summary>
    
    
    
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="暴力" scheme="https://dyd-true.github.io/tags/%E6%9A%B4%E5%8A%9B/"/>
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="骗分" scheme="https://dyd-true.github.io/tags/%E9%AA%97%E5%88%86/"/>
    
    <category term="计数" scheme="https://dyd-true.github.io/tags/%E8%AE%A1%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>luoguP4616 [COCI2017-2018#5] Pictionary</title>
    <link href="https://dyd-true.github.io/2021/11/30/luoguP4616-COCI2017-2018-5-Pictionary/"/>
    <id>https://dyd-true.github.io/2021/11/30/luoguP4616-COCI2017-2018-5-Pictionary/</id>
    <published>2021-11-30T03:35:17.000Z</published>
    <updated>2021-12-01T09:06:35.070Z</updated>
    
    <content type="html"><![CDATA[<p> 不要老往数学上想</p><span id="more"></span><p>第一反应是 $O(n^2)$ 40分的做法（很显然），直接 $O(n\sqrt{n})$ 把每个数分解，建图连边，再从大到小扫描每个因数，由此处理出所有 $gcd(a, b)$ ，这里是 $O(n^2)$ ，然后暴力枚举 $i : 1 \rightarrow m$  ，并查集维护即可，这里是 $O(n\log n)$ </p><p>但满数据 $n \le 10^5$ 肯定不允许 $n^2$ ，空间时间都挂了</p><p>仔细看，上面的瓶颈主要在求 $gcd(a, b)$ 只要我们要求出所有 $gcd$ ，就一定会有一个 $n^2$ 的时空复杂度，这显然应该<strong>放弃</strong>，那么考虑题目可否不求或者不求出全部的 $gcd$ </p><p>发现题目的问题有一下性质：</p><ol><li>这 $n$ 个数是 $1 \sim n$ 连续的（我以为很有用，然并卵）</li><li>只是询问图的<strong>联通性</strong>，不询问具体的两个数的 $gcd$ </li><li>答案求的是一个<strong>最值</strong></li><li>图建好后，询问<strong>不会再改变图</strong>了</li></ol><p>除开第一个误导我好久的性质，我们来看看其它性质如何使用：</p><p>首先最好用的是性质3，它明显提示我们建一个有权值的图，将询问转化为求权值，具体的，可以建<strong>一棵有边权的树</strong>，权值对应的时间，两个点之间的路径上的最大边权就是答案</p><p>现在主要问题在建图了，再看现性质2，明显我们不必也不能求 $gcd$ 来建图，正难则反，考虑可否枚举倍数，发现在<strong>只关注图的联通性</strong>的情况下，每天连出的边<strong>等效于从第 $m - i + 1$ 号城向它的所有倍数号城连边</strong>，边权就是天数，正确性显然，而这样建图，时间复杂度为 $O(\frac{n}{1} + \frac{n}{2} + … + \frac{n}{n}) = O(n)$ ，但我们要的是<strong>树</strong>，毕竟如果有多条路径就不好处理了，于是用类似最小生成树的思想，取最小的边权（其实就是天数最小）加入树中，用并查集维护联通性，一共是 $O(n \log n)$ </p><p>现在树建好了，性质2、3也都用了，来考虑询问，上面说过，两个点之间的路径上的最大边权就是答案，但每次暴力求权值肯定不行，结合 $n \le 10^5$ 和所求问题，不难想到<strong>树链剖分</strong>，如果是树剖，当然，本题得以解决</p><p>但是考虑性质4，树剖是支持修改和区间操作的，用在本题这静态的图上不免大材小用（<del>主要是调不出来</del>），于是思考，可否用一个预处理后在 $O(\log n)$ 内回答询问</p><p>当然是可以的，考虑树上倍增，用ST表+lca即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, D = <span class="number">25</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ne, ver, w;</span><br><span class="line">&#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> h[N], idx;</span><br><span class="line"><span class="keyword">int</span> fa[N];</span><br><span class="line"><span class="keyword">int</span> f[N][D], st[N][D], dep[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx] = (Edge)&#123;h[x], y, z&#125;, h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_f</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">get_f</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = m, u, v; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt;= n; j += i)</span><br><span class="line">&#123;</span><br><span class="line">u = <span class="built_in">get_f</span>(i), v = <span class="built_in">get_f</span>(j);</span><br><span class="line"><span class="keyword">if</span> (u != v)</span><br><span class="line">&#123;</span><br><span class="line">fa[u] = v;</span><br><span class="line"><span class="built_in">add</span>(i, j, m - i + <span class="number">1</span>);  <span class="comment">//i枚举的是m-i+1的值,所以这里要变回来</span></span><br><span class="line"><span class="built_in">add</span>(j, i, m - i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">dep[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">st[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">x = q.<span class="built_in">front</span>(), q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (y == f[x][<span class="number">0</span>])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">f[y][<span class="number">0</span>] = x;</span><br><span class="line">st[y][<span class="number">0</span>] = e[i].w;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; D; ++i)</span><br><span class="line">&#123;</span><br><span class="line">f[y][i] = f[f[y][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">st[y][i] = <span class="built_in">max</span>(st[y][i - <span class="number">1</span>], st[f[y][i - <span class="number">1</span>]][i - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">q.<span class="built_in">push</span>(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_ans</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">//类似lca</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (dep[y] &lt; dep[x])</span><br><span class="line"><span class="built_in">swap</span>(x, y);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = D - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line"><span class="keyword">if</span> (dep[f[y][i]] &gt;= dep[x])</span><br><span class="line">&#123;</span><br><span class="line">res = <span class="built_in">max</span>(res, st[y][i]);</span><br><span class="line">y = f[y][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x == y)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = D - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line"><span class="keyword">if</span> (f[x][i] != f[y][i])</span><br><span class="line">&#123;</span><br><span class="line">res = <span class="built_in">max</span>(res, <span class="built_in">max</span>(st[y][i], st[x][i]));</span><br><span class="line">y = f[y][i], x = f[x][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(res, <span class="built_in">max</span>(st[x][<span class="number">0</span>], st[y][<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> Q, u, v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;Q);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">h[i] = <span class="number">-1</span>, fa[i] = i;</span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; D; ++j)</span><br><span class="line">st[i][j] = INF;</span><br><span class="line"><span class="built_in">build</span>();</span><br><span class="line"><span class="built_in">bfs</span>();</span><br><span class="line"><span class="keyword">while</span> (Q--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">get_ans</span>(u, v));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 不要老往数学上想&lt;/p&gt;</summary>
    
    
    
    
    <category term="树" scheme="https://dyd-true.github.io/tags/%E6%A0%91/"/>
    
    <category term="图论" scheme="https://dyd-true.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="COCI" scheme="https://dyd-true.github.io/tags/COCI/"/>
    
    <category term="并查集" scheme="https://dyd-true.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="ST表" scheme="https://dyd-true.github.io/tags/ST%E8%A1%A8/"/>
    
    <category term="lca" scheme="https://dyd-true.github.io/tags/lca/"/>
    
    <category term="倍增" scheme="https://dyd-true.github.io/tags/%E5%80%8D%E5%A2%9E/"/>
    
  </entry>
  
  <entry>
    <title>test2021/11/29总结</title>
    <link href="https://dyd-true.github.io/2021/11/29/test2021-11-29%E6%80%BB%E7%BB%93/"/>
    <id>https://dyd-true.github.io/2021/11/29/test2021-11-29%E6%80%BB%E7%BB%93/</id>
    <published>2021-11-29T04:01:13.000Z</published>
    <updated>2021-11-29T14:05:11.287Z</updated>
    
    <content type="html"><![CDATA[<p> 暴力狂魔</p><span id="more"></span><h1 id="test2021-11-29总结"><a href="#test2021-11-29总结" class="headerlink" title="test2021/11/29总结"></a>test2021/11/29总结</h1><p>学校测试，考了<strong>2021全国统一省选Day2</strong></p><h2 id="题目、成绩和题解"><a href="#题目、成绩和题解" class="headerlink" title="题目、成绩和题解"></a>题目、成绩和题解</h2><p><a href="./%E7%9C%81%E9%80%892021.A%E5%8D%B7.day2.pdf">题目</a></p><p><a href="./noi2021sx-day2%E6%AF%94%E8%B5%9B%E7%BB%93%E6%9E%9C.pdf">成绩</a></p><p><a href="./NOI2021%E5%85%A8%E5%9B%BD%E7%BB%9F%E4%B8%80%E7%9C%81%E9%80%89A%E5%8D%B7%EF%BC%88%E9%A2%98%E8%A7%A3%EF%BC%89.docx">题解</a></p><h2 id="早上做题"><a href="#早上做题" class="headerlink" title="早上做题"></a>早上做题</h2><p>一大早考试，看到题就已经做好打三道暴力的准备</p><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>快速瞟了一眼，一看，第一感觉暴力可以拿25（<del>实际也是25分，一分不多艹</del>），后来仔细观察了数据范围，特殊性质有两个，一个是 $m \le 300$  再加上满数据的 $m$ 也比 $n$ 小，像是提示我要打权值线段树的样子；又有一个是链，像是提示我树链剖分</p><p>感觉上从数据范围看是 $O(n\log n)$ 或者常数小的 $O(n\log^2 n)$ ，个人考场上偏向于是树剖（<del>特别打脸</del>），想到树剖不好调（同机房的<strong>l18q</strong>就是死调树剖），决定打个暴力往下看</p><p>暴力思路这里简单说一下（免得我忘了）：大概是倍增法的lca找路径，存下来，然后再扫一遍求答案，时间复杂度 $O(qn)$ </p><h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>不多说，计算机一算，$13!$ 都炸了，直接放弃想正解，感觉暴力分挺多的，于是打暴力，dfs求排列，倒序扫排名判定是否可行，时间复杂度 $O(n!n)$ ，考场上得了60分，第三个大样例过不了</p><h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>这个才<del>nm</del>离谱，<strong>wfy</strong>大佬会打支配树，刚开考就（在我旁边）说他先做T3，我内心忐忑的来到T3，一看，连暴力都觉得好麻烦，但麻烦也得打啊，就硬着头皮打暴力</p><p>第一遍打了个非多项式时间复杂度的（<del>其实就是玄学，说的那么文雅</del>），连样例三都超时，样例二还WA了，没多想，换思路</p><p>第二边打了个正经暴力，思路是先bfs求出每个点到1的最短路径，存在vector $D[N]$ 里，然后对于 $D[i]$ 中的每一个点，判断删去该点后1和 $i$ 是否联通，不联通则该点是支配点，对于每个加边操作，就加上边然后再判一次（因为 $D[i]$ 只会变小，不会变大），时间复杂度为 $O(qn^3)$ ，因为第二、三个 $n$ 都绝对跑不满，所以其实大概是 $O(qn\xi)$ 的，反正样例三是没TLE了</p><p>然鹅样例二的WA还是不变！我对着大样例极端痛苦的调到考试快结束，大概最后三分钟（其它人好多都交了）的时候才发现：“ 有 $q$ 次 ${\color{red}\colorbox{yellow}{互相独立}}$ 的询问”，所以每次询问完后要恢复原状！我用的链式前向星，不好复原，三分钟改成vector存图，没来得及调就交了，结果爆零</p><h3 id="总分"><a href="#总分" class="headerlink" title="总分"></a>总分</h3><p>25 + 60 + 0，85分，还算正常分数吧（毕竟我太弱了），最高是<strong>wfy</strong>大佬和<strong>龙巨</strong>，看了一下，T3都打出来了30分，不愧是他们，下午打算先把T3的30分改出来</p><h2 id="下午改题"><a href="#下午改题" class="headerlink" title="下午改题"></a>下午改题</h2><h3 id="T3-1"><a href="#T3-1" class="headerlink" title="T3"></a>T3</h3><p>首先，上午的方法打出来了，不知为何，有几个询问都比答案小1，调了半天没办法，只好<del>看题解</del>，找了个支配树的方法，如下：</p><p>首先，用 $O(n^2)$  建出<strong>支配树</strong>（定义为一棵树，满足点 $u$ 的受支配集 $D_u$ 即为它到根的路径上的所有点组成的集合），建法为先求出 $D[]$ （方法同上午的），然后类似拓扑排序一样，首先把1入队，对于队头 $x$ 删除所以 $D[]$ 中的 $x$ ，若有一个 $i$ 满足 $D[i] = {i}$ 即只剩下自己支配自己，就入队，并连边 $(x, i)$ </p><p>建好支配树后，对于每次添加边 $(u, v)$ ，若一个点 $x$ 的支配集改变，一定是出现了 $1 \rightarrow u \rightarrow v \rightarrow x$ 并且该路径不经过支配树上 $x$ 的某个祖先</p><p>但枚举祖先太麻烦，而且会TLE，我们发现一个性质：若 $x$ 的支配集改变，则支配树上 $x$ 的所有孩子的支配集也会改变，正确性显然</p><p>于是利用该性质，问题转化为：如果存在一条路径 $1 \rightarrow u \rightarrow v \rightarrow x$ 不经过点 $x$ 的<strong>父亲</strong>，那么 $x$ 子树内所有点都会对答案产生贡献（支配集都会发生改变），问贡献和</p><p>我们可以预处理每一个点 $x$ ，把 $x$ 的父亲从原图的反图中删去，$x$ 能到达哪些点，它就可能对这些点产生贡献，对于一组询问 $(u, v)$ ，我们只需要枚举所有可能对 $v$ 产生贡献的点，如果它的父亲不在支配树上的 $1 \rightarrow u$ 这条路径上，它这棵子树就可以产生贡献，时间复杂度 $O(nq)$ </p><p>类似树剖，用dfn化为链，直接差分即可（因为修改一定是在同一子树，不必像树剖一样轻重链划分）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IL inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3000</span> + <span class="number">5</span>, Que = <span class="number">2e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ne, ver;</span><br><span class="line">&#125; e[<span class="number">5</span>][N &lt;&lt; <span class="number">3</span>]; <span class="comment">//1-原图,2-反图,3-支配树</span></span><br><span class="line"><span class="keyword">int</span> h[<span class="number">5</span>][N], idx[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="keyword">int</span> stk[N * N], top;</span><br><span class="line"><span class="keyword">int</span> fa[N], si[N], dfn[N], id;</span><br><span class="line"><span class="keyword">int</span> vs[N], cf[N];  <span class="comment">//vs:第几次询问,cf:差分</span></span><br><span class="line"><span class="keyword">bool</span> del[N], vis[N], can[N][N], ins[N], cc[N][N]; <span class="comment">//cc:能否贡献</span></span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[o][idx[o]] = (Edge)&#123;h[o][x], y&#125;, h[o][x] = idx[o]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">dfs12</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x])</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[o][x]; i != <span class="number">-1</span>; i = e[o][i].ne)</span><br><span class="line"><span class="keyword">if</span> (!vis[e[o][i].ver])</span><br><span class="line"><span class="built_in">dfs12</span>(o, e[o][i].ver);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">del[j] = vis[j] = <span class="literal">false</span>;</span><br><span class="line">del[i] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">dfs12</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line"><span class="keyword">if</span> (!vis[j])</span><br><span class="line">can[j][i] = <span class="literal">true</span>, ++cnt[j];</span><br><span class="line">&#125;</span><br><span class="line">top = <span class="number">1</span>;</span><br><span class="line">stk[top] = <span class="number">1</span>;</span><br><span class="line">ins[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= top; i++)</span><br><span class="line">&#123;</span><br><span class="line">x = stk[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line"><span class="keyword">if</span> (can[j][x])</span><br><span class="line">--cnt[j];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line"><span class="keyword">if</span> (cnt[j] == <span class="number">1</span> &amp;&amp; !ins[j])</span><br><span class="line">ins[j] = <span class="literal">true</span>, <span class="built_in">add</span>(<span class="number">3</span>, x, j), stk[++top] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">si[x] = <span class="number">1</span>;</span><br><span class="line">dfn[x] = ++id;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[<span class="number">3</span>][x], y; i != <span class="number">-1</span>; i = e[<span class="number">3</span>][i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[<span class="number">3</span>][i].ver;</span><br><span class="line">fa[y] = x;</span><br><span class="line"><span class="built_in">dfs3</span>(y);</span><br><span class="line">si[x] += si[y];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">prev</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fa[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">id = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">dfs3</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">del[j] = vis[j] = <span class="literal">false</span>;</span><br><span class="line">del[fa[i]] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">dfs12</span>(<span class="number">2</span>, i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">cc[i][j] = vis[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m, Q, u, v, _u, ans, t;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;Q);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">h[<span class="number">1</span>][i] = h[<span class="number">2</span>][i] = h[<span class="number">3</span>][i] = <span class="number">-1</span>;</span><br><span class="line">idx[<span class="number">1</span>] = idx[<span class="number">2</span>] = idx[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line"><span class="built_in">add</span>(<span class="number">1</span>, u, v);</span><br><span class="line"><span class="built_in">add</span>(<span class="number">2</span>, v, u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">build</span>();</span><br><span class="line"><span class="built_in">prev</span>();</span><br><span class="line">t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (Q--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">_u = u;</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line">++t;</span><br><span class="line"><span class="keyword">while</span> (_u != <span class="number">1</span>)</span><br><span class="line">vs[_u] = t, _u = fa[_u];</span><br><span class="line">vs[<span class="number">1</span>] = t;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i)</span><br><span class="line">cf[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span> (cc[i][v] &amp;&amp; vs[fa[i]] != t)</span><br><span class="line">++cf[dfn[i]], --cf[dfn[i] + si[i]];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">cf[i] += cf[i - <span class="number">1</span>], ans += (cf[i] != <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果一下午+晚上只改了一道题，笑死我了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt; 暴力狂魔&lt;/p&gt;</summary>
    
    
    
    
    <category term="test" scheme="https://dyd-true.github.io/tags/test/"/>
    
    <category term="差分" scheme="https://dyd-true.github.io/tags/%E5%B7%AE%E5%88%86/"/>
    
    <category term="支配树" scheme="https://dyd-true.github.io/tags/%E6%94%AF%E9%85%8D%E6%A0%91/"/>
    
    <category term="dfs" scheme="https://dyd-true.github.io/tags/dfs/"/>
    
  </entry>
  
  <entry>
    <title>线性基</title>
    <link href="https://dyd-true.github.io/2021/11/28/%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
    <id>https://dyd-true.github.io/2021/11/28/%E7%BA%BF%E6%80%A7%E5%9F%BA/</id>
    <published>2021-11-28T11:04:24.000Z</published>
    <updated>2021-11-28T13:53:59.422Z</updated>
    
    <content type="html"><![CDATA[<p> 一堆无意义的定义</p><span id="more"></span><h1 id="线性基"><a href="#线性基" class="headerlink" title="线性基"></a>线性基</h1><p>线性基是竞赛中常用来解决<strong>子集异或</strong>一类题目的算法</p><h2 id="数学相关定义"><a href="#数学相关定义" class="headerlink" title="数学相关定义"></a>数学相关定义</h2><p>一大堆没用的</p><h3 id="向量空间"><a href="#向量空间" class="headerlink" title="向量空间"></a>向量空间</h3><p>向量空间亦称线性空间，具体可见<a href="https://baike.baidu.com/item/%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4">百度百科</a>，反正简单来说，就是定义了加法和乘法的向量的集合（其实完全不一样，但我们只需要用到这么多）</p><h3 id="线性相关和线性无关"><a href="#线性相关和线性无关" class="headerlink" title="线性相关和线性无关"></a>线性相关和线性无关</h3><p>若 $V$ 是一个向量空间（集合），如果存在不全为零的系数数列 $c_1, c_2, …, c_n \in \mathbb{F}$ （ $\mathbb{F}$ 是<a href="https://baike.baidu.com/item/%E4%BB%A3%E6%95%B0%E6%95%B0%E5%9F%9F/9551710?fr=aladdin">代数域</a>），使得 $c_1 \vec{v_1} + c_2 \vec{v_2} + … +c_n \vec{v_n} = 0$ （即 $\exists \vec{v_j}$ 可以被除它本身外其它属于 $V$ 的向量表示出来），那么 $V$ 中的向量就叫做<strong>线性相关</strong>的，反之，则为<strong>线性无关</strong>的</p><h3 id="子空间"><a href="#子空间" class="headerlink" title="子空间"></a>子空间</h3><p>设 $W$ 为向量空间 $V$ 的一个非空子集，若 $W$ 在 $V$ 的加法及标量乘法下是封闭的，且零向量 $\vec{0} \in W$ ，就称 $W$ 为 $V$ 的<strong>线性子空间</strong>，简称<strong>子空间</strong></p><h3 id="扩张和生成集合"><a href="#扩张和生成集合" class="headerlink" title="扩张和生成集合"></a>扩张和生成集合</h3><p>给出一个向量集合 $B$ ，那么<strong>包含它</strong>的<strong>最小</strong>子空间 $W$ 就称为它的<strong>扩张</strong>（也叫<strong>张成</strong>），记作 $span(B)$ ，另外规定空集的扩张为 ${\vec{0}}$ </p><p>而 $B$ 也被叫做 $W$ 的<strong>生成集合</strong>（可以理解为通过 $B$ 中的元素可以将 $W$ 中的所有元素表示出来）</p><h3 id="基和维度"><a href="#基和维度" class="headerlink" title="基和维度"></a>基和维度</h3><p>给出一个向量集合 $B$ ，若 $B$ 是<strong>线性无关</strong>的，且 $B$ 能够生成 $V$ ，就称 $B$ 为 $V$ 的一个<strong>基</strong></p><p>对非零向量空间 $V$ ，基是 $V$ 最小的生成集，也是<a href="https://baike.baidu.com/item/%E6%9E%81%E5%A4%A7%E7%BA%BF%E6%80%A7%E6%97%A0%E5%85%B3%E7%BB%84">极大线性无关组</a></p><p>如果一个向量空间 $V$ 拥有一个元素个数<strong>有限</strong>的生成集，那么就称 $V$ 是一个<strong>有限维空间</strong>，向量空间的所有基拥有<strong>相同基数</strong>，称为该空间的<a href="https://baike.baidu.com/item/%E7%BB%B4%E5%BA%A6">维度</a></p><p>空间内的每个向量都有唯一的方法表达成基中向量的<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E7%BB%84%E5%90%88">线性组合</a>，而且，将基中向量进行排列，表示成有序基，每个向量便可以坐标系统来表示</p><h2 id="线性基-1"><a href="#线性基-1" class="headerlink" title="线性基"></a>线性基</h2><p>扯了那么多没有用的，下面才是真的要用的</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>线性基其实就是上面数学定义中，将向量空间的加法和乘法定义为<strong>异或</strong>的意义下的基，具体来说，在异或的定义下：</p><ul><li>用<strong>无符号整数集</strong>来替代<strong>向量的集合</strong></li><li>对于集合 $B$ ，在其中选出任意多个数，其异或和的所有可能的结果组成的集合 $S$ 称作 $B$ 的<strong>扩张</strong>，记为 $span(B)$ </li><li>对于一个集合 $B$ ，若存在一个元素可以用其它若干个元素异或起来得到，则称 $B$ 中元素<strong>线性相关</strong>，反之，则为<strong>线性无关</strong></li><li>对于集合 $B, S$ ，若 $S \subseteq span(B)$ 且 $B$ 线性无关，则称 $B$ 为 $S$ 的<strong>线性基</strong>，集合 $B$ 中元素的个数，称为线性基的<strong>长度</strong></li></ul><p>个人觉得对照这数学中的定义还是比较好理解的</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>若 $B$ 是 $S$ 的线性基，则 $S$ 中的任意元素都可以<strong>唯一</strong>表示为 $B$ 中若干个元素异或起来的结果，正确性显然</p><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p>设 $S$ 中最大的数在二进制下有 $L$ 为，我们用一个下标为 $0 \sim L$ 的数组 $a[]$ 来存储线性基，在接下来的构造中，我们称第 $i$ 位<strong>存在于</strong>线性基中，当且仅当 $a[i] \ne 0$</p><p>首先，线性基是动态构造的，我们只需要从空的，每次考虑在一个已存在的线性基中插入一个数 $t$ 即可</p><p>从 $t$ 最高位上的1开始考虑，设这是第 $j$ 位，如果这一位已经存在于线性基中，则我们需要将 $t$ 中的这一位消掉（将 $t$ 异或上 $a[i]$ ），才可以继续插入（因为要保证 $B$ 线性无关）；如果这一位不存在于线性基中，则可以将  插入到 $a[j]$ 的位置上</p><p>对于具体实现，我们采用逆序枚举 $t$ 所以为1的二进制位 $j$ ，对于每个 $j$ ：</p><ol><li>若 $a[j] \ne 0$ ，则 $t = t \oplus a[j]$ </li><li>若 $a[j] = 0$ ，则 $a[i] = t$ ，结束</li></ol><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>线性基支持一下操作：</p><ul><li><p>求集合的最大异或和：</p><p>只需倒序枚举每一个 $a[i]$ ，贪心异或即可</p></li><li><p>求集合的最小异或和：</p><p>先特判能否为0，然后正序序枚举每一个 $a[i]$ ，第一个存在的就是答案</p></li><li><p>查询 $t$ 是否在值域中</p><p>类似于插入</p></li><li><p>查询第 $k$ 小的值</p><p>先特判减去0，然后从高到低处理线性基每一位，对于每一位向后扫，如果当前数第 $i$ 位为0，且线性基第 $i$ 位不为0，则将当前数异或上 $a[i]$ ，这一操作可以在 $O(L^2)$ 的时间内解决，我们称其为重构<br>经过这一步操作后，设线性基内共有 $cnt$ 个数，则它们共可以表示出 $2^{cnt}$ 个数<br>随后，我们考虑将 $k$ 二进制拆分，用与快速幂类似的方法就可以求出第 $k$ 小值</p></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>一定要注意long long</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">64</span>; <span class="comment">//这个N一定要开对，大了小了都不行</span></span><br><span class="line">LL a[N], tmp[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">a[i] = tmp[i] = <span class="number">0</span>;</span><br><span class="line">cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line"><span class="keyword">if</span> ((x &gt;&gt; i) &amp; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!a[i])</span><br><span class="line">&#123;</span><br><span class="line">a[i] = x;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">x ^= a[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">get_max</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">res = <span class="built_in">max</span>(res ^ a[i], res);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">get_min</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> _c = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line"><span class="keyword">if</span> (a[i])</span><br><span class="line">++_c;</span><br><span class="line"><span class="keyword">if</span> (_c &lt; n)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line"><span class="keyword">if</span> (a[i])</span><br><span class="line"><span class="keyword">return</span> a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> ((x &gt;&gt; i) &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">if</span> (!a[i])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">x^=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">()</span> <span class="comment">//重构线性基</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line"><span class="keyword">if</span> ((a[i] &gt;&gt; j) &amp; <span class="number">1</span>)</span><br><span class="line">a[i] ^= a[j];</span><br><span class="line"><span class="keyword">if</span> (a[i])</span><br><span class="line">tmp[cnt++] = a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i)</span><br><span class="line">a[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">get_k</span><span class="params">(LL k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (cnt &lt; n)</span><br><span class="line">--k;</span><br><span class="line">    <span class="keyword">if</span>(!k)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= (<span class="number">1ll</span> &lt;&lt; cnt))</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i)</span><br><span class="line">    <span class="keyword">if</span> ((k &gt;&gt; i) &amp; <span class="number">1</span>)</span><br><span class="line">    res ^= a[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个用vector实现，比较短的（太香了）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line">vector&lt;LL&gt; b;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (LL i : b)</span><br><span class="line">x = <span class="built_in">min</span>(x ^ i, x);</span><br><span class="line"><span class="keyword">for</span> (LL &amp;i : b)</span><br><span class="line">i = <span class="built_in">min</span>(x ^ i, i);</span><br><span class="line"><span class="keyword">if</span> (x)</span><br><span class="line">b.<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">get_max</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (LL i : b)</span><br><span class="line">res = <span class="built_in">max</span>(res ^ i, res);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">get_min</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (b.<span class="built_in">size</span>() &lt; n)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> b[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (LL i : b)</span><br><span class="line">x = <span class="built_in">min</span>(x ^ i, x);</span><br><span class="line">    <span class="keyword">return</span> x == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">get_k</span><span class="params">(LL k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (b.<span class="built_in">size</span>() &lt; n) <span class="comment">//减去为0的情况</span></span><br><span class="line">    --k;</span><br><span class="line">    <span class="keyword">for</span> (LL i : b)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span> (k &amp; <span class="number">1</span>)</span><br><span class="line">    res ^= i;</span><br><span class="line">    k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 一堆无意义的定义&lt;/p&gt;</summary>
    
    
    
    
    <category term="数论,数学" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
    <category term="线性基" scheme="https://dyd-true.github.io/tags/%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
    
  </entry>
  
  <entry>
    <title>斯特林数</title>
    <link href="https://dyd-true.github.io/2021/11/28/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"/>
    <id>https://dyd-true.github.io/2021/11/28/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/</id>
    <published>2021-11-28T07:40:53.000Z</published>
    <updated>2021-11-28T11:05:01.320Z</updated>
    
    <content type="html"><![CDATA[<p> 还是卡特兰数简单一点……</p><span id="more"></span><h1 id="斯特林数"><a href="#斯特林数" class="headerlink" title="斯特林数"></a>斯特林数</h1><h2 id="第一类斯特林数"><a href="#第一类斯特林数" class="headerlink" title="第一类斯特林数"></a>第一类斯特林数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>第一类斯特林数（Stirling）分为无符号第一类斯特林数 $s_s(n, m)$ 和带符号第一类斯特林数 $s_u(n, m)$ ，有无符号斯特林数分别表现为其升阶函数和降阶函数的各项系数（<del>反正我是没看懂</del>），形式如下：<br>$$<br>\begin{aligned}<br>x^{n\uparrow} = x(x + 1)(x + 2)…(x + n - 1) = \sum_{k = 0}^{n}s_u(n, k)x^k\\<br>x^{n\downarrow} = x(x - 1)(x - 2)…(x - n  + 1) = \sum_{k = 0}^{n}s_s(n, k)x^k\\<br>\end{aligned}<br>$$<br>对于有无符号斯特林数之间的关系有 $s_s(n, m) = (-1)^{n + m}s_u(n, m)$</p><p>组合数学中的第一类斯特林数一般指无符号的第一类斯特林数，以下的“第一类斯特林数”若无特殊说明，也指“无符号的第一类斯特林数”，无符号的第一类斯特林数还有一个组合数学上的定义，为： $n$ 个不同元素构成 $m$ 个圆排列（两个圆排列间没有顺序之分）的方案数，记作 $s(n, m)$ 或 ${n \brack m}$ </p><h3 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h3><p>第一类斯特林数有一个递推式：<br>$$<br>{n \brack m} = {n - 1 \brack m - 1} + (n - 1){n - 1 \brack m}<br>$$<br>证明：</p><p>考虑第一类斯特林数的定义，${n \brack m}$ 表示把 $n$ 个不同元素构成 $m$ 个圆排列的方案数，对于第 $n$ 个数，若它单独成为新的一个圆，则它前面的 $n - 1$ 个数构成了 $m - 1$ 个圆，方案数为 ${n - 1 \brack m - 1}$ ；若它加入到前面构成的圆中，则它前面的 $n - 1$ 个数构成了 $m$ 个圆，方案数为 ${n - 1 \brack m}$ ，而这 $n - 1$ 个数间有 $n - 1$ 空位可以选择，共 $(n - 1){n - 1 \brack m}$  种方案</p><p>两种情况综合，即得递推式</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>, P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> s[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">s[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">s[i][j] = (s[i - <span class="number">1</span>][j - <span class="number">1</span>] + (LL)(i - <span class="number">1</span>) * s[i - <span class="number">1</span>][j]) % P;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s[n][m]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul><li> ${0 \brack 0} = 1$ </li><li> ${n \brack 0} = 0$ </li><li> ${n \brack n} = 1$ </li></ul><p>以上三条由定义不难得到</p><ul><li><p>  ${n \brack 1} = (n - 1)!$ </p></li><li><p> ${n \brack n - 1} = \binom{n}{2}$ </p></li></ul><p>  证明：</p><p>  依然考虑定义，$n$ 个不同元素构成 $n - 1$ 个圆排列，必然有一个圆排列有两个数，其它圆排列只有一个数，有两个数的圆排列有 $\binom{n}{2}$ 种方案，对应其它都只有一种方案</p><ul><li> $\sum_{k = 0}^{n} {n \brack k} = n!$ </li></ul><p>  证明：</p><p>  令升阶函数中的 $x = 1$ ，即得原式</p><h2 id="第二类斯特林数"><a href="#第二类斯特林数" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>第二类斯特林数实际上是集合的一个拆分，表示将 $n$ 个不同的元素划分成 $m$ 个集合（两个集合间没有顺序之分）的方案数，记为 $S(n, m)$ 或 ${n \brace m}$ ，和第一类斯特林数不同的是，集合内是不考虑次序的，而圆排列是有序的</p><h3 id="求法-1"><a href="#求法-1" class="headerlink" title="求法"></a>求法</h3><p>递推式：<br>$$<br>{n \brace m} = {n - 1 \brace m - 1} + m {n - 1 \brace m}<br>$$<br>还是考虑定义，将 $n$ 个不同的元素划分成 $m$ 个集合，对于第 $n$ 个数，可以单独为一个集合，则前面 $n - 1$ 个数构成 $m - 1$ 个集合，方案数为 ${n - 1 \brace m - 1}$ ；也可以加入到原有集合中，则前面 $n - 1$ 个数构成 $m$ 个集合，方案数为 ${n - 1 \brace m}$ ，而第 $n$ 个数在 $m$ 个集合中选一个加入，方案数为 $m$ </p><p>两种情况综合，即得递推式</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>, P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> S[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">S[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">S[i][j] = (S[i - <span class="number">1</span>][j - <span class="number">1</span>] + (LL)j * S[i - <span class="number">1</span>][j]) % P;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, S[n][m]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算式：<br>$$<br>{n \brace m} = \frac{1}{m!} \sum_{k = 0}^{m} (-1)^k \binom{m}{k} (m - k)^n<br>$$<br>证明见<a href="https://baike.baidu.com/item/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0">百度百科</a></p><h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><ul><li> ${n \brace 0} = 0^n$ </li><li> ${n \brace 1} = 1$ </li><li> ${n \brace n} = 1$ </li><li> ${n \brace 2} = 2^{n - 1} - 1$ </li><li> ${n \brace n - 1} = \binom{n}{2}$ </li><li> $\sum_{k = 0}^{n} {n \brace k} = B_n$ ，其中 $B_n$ 是<a href="https://baike.baidu.com/item/%E5%80%8D%E5%B0%94%E6%95%B0/369479?fromtitle=%E8%B4%9D%E5%B0%94%E6%95%B0&fromid=9227873">贝尔数</a>  </li></ul><h2 id="两类斯特林数的关系"><a href="#两类斯特林数的关系" class="headerlink" title="两类斯特林数的关系"></a>两类斯特林数的关系</h2><p>其实就一个：<br>$$<br>\sum_{k = 0}^{n} {n \brace k}{k \brack m} = \sum_{k = 0}^{n} {n \brack k}{k \brace m}<br>$$</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.com.cn/problem/P4609">建筑师</a></p><p>以高度为 $n$ 的建筑为分界线，左边选择 $A - 1$ 个建筑让他们可以被看见，右边 $B - 1$ 个，如图：</p><p><img src="https://i.loli.net/2021/11/28/lhKaJEux2kpqHmW.jpg" alt="AB"></p><p>问题转化为将 $1 \sim n - 1$ 划分为 $A + B - 2$ 部分（即红框里的），对于每一个部分，将其中元素排成一个圆排列，放置时保证最高的在最左边（如果是放在 $n$ 右边，则最高的在最右边），故有 ${n \brack m}$ 种方案</p><p>然后将这些部分划分给  $n$ 两边，有 $\binom{A + B - 2}{A - 1}$ 种方案</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span> + <span class="number">5</span>, P = <span class="number">1e9</span> + <span class="number">7</span>, M = <span class="number">200</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> s[N][M], C[M][M];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pred</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">s[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; M; ++j)</span><br><span class="line">s[i][j] = (s[i - <span class="number">1</span>][j - <span class="number">1</span>] + (LL)(i - <span class="number">1</span>) * s[i - <span class="number">1</span>][j]) % P;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j)</span><br><span class="line"><span class="keyword">if</span> (!j)</span><br><span class="line">C[i][j] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">C[i][j] = (C[i - <span class="number">1</span>][j] + C[i - <span class="number">1</span>][j - <span class="number">1</span>]) % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">pred</span>();</span><br><span class="line"><span class="keyword">int</span> T, n, a, b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line"><span class="keyword">while</span> (T--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;a, &amp;b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (LL)s[n - <span class="number">1</span>][a + b - <span class="number">2</span>] * C[a + b - <span class="number">2</span>][a - <span class="number">1</span>] % P);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 还是卡特兰数简单一点……&lt;/p&gt;</summary>
    
    
    
    
    <category term="数论,数学" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
    <category term="Stirling数,斯特林数" scheme="https://dyd-true.github.io/tags/Stirling%E6%95%B0-%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"/>
    
    <category term="排列组合" scheme="https://dyd-true.github.io/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>luoguP4429 [BJOI2018]染色</title>
    <link href="https://dyd-true.github.io/2021/11/28/luoguP4429-BJOI2018-%E6%9F%93%E8%89%B2/"/>
    <id>https://dyd-true.github.io/2021/11/28/luoguP4429-BJOI2018-%E6%9F%93%E8%89%B2/</id>
    <published>2021-11-28T02:02:51.000Z</published>
    <updated>2021-11-28T06:23:17.876Z</updated>
    
    <content type="html"><![CDATA[<p> 结论题，靠手玩</p><span id="more"></span><p>拿到题就先被吓了一跳，然后又看了看数据范围，毫无提示性</p><p>先盲猜一手考的二分图，也就是每个点的颜色集合都相同，然后……<del>理所当然的</del> 错了，但还是给了我们一点希望，因为我们发现明显，存在奇环就是No</p><p>那就还有不存在环和存在偶环两种情况</p><p>不存在环，即 $m &lt; n$ ，考虑节点 $u$ 染为颜色 $A$ ，那么与它相连的节点 $v$ 最多只是有一个颜色不能染，此外便再无其它限制，明显是有染色方案的，故为Yes</p><p>再考虑偶环的情况，若只有一个偶环，即 $n = m$ ，我们将其断开，记断开处两个节点为根节点和尾节点，从根节点开始用无环的方法染色，设根节的颜色集合为 ${A, B}$ ，分三种情况：</p><ol><li>若尾节点的颜色集合为 ${C, D}$ ，则染色成立</li><li>若尾节点的颜色集合为 ${A, C}$ ，只要根节点染为颜色 $B$ 即可</li><li>若尾节点的颜色集合为 ${A, B}$ ，设根节点染为颜色 $A$ 如果要让尾节点也必须染颜色 $A$ 则与尾节点相连的另一个点必须染为颜色 $B$ ，以此类推，每个节点的颜色都是“必须染成颜色 $X$ ”，设于根节点相连的另一个点的颜色是必须染成颜色 $E$ （这个 $E$ 可以等于于任何颜色，包括 $A, B$ ），由于这个“必须”，该节点的颜色集合一定是 ${A, E}$ （这样才能用“根节点染成颜色 $A$ ”推出“该节点染成颜色 $E$ ”），那么只要将根节点染成颜色 $B$ ，该节点染成颜色 $E$ ，由于刚才的一系列“必须”，尾节点只能保持颜色 $A$ 不变，染色成立</li></ol><p>综上，若只有一个偶环，必定可以染色，故为Yes</p><p>那有多个偶环，即 $m &gt; n$ ，怎么办？</p><p>先考虑两个偶环没有公共边，看看下图：</p><p><img src="https://i.loli.net/2021/11/28/41UTVmnNBcKjADr.png" alt="偶环"></p><p>不难发现在这种构造下，最下方的点只能选颜色 $X$ </p><p>于是有下图：</p><p><img src="https://i.loli.net/2021/11/28/OhjP4dcNZMFwrt8.png" alt="卡"></p><p>明显为No</p><p>推广一下，考虑把节点 ${C, D}$ 拆成多个节点相连，换句话说，用多个节点连成的链作为广义的“交叉节点”，我们 <del>玄学的</del> 得出了结论：如果存在两个没有公共边但联通的环，那么答案是No，构造方法类似上图，可以证明（<del>我也不知道咋证</del>）这种情况的充分条件为 $m &gt; n + 1$ </p><p>最后只剩一种情况： $m = n + 1$ 且为偶环</p><p>这种情况下，要么有一个点度数为4，要么有两个点度数为3，度数为四的情况就和上图一样，明显为No</p><p>考虑两个度数为3的点，它们之间必定有3条路径，设路径长度（经过的边数）分别为 $(x, y, z)$ ，<del>手玩一下</del> 发现只有 $(2, 2, 2k), k\in \mathbb{N_+}$ 的情况为Yes</p><hr><p>最后总结一下：</p><ol><li> $m &lt; n$ 为Yes</li><li> $m = n$ 且无奇环为Yes，否则为No</li><li> $m = n + 1$ 且无奇环，若有两个度为3的节点且两点间路径为 $(2, 2, 2k), k\in \mathbb{N_+}$ 则为Yes，否则为No；若有奇环为No</li><li> $m &gt; n + 1$ 为No</li></ol><p>注意以上结论均是在保证图联通的情况下得出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VIT vector<span class="meta-string">&lt;int&gt;</span>::iterator</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, e, v;</span><br><span class="line"><span class="keyword">int</span> c[N], du[N];</span><br><span class="line"><span class="keyword">bool</span> f; <span class="comment">//true-No,false-Yes</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; to[N], cir;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">to[i].<span class="built_in">clear</span>(), c[i] = <span class="number">0</span>;</span><br><span class="line">f = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> _c)</span> <span class="comment">//染色法判奇环</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (f)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span> (c[x])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (c[x] != _c)</span><br><span class="line">f = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">c[x] = _c;</span><br><span class="line">++v;</span><br><span class="line">e += to[x].<span class="built_in">size</span>();</span><br><span class="line">cir.<span class="built_in">push_back</span>(x);</span><br><span class="line"><span class="keyword">for</span> (VIT i = to[x].<span class="built_in">begin</span>(); i != to[x].<span class="built_in">end</span>(); ++i)</span><br><span class="line"><span class="built_in">dfs</span>(*i, <span class="number">3</span> - _c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topu</span><span class="params">()</span> <span class="comment">//拓扑处理非环节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span> (VIT i = cir.<span class="built_in">begin</span>(); i != cir.<span class="built_in">end</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">du[*i] = to[*i].<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (du[*i] == <span class="number">1</span>)</span><br><span class="line">q.<span class="built_in">push</span>(*i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">x = q.<span class="built_in">front</span>(), q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (VIT i = to[x].<span class="built_in">begin</span>(); i != to[x].<span class="built_in">end</span>(); ++i)</span><br><span class="line"><span class="keyword">if</span>(--du[*i] == <span class="number">1</span>)</span><br><span class="line">q.<span class="built_in">push</span>(*i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> T, t, tt;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line"><span class="keyword">while</span> (T--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">to[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">to[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">if</span> (!c[i])</span><br><span class="line">&#123;</span><br><span class="line">e = v = <span class="number">0</span>;</span><br><span class="line">cir.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">dfs</span>(i, <span class="number">1</span>);</span><br><span class="line">e /= <span class="number">2</span>; <span class="comment">//存的是双向边,真正的边数要除以2</span></span><br><span class="line"><span class="keyword">if</span> (e &gt; v + <span class="number">1</span>)</span><br><span class="line">f = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (f)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (e &lt;= v)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">topu</span>();</span><br><span class="line">tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (VIT j = cir.<span class="built_in">begin</span>(); j != cir.<span class="built_in">end</span>(); ++j)</span><br><span class="line"><span class="keyword">if</span> (du[*j] == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (VIT k = to[*j].<span class="built_in">begin</span>(); k != to[*j].<span class="built_in">end</span>(); ++k)</span><br><span class="line"><span class="keyword">if</span> (du[*k] == <span class="number">3</span>)</span><br><span class="line">++t;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="number">2</span>)</span><br><span class="line">++tt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tt &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">f = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (f)</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 结论题，靠手玩&lt;/p&gt;</summary>
    
    
    
    
    <category term="图论" scheme="https://dyd-true.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="结论" scheme="https://dyd-true.github.io/tags/%E7%BB%93%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>luoguP2723 [USACO3.1]丑数 Humble Numbers</title>
    <link href="https://dyd-true.github.io/2021/11/28/luoguP2723-USACO3-1-%E4%B8%91%E6%95%B0-Humble-Numbers/"/>
    <id>https://dyd-true.github.io/2021/11/28/luoguP2723-USACO3-1-%E4%B8%91%E6%95%B0-Humble-Numbers/</id>
    <published>2021-11-28T00:47:16.000Z</published>
    <updated>2021-11-28T01:49:45.263Z</updated>
    
    <content type="html"><![CDATA[<p> 时间复杂度的计算是个技术活</p><span id="more"></span><p>第一次想到的是用一个小根堆，每次取出最小值，乘其它数的积插入堆中，最后取出的第 $n$ 个就是答案，然鹅，时间（ $O(n^2\log n)$ ）和空间（ $O(n^2)$ ）上都不允许（ $n \le 10^5$ 太艹了）</p><p>然后发现其实真正有用的跟新只有 $f[i] * a[i]$ 的形式，其中 $f[i]$ 表示第 $i$ 个丑数， $a[i]$ 表示质数，由于 $k$ 很小，用平衡树维护貌似可做？（<del>黄题啊，平衡树个寂寞啊</del>）</p><p>最后实在 <del>不想打平衡树</del> 想不出来，一看题解：艹，暴力求第 $n$ 个就好了，加个记录的优化，时间复杂度 $O(nk \xi)$ ，其中 $\xi$ 代表玄学因子（因为没人知道那层while会跑多少），空间复杂度 $O(n)$ </p><p>无语，这个故事告诉我们不要一看见 $10^5$ 就想 $n\log n$  </p><p>似乎要long long</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, K = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> LL INF = (LL)<span class="number">1e18</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> k, n;</span><br><span class="line">LL f[N];</span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;k, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"><span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + k);</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//有只有一个质因数的情况,所以从1开始</span></span><br><span class="line">LL mn;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">mn = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里是一个优化(不加会TLE),用b记录每个质数对应的最小的f[i]</span></span><br><span class="line"><span class="comment">下一次的i只会更大而不会更小</span></span><br><span class="line"><span class="comment">当然,也可以写二分查找f[i],时间复杂度更稳定一点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">while</span> (f[b[j]] * a[j] &lt;= f[i - <span class="number">1</span>])</span><br><span class="line">++b[j];</span><br><span class="line">mn = <span class="built_in">min</span>(f[b[j]] * a[j], mn);</span><br><span class="line">&#125;</span><br><span class="line">f[i] = mn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, f[n]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 时间复杂度的计算是个技术活&lt;/p&gt;</summary>
    
    
    
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="USACO" scheme="https://dyd-true.github.io/tags/USACO/"/>
    
    <category term="暴力" scheme="https://dyd-true.github.io/tags/%E6%9A%B4%E5%8A%9B/"/>
    
    <category term="枚举" scheme="https://dyd-true.github.io/tags/%E6%9E%9A%E4%B8%BE/"/>
    
  </entry>
  
  <entry>
    <title>luoguP2991 [USACO10OPEN]Water Slides G</title>
    <link href="https://dyd-true.github.io/2021/11/26/luoguP2991-USACO10OPEN-Water-Slides-G/"/>
    <id>https://dyd-true.github.io/2021/11/26/luoguP2991-USACO10OPEN-Water-Slides-G/</id>
    <published>2021-11-26T14:23:15.000Z</published>
    <updated>2021-11-28T00:15:32.325Z</updated>
    
    <content type="html"><![CDATA[<p> 题目描述过于“清晰”</p><span id="more"></span><p>最开始理解了，以为是一个搜索，大概是预处理出每个点到终点的最长路，然后bfs，每个状态由位置、失误次数、权值和组成，不会TLE</p><p>但其实题目要求中失误是走“最坏的”，而不失误是走“最好的”；我理解的失误是走“除最好的以外的节点”（<del>太nm离谱了</del>）</p><p>再看原题，发现只有两种选择（最好的和最坏的），在暴搜的基础上加一个记忆化，令 $f[i][j]$ 表示从 $i$ 走到 $n$ 失误 $j$ 条边的情况下最大权值和，明显有 $f[n][0] = 0$ ， $Ans = f[1][k]$ ，由于是在一个DAG上，在搜索时转移，方程为<br>$$<br>f[u][j] =<br>\begin{cases}<br>    \min(f[v][j - 1] + w_{u,v})\\<br>    \max(f[v][j] + w_{u,v})<br>\end{cases}<br>$$<br>最后，记得开long long</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span> + <span class="number">5</span>, M = <span class="number">1.5e5</span> + <span class="number">5</span>, K = <span class="number">10</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line">LL f[N][K];</span><br><span class="line"><span class="keyword">bool</span> vis[N][K];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ne, ver;</span><br><span class="line">LL w;</span><br><span class="line">&#125; e[M];</span><br><span class="line"><span class="keyword">int</span> h[N], idx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, LL z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx] = (Edge)&#123;h[x], y, z&#125;, h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[x][j])</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="built_in">dp</span>(y, j);</span><br><span class="line">f[x][j] = <span class="built_in">max</span>(f[y][j] + e[i].w, f[x][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="built_in">dp</span>(y, j - <span class="number">1</span>);</span><br><span class="line">f[x][j] = <span class="built_in">min</span>(f[y][j - <span class="number">1</span>] + e[i].w, f[x][j]);</span><br><span class="line">&#125;</span><br><span class="line">vis[x][j] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">h[i] = <span class="number">-1</span>;</span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> u, v;</span><br><span class="line">LL w;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line"><span class="built_in">add</span>(u, v, w);</span><br><span class="line">&#125;</span><br><span class="line">f[n][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">vis[n][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">dp</span>(<span class="number">1</span>, k);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, f[<span class="number">1</span>][k]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 题目描述过于“清晰”&lt;/p&gt;</summary>
    
    
    
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="USACO" scheme="https://dyd-true.github.io/tags/USACO/"/>
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="记忆化" scheme="https://dyd-true.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>luoguP5091 【模板】扩展欧拉定理</title>
    <link href="https://dyd-true.github.io/2021/11/26/luoguP5091-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%89%A9%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/"/>
    <id>https://dyd-true.github.io/2021/11/26/luoguP5091-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%89%A9%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/</id>
    <published>2021-11-26T03:56:02.000Z</published>
    <updated>2021-11-26T14:23:59.439Z</updated>
    
    <content type="html"><![CDATA[<p> 我太弱了</p><span id="more"></span><p>本来以为可以秒杀的（<del>毕竟是板子</del>），但遗忘的比我想象的严重，主要是当 $b &lt; \varphi(m)$ 时，不能让 $b = (b \mod \varphi(m)) + \varphi(m)$ 这个特判改了 ${\color{red} \text{三次}}$ </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20000000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a, m, phi, p;</span><br><span class="line"><span class="keyword">char</span> b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">res = (LL)res * x % p;</span><br><span class="line">x = (LL)x * x % p;</span><br><span class="line">y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%s&quot;</span>, &amp;a, &amp;m, b + <span class="number">1</span>);</span><br><span class="line">phi = p = m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j; i &lt;= m; ++i)</span><br><span class="line"><span class="keyword">if</span> (m % i == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">phi = (LL)phi * (i - <span class="number">1</span>) / i;</span><br><span class="line"><span class="keyword">while</span> (m % i == <span class="number">0</span>)</span><br><span class="line">m /= i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">strlen</span>(b + <span class="number">1</span>), bb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">8</span>) <span class="comment">//特判</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">bb = bb * <span class="number">10</span> + b[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (bb &gt;= phi)</span><br><span class="line">bb = bb % phi + phi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">bb = (bb * <span class="number">10</span> + b[i] - <span class="string">&#x27;0&#x27;</span>) % phi;</span><br><span class="line">bb += phi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">qpow</span>(a, bb));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 我太弱了&lt;/p&gt;</summary>
    
    
    
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="模板" scheme="https://dyd-true.github.io/tags/%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="扩展欧拉定理" scheme="https://dyd-true.github.io/tags/%E6%89%A9%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>生成函数</title>
    <link href="https://dyd-true.github.io/2021/11/24/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    <id>https://dyd-true.github.io/2021/11/24/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/</id>
    <published>2021-11-24T09:05:49.000Z</published>
    <updated>2021-11-24T09:27:28.910Z</updated>
    
    <content type="html"><![CDATA[<p>too difficult for me</p><span id="more"></span><h1 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>任给我们一个序列 ${ a_i } ( i \in [ 0, n ] )$ ，可以定义一个函数 $g(x) = a_0 + a_1x + a_2x^2 + … + a_nx^n$ （一般为了使函数可以收敛，定义 $x \in ( -1, 1 )$ ），则称 $g(x)$ 为序列 ${ a_i }$ 的生成函数</p><p>我们将序列转化为函数的原因是为了用函数的知识（一般是数学知识，数学不好的慎用）使问题变的简单</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.acwing.com/problem/content/3135/">食物</a></p><p>本题是一个常用的转换，即将乘法原理转化为多项式的乘法，具体如下：</p><p>先将每一种食物当作一个子问题，如，对于食物1 ，定义序列 ${ a_i }$  为只选食物1能够选出 $i$ 个食物的方案数，由于食物以只能选偶数个，故 ${ a_i } = { 1,0,1,0,1…}$ ，定义其生成函数为 $f_1(x) = 1 + x^2 + x^4 + x^6 + … (x \in (-1, 1))$ 由等比数列求和公式有 $f_1(x) = \frac{1 - x^n}{1 - x^2}$ ，又因为 $n \rightarrow \infty$ ，所以 $x^n \rightarrow 0$ ，则 $f_1(x) = \frac{1}{1 - x^2}$ </p><p>同理，有：<br>$$<br>\begin{align}<br>f_2(x) &amp;= 1 + x = \frac{1 - x^2}{1 - x}\\<br>f_3(x) &amp;= 1 + x + x^2 = \frac{1 - x^3}{1 - x}\\<br>f_4(x) &amp;= x + x^3 + x^5 + … = \frac{x}{1 - x^2}\\<br>f_6(x) &amp;= 1 + x^4 + x^8 + … = \frac{1}{1 - x^4}\\<br>f_6(x) &amp;= 1 + x + x^2 + x^3 = \frac{1 - x^4}{1 - x}\\<br>f_7(x) &amp;= 1 + x = \frac{1 - x^2}{1 - x}\\<br>f_8(x) &amp;= 1 + x^3 + x^6 + x^9 = \frac{1}{1 - x^3}\\<br>\end{align}<br>$$<br> 设 $Ans(x) = \prod_{i = 1}^{8} f_i(x)$ ，则答案即为 $Ans(x)$ 展开后 $x^n$ 项的系数，证明可以考虑乘法原理，每一个多项式 $f_i(x)$ 中选一项 $ai_jx^j$ ，代表用第 $i$ 种食物凑成 $j$ 个的方案数有 $ai<br><em>j$ 种，乘起来方案共有 $\prod</em>{i = 1}^{8} ai_j$ 种，这些方案共献到 $x^{\sum j}$ 中，最后 $x^n$ 的系数就是最终方案数，正确性显然</p><p>现在考虑如何求系数<br>$$<br>\begin{align}<br>Ans &amp;= \prod_{i = 1}^{8} f_i(x)\\<br>    &amp;= \frac{1 - x^2}{1 - x} \frac{1 - x^3}{1 - x} \frac{x}{1 - x^2} \frac{1}{1 - x^4} \frac{1 - x^4}{1 - x} \frac{1 - x^2}{1 - x} \frac{1}{1 - x^3}\\<br>    &amp;= \frac{x}{(1 - x)^4}\\<br>    &amp;= x (1 - x)^{-4}\\<br>\text{又由} &amp;\text{牛顿广义二项式定理（广义二项式定理）：}\\<br>(x + y)^\alpha &amp;= \sum_{k = 0}^{\infty} \binom{\alpha}{k} x^{\alpha - k} y^k , \text{其中} \binom{\alpha}{k} = \frac{\alpha (\alpha - 1) (\alpha - 2) … (\alpha - k + 1)}{k!} , (\alpha \in \mathbb{R})\\<br>\text{有：} &amp; \\<br>(1 - x)^{-4} &amp;= \sum_{k = 0}^{\infty} \binom{-4}{k} 1^{-4 - k} (-x)^{k}\\<br>\text{又因} &amp;\binom{-k}{n} * (-x)^n = [(-1)^n * \binom{n+k-1}{n}] * [(-1)^n * x^n] = \binom{n+k-1}{n} x^n\\<br>\text{故} &amp; (1 - x)^4 \text{展开后} x^n \text系数为 \binom{n+k-1}{n}\\<br>\text{所以}\\<br>Ans &amp;= x (1 - x)^{-4}\\<br>    &amp;= x (\sum_{n = 0}^{\infty} \binom{n + 4 - 1}{4 - 1} x^n)\\<br>    &amp;= \sum_{n = 0}^{\infty} \binom{n + 4 - 1}{4 - 1} x^{n + 1}\\<br>\end{align}<br>$$</p><p>由上， $x^n$ 项的系数为 $\binom{n + 2}{3} = \frac{(n + 2)(n + 1)n}{6}$ ，问题得以解决</p><p> 代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500</span>, P = <span class="number">10007</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>, l = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l; ++i)</span><br><span class="line">n = (n * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>) % P;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (LL)n * (n + <span class="number">1</span>) * (n + <span class="number">2</span>) / <span class="number">6</span> % P); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;too difficult for me&lt;/p&gt;</summary>
    
    
    
    
    <category term="数论,数学" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
    <category term="生成函数" scheme="https://dyd-true.github.io/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>斜率优化dp</title>
    <link href="https://dyd-true.github.io/2021/11/22/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96dp/"/>
    <id>https://dyd-true.github.io/2021/11/22/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96dp/</id>
    <published>2021-11-22T08:42:46.000Z</published>
    <updated>2021-11-24T09:25:44.091Z</updated>
    
    <content type="html"><![CDATA[<p>然而我dp废的一比</p><span id="more"></span><p>用例题开讲：<br><a href="https://www.luogu.com.cn/problem/P2365">P2365 任务安排</a><br>明显<del>看题解</del>可知，dp方程为：<br> $f_i=min(f_j+sumt_i*(sumc_i-sumc_j)+s*(sumc_n-sunc_j),f_i)$<br> 故标程如下：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//P2365</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> t, c;</span><br><span class="line">&#125; sum[N];</span><br><span class="line"><span class="keyword">int</span> n, s;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;t, &amp;c);</span><br><span class="line">        sum[i].t = sum[i - <span class="number">1</span>].t + t;</span><br><span class="line">        sum[i].c = sum[i - <span class="number">1</span>].c + c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">            f[i] = <span class="built_in">min</span>(f[i], f[j] + sum[i].t * (sum[i].c - sum[j].c) + s * (sum[n].c - sum[j].c));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，康康这个——<a href="https://www.luogu.com.cn/problem/P5785">P5785 SDOI2012任务安排</a><br>令人惋惜的是，在数据加强后， $O(n^2)$ 的时间复杂度似乎确凿过不了，为此，我们<del>看题解后</del>想到救星——</p><h2 id="斜率优化"><a href="#斜率优化" class="headerlink" title="斜率优化"></a>斜率优化</h2><p>我们先假设所有的 $t$ 都大于0。<br>我们来康康转移方程：<br>$f_i=min(f_j+sumt_i*(sumc_i-sumc_j)+s*(sumc_n-sunc_j),f_i)$<br>不妨去掉 $min$ 看成：<br>$f_i=f_j+sumt_i*(sumc_i-sumc_j)+s*(sumc_n-sunc_j)$<br>它等价于：<br>$f_i=f_j-(sumt_i+s) * sumc_j+sumt_i* sumc_i+s* sumc_n$<br>设 $f_j=y,sumc_j=x$ （这是所有的关于 $j$ 的变量），然后化为直线表达式 $y=kx+b$ 的形式：<br>$f_j=(sumt_i+s)* sumc_j+f_i-sumt_i* sumc_i-s* umc_n$<br>不难发现 ：</p><ol><li><p>$k=sumt_i+s$ ，故 $0&lt;k&lt;\infty$ 。</p></li><li><p>且 $0 \le j \le i-1,j \in Z$  </p></li><li><p>而直线上的点为：$(f_0,sumc_0)$ 、 $(f_1,sumc_1)$ 、 … 、 $(f_{i-1},sunc_{i-1})$ </p></li><li><p>我们的目标是让 $f_i$ 最小  </p></li></ol><p>我们带着目标，看看图像：<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/u8nbza21.png" alt="xoy"><br>对于一个已知的 $i$ ， $k=sumt_i+s$ 是固定的，而若点 $(x_0,y_0)$在 $y=kx+b$ 上，那么截距 $b$ 是可以算出来的，又因 $b=f_i-sumt_i* sumc_i-s* umc_n$ ，故 $b$ 最小时 $f_i$ 最小。<br>那么，我们康康下图：<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/14w4y6tp.png" alt="xoy2"><br>图中绿色的点是所有可能的 $(x_0,y_0)$ ,红色的线是 $y=kx+b$ （只有 $k$ 确定，所以在从下往上平移）。<br>不难发现，凸包（绿线）内部的点对于 $b$ 的最小值毫无意义。换句话说，<strong>最小值的点只会在凸包上</strong>。<br>那么在凸包上哪一点呢？<br>还是上图，令构成凸包的三条直线斜率为 $k_1,k_2,k_3$ ，由凸包性质可得 $k_1&lt;k_2&lt;k_3$ 。再看看上图中我们要找的那个点（不妨设它为点 $A$ ）， $A$ 所在的两条直线斜率为 $k_2,k_3$ ,且 $k_2&lt;k&lt;k_3$ 也就是说，<strong>对于一个给定斜率为的直线 $y=kx+b$ 让它的截距 $b$ 取得最小值的点就是凸包上第一个斜率大于 $k$ 的线段的下端点</strong>。<br>由此，我们想到在单调队列中维护第一个大于某个数的点。<br>我们又发现，因为 $t$ 大于0，所以：<br>斜率是单调递增的，且新加的点的横坐标也单调递增。<br>所以：<br>在查询的时候，可以将队头小于当前斜率的点全删除掉。<br>在插入的时候，可以将队尾所有不在凸包上的点全删除掉。<br>我们便得到以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll t, c;</span><br><span class="line">&#125; sum[N];</span><br><span class="line">ll n, s;</span><br><span class="line">ll f[N];</span><br><span class="line">ll q[N], hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//除法会损失精度，故改成乘法</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_slopeh</span><span class="params">(ll x, ll y, ll o)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (f[y] - sum[y].c * s - f[x] + sum[x].c * s) &lt;= sum[o].t * (sum[y].c - sum[x].c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_slopet</span><span class="params">(ll x, ll y, ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (f[y] - sum[y].c - f[x] + sum[x].c) * (sum[b].c - sum[a].c) &gt;= (f[b] - sum[b].c - f[a] + sum[a].c) * (sum[y].c - sum[x].c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;s);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ll t, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;t, &amp;c);</span><br><span class="line">        sum[i].t = sum[i - <span class="number">1</span>].t + t;</span><br><span class="line">        sum[i].c = sum[i - <span class="number">1</span>].c + c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x7f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">check_slopeh</span>(q[hh], q[hh + <span class="number">1</span>], i))</span><br><span class="line">            hh++;</span><br><span class="line">        ll j = q[hh];</span><br><span class="line">        f[i] = f[j] + sum[i].t * (sum[i].c - sum[j].c) + s * (sum[n].c - sum[j].c);</span><br><span class="line">        <span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">check_slopet</span>(q[tt - <span class="number">1</span>], q[tt], q[tt], i))</span><br><span class="line">            tt--;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是——60分！哦可恶！题目中的 $t$ 可以为负数，咋办？</p><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><p>我们来看看 $t$ 可以为负数的情况：</p><ol><li><p>$k=sumt_i+s$ ，但 $sumt_i$ 可能小于0，故 $ -\infty &lt;k&lt; \infty$ 。</p></li><li><p>$0 \le j \le i-1,j \in Z$  </p></li><li><p>而直线上的点为：$(f_0,sumc_0)$ 、 $(f_1,sumc_1)$ 、 … 、 $(f_{i-1},sunc_{i-1})$ </p></li><li><p>我们的目标是让 $f_i$ 最小 </p></li></ol><p>其实只有 $k$ 的范围变了， $k$ 可以小于0了，所以：<br>斜率不再具有单调性，但新加的点的横坐标仍然单调递增。<br>所以：<br>在查询的时候，只能用二分来查找了。<br>但在插入的时候，仍可以将队尾所有不在凸包上的点全删除掉。<br>终于，正解如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//P5785</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll t, c;</span><br><span class="line">&#125; sum[N];</span><br><span class="line">ll n, s;</span><br><span class="line">ll f[N];</span><br><span class="line">ll q[N], hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//除法会损失精度，故改成乘法</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_slopeh</span><span class="params">(ll x, ll y, ll o)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (f[y] - sum[y].c * s - f[x] + sum[x].c * s) &lt;= sum[o].t * (sum[y].c - sum[x].c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_slopet</span><span class="params">(ll x, ll y, ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (f[y] - sum[y].c - f[x] + sum[x].c) * (sum[b].c - sum[a].c) &gt;= (f[b] - sum[b].c - f[a] + sum[a].c) * (sum[y].c - sum[x].c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">work</span><span class="params">(ll o)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll l = hh, r = tt;</span><br><span class="line">    <span class="keyword">int</span> ans = l;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        ll mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">check_slopeh</span>(q[mid], q[mid + <span class="number">1</span>], o))</span><br><span class="line">            r = mid - <span class="number">1</span>, ans = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q[ans];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;s);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ll t, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;t, &amp;c);</span><br><span class="line">        sum[i].t = sum[i - <span class="number">1</span>].t + t;</span><br><span class="line">        sum[i].c = sum[i - <span class="number">1</span>].c + c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x7f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ll j = <span class="built_in">work</span>(i);</span><br><span class="line">        f[i] = f[j] + sum[i].t * (sum[i].c - sum[j].c) + s * (sum[n].c - sum[j].c);</span><br><span class="line">        <span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">check_slopet</span>(q[tt - <span class="number">1</span>], q[tt], q[tt], i))</span><br><span class="line">            tt--;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;然而我dp废的一比&lt;/p&gt;</summary>
    
    
    
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="斜率优化" scheme="https://dyd-true.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>线段树</title>
    <link href="https://dyd-true.github.io/2021/11/22/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>https://dyd-true.github.io/2021/11/22/%E7%BA%BF%E6%AE%B5%E6%A0%91/</id>
    <published>2021-11-22T08:41:35.000Z</published>
    <updated>2021-11-24T09:25:29.699Z</updated>
    
    <content type="html"><![CDATA[<p>有点久远了，有点丑</p><span id="more"></span><h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>对于一个区间 $[x,y]$  , 我们将其分为两个区间 :  $[x,mid]$ 和 $[mid+1,y]$  , 在对这两个区间进行同样操作 , 直到无法继续 , 如图 :<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/yiorodlt.png" alt="例子"><br>不难发现 , 线段树除去最后一层后 , 一定是一颗满二叉树 , 深度为 $O(\log{}{N})$  。 所以我们用<strong>父子二倍</strong>的节点编号法:</p><ol><li><p> $root=1$ </p></li><li><p> $x$ 的左节点编号为 $x * 2$  ， 右节点编号为 $x * 2+1$ </p></li></ol><p>一个 $N$ 个叶节点线段数最多有 $4N$ 个节点 , 所以数组要开 $4$ 倍 。  </p><h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><ul><li> $sum$ ：当前区间的总和</li><li> $add$ ：懒标记，表示给以当前节点为根的子树中的每一个节点都加上 $add$ 。不难发现，为维护 $add$ ，我们用一个 $push_down()$ 来下传 $add$ 。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ST</span>&#123;</span></span><br><span class="line">ll sum,add;</span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line">&#125;tr[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[u].add)&#123;</span><br><span class="line">tr[u&lt;&lt;<span class="number">1</span>].add+=tr[u].add;</span><br><span class="line">tr[u&lt;&lt;<span class="number">1</span>].sum+=(ll)(tr[u&lt;&lt;<span class="number">1</span>].r-tr[u&lt;&lt;<span class="number">1</span>].l+<span class="number">1</span>)*tr[u].add;</span><br><span class="line">tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].add+=tr[u].add;</span><br><span class="line">tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum+=(ll)(tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].r-tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].l+<span class="number">1</span>)*tr[u].add;</span><br><span class="line">tr[u].add=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">tr[u].sum=tr[u&lt;&lt;<span class="number">1</span>].sum+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tr[u].l=l,tr[u].r=r;</span><br><span class="line">tr[u].sum=a[r];</span><br><span class="line">tr[u].add=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">tr[u].l=l,tr[u].r=r;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">push_up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)&#123;</span><br><span class="line">tr[u].sum+=(ll)(tr[u].r-tr[u].l+<span class="number">1</span>)*d;</span><br><span class="line">tr[u].add+=d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">push_down</span>(u);</span><br><span class="line"><span class="keyword">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>,l,r,d);</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid) <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,d);</span><br><span class="line"><span class="built_in">push_up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line"><span class="built_in">push_down</span>(u);</span><br><span class="line"><span class="keyword">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">ll as=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) as+=<span class="built_in">ask</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid) as+=<span class="built_in">ask</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">return</span> as;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> l,r,d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;d);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,l,r,d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">ask</span>(<span class="number">1</span>,l,r));</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用1——扫描线"><a href="#应用1——扫描线" class="headerlink" title="应用1——扫描线"></a>应用1——扫描线</h2><p><a href="https://www.luogu.com.cn/problem/P5490">P5490 【模板】扫描线</a>  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line">ll n;</span><br><span class="line">vector&lt;ll&gt;ys;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment</span>&#123;</span></span><br><span class="line">ll k;</span><br><span class="line">ll x,yl,yr;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Segment &amp;t) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&lt;t.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ll _x,ll _yl,ll _yr,ll _k)</span></span>&#123;</span><br><span class="line">x=_x;</span><br><span class="line">yl=_yl;</span><br><span class="line">yr=_yr;</span><br><span class="line">k=_k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;seg[N*<span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LineTree</span>&#123;</span></span><br><span class="line">ll l,r;</span><br><span class="line">ll cnt;</span><br><span class="line">ll len;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ll _l,ll _r,ll _cnt,ll _len)</span></span>&#123;</span><br><span class="line">l=_l;</span><br><span class="line">r=_r;</span><br><span class="line">cnt=_cnt;</span><br><span class="line">len=_len;</span><br><span class="line">&#125;</span><br><span class="line">&#125;tr[N*<span class="number">8</span>];</span><br><span class="line"><span class="function">ll <span class="title">find</span><span class="params">(ll y)</span></span>&#123;</span><br><span class="line"><span class="comment">//lower_bound()函数用于在指定区域内查找不小于目标值的第一个元素。</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">lower_bound</span>(ys.<span class="built_in">begin</span>(),ys.<span class="built_in">end</span>(),y)-ys.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(ll u)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[u].cnt) tr[u].len=ys[tr[u].r+<span class="number">1</span>]-ys[tr[u].l];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(tr[u].l!=tr[u].r)</span><br><span class="line">tr[u].len=tr[u&lt;&lt;<span class="number">1</span>].len+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].len;</span><br><span class="line"><span class="keyword">else</span> tr[u].len=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll u,ll l,ll r)</span></span>&#123;</span><br><span class="line">tr[u].<span class="built_in">init</span>(l,r,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(l!=r)&#123;</span><br><span class="line">ll mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(ll u,ll l,ll r,ll k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)&#123;</span><br><span class="line">tr[u].cnt+=k;</span><br><span class="line"><span class="built_in">push_up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">ll mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid) <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">        <span class="built_in">push_up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">ys.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">ll xr,xl,yr,yl;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld&quot;</span>,&amp;xl,&amp;yl,&amp;xr,&amp;yr);</span><br><span class="line">seg[j++].<span class="built_in">init</span>(xl,yl,yr,<span class="number">1</span>);</span><br><span class="line">seg[j++].<span class="built_in">init</span>(xr,yl,yr,<span class="number">-1</span>);</span><br><span class="line">ys.<span class="built_in">push_back</span>(yl),ys.<span class="built_in">push_back</span>(yr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(ys.<span class="built_in">begin</span>(),ys.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//unique函数功能是去除相邻的重复元素</span></span><br><span class="line"><span class="comment">//它并不真正把重复的元素删除,而是将无重复的元素复制到序列的前段,</span></span><br><span class="line"><span class="comment">//从而覆盖相邻的重复元素.unique返回的迭代器指向超出无重复的元素范围末端的下一个位置.</span></span><br><span class="line"><span class="comment">//erase:删除</span></span><br><span class="line">ys.<span class="built_in">erase</span>(<span class="built_in">unique</span>(ys.<span class="built_in">begin</span>(),ys.<span class="built_in">end</span>()),ys.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">0</span>,ys.<span class="built_in">size</span>()<span class="number">-2</span>);</span><br><span class="line"><span class="built_in">sort</span>(seg,seg+n*<span class="number">2</span>);</span><br><span class="line">ll res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n*<span class="number">2</span>;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;<span class="number">0</span>) res+=tr[<span class="number">1</span>].len*(seg[i].x-seg[i<span class="number">-1</span>].x);</span><br><span class="line"><span class="built_in">modify</span>(<span class="number">1</span>,<span class="built_in">find</span>(seg[i].yl),<span class="built_in">find</span>(seg[i].yr)<span class="number">-1</span>,seg[i].k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>以下是一个维护最值的线段树的修改操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//单点修改,将[x,x]的值改为z</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l[p]==r[p]) dmax[p]=z,<span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> mid=(l[p]+r[p])&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) <span class="built_in">Modify</span>(p&lt;&lt;<span class="number">1</span>,x,z);</span><br><span class="line"><span class="keyword">if</span>(y&gt;mid) <span class="built_in">Modify</span>(p&lt;&lt;|<span class="number">1</span>,x,z);</span><br><span class="line"><span class="comment">//从下往上跟新信息,也叫push_up </span></span><br><span class="line">dmax[p]=<span class="built_in">max</span>(dmax[p&lt;&lt;<span class="number">1</span>],dmax[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125; </span><br><span class="line">   <span class="comment">//调用入口: st.Modify(1,x,z);</span></span><br></pre></td></tr></table></figure><p>以下是一个维护区间和的线段树，支持区间增加，区间乘法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//洛谷P3373 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[N],mod;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ST</span>&#123;</span><span class="comment">//SegmentTree</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dat[N*<span class="number">4</span>];<span class="comment">//维护区间和</span></span><br><span class="line"><span class="keyword">int</span> l[N*<span class="number">4</span>],r[N*<span class="number">4</span>];<span class="comment">//区间 </span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> add[N*<span class="number">4</span>],mul[N*<span class="number">4</span>];<span class="comment">//懒惰标记(lazytag) </span></span><br><span class="line"><span class="comment">//建立区间ll-rr,编号为p </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> ll,<span class="keyword">int</span> rr)</span></span>&#123;</span><br><span class="line"><span class="comment">//初始化lazytag </span></span><br><span class="line">add[p]=<span class="number">0</span>;</span><br><span class="line">mul[p]=<span class="number">1</span>; </span><br><span class="line">l[p]=ll;r[p]=rr;<span class="comment">//以p为编号的节点维护的区间为ll到rr</span></span><br><span class="line"><span class="comment">//ll==rr的话,这个区间就只有一个数,直接让区间维护的值等于a[ll]</span></span><br><span class="line"><span class="keyword">if</span>(ll==rr)</span><br><span class="line">dat[p]=a[ll];</span><br><span class="line"><span class="comment">//否则维护的值等于左儿子加右儿子</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(ll+rr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">Build</span>(p&lt;&lt;<span class="number">1</span>,ll,mid);</span><br><span class="line"><span class="built_in">Build</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,rr);</span><br><span class="line">dat[p]=dat[p&lt;&lt;<span class="number">1</span>]+dat[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];<span class="comment">//当然,具体的维护视题目而定</span></span><br><span class="line">&#125;</span><br><span class="line">dat[p]%=mod; </span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//懒惰标记,规定乘法优先</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Spread</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="comment">//如果懒标记不为0,就将其下传,修改左右儿子维护的值 </span></span><br><span class="line"><span class="keyword">if</span>(add[p]!=<span class="number">0</span>||mul[p]!=<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//根据我们规定的优先度,儿子的值=</span></span><br><span class="line"><span class="comment">//此刻儿子的值*爸爸的乘法lazytag+</span></span><br><span class="line"><span class="comment">//儿子的区间长度*爸爸的加法lazytag</span></span><br><span class="line">dat[p&lt;&lt;<span class="number">1</span>]=(dat[p&lt;&lt;<span class="number">1</span>]*mul[p]+add[p]*(r[p&lt;&lt;<span class="number">1</span>]-l[p&lt;&lt;<span class="number">1</span>]+<span class="number">1</span>))%mod;</span><br><span class="line">dat[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(dat[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]*mul[p]+add[p]*(r[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]-l[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1</span>))%mod;</span><br><span class="line"><span class="comment">//为该节点的左右儿子打上标记,</span></span><br><span class="line">mul[p&lt;&lt;<span class="number">1</span>]=(mul[p&lt;&lt;<span class="number">1</span>]*mul[p])%mod;</span><br><span class="line">mul[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(mul[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]*mul[p])%mod; </span><br><span class="line"><span class="comment">//由于乘法优先,加法打标记时要先乘一下 </span></span><br><span class="line">add[p&lt;&lt;<span class="number">1</span>]=(add[p&lt;&lt;<span class="number">1</span>]*mul[p]+add[p])%mod;</span><br><span class="line">add[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(add[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]*mul[p]+add[p])%mod;</span><br><span class="line"><span class="comment">//下传之后将父节点的懒标记清0</span></span><br><span class="line">mul[p]=<span class="number">1</span>;</span><br><span class="line">add[p]=<span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//区间修改,将区间[x,y]都加上z </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Change_add</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=l[p]&amp;&amp;y&gt;=r[p])&#123;<span class="comment">//被覆盖的话,就对其进行修改</span></span><br><span class="line">dat[p]+=(<span class="keyword">long</span> <span class="keyword">long</span>)z*(r[p]-l[p]+<span class="number">1</span>);</span><br><span class="line">dat[p]%=mod;</span><br><span class="line">add[p]=(add[p]+z)%mod;<span class="comment">//打上懒标记</span></span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果没有被覆盖,就继续向下找,但儿子所维护的区间可能因为</span></span><br><span class="line"><span class="comment">//懒标记的存在而没有修改,因此将懒标记下放</span></span><br><span class="line"><span class="built_in">Spread</span>(p);</span><br><span class="line"><span class="keyword">int</span> mid=(l[p]+r[p])&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) <span class="built_in">Change_add</span>(p&lt;&lt;<span class="number">1</span>,x,y,z);<span class="comment">//如果要修改的区间覆盖了左儿子</span></span><br><span class="line"><span class="keyword">if</span>(y&gt;mid) <span class="built_in">Change_add</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,y,z);<span class="comment">//右儿子同理</span></span><br><span class="line"><span class="comment">//维护值</span></span><br><span class="line">dat[p]=(dat[p&lt;&lt;<span class="number">1</span>]+dat[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])%mod;</span><br><span class="line"><span class="keyword">return</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//区间修改,将区间[x,y]都乘上z</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Change_mul</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=l[p]&amp;&amp;y&gt;=r[p])&#123;</span><br><span class="line">dat[p]=(dat[p]*z)%mod;</span><br><span class="line">mul[p]=(mul[p]*z)%mod;</span><br><span class="line"><span class="comment">//乘法优先,故加法标记也要乘</span></span><br><span class="line">add[p]=(add[p]*z)%mod;</span><br><span class="line"><span class="keyword">return</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//否则同加法,向下找</span></span><br><span class="line"><span class="built_in">Spread</span>(p);</span><br><span class="line"><span class="keyword">int</span> mid=(l[p]+r[p])&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) <span class="built_in">Change_mul</span>(p&lt;&lt;<span class="number">1</span>,x,y,z);</span><br><span class="line"><span class="keyword">if</span>(y&gt;mid) <span class="built_in">Change_mul</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,y,z);</span><br><span class="line">dat[p]=(dat[p&lt;&lt;<span class="number">1</span>]+dat[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])%mod;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//区间查询,查询[x,y]的和 </span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=l[p]&amp;&amp;y&gt;=r[p]) <span class="keyword">return</span> dat[p];<span class="comment">//如果被覆盖，就返回维护的值</span></span><br><span class="line"><span class="comment">//下传懒标记，并查询左右儿子</span></span><br><span class="line"><span class="built_in">Spread</span>(p);</span><br><span class="line"><span class="keyword">int</span> mid=(l[p]+r[p])&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) ans=(ans+<span class="built_in">Ask</span>(p&lt;&lt;<span class="number">1</span>,x,y))%mod;</span><br><span class="line"><span class="keyword">if</span>(y&gt;mid) ans=(ans+<span class="built_in">Ask</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,y));</span><br><span class="line"><span class="keyword">return</span> ans%mod;</span><br><span class="line">&#125; </span><br><span class="line">&#125;st;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;mod);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">st.<span class="built_in">Build</span>(<span class="number">1</span>,<span class="number">1</span>,n); </span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="keyword">int</span> q,x,y,z;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line"><span class="keyword">if</span>(q==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">st.<span class="built_in">Change_mul</span>(<span class="number">1</span>,x,y,z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(q==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">st.<span class="built_in">Change_add</span>(<span class="number">1</span>,x,y,z);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,st.<span class="built_in">Ask</span>(<span class="number">1</span>,x,y));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注：打线段树的时候一定要注意两端取等 </span></span><br><span class="line"><span class="comment">//如51行两端取等，61、62行单边取等 </span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;有点久远了，有点丑&lt;/p&gt;</summary>
    
    
    
    
    <category term="数据结构" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树" scheme="https://dyd-true.github.io/tags/%E6%A0%91/"/>
    
    <category term="线段树" scheme="https://dyd-true.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>网络流</title>
    <link href="https://dyd-true.github.io/2021/11/22/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    <id>https://dyd-true.github.io/2021/11/22/%E7%BD%91%E7%BB%9C%E6%B5%81/</id>
    <published>2021-11-22T08:36:17.000Z</published>
    <updated>2021-11-24T09:25:05.825Z</updated>
    
    <content type="html"><![CDATA[<p>老有用了</p><span id="more"></span><h2 id="网络流的基本概念："><a href="#网络流的基本概念：" class="headerlink" title="网络流的基本概念："></a>网络流的基本概念：</h2><p>一个有向图 $G=(V,E)$ ，每条有向边 $(x,y)$ 都有一个给定的<strong>容量</strong>记为 $c(x,y)$ （若 $c(x,y)=0$ ，就说明不存在边 $(x,y)$ ），图中还有两个特殊节点<strong>源点</strong>、<strong>汇点</strong>分别记为 $S$ 、 $T$ 。 $S$ 会源源不断地流出无穷的水流，但每条边只能通过 $c(x,y)$ 的水流， $T$ 可以容纳无穷的水流，而其余个点无法容纳水流（即流入就必须全部流出）。<br>任意一种满足条件的流水方法（即让水流从 $S$ 流到 $T$ ）叫做<strong>流函数</strong>，记为 $f(x,y)$ （表示从点 $x$ 流向 $y$ 的水流），明显，流函数具有如下性质：</p><ul><li><p>$0 \le f(x,y) \le c(x,y)$</p></li><li><p>$f(x,y)=-f(y,x)$ （即从 $x$ 流向 $y$ 的流量也就是从 $y$ 流向 $x$ 的流量的相反数）</p></li><li><p>$\forall x \ne S,T, \sum\limits_{u,x\in     E}^{}f(u,x)= \sum\limits_{x,v\in     E}^{}f(x,v)$ （即除 $S$ ， $T$ 外其余点流入流量等于流出流量，流量守恒）</p></li></ul><h2 id="残量网络"><a href="#残量网络" class="headerlink" title="残量网络"></a>残量网络</h2><p>对于任意合法的流函数 $f$ ，都可构建一个新图 $G2$ （其实应该记做 $G’$ 但这里为了方便记为 $G2$ ），构建方法如下：</p><ol><li>将原图每条边容量变为 $c(x,y)-f(x,y)$ （即减掉已经用掉的流量）</li><li>对于每条边 $(x,y)$ ，创建它的反向边 $(y,x)$ 并令 $c(y,x)=f(x,y)$ （即以流的流量让它可以反悔再流回来）</li></ol><p>该图G2被我们叫做<strong>残量网络</strong><br>需要注意的是,反向边是我们新加的,原图中并不存在,若原图中本就有边 $(x,y)$ 和边 $(y,x)$ （即原图就有反向边），应在构建原图 $G$ 时就新建一点 $z$ ，使得 $(y,x)$ 变为 $(y,z)$ ， $(z,x)$ 。<br>如图（画的丑求你憋着吧！）<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/2fzwiq9k.png" alt="输入"><br> $\uparrow$ 这是输入的有向图。<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/qp8a10w5.png" alt="G"><br> $\uparrow$ 这是去掉反向边的原图 $G$ 。<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/eri7qydk.png" alt="f"><br> $\uparrow$ 这是一个合法的流函数，图中绿色代表 $f(x,y)$ 。<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/pq7ur9ym.png" alt="G2"><br> $\uparrow$ 这是该流函数的残量网络，蓝色为原图边容量（已改变），紫色为加入的反向边。</p><h2 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h2><p>给定一个网络 $G$ ,对于所有合法的 $f$ ,从 $S$ 流出的流量最大的记为该网络的最大流，如上图中最大流为 $7$ （即是绿色的流函数）<br>最大流的求法很多,但基本思路大体相同：</p><ol><li><p>先找到任意的一个流函数 $f$ ，并构建它的残量网络 $G2$ </p></li><li><p>在 $G2$ 中寻找 $G2$ 的合法流函数（我们一般记其为 $f’$ ，文中称其为 $f2$ ， $f2$ 也叫做<strong>增广路</strong>）</p></li><li><p>将找到的增广路加上原图的流函数构成新的流函（即 $f_{now}=f+f2$ 并将 $G2$ 更新成为 $f_{now}$ 的残量网络）</p></li><li><p>重复第 $2$ ， $3$ 步直到无增广路，此时的 $f$ 即是最大流</p></li></ol><p>该思路的证明比较简单，想了解的可以自己百度，下面放两种算法（都已通过<a href="https://www.luogu.com.cn/problem/P3376">P3376</a>）：</p><h3 id="一-Edmonds-Karp-EK算法"><a href="#一-Edmonds-Karp-EK算法" class="headerlink" title="一.Edmonds-Karp(EK算法)"></a>一.Edmonds-Karp(EK算法)</h3><p>该算法就是以上思路的直接实现，（未优化版）几乎不会用，仅了解即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Edmonds-Karp    O(nm^2)</span></span><br><span class="line"><span class="comment">//n+m = 10^3~10^4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000</span>+<span class="number">5</span>,M=<span class="number">20000</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,S,T;</span><br><span class="line"><span class="keyword">int</span> q[N],incf[N],pre[N];<span class="comment">//q队列,incf残留网络流量,pre前驱边 </span></span><br><span class="line"><span class="keyword">bool</span> vis[N]; </span><br><span class="line"><span class="keyword">int</span> h[N],e[M],f[M],ne[M],idx=<span class="number">0</span>;<span class="comment">//e目标编号,f该边流量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> c)</span></span>&#123;<span class="comment">//使用成对储存的技巧i^1及是i的反向边,不懂的请看第二大部分</span></span><br><span class="line">e[idx]=y,f[idx]=c;</span><br><span class="line">ne[idx]=h[x],h[x]=idx++;</span><br><span class="line"></span><br><span class="line">e[idx]=x,f[idx]=<span class="number">0</span>;</span><br><span class="line">ne[idx]=h[y],h[y]=idx++;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;<span class="comment">//寻找增广路 </span></span><br><span class="line"><span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">q[<span class="number">0</span>]=S,vis[S]=<span class="literal">true</span>,incf[S]=INF;<span class="comment">//初始化,把S的出流量定为无穷大 </span></span><br><span class="line"><span class="keyword">while</span>(hh&lt;=tt)&#123;</span><br><span class="line"><span class="keyword">int</span> t=q[hh++];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i])&#123;</span><br><span class="line"><span class="keyword">int</span> ver=e[i];</span><br><span class="line"><span class="keyword">if</span>(!vis[ver]&amp;&amp;f[i])&#123;<span class="comment">//未到过且还有流量 </span></span><br><span class="line">vis[ver]=<span class="literal">true</span>;</span><br><span class="line">incf[ver]=<span class="built_in">min</span>(incf[t],f[i]);<span class="comment">//最大流量为各边流量最小值 </span></span><br><span class="line">pre[ver]=i;<span class="comment">//记录前驱边 </span></span><br><span class="line"><span class="keyword">if</span>(ver==T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">q[++tt]=ver;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">EK</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> maxflow=<span class="number">0</span>;<span class="comment">//这里仅是本人习惯开了long long</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;<span class="comment">//若存在增广路 </span></span><br><span class="line">maxflow+=incf[T]; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=T;i!=S;i=e[pre[i]^<span class="number">1</span>])&#123;<span class="comment">//pre[i]为前驱边-&gt;pre[i]^1为前驱边的反向边 </span></span><br><span class="line">                                                        <span class="comment">//-&gt;e[pre[i]^]为该反向边的目标点,即是前一个点</span></span><br><span class="line"><span class="comment">//更改残留网络 </span></span><br><span class="line">f[pre[i]]-=incf[T];</span><br><span class="line">f[pre[i]^<span class="number">1</span>]+=incf[T];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;S,&amp;T);</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line"><span class="keyword">int</span> x,y,c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;c);</span><br><span class="line"><span class="built_in">add</span>(x,y,c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld&quot;</span>,<span class="built_in">EK</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二-Di-nic算法"><a href="#二-Di-nic算法" class="headerlink" title="二.Di#nic算法"></a>二.Di#nic算法</h3><p>通过构建<strong>分层图</strong>来使增广时一次性增广多条增广路,是以上思路的优化,本人较为偏爱该算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dinic   O(n^2m)</span></span><br><span class="line"><span class="comment">//n+m = 10^4~10^5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll; </span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1000</span>+<span class="number">5</span>,M=<span class="number">20000</span>+<span class="number">5</span>;<span class="comment">//有方向边M要开2倍 </span></span><br><span class="line"><span class="keyword">const</span> ll INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">ll n,m,S,T;</span><br><span class="line">ll q[N],d[N],cur[N];<span class="comment">//q队列,d高度,cur当前弧优化 </span></span><br><span class="line">ll h[N],e[M],f[M],ne[M],idx=<span class="number">0</span>;<span class="comment">//h,e,ne,idx邻接表,f流量 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll x,ll y,ll c)</span></span>&#123; </span><br><span class="line">e[idx]=y,f[idx]=c;</span><br><span class="line">ne[idx]=h[x],h[x]=idx++;</span><br><span class="line"></span><br><span class="line">e[idx]=x,f[idx]=<span class="number">0</span>;</span><br><span class="line">ne[idx]=h[y],h[y]=idx++;</span><br><span class="line"><span class="keyword">return</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;<span class="comment">//寻找有无增广路并建立分层图 </span></span><br><span class="line">ll hh=<span class="number">0</span>,tt=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">q[<span class="number">0</span>]=S,d[S]=<span class="number">0</span>,cur[S]=h[S]; <span class="comment">//S初始高度为0,当前弧初始为第一条出边 </span></span><br><span class="line"><span class="keyword">while</span>(hh&lt;=tt)&#123;</span><br><span class="line">ll t=q[hh++];</span><br><span class="line"><span class="keyword">for</span>(ll i=h[t];i!=<span class="number">-1</span>;i=ne[i])&#123;</span><br><span class="line">ll ver=e[i];</span><br><span class="line"><span class="keyword">if</span>(d[ver]==<span class="number">-1</span> &amp;&amp;f[i])&#123;<span class="comment">//一定要判断容量大于0 </span></span><br><span class="line">d[ver]=d[t]+<span class="number">1</span>;<span class="comment">//层数 </span></span><br><span class="line">cur[ver]=h[ver];<span class="comment">//当前弧初始为第一条出边 </span></span><br><span class="line"><span class="keyword">if</span>(ver==T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">q[++tt]=ver;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">find</span><span class="params">(ll u,ll limit)</span></span>&#123;<span class="comment">//找到增广路,find(u,limit)表示从点u开始,</span></span><br><span class="line"><span class="comment">//从S到u的最大容量为limit </span></span><br><span class="line"><span class="keyword">if</span>(u==T) <span class="keyword">return</span> limit;</span><br><span class="line">ll flow=<span class="number">0</span>;<span class="comment">//flow表示从u向T流的最大流量 </span></span><br><span class="line"><span class="keyword">for</span>(ll i=cur[u];i!=<span class="number">-1</span>&amp;&amp;flow&lt;limit;i=ne[i])&#123;<span class="comment">//从未满的路径开始搜</span></span><br><span class="line"><span class="comment">//flow&lt;limit是很重要的优化! </span></span><br><span class="line">cur[u]=i;<span class="comment">//当前弧优化,搜到i就意味着i前的边已用完,将当前弧更新 </span></span><br><span class="line">ll ver=e[i];</span><br><span class="line"><span class="keyword">if</span>(d[ver]==d[u]+<span class="number">1</span>&amp;&amp;f[i])&#123;<span class="comment">//保证当前点在上一点的下一层,同样要注意f&gt;0 </span></span><br><span class="line">ll t=<span class="built_in">find</span>(ver,<span class="built_in">min</span>(f[i],limit-flow));</span><br><span class="line"><span class="keyword">if</span>(!t) d[ver]=<span class="number">-1</span>;<span class="comment">//若t到终点无增广路径,就删去点ver(把ver高度定为-1) </span></span><br><span class="line"></span><br><span class="line">f[i]-=t;</span><br><span class="line">f[i^<span class="number">1</span>]+=t;</span><br><span class="line">flow+=t; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">ll maxflow=<span class="number">0</span>,flow;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">bfs</span>())<span class="comment">//若存在增广路 </span></span><br><span class="line"><span class="keyword">while</span>(flow=<span class="built_in">find</span>(S,INF)) <span class="comment">//找出当前图上所有增广路 </span></span><br><span class="line">maxflow+=flow;</span><br><span class="line"><span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld&quot;</span>,&amp;n,&amp;m,&amp;S,&amp;T);</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">ll x,y,c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;x,&amp;y,&amp;c);</span><br><span class="line"><span class="built_in">add</span>(x,y,c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="built_in">Dinic</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="无源汇上下界可行流"><a href="#无源汇上下界可行流" class="headerlink" title="无源汇上下界可行流"></a>无源汇上下界可行流</h2><p>在这类问题中不在仅存在容量上界 $c$ ，还存在下界（不妨记为 $l$ ），并且不存在 $S$ ， $T$ 两点。<br>对于此类问题，我们可以用如下操作变为网络最大流：</p><ol><li><p>新建源点和汇点</p></li><li><p>为满足性质1（忘了的上去看），将 $c$ 变为 $c-l$ ，即原来 $(x,y) \le f(x,y) \le c(x,y)$ 变为 $0 \le f(x,y) \le c(x,y)-l(x,y)$ </p></li><li><p>经过第2步后我们发现流量不守恒，故用一个数组 $ve$ （Virtual Edge）储存每个点的流量变化量，即对于边 $(x,y)$ ，经第2步变化后， $x$ 的出流量少了 $l(x,y)$ ， $y$ 的入流量少了 $l(x,y)$ ，故 $ve(x)-=l(x,y)$ ， $ve(y)+=l(x,y)$ </p></li><li><p>利用第3步统计的 $ve$ 数组，新建虚拟边使流量守恒，即若 $ve(x)&gt;0$ ，新建边 $(S,x)$ 并令 $c(S,x)=ve(x)$ ；若 $ve(x)&lt;0$ ，新建边 $(x,T)$ 并令 $c(x,T)=-ve(x)$ ；</p></li><li><p>跑一遍 $S$ 到 $T$ 的最大流，若 $S$ （或 $T$ ）的所有边都可以流满，就说明存在可行流</p></li></ol><p>经过如上操作，就将其变为一个基本的最大流问题，我们把这样建成的图称作虚拟图（仅是本人习惯），记为 $G3$ 。</p><h2 id="有源汇上下界可行流"><a href="#有源汇上下界可行流" class="headerlink" title="有源汇上下界可行流"></a>有源汇上下界可行流</h2><p>终于步入正题了<br>此类问题相比于上一类区别在于原题中就存在源点和汇点（为以示区别记为 $s$ 、 $t$ ）。<br>而解决方式与上类问题类似，区别仅在于我们要将点 $s$ 、 $t$ 这两个不满足流量守恒的点变为普通点，再用新建的 $S$ 、 $T$ 当为源点。<br>而使其守恒的方式即是新建一条边 $(t,s)$ 并令<br> $c(t,s)= \infty$ （正无穷）。</p><h2 id="有源汇上下界最大流"><a href="#有源汇上下界最大流" class="headerlink" title="有源汇上下界最大流"></a>有源汇上下界最大流</h2><p>好，现在问题来了，我们求解可行流时就是求的 $G3$ 的最大流，那么如果我们现在要求原图 $G$ 的可行流中的最大流我们该怎么办？<br>仔细思考，发现我们还有一个图没用——原图的残量网络 $G2$ ！辣么，我们可否使用这三个图求出答案呢？<br>当然是可以的，<del>不然我讲个屁啊</del>，而方法如下： </p><ol><li>同上类问题跑出 $G3$ 的最大流记为 $flow3$ ，并将此时原图中的流函数记为 $f3$ 。</li><li>构建原图 $G$ 关于 $f3$ 的残量网络 $G2$ ，求出 $G2$ 中的曾广路，我们发现这就等价于求出 $G$ 的最大流 $flow$ （注意此时用的是原图 $G$ ，故应删去边 $(t,s)$ ）</li><li>最后答案即是 $flow+flow3$ </li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有 $n$ 天， $m$ 位少女，至少为她们每人拍 $G(i)$ 张照片，每天总的最多拍 $D(i)$ 张，且每天只能为特定的少女拍照，张数为 $x \in [L,R]$ 。</p><h3 id="建立模型"><a href="#建立模型" class="headerlink" title="建立模型"></a>建立模型</h3><p>我们可以很轻松的<del>由题目标题</del>得出应使用网络流，并在稍微，<del>指3天</del>，思考后得出如下方法：</p><ul><li>建立原图 $G$ ：<ol><li>建立源点 $s=1$ ，汇点 $t=m+n+2$ ，并将少女建为点 $2 \sim  m+1$ ，天数建为点 $m+2 \sim n+m+1$ </li><li>将少女至少要拍的照片数 $G(i)$ 定为下界，无穷大定为上界，让少女 $x$ 与源点 $s$ 相连，即建立边 $(s,x)$ （ $x \in [2,m+1]$ ）并使 $c(s,x)=\infty -G(i)$ </li><li>将每天的最大拍照量定为上界， $0$ 为下界，让天数 $y$ 与汇点 $t$ 相连，即建边 $(y,t)$ （ $y \in [m+2,m+n+1]$ ）并使 $c(y,t)=D(i)-0$ </li><li>将少女与天相连，定上下界为 $[L,R]$ ，即建边 $(x,y)$ （ $x \in [2,m+1],y \in [m+2,m+n+1]$ ）并使 $c(x,y)=R-L$ </li><li>在构建原图的同时维护 $ve$ 数组</li></ol></li><li>构建虚拟图 $G3$ ：<ol><li>建立源点 $S=0$ ， $T=n+m+3$ </li><li>用 $ve$ 数组建立连接 $S$ ， $T$ 与其他点的边</li><li>增加边 $(t,s)$ ，并使 $c(t,s)=\infty$ </li><li>并同时维护 $outflow$ （记录从S流出的流量,用于判定是否满流）</li></ol></li><li>求解 $G3$ 的最大流<ol><li>直接用Dinic求解</li><li>判断 $Dinic()$ 是否等于 $outflow$ ，若不等，则说明原图无可行流（原题无解）</li><li>若相等，用 $res$ 记录此时 $s$ 到 $t$ 的流量，并进入下一步</li></ol></li><li>求解 $G$ 的最大流（即是 $G2$ 中的曾广路）<ol><li>删去边 $(t,s)$ </li><li>使 $S=s$ ， $T=t$ （即将 $G3$ 变为 $G$ ）</li><li>Dinic求解最大流，答案即为 $Dinic()+res$ </li></ol></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000000</span>+<span class="number">5</span>,M=<span class="number">1000000</span>+<span class="number">5</span>,INF=<span class="number">2147483647</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;<span class="comment">//如题意 </span></span><br><span class="line"><span class="keyword">int</span> nn,s,t,S,T;<span class="comment">//nn:原图中的点数,s:原图的源点,S虚拟图的源点,t,T同理 </span></span><br><span class="line"><span class="keyword">int</span> q[N],d[N],cur[N],ve[N];<span class="comment">//q:队列,d:高度,cur:当前弧优化,ve(Virtual Edge):虚拟边 </span></span><br><span class="line"><span class="keyword">int</span> h[N],e[N],f[N],ne[N],idx=<span class="number">0</span>;<span class="comment">//h,e,ne,idx:邻接表,f:流量 </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">e[idx]=y,f[idx]=c,ne[idx]=h[x],h[x]=idx++;</span><br><span class="line">e[idx]=x,f[idx]=<span class="number">0</span>,ne[idx]=h[y],h[y]=idx++;<span class="comment">//使用成对储存的技巧 </span></span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&lt;b? a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;<span class="comment">//寻找有无增广路并建立分层图 </span></span><br><span class="line"><span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">q[hh]=S,d[S]=<span class="number">0</span>,cur[S]=h[S];<span class="comment">//S初始高度为0,当前弧初始为第一条出边 </span></span><br><span class="line"><span class="keyword">while</span>(hh&lt;=tt)&#123;</span><br><span class="line"><span class="keyword">int</span> p=q[hh++];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[p];i!=<span class="number">-1</span>;i=ne[i])&#123;</span><br><span class="line"><span class="keyword">int</span> ver=e[i];</span><br><span class="line"><span class="keyword">if</span>(d[ver]==<span class="number">-1</span>&amp;&amp;f[i])&#123;<span class="comment">//一定要判断容量大于0 </span></span><br><span class="line">d[ver]=d[p]+<span class="number">1</span>;<span class="comment">//层数  </span></span><br><span class="line">cur[ver]=h[ver];<span class="comment">//当前弧初始为第一条出边 </span></span><br><span class="line"><span class="keyword">if</span>(ver==T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">q[++tt]=ver;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> limit)</span></span>&#123;<span class="comment">//找到增广路,find(u,limit)表示从点u开始,</span></span><br><span class="line"><span class="comment">//从S到u的最大容量为limit </span></span><br><span class="line"><span class="keyword">if</span>(u==T) <span class="keyword">return</span> limit;</span><br><span class="line"><span class="keyword">int</span> nowflow=<span class="number">0</span>;<span class="comment">//nowflow表示从u向T流的最大流量 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=cur[u];i!=<span class="number">-1</span>&amp;&amp;nowflow&lt;limit;i=ne[i])&#123;<span class="comment">//从未满的路径开始搜</span></span><br><span class="line"><span class="comment">//nowflow&lt;limit是很重要的优化! </span></span><br><span class="line">cur[u]=i;<span class="comment">//当前弧优化,搜到i就意味着i前的边已用完,将当前弧更新 </span></span><br><span class="line"><span class="keyword">int</span> ver=e[i];</span><br><span class="line"><span class="keyword">if</span>(d[ver]==d[u]+<span class="number">1</span>&amp;&amp;f[i])&#123;<span class="comment">//保证当前点在上一点的下一层,同样要注意f&gt;0 </span></span><br><span class="line"><span class="keyword">int</span> tflow=<span class="built_in">find</span>(ver,<span class="built_in">min</span>(f[i],limit-nowflow));</span><br><span class="line"><span class="keyword">if</span>(!tflow) d[ver]=<span class="number">-1</span>;<span class="comment">//若t到终点无增广路径,就删去点ver(把ver高度定为-1) </span></span><br><span class="line">f[i]-=tflow,f[i^<span class="number">1</span>]+=tflow,nowflow+=tflow;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nowflow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> maxflow=<span class="number">0</span>,inflow;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">bfs</span>())<span class="comment">//若存在增广路 </span></span><br><span class="line"><span class="keyword">while</span>(inflow=<span class="built_in">find</span>(S,INF))  maxflow+=inflow;<span class="comment">//找出当前图上所有增广路 </span></span><br><span class="line"><span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m))&#123;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="built_in">memset</span>(ve,<span class="number">0</span>,<span class="keyword">sizeof</span> ve);</span><br><span class="line"><span class="comment">//构建原图 </span></span><br><span class="line">s=<span class="number">1</span>,t=n+m+<span class="number">2</span>;<span class="comment">//原图中s=1为源点,t=n+m+2为汇点 </span></span><br><span class="line">nn=n+m+<span class="number">2</span>;<span class="comment">//nn:原图的点数 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m+<span class="number">1</span>;++i)&#123;<span class="comment">//将少女编号为2~m+1,并和源点连通 </span></span><br><span class="line"><span class="keyword">int</span> G;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;G);</span><br><span class="line"><span class="built_in">add</span>(s,i,INF-G);</span><br><span class="line">ve[i]+=G;</span><br><span class="line">ve[s]-=G;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=m+<span class="number">2</span>;i&lt;=m+n+<span class="number">1</span>;++i)&#123;<span class="comment">//将天数编号为m+2~m+n+1,并和汇点连通 </span></span><br><span class="line"><span class="keyword">int</span> C,D;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;C,&amp;D);</span><br><span class="line"><span class="built_in">add</span>(i,t,D);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=C;++j)&#123;<span class="comment">//将天与少女连通 </span></span><br><span class="line"><span class="keyword">int</span> TT,L,R;<span class="comment">//TT即为题中的T</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;TT,&amp;L,&amp;R);</span><br><span class="line">TT+=<span class="number">2</span>;<span class="comment">//注意输入中的少女是从0编号的</span></span><br><span class="line"><span class="built_in">add</span>(TT,i,R-L);</span><br><span class="line">ve[TT]-=L;<span class="comment">//一定要减L,别减R！ </span></span><br><span class="line">ve[i]+=L; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构建虚拟图 </span></span><br><span class="line">S=<span class="number">0</span>,T=n+m+<span class="number">3</span>;<span class="comment">//S=0为虚拟图源点,T=n+m+3为虚拟图汇点 </span></span><br><span class="line"><span class="keyword">int</span> outflow=<span class="number">0</span>;<span class="comment">//记录从虚拟源点出流量,用于判断是否是满流 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nn;++i)&#123;<span class="comment">//创建虚拟边保证虚拟图中流量守恒 </span></span><br><span class="line"><span class="keyword">if</span>(ve[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">add</span>(S,i,ve[i]);</span><br><span class="line">outflow+=ve[i]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ve[i]&lt;<span class="number">0</span>) <span class="built_in">add</span>(i,T,-ve[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">add</span>(t,s,INF);<span class="comment">//增加一条从t到s的边,保证流量守恒 </span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Dinic</span>()&lt;outflow) <span class="built_in">printf</span>(<span class="string">&quot;-1\n\n&quot;</span>);<span class="comment">//务必两个\n </span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=f[idx<span class="number">-1</span>];<span class="comment">//最后加的边的反向边的流量</span></span><br><span class="line"><span class="comment">//即是当前(虚拟图的)满流中s-&gt;t的流量</span></span><br><span class="line">f[idx<span class="number">-1</span>]=f[idx<span class="number">-2</span>]=<span class="number">0</span>;<span class="comment">//删除该边</span></span><br><span class="line">S=s,T=t;<span class="comment">//因为现在求的是s-&gt;t的最大流量,</span></span><br><span class="line"><span class="comment">//所以重新初始化源点和汇点 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n\n&quot;</span>,res+<span class="built_in">Dinic</span>()); <span class="comment">//ans即为虚拟图中s-&gt;t的流量+</span></span><br><span class="line"><span class="comment">//新增加的可行流量 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="网络流二"><a href="#网络流二" class="headerlink" title="网络流二"></a>网络流二</h1><p>临时复习一下网络流，顺便学习一点新东西</p><h2 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h2><p>不多说，以前的模板太丑了，这里给一个符合我现在（2021/11/16）码风的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200</span> + <span class="number">5</span>, M = <span class="number">5000</span> + <span class="number">5</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> S, T, n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ne, ver, w;</span><br><span class="line">&#125; e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> h[N], idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> dep[N], cur[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx].ver = y, e[idx].w = z, e[idx].ne = h[x], h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> <span class="comment">//add-double</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(x, y, z), <span class="built_in">add</span>(y, x, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">dep[i] = <span class="number">-1</span>;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(S);</span><br><span class="line">dep[S] = <span class="number">0</span>;</span><br><span class="line">cur[S] = h[S];</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">x = q.<span class="built_in">front</span>(), q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (dep[y] == <span class="number">-1</span> &amp;&amp; e[i].w)</span><br><span class="line">&#123;</span><br><span class="line">dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">cur[y] = h[y];</span><br><span class="line"><span class="keyword">if</span> (y == T)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">q.<span class="built_in">push</span>(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == T)</span><br><span class="line"><span class="keyword">return</span> limit;</span><br><span class="line"><span class="keyword">int</span> flow = <span class="number">0</span>, y, t;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = cur[x]; i != <span class="number">-1</span> &amp;&amp; flow &lt; limit; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">cur[x] = i;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (dep[y] == dep[x] + <span class="number">1</span> &amp;&amp; e[i].w)</span><br><span class="line">&#123;</span><br><span class="line">t = <span class="built_in">find</span>(y, <span class="built_in">min</span>(limit - flow, e[i].w));</span><br><span class="line"><span class="keyword">if</span> (!t)</span><br><span class="line">dep[t] = <span class="number">-1</span>;</span><br><span class="line">e[i].w -= t;</span><br><span class="line">e[i ^ <span class="number">1</span>].w += t;</span><br><span class="line">flow += t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL maxflow = <span class="number">0</span>, flow;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">bfs</span>())</span><br><span class="line"><span class="keyword">while</span> (flow = <span class="built_in">find</span>(S, INF))</span><br><span class="line">maxflow += flow;</span><br><span class="line"><span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;S, &amp;T);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">h[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, w; i &lt;= m; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line"><span class="built_in">addd</span>(u, v, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">dinic</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="费用流"><a href="#费用流" class="headerlink" title="费用流"></a>费用流</h2><p>我们已经解决了网络最大流的问题，但是，如果边不仅有容量限制，还有“价格”，也就是说，流单位容量的流还要付出一定代价该怎么办呢？</p><p><strong>最小费用最大流(mcmf)<strong>简称</strong>费用流</strong>就可以解决这样一个问题：给定一张网络，有源点和汇点，网络上的每条边 $(u,v)$ 都有一个流量限制 $w(u,v)$ 和单位流量的费用 $c(u,v)$ ，在满足流量守恒的前提下，求出<strong>使流量最大的最小费用</strong></p><p>其实非常简单，考虑我们Dinic的过程，其实就是不断一个寻找增广路的过程，那么我们在每次寻找增广路的时候，贪心的寻找<strong>单位费用最小</strong>的增广路，正确性显然，考虑具体实现，只需将每条边 $(u,v)$ 的反向边的费用定为 $-c(u,v)$ ，每次寻找增广路的bfs换成一个最短路即可</p><h3 id="spfa实现"><a href="#spfa实现" class="headerlink" title="spfa实现"></a>spfa实现</h3><p>使用spfa可以简单，高效（<del>前提是spfa没死</del>）的实现费用流，但需要注意的是，费用流的时间复杂度是 $O(nmf)$ ，其中 $f$ 代表最大流量，这个复杂度是<strong>伪多项式</strong>的，因为 $f_{max}=2^{\frac{n}{2}},m_{max}=n^2$ ，所以最坏为 $O(n^32^{\frac{n}{2}})$ ，当然实际上远远达不到这个上界</p><p>这里用Dinic+spfa实现了一个费用流：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5000</span> + <span class="number">5</span>, M = <span class="number">50000</span> + <span class="number">5</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> S, T, n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ne, ver, w, c;</span><br><span class="line">&#125; e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> h[N], idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> dis[N], cur[N];</span><br><span class="line"><span class="keyword">bool</span> v[N];</span><br><span class="line"><span class="keyword">int</span> maxflow, mincost;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx].ver = y, e[idx].w = z, e[idx].c = c, e[idx].ne = h[x], h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z, <span class="keyword">int</span> c)</span> <span class="comment">//add-double</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(x, y, z, c), <span class="built_in">add</span>(y, x, <span class="number">0</span>, -c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">dis[i] = INF, cur[i] = h[i];</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(S);</span><br><span class="line">dis[S] = <span class="number">0</span>;</span><br><span class="line">v[S] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">x = q.<span class="built_in">front</span>(), q.<span class="built_in">pop</span>();</span><br><span class="line">v[x] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (dis[y] &gt; dis[x] + e[i].c &amp;&amp; e[i].w)</span><br><span class="line">&#123;</span><br><span class="line">dis[y] = dis[x] + e[i].c;</span><br><span class="line"><span class="keyword">if</span> (!v[y])</span><br><span class="line">&#123;</span><br><span class="line">v[y] = <span class="literal">true</span>;</span><br><span class="line">q.<span class="built_in">push</span>(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dis[T] != INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == T)</span><br><span class="line"><span class="keyword">return</span> limit;</span><br><span class="line">v[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> flow = <span class="number">0</span>, y, t;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = cur[x]; i != <span class="number">-1</span> &amp;&amp; flow &lt; limit; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">cur[x] = i;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (!v[y] &amp;&amp; dis[y] == dis[x] + e[i].c &amp;&amp; e[i].w)</span><br><span class="line">&#123;</span><br><span class="line">t = <span class="built_in">find</span>(y, <span class="built_in">min</span>(limit - flow, e[i].w));</span><br><span class="line"><span class="keyword">if</span> (!t)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">e[i].w -= t;</span><br><span class="line">e[i ^ <span class="number">1</span>].w += t;</span><br><span class="line">flow += t;</span><br><span class="line">mincost += t * e[i].c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">v[x] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mcmf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">maxflow = mincost = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> flow;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">spfa</span>())</span><br><span class="line"><span class="keyword">while</span> (flow = <span class="built_in">find</span>(S, INF))</span><br><span class="line">maxflow += flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;S, &amp;T);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">h[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, w, c; i &lt;= m; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w, &amp;c);</span><br><span class="line"><span class="built_in">addd</span>(u, v, w, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">mcmf</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, maxflow, mincost);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dijkstra实现"><a href="#Dijkstra实现" class="headerlink" title="Dijkstra实现"></a>Dijkstra实现</h3><p>由于dij不能处理负全，必须像Johns全源最短路一样用一个势能来转换为正权</p><p>首先跑一次最短路，求出源点到每个点的最短距离 $h_i$ （也是该点的初始势能），接下来和Johnson算法一样，对于一条从 $u$ 到 $v$ ，单位费用为 $w$ 的边，将其边权重置为 $w+h_u-h_v$          </p><p>可以发现，这样设置势能后新网络上的最短路径和原网络上的最短路径一定对应，不妨设一条从 $S$ 到 $T$ 的路径为 $S\rightarrow p_1\rightarrow p_2\rightarrow…\rightarrow p_k\rightarrow T$ ，则其重表权值后，路径权值和为<br>$$<br>\begin{align}<br>&amp;(w(S,p_1)+ h_S-h_{p_1})+ (w(p_1,p_2)+ h_{p_1}- h_{p_2}) + … + (w(p_k,T) + h_{p_k}-h_T)\\<br>=&amp;w(S,p_1) + w(p_1,p_2) + … + w(p_k,T) + h_S - h_T<br>\end{align}<br>$$<br>可以发现 $S$ 到 $T$ 的所有路径的相对大小不变</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5000</span> + <span class="number">5</span>, M = <span class="number">50000</span> + <span class="number">5</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> S, T, n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ne, ver, w, c;</span><br><span class="line">&#125; e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> dis, id;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;t) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> dis &gt; t.dis;</span><br><span class="line">&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">int</span> h[N], idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> dis[N], cur[N];</span><br><span class="line"><span class="keyword">bool</span> v[N], vfind[N]; <span class="comment">//为find单独开一个v</span></span><br><span class="line"><span class="keyword">int</span> pe[N]; <span class="comment">//potential energy,势能</span></span><br><span class="line"><span class="keyword">int</span> maxflow, mincost;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx].ver = y, e[idx].w = z, e[idx].c = c, e[idx].ne = h[x], h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z, <span class="keyword">int</span> c)</span> <span class="comment">//add-double</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">add</span>(x, y, z, c), <span class="built_in">add</span>(y, x, <span class="number">0</span>, -c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">pe[i] = INF;</span><br><span class="line">q.<span class="built_in">push</span>(S);</span><br><span class="line">pe[S] = <span class="number">0</span>;</span><br><span class="line">v[S] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">x = q.<span class="built_in">front</span>(), q.<span class="built_in">pop</span>();</span><br><span class="line">v[x] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (pe[y] &gt; pe[x] + e[i].c &amp;&amp; e[i].w)</span><br><span class="line">&#123;</span><br><span class="line">pe[y] = pe[x] + e[i].c;</span><br><span class="line"><span class="keyword">if</span> (!v[y])</span><br><span class="line">&#123;</span><br><span class="line">v[y] = <span class="literal">true</span>;</span><br><span class="line">q.<span class="built_in">push</span>(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dij</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">priority_queue&lt;Node&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">dis[i] = INF, v[i] = <span class="literal">false</span>, cur[i] = h[i];</span><br><span class="line">dis[S] = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push</span>((Node)&#123;<span class="number">0</span>, S&#125;);</span><br><span class="line"><span class="keyword">int</span> x, y, nc;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">x = q.<span class="built_in">top</span>().id, q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span> (v[x])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">v[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver, nc = e[i].c + pe[x] - pe[y];</span><br><span class="line"><span class="keyword">if</span> (dis[y] &gt; dis[x] + nc &amp;&amp; e[i].w)</span><br><span class="line">&#123;</span><br><span class="line">dis[y] = dis[x] + nc;</span><br><span class="line"><span class="keyword">if</span> (!v[y])</span><br><span class="line">q.<span class="built_in">push</span>((Node)&#123;dis[y], y&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dis[T] != INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == T)</span><br><span class="line"><span class="keyword">return</span> limit;</span><br><span class="line">vfind[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> flow = <span class="number">0</span>, y, t, nc;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = cur[x]; i != <span class="number">-1</span> &amp;&amp; flow &lt; limit; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">cur[x] = i;</span><br><span class="line">y = e[i].ver, nc = e[i].c + pe[x] - pe[y];</span><br><span class="line"><span class="keyword">if</span> (!vfind[y] &amp;&amp; dis[y] == dis[x] + nc &amp;&amp; e[i].w)</span><br><span class="line">&#123;</span><br><span class="line">t = <span class="built_in">find</span>(y, <span class="built_in">min</span>(limit - flow, e[i].w));</span><br><span class="line"><span class="keyword">if</span> (!t)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">e[i].w -= t;</span><br><span class="line">e[i ^ <span class="number">1</span>].w += t;</span><br><span class="line">flow += t;</span><br><span class="line">mincost += t * e[i].c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">vfind[x] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mcmf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">maxflow = mincost = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> flow;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">dij</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (flow = <span class="built_in">find</span>(S, INF))</span><br><span class="line">maxflow += flow;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="comment">//记得每次更新势能</span></span><br><span class="line">pe[i] += dis[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;S, &amp;T);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">h[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, w, c; i &lt;= m; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w, &amp;c);</span><br><span class="line"><span class="built_in">addd</span>(u, v, w, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">spfa</span>();</span><br><span class="line"><span class="built_in">mcmf</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, maxflow, mincost);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>然鹅实测spfa不被卡的话和Dijkstra差不多，反而是开了O2两个都快的飞起</del></p><h2 id="最高标号预流推进"><a href="#最高标号预流推进" class="headerlink" title="最高标号预流推进"></a>最高标号预流推进</h2><p>最高标号预流推进（High Level Preflow Push，即HLPP）是另一种网络流算法，该算法较Dinic更为高效，<del>然而常数更大</del></p><p>HLPP并不是像Dinic和EK一样基于增广路的算法，它用另外一种更直观的方法求最大流</p><h3 id="预流推进"><a href="#预流推进" class="headerlink" title="预流推进"></a>预流推进</h3><p>想象一下，如果给到一个网络流让你手算，你咋办？当然是贪心地从源点开始往死里流，尽可能的把每条边流满，如果超过容量就减掉超过部分，一直推到汇点（应该很好理解，可以自己手推试试）</p><p>PP也是基于以上思想，用一个队列储存待维护的点（初始时只有 $S$ ），对于每一个当前点，把它有的流量尽可能地推往与之相连的点，然后将相连的点也加入队列</p><p>但这样明显有一个问题：可能出现两个点一个推过来一个推回去，结果就死循环了，为了不死循环，我们类似Dinic，引入一个<strong>高度</strong> $hi$ ， $hi[S]=n,hi[T]=0$ 规定只能由高为 $hight$ 的点流向高为 $hight-1$ 的点，如果遇到一个点有多余的流量无法流出，就尝试将其抬高一个高度（我们把这个操作叫做<strong>重贴标签</strong>），直到最后高为 $n+1$ 流回 $S$ </p><h3 id="最高标号"><a href="#最高标号" class="headerlink" title="最高标号"></a>最高标号</h3><p><del>令人讨厌的、让人无奈的、使人疯魔的</del><strong>Tarjan</strong>和他的同事Goldberg在1986年提出了最高标号（HL）预留推进算法，即把普通队列换成<strong>优先队列</strong>，每次取出高度最高的那个来推进，可以理解为先将高处的点的水移到低处，那么给低处节点推流时可以顺便带走，Cheriyan和Maheshwari在1988年证明了这样做的复杂度为 $O(n^2\sqrt{m})$ </p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>虽然上述的算法是正确的，并且复杂度是稳定的（<del>不像某玄学Dinic</del>），但是因为缺少一些优化，使得其上界比较紧，因此在随机数据下可能不如增广路算法，所以下面介绍一些优化</p><p>首先是喜闻乐见的gap优化：如果我们发现在给一个点抬高一的高度的时候，这个点原来的高度已经没有点了（出现断层），那么我们直接把大于这个高度的点的高度全部设 $n+1$ ，让他们回流到源点去，因为有了断层，他们无法再有机会把水推到汇点（为什么不能有下面一个点抬上来形成路径呢？因为一个点的高度是所有相邻点高度最小值加一，所以不可能出现这种情况）</p><p>其次，我们发现将所有非源点的高度设置为0是有些浪费的。我们不妨通过一遍bfs将每个点的初始高度设置为它到汇点 $T$ 的最短距离，这样就节省了大量重贴标签操作。当然，源点 $S$ 的高度还是应该设置为 $n$ </p><p>然后，我们发现完全没有必要用优先队列的 $O(\log{n})$ 来求最高点，因为高度最大也就 $n+1$ ，完全可以用一个桶存下所有高度的节点，$O(1)$ 得到最高点</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><a href="https://www.luogu.com.cn/problem/P4722">模板</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1200</span> + <span class="number">5</span>, M = <span class="number">120000</span> + <span class="number">5</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, S, T;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ne, ver, w;</span><br><span class="line">&#125; e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> h[N], idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> hi[N], ex[N], gap[N]; <span class="comment">//hi:高度,ex:超额流,gap[i]:高度为i的节点的数量</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; B[N]; <span class="comment">// 桶B[i]中记录所有hi[x]=i的x</span></span><br><span class="line"><span class="keyword">int</span> level = <span class="number">0</span>; <span class="comment">//溢出节点的最高高度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx] = (Edge)&#123;h[x], y, z&#125;, h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(x, y, z), <span class="built_in">add</span>(y, x, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">hi[i] = INF;</span><br><span class="line">hi[T] = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push</span>(T);</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">x = q.<span class="built_in">front</span>(), q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (e[i ^ <span class="number">1</span>].w &amp;&amp; hi[y] &gt; hi[x] + <span class="number">1</span>) <span class="comment">//从T倒着搜回去走的是反向边,^1以后就变回正向边</span></span><br><span class="line">hi[y] = hi[x] + <span class="number">1</span>, q.<span class="built_in">push</span>(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> hi[S] != INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//尽可能通过能够推送的边推送超额流</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> init = x == S;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y, k; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (!e[i].w || (init == <span class="literal">false</span> &amp;&amp; hi[x] != hi[y] + <span class="number">1</span>)) <span class="comment">//初始化时不考虑高度差为1</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">k = init ? e[i].w : <span class="built_in">min</span>(e[i].w, ex[x]); <span class="comment">//取到剩余容量和超额流的最小值初始化时可以使源的溢出量为负数</span></span><br><span class="line"><span class="keyword">if</span> (y != S &amp;&amp; y != T &amp;&amp; !ex[y])</span><br><span class="line">B[hi[y]].<span class="built_in">push_back</span>(y), level = <span class="built_in">max</span>(level, hi[y]);</span><br><span class="line">ex[x] -= k, ex[y] += k, e[i].w -=k, e[i ^ <span class="number">1</span>].w += k;</span><br><span class="line"><span class="keyword">if</span> (!ex[x]) <span class="comment">//如果已经推送完就返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">relabel</span><span class="params">(<span class="keyword">int</span> x)</span>  <span class="comment">//重贴标签(高度)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  hi[x] = INF;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">    <span class="keyword">if</span> (e[i].w)</span><br><span class="line">hi[x] = <span class="built_in">min</span>(hi[x], hi[e[i].ver]);</span><br><span class="line">  <span class="keyword">if</span> (++hi[x] &lt; n) <span class="comment">//只处理高度小于n的节点</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="comment">//新的高度,更新gap</span></span><br><span class="line">  B[hi[x]].<span class="built_in">push_back</span>(x);</span><br><span class="line">  level = <span class="built_in">max</span>(level, hi[x]);</span><br><span class="line">  ++gap[hi[x]];  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_max</span><span class="params">()</span> <span class="comment">//选出当前高度最大的节点之一,如果已经没有溢出节点返回0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (B[level].<span class="built_in">empty</span>() &amp;&amp; level &gt; <span class="number">-1</span>)</span><br><span class="line">--level;</span><br><span class="line"><span class="keyword">return</span> level == <span class="number">-1</span> ? <span class="number">0</span> : B[level].<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hlpp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">bfs</span>())</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i)</span><br><span class="line">gap[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">if</span> (hi[i] != INF)</span><br><span class="line">++gap[hi[i]];</span><br><span class="line">hi[S] = n;</span><br><span class="line"><span class="built_in">push</span>(S); <span class="comment">//初始化预流</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">while</span> (x = <span class="built_in">find_max</span>())</span><br><span class="line">&#123;</span><br><span class="line">B[level].<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">push</span>(x)) <span class="comment">//仍然溢出</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!--gap[hi[x]])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">if</span> (i != S &amp;&amp; i != T &amp;&amp; hi[i] &gt; hi[x] &amp;&amp; hi[i] &lt; n + <span class="number">1</span>)</span><br><span class="line">hi[i] = n + <span class="number">1</span>;  <span class="comment">// 这里重贴成 n+1 的节点都不是溢出节点</span></span><br><span class="line">      <span class="built_in">relabel</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ex[T];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;S, &amp;T);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">h[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, w, c; i &lt;= m; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line"><span class="built_in">addd</span>(u, v, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">hlpp</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>一般来说好用又好打的Dinic已经足够，但HLPP在加上优化后完虐Dinic，但不管是哪个，需要注意有可能的最大流炸int的情况</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;老有用了&lt;/p&gt;</summary>
    
    
    
    
    <category term="图论" scheme="https://dyd-true.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="网络流" scheme="https://dyd-true.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
    <category term="Dinic" scheme="https://dyd-true.github.io/tags/Dinic/"/>
    
    <category term="HLPP" scheme="https://dyd-true.github.io/tags/HLPP/"/>
    
    <category term="费用流" scheme="https://dyd-true.github.io/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>拓展欧几里得</title>
    <link href="https://dyd-true.github.io/2021/11/22/%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
    <id>https://dyd-true.github.io/2021/11/22/%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/</id>
    <published>2021-11-22T08:35:18.000Z</published>
    <updated>2021-11-24T09:24:45.316Z</updated>
    
    <content type="html"><![CDATA[<p>拓欧</p><span id="more"></span><h1 id="欧几里德算法（辗转相除法）"><a href="#欧几里德算法（辗转相除法）" class="headerlink" title="欧几里德算法（辗转相除法）"></a>欧几里德算法（辗转相除法）</h1><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p> $\forall a,b \in \mathbb{N},b \ne 0,$ 有 $gcd(a,b)=gcd(b,a \bmod b)$</p><p>证明：</p><ul><li>若 $a&lt;b$ ，则 $gcd(b,a \bmod b)=gcd(b,a)=gcd(a,b)$</li><li>若 $a \ge b$ 设 $a=q \times b +r$ ,其中 $0 \le r &lt;b$ ,则 $gcd(b,a \bmod b)=gcd(b,r)$ 。对于 $a,b$ 的任何公约数 $d$ ，必有 $d|a,d|b$ ，故 $d|q \times b$ ，故 $d|(a-(q \times b))$ ，即 $d|r$ 。因此， $d$ 也是 $r,b$　的公约数，于是 $gcd(a,b)=gcd(r,b)$</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为 $O(\log{(a+b)})$ </p><h1 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h1><h2 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h2><p>$\forall a,b,c \in \mathbb{Z}$ 关于 $x,y$ 的不定方程 $ax+by=c$ 有整数解当且仅当 $gcd(a,b)|c$ ，且一定存在 $x,y$ 使 $c=gcd(a,b)$</p><p>该定理的正确性初中就学过了，这里再简要证明一下：</p><p>设 $d=gcd(a,b)$ ，则 $d|a,d|b$ ，故 $d|(ax+by)$ 。<br>再设 $s$ 为 $ax+by$ 当 $x,y\in \mathbb{Z}$ 时能取得的最小正值。设 $r=a \bmod s=a-\left \lfloor \frac{a}{s} \right \rfloor \times s=a-\left \lfloor \frac{a}{(ax+by)} \right \rfloor \times (ax+by) =a(1-\left \lfloor \frac{a}{ax+by} \right \rfloor x)+b(-\left \lfloor \frac{a}{ax+by} \right \rfloor y)$ ，这里的 $x,y$ 是常量，使 $ax+by=s$ 。<br>可见 $r$ 是 $a,b$ 的线性组合，由于 $r= a \bmod s$ ，故 $0 \le r&lt; s$ 。<br>而 $s=ax+by$ 是 $a,b$ 线性组合的最小正值，故 $r=0$ 。因此 $s|a$ 。<br>同理， $s|b$ 。<br>故 $s$  是 $a,b$　的公约数，故 $s|d$ 。<br>又因为 $d|(ax+by)$ ，故有 $d|s$ ，那么只能 $d=s$ ，命题得证。</p><h2 id="特解"><a href="#特解" class="headerlink" title="特解"></a>特解</h2><p>有了裴蜀定理，我们就可以解出 $ax+by=gcd(a,b)$ ，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span>&amp; x,<span class="keyword">int</span>&amp; y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!b)&#123;</span><br><span class="line">   x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> a;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">int</span> d=<span class="built_in">exgcd</span>(b,a%b,y,x);<span class="comment">//这里交换了x和y</span></span><br><span class="line">   y-=(a/b)*x;</span><br><span class="line">   <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们调用函数 $d=exgcd(a,b,x_0,y_0)$ 时，由于 $x,y$ 是实参，结束后 $x_0,y_0$ 即为一组特解， $d$ 为 $gcd(a,b)$ 。</p><p>那么，由于 $d|c$ , $ax+by=c$ 的通解为：</p><p>$$<br>\begin{align}<br>x=\frac{c}{d}x_0+k\frac{b}{d} \\<br>y=\frac{c}{d}y_0-k\frac{a}{d}<br>\end{align}<br>$$</p><p>其中 $k$ 取遍 $\mathbb{Z}$ ，$d=gcd(a,b)$ ，$x_0,y_0$ 是方程 $ax+by=gcd(a,b)$ 的一组特解</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><a href="https://www.luogu.com.cn/problem/P1082">P1082</a><br>我们发现 $ax \equiv 1 \pmod{b}$ ，就等价于 $ax=by+1$ 移项得 $ax-by=1$ 。</p><p>代码如下：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line">LL a,m; </span><br><span class="line">LL exgcd(LL a,LL b,LL&amp; x,LL&amp; y)<span class="comment">&#123;</span></span><br><span class="line"><span class="comment">if(!b)&#123;</span></span><br><span class="line"><span class="comment">x=1,y=0;</span></span><br><span class="line"><span class="comment">return a;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line">LL d=exgcd(b,a%b,y,x); </span><br><span class="line">y-=a/b*x;</span><br><span class="line">return d;</span><br><span class="line">&#125;</span><br><span class="line">int main()<span class="comment">&#123;</span></span><br><span class="line"><span class="comment">scanf(&quot;%lld%lld&quot;,&amp;a,&amp;m);</span></span><br><span class="line"><span class="comment">LL x,y;</span></span><br><span class="line"><span class="comment">exgcd(a,m,x,y);</span></span><br><span class="line"><span class="comment">x=(x%m+m)%m; </span></span><br><span class="line"><span class="comment">printf(&quot;%lld&quot;,x);</span></span><br><span class="line"><span class="comment">return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;拓欧&lt;/p&gt;</summary>
    
    
    
    
    <category term="数论,数学" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
    <category term="拓展欧几里得" scheme="https://dyd-true.github.io/tags/%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>数位dp</title>
    <link href="https://dyd-true.github.io/2021/11/22/%E6%95%B0%E4%BD%8Ddp/"/>
    <id>https://dyd-true.github.io/2021/11/22/%E6%95%B0%E4%BD%8Ddp/</id>
    <published>2021-11-22T08:33:32.000Z</published>
    <updated>2021-11-24T09:24:32.519Z</updated>
    
    <content type="html"><![CDATA[<p>简单写写</p><span id="more"></span><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>思考以下问题：<br>对于给定范围的整数 $x \in [a,b]$ ，有多少个 $x$ 满足性质 $p$ （ $p$ 与数的各个位都有关，如“该数中有3个1”）。<br>对于此类问题，我们可以考虑如下方法：  </p><ol><li><p>用 $f[i]$ 表示对于所有的整数 $x \in [0,i]$ 中，满足性质 $p$ 的数的个数</p></li><li><p>则 $ans \ge f[b]-f[a-1]$ </p></li></ol><p>那么，我们来考虑如何去求 $f[N]$ 。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>设数 $N$ 是一个 $n$ 位数，且 $N=\overline{a_{n-1}a_{n-2}a_{n-3}…a_0} (a_<br>{n-1} \ne 0)$ 。<br>辣么，对于 $\forall x \in [0,N],x=\overline{b_{n-1}b_{n-2}b_{n-3}…b_0}$ ，有两种情况：</p><ol><li><p>$b_{n-1}=a_{n-1}$ </p></li><li><p>$0 \le b_{n-1} &lt; a_{n-1}$ </p></li></ol><p>我们发现，对于第二种情况，当 $b_{n-1}$ 确定时，方案数可以直接计算。如当 $N=7654321$ ， $p$ 为“该数中有3个1” 时，若 $0 \le b_6 &lt; 7$ 那么 $b_6=1$ 时，有 $C_{6}^{2}$ 种方案，而当 $b_6 \ne 1$ 时，有 $C_{6}^{3}$ 种方案。<br>对于第一种情况，我们只需继续讨论 $b_{n-2}$ 。<br>如图：<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/6zh87oc2.png" alt="dp顺序"></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/w0g1xgw3.png" alt="题"><br>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">35</span>;</span><br><span class="line"><span class="keyword">int</span> k, B; <span class="comment">//B进制数</span></span><br><span class="line"><span class="keyword">int</span> C[N][N];</span><br><span class="line"><span class="comment">//预处理组合数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j)</span><br><span class="line">            <span class="keyword">if</span> (!j)</span><br><span class="line">                C[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                C[i][j] = C[i - <span class="number">1</span>][j] + C[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算0到n中的数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">        nums.<span class="built_in">push_back</span>(n % B), n /= B;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = nums[i];</span><br><span class="line">        <span class="comment">//求左边分支</span></span><br><span class="line">        <span class="keyword">if</span> (x)</span><br><span class="line">        &#123;</span><br><span class="line">            res += C[i][k - last];</span><br><span class="line">            <span class="keyword">if</span> (x &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (k &gt; last)</span><br><span class="line">                    res += C[i][k - last - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                last++;</span><br><span class="line">                <span class="keyword">if</span> (last &gt; k)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加上最右侧分支上的方案</span></span><br><span class="line">        <span class="keyword">if</span> (!i &amp;&amp; last == k)</span><br><span class="line">            res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r &gt;&gt; k &gt;&gt; B;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dp</span>(r) - <span class="built_in">dp</span>(l - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单写写&lt;/p&gt;</summary>
    
    
    
    
    <category term="数论,数学" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>树状数组（BIT）</title>
    <link href="https://dyd-true.github.io/2021/11/22/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%88BIT%EF%BC%89/"/>
    <id>https://dyd-true.github.io/2021/11/22/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%88BIT%EF%BC%89/</id>
    <published>2021-11-22T08:31:56.000Z</published>
    <updated>2021-11-24T09:24:19.288Z</updated>
    
    <content type="html"><![CDATA[<p>BIT常数小！（<del>然并卵</del>）</p><span id="more"></span><h2 id="思想铺垫"><a href="#思想铺垫" class="headerlink" title="思想铺垫:"></a>思想铺垫:</h2><p>将一个数$x$化为二进制数$(\overline{a_{k-1}a_{k-2}…a_1a_0})<em>2$ , 并设其中等于1的位是${a</em>{i_1},a_{i_2}…a_{i_m}}$ , 则$x=2^{i_1}+2^{i_2}+…+2^{i_m}$ , 不妨设$i_1&gt;i_2&gt;…&gt;i_m$ , 那么区间$[1,x]$可以拆分成$O(\log_{}{x})$个小区间:  </p><ol><li><p>长度为$2^{i_1}$的小区间$[1,2^{i_1}]$</p></li><li><p>长度为$2^{i_2}$的小区间$[2^{i_1}+1,2^{i_1}+2^{i_2}]$</p></li><li><p>长度为$2^{i_3}$的小区间$[2^{i_1}+2^{i_2}+1,2^{i_1}+2^{i_2}+2^{i_3}]$; </p><p>……</p></li><li><p>长度为$2^{i_m}$的小区间$[2^{i_1}+2^{i_2}+…+2^{i_{m-1}}+1,2^{i_1}+2^{i_2}+…+2^{i_m}]$ </p></li></ol><p>而这些小区间的共同特点是:对于$\forall[x,y ]$ , 其区间长度(记为$|[x,y]|$)就等于”y的二进制拆分下的最小的2的次幂” , 即$lowbit(y)$ .<br>例如大区间$[1,7]$ , 因为$7=2^{2}+2^{1}+2^{0}$ , 所以被分为三个小区间 : $[1,4]$、$[5,6]$、$[7,7]$ . 而其长度分别是$lowbit(4)=4$、$lowbit(4)=4$、$lowbit(4)=4$<br>补充——$lowbit()$:<br>$lowbit(n)$定义为”非负整数$n$在而进制表示下最低位的1及其后的0构成的数的值”. 如$n=22=(10110)_2$ , 则$lowbit(22)=(10)_2=2$<br>则其代码实现如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本思路："><a href="#基本思路：" class="headerlink" title="基本思路："></a>基本思路：</h2><p>对于给定的原序列$a$ , 我们建立一个数组$c$ , 其中$c[x]$保存<strong>原序列$a$的区间$[x-lowbit(x)+1,x]$中所有数的和</strong> , 即$\textstyle\sum_{i=x-lowbit(x)+1}^{x}a[i]$<br>不难发现 , 数组$c$可以看作一个树形结构 , 且满足如下性质:</p><ol><li>每个节点$c[x]$保存以它为根的子树中所有叶节点的和.</li><li>每个节点$c[x]$的子节点个数等于$lowbit(x)$的位数 , 如$lowbit(4)=(100)_2$ , 其位数为$3$ , 故$c[4]有3个子节点$.</li><li>除树根外 , 每个节点$c[x]$的父节点就是$c[x+lowbit(x)]$.</li><li>树的深度为$O(\log_{}{N})$.</li></ol><p>如果$n$不是$2$的整数次幂 , 那么树状数组就是一个具有同样性质的森林.<br>如图:<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/4yowzx8l.png" alt="树状数组"><br>而树状数组支持的操作有两个:<br> <strong>查询前缀和</strong> : 即找到序列$a$第$1 \sim x$个数的和.  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;x;x-=x&amp;-x) ans+=c[x];<span class="comment">//x&amp;-x即为lowbit(x)</span></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若要查询$a$的区间$[l,r]$ , 只需计算$ask(r)-ask(l-1)$.<br><strong>单点增加</strong> : 给序列中一个数$a[x]$加上y , 不难发现至多只有$\log{}{N}$个节点包含$a[x]$ , 故时间复杂度为$O(\log{}{N})$.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(;x&lt;=N;x+=x&amp;-x) c[x]+=y;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在执行操作前 , 我们先要构造出$c$数组.<br>简单方法是 , 先让$c$全为$0$ , 然后对每个$x$执行$add(x,a[x])$ , 时间复杂度为$O(N\log{}{N})$ , 通常用这种方法就已足够.<br>更高效的方法是 , 从小到大依次考虑节点$x$ , 借助$lowbit$运算扫描它的子节点求和.若采用这种办法 , 上面树形结构的每条边只会被遍历一次 , 时间复杂度为 $O(\sum_{k = 1} ^ {\log{N}}k * N / 2 ^ {k}) = O(N)$<br>另外 , 若是题目需要<strong>区间增加</strong> , 可以改存$a$的差分数组.</p><p><a href="https://www.luogu.com.cn/problem/P3374">树状数组1</a><br><a href="https://www.luogu.com.cn/problem/P3368">树状数组2</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;BIT常数小！（&lt;del&gt;然并卵&lt;/del&gt;）&lt;/p&gt;</summary>
    
    
    
    
    <category term="数据结构" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树" scheme="https://dyd-true.github.io/tags/%E6%A0%91/"/>
    
    <category term="树状数组" scheme="https://dyd-true.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
</feed>
