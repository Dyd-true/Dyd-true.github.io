<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dyd&#39;s Blog</title>
  
  <subtitle>He who has a strong enough why can bear almost any how.</subtitle>
  <link href="https://dyd-true.github.io/atom.xml" rel="self"/>
  
  <link href="https://dyd-true.github.io/"/>
  <updated>2021-11-29T14:05:11.287Z</updated>
  <id>https://dyd-true.github.io/</id>
  
  <author>
    <name>Dyd</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>test2021/11/29总结</title>
    <link href="https://dyd-true.github.io/2021/11/29/test2021-11-29%E6%80%BB%E7%BB%93/"/>
    <id>https://dyd-true.github.io/2021/11/29/test2021-11-29%E6%80%BB%E7%BB%93/</id>
    <published>2021-11-29T04:01:13.000Z</published>
    <updated>2021-11-29T14:05:11.287Z</updated>
    
    <content type="html"><![CDATA[<p> 暴力狂魔</p><span id="more"></span><h1 id="test2021-11-29总结"><a href="#test2021-11-29总结" class="headerlink" title="test2021/11/29总结"></a>test2021/11/29总结</h1><p>学校测试，考了<strong>2021全国统一省选Day2</strong></p><h2 id="题目、成绩和题解"><a href="#题目、成绩和题解" class="headerlink" title="题目、成绩和题解"></a>题目、成绩和题解</h2><p><a href="./%E7%9C%81%E9%80%892021.A%E5%8D%B7.day2.pdf">题目</a></p><p><a href="./noi2021sx-day2%E6%AF%94%E8%B5%9B%E7%BB%93%E6%9E%9C.pdf">成绩</a></p><p><a href="./NOI2021%E5%85%A8%E5%9B%BD%E7%BB%9F%E4%B8%80%E7%9C%81%E9%80%89A%E5%8D%B7%EF%BC%88%E9%A2%98%E8%A7%A3%EF%BC%89.docx">题解</a></p><h2 id="早上做题"><a href="#早上做题" class="headerlink" title="早上做题"></a>早上做题</h2><p>一大早考试，看到题就已经做好打三道暴力的准备</p><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>快速瞟了一眼，一看，第一感觉暴力可以拿25（<del>实际也是25分，一分不多艹</del>），后来仔细观察了数据范围，特殊性质有两个，一个是 $m \le 300$  再加上满数据的 $m$ 也比 $n$ 小，像是提示我要打权值线段树的样子；又有一个是链，像是提示我树链剖分</p><p>感觉上从数据范围看是 $O(n\log n)$ 或者常数小的 $O(n\log^2 n)$ ，个人考场上偏向于是树剖（<del>特别打脸</del>），想到树剖不好调（同机房的<strong>l18q</strong>就是死调树剖），决定打个暴力往下看</p><p>暴力思路这里简单说一下（免得我忘了）：大概是倍增法的lca找路径，存下来，然后再扫一遍求答案，时间复杂度 $O(qn)$ </p><h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>不多说，计算机一算，$13!$ 都炸了，直接放弃想正解，感觉暴力分挺多的，于是打暴力，dfs求排列，倒序扫排名判定是否可行，时间复杂度 $O(n!n)$ ，考场上得了60分，第三个大样例过不了</p><h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>这个才<del>nm</del>离谱，<strong>wfy</strong>大佬会打支配树，刚开考就（在我旁边）说他先做T3，我内心忐忑的来到T3，一看，连暴力都觉得好麻烦，但麻烦也得打啊，就硬着头皮打暴力</p><p>第一遍打了个非多项式时间复杂度的（<del>其实就是玄学，说的那么文雅</del>），连样例三都超时，样例二还WA了，没多想，换思路</p><p>第二边打了个正经暴力，思路是先bfs求出每个点到1的最短路径，存在vector $D[N]$ 里，然后对于 $D[i]$ 中的每一个点，判断删去该点后1和 $i$ 是否联通，不联通则该点是支配点，对于每个加边操作，就加上边然后再判一次（因为 $D[i]$ 只会变小，不会变大），时间复杂度为 $O(qn^3)$ ，因为第二、三个 $n$ 都绝对跑不满，所以其实大概是 $O(qn\xi)$ 的，反正样例三是没TLE了</p><p>然鹅样例二的WA还是不变！我对着大样例极端痛苦的调到考试快结束，大概最后三分钟（其它人好多都交了）的时候才发现：“ 有 $q$ 次 ${\color{red}\colorbox{yellow}{互相独立}}$ 的询问”，所以每次询问完后要恢复原状！我用的链式前向星，不好复原，三分钟改成vector存图，没来得及调就交了，结果爆零</p><h3 id="总分"><a href="#总分" class="headerlink" title="总分"></a>总分</h3><p>25 + 60 + 0，85分，还算正常分数吧（毕竟我太弱了），最高是<strong>wfy</strong>大佬和<strong>龙巨</strong>，看了一下，T3都打出来了30分，不愧是他们，下午打算先把T3的30分改出来</p><h2 id="下午改题"><a href="#下午改题" class="headerlink" title="下午改题"></a>下午改题</h2><h3 id="T3-1"><a href="#T3-1" class="headerlink" title="T3"></a>T3</h3><p>首先，上午的方法打出来了，不知为何，有几个询问都比答案小1，调了半天没办法，只好<del>看题解</del>，找了个支配树的方法，如下：</p><p>首先，用 $O(n^2)$  建出<strong>支配树</strong>（定义为一棵树，满足点 $u$ 的受支配集 $D_u$ 即为它到根的路径上的所有点组成的集合），建法为先求出 $D[]$ （方法同上午的），然后类似拓扑排序一样，首先把1入队，对于队头 $x$ 删除所以 $D[]$ 中的 $x$ ，若有一个 $i$ 满足 $D[i] = {i}$ 即只剩下自己支配自己，就入队，并连边 $(x, i)$ </p><p>建好支配树后，对于每次添加边 $(u, v)$ ，若一个点 $x$ 的支配集改变，一定是出现了 $1 \rightarrow u \rightarrow v \rightarrow x$ 并且该路径不经过支配树上 $x$ 的某个祖先</p><p>但枚举祖先太麻烦，而且会TLE，我们发现一个性质：若 $x$ 的支配集改变，则支配树上 $x$ 的所有孩子的支配集也会改变，正确性显然</p><p>于是利用该性质，问题转化为：如果存在一条路径 $1 \rightarrow u \rightarrow v \rightarrow x$ 不经过点 $x$ 的<strong>父亲</strong>，那么 $x$ 子树内所有点都会对答案产生贡献（支配集都会发生改变），问贡献和</p><p>我们可以预处理每一个点 $x$ ，把 $x$ 的父亲从原图的反图中删去，$x$ 能到达哪些点，它就可能对这些点产生贡献，对于一组询问 $(u, v)$ ，我们只需要枚举所有可能对 $v$ 产生贡献的点，如果它的父亲不在支配树上的 $1 \rightarrow u$ 这条路径上，它这棵子树就可以产生贡献，时间复杂度 $O(nq)$ </p><p>类似树剖，用dfn化为链，直接差分即可（因为修改一定是在同一子树，不必像树剖一样轻重链划分）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IL inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3000</span> + <span class="number">5</span>, Que = <span class="number">2e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ne, ver;</span><br><span class="line">&#125; e[<span class="number">5</span>][N &lt;&lt; <span class="number">3</span>]; <span class="comment">//1-原图,2-反图,3-支配树</span></span><br><span class="line"><span class="keyword">int</span> h[<span class="number">5</span>][N], idx[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="keyword">int</span> stk[N * N], top;</span><br><span class="line"><span class="keyword">int</span> fa[N], si[N], dfn[N], id;</span><br><span class="line"><span class="keyword">int</span> vs[N], cf[N];  <span class="comment">//vs:第几次询问,cf:差分</span></span><br><span class="line"><span class="keyword">bool</span> del[N], vis[N], can[N][N], ins[N], cc[N][N]; <span class="comment">//cc:能否贡献</span></span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[o][idx[o]] = (Edge)&#123;h[o][x], y&#125;, h[o][x] = idx[o]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">dfs12</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x])</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[o][x]; i != <span class="number">-1</span>; i = e[o][i].ne)</span><br><span class="line"><span class="keyword">if</span> (!vis[e[o][i].ver])</span><br><span class="line"><span class="built_in">dfs12</span>(o, e[o][i].ver);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">del[j] = vis[j] = <span class="literal">false</span>;</span><br><span class="line">del[i] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">dfs12</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line"><span class="keyword">if</span> (!vis[j])</span><br><span class="line">can[j][i] = <span class="literal">true</span>, ++cnt[j];</span><br><span class="line">&#125;</span><br><span class="line">top = <span class="number">1</span>;</span><br><span class="line">stk[top] = <span class="number">1</span>;</span><br><span class="line">ins[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= top; i++)</span><br><span class="line">&#123;</span><br><span class="line">x = stk[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line"><span class="keyword">if</span> (can[j][x])</span><br><span class="line">--cnt[j];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line"><span class="keyword">if</span> (cnt[j] == <span class="number">1</span> &amp;&amp; !ins[j])</span><br><span class="line">ins[j] = <span class="literal">true</span>, <span class="built_in">add</span>(<span class="number">3</span>, x, j), stk[++top] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">si[x] = <span class="number">1</span>;</span><br><span class="line">dfn[x] = ++id;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[<span class="number">3</span>][x], y; i != <span class="number">-1</span>; i = e[<span class="number">3</span>][i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[<span class="number">3</span>][i].ver;</span><br><span class="line">fa[y] = x;</span><br><span class="line"><span class="built_in">dfs3</span>(y);</span><br><span class="line">si[x] += si[y];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">prev</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fa[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">id = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">dfs3</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">del[j] = vis[j] = <span class="literal">false</span>;</span><br><span class="line">del[fa[i]] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">dfs12</span>(<span class="number">2</span>, i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">cc[i][j] = vis[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m, Q, u, v, _u, ans, t;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;Q);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">h[<span class="number">1</span>][i] = h[<span class="number">2</span>][i] = h[<span class="number">3</span>][i] = <span class="number">-1</span>;</span><br><span class="line">idx[<span class="number">1</span>] = idx[<span class="number">2</span>] = idx[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line"><span class="built_in">add</span>(<span class="number">1</span>, u, v);</span><br><span class="line"><span class="built_in">add</span>(<span class="number">2</span>, v, u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">build</span>();</span><br><span class="line"><span class="built_in">prev</span>();</span><br><span class="line">t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (Q--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">_u = u;</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line">++t;</span><br><span class="line"><span class="keyword">while</span> (_u != <span class="number">1</span>)</span><br><span class="line">vs[_u] = t, _u = fa[_u];</span><br><span class="line">vs[<span class="number">1</span>] = t;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i)</span><br><span class="line">cf[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span> (cc[i][v] &amp;&amp; vs[fa[i]] != t)</span><br><span class="line">++cf[dfn[i]], --cf[dfn[i] + si[i]];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">cf[i] += cf[i - <span class="number">1</span>], ans += (cf[i] != <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果一下午+晚上只改了一道题，笑死我了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt; 暴力狂魔&lt;/p&gt;</summary>
    
    
    
    
    <category term="test" scheme="https://dyd-true.github.io/tags/test/"/>
    
    <category term="差分" scheme="https://dyd-true.github.io/tags/%E5%B7%AE%E5%88%86/"/>
    
    <category term="支配树" scheme="https://dyd-true.github.io/tags/%E6%94%AF%E9%85%8D%E6%A0%91/"/>
    
    <category term="dfs" scheme="https://dyd-true.github.io/tags/dfs/"/>
    
  </entry>
  
  <entry>
    <title>线性基</title>
    <link href="https://dyd-true.github.io/2021/11/28/%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
    <id>https://dyd-true.github.io/2021/11/28/%E7%BA%BF%E6%80%A7%E5%9F%BA/</id>
    <published>2021-11-28T11:04:24.000Z</published>
    <updated>2021-11-28T13:53:59.422Z</updated>
    
    <content type="html"><![CDATA[<p> 一堆无意义的定义</p><span id="more"></span><h1 id="线性基"><a href="#线性基" class="headerlink" title="线性基"></a>线性基</h1><p>线性基是竞赛中常用来解决<strong>子集异或</strong>一类题目的算法</p><h2 id="数学相关定义"><a href="#数学相关定义" class="headerlink" title="数学相关定义"></a>数学相关定义</h2><p>一大堆没用的</p><h3 id="向量空间"><a href="#向量空间" class="headerlink" title="向量空间"></a>向量空间</h3><p>向量空间亦称线性空间，具体可见<a href="https://baike.baidu.com/item/%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4">百度百科</a>，反正简单来说，就是定义了加法和乘法的向量的集合（其实完全不一样，但我们只需要用到这么多）</p><h3 id="线性相关和线性无关"><a href="#线性相关和线性无关" class="headerlink" title="线性相关和线性无关"></a>线性相关和线性无关</h3><p>若 $V$ 是一个向量空间（集合），如果存在不全为零的系数数列 $c_1, c_2, …, c_n \in \mathbb{F}$ （ $\mathbb{F}$ 是<a href="https://baike.baidu.com/item/%E4%BB%A3%E6%95%B0%E6%95%B0%E5%9F%9F/9551710?fr=aladdin">代数域</a>），使得 $c_1 \vec{v_1} + c_2 \vec{v_2} + … +c_n \vec{v_n} = 0$ （即 $\exists \vec{v_j}$ 可以被除它本身外其它属于 $V$ 的向量表示出来），那么 $V$ 中的向量就叫做<strong>线性相关</strong>的，反之，则为<strong>线性无关</strong>的</p><h3 id="子空间"><a href="#子空间" class="headerlink" title="子空间"></a>子空间</h3><p>设 $W$ 为向量空间 $V$ 的一个非空子集，若 $W$ 在 $V$ 的加法及标量乘法下是封闭的，且零向量 $\vec{0} \in W$ ，就称 $W$ 为 $V$ 的<strong>线性子空间</strong>，简称<strong>子空间</strong></p><h3 id="扩张和生成集合"><a href="#扩张和生成集合" class="headerlink" title="扩张和生成集合"></a>扩张和生成集合</h3><p>给出一个向量集合 $B$ ，那么<strong>包含它</strong>的<strong>最小</strong>子空间 $W$ 就称为它的<strong>扩张</strong>（也叫<strong>张成</strong>），记作 $span(B)$ ，另外规定空集的扩张为 ${\vec{0}}$ </p><p>而 $B$ 也被叫做 $W$ 的<strong>生成集合</strong>（可以理解为通过 $B$ 中的元素可以将 $W$ 中的所有元素表示出来）</p><h3 id="基和维度"><a href="#基和维度" class="headerlink" title="基和维度"></a>基和维度</h3><p>给出一个向量集合 $B$ ，若 $B$ 是<strong>线性无关</strong>的，且 $B$ 能够生成 $V$ ，就称 $B$ 为 $V$ 的一个<strong>基</strong></p><p>对非零向量空间 $V$ ，基是 $V$ 最小的生成集，也是<a href="https://baike.baidu.com/item/%E6%9E%81%E5%A4%A7%E7%BA%BF%E6%80%A7%E6%97%A0%E5%85%B3%E7%BB%84">极大线性无关组</a></p><p>如果一个向量空间 $V$ 拥有一个元素个数<strong>有限</strong>的生成集，那么就称 $V$ 是一个<strong>有限维空间</strong>，向量空间的所有基拥有<strong>相同基数</strong>，称为该空间的<a href="https://baike.baidu.com/item/%E7%BB%B4%E5%BA%A6">维度</a></p><p>空间内的每个向量都有唯一的方法表达成基中向量的<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E7%BB%84%E5%90%88">线性组合</a>，而且，将基中向量进行排列，表示成有序基，每个向量便可以坐标系统来表示</p><h2 id="线性基-1"><a href="#线性基-1" class="headerlink" title="线性基"></a>线性基</h2><p>扯了那么多没有用的，下面才是真的要用的</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>线性基其实就是上面数学定义中，将向量空间的加法和乘法定义为<strong>异或</strong>的意义下的基，具体来说，在异或的定义下：</p><ul><li>用<strong>无符号整数集</strong>来替代<strong>向量的集合</strong></li><li>对于集合 $B$ ，在其中选出任意多个数，其异或和的所有可能的结果组成的集合 $S$ 称作 $B$ 的<strong>扩张</strong>，记为 $span(B)$ </li><li>对于一个集合 $B$ ，若存在一个元素可以用其它若干个元素异或起来得到，则称 $B$ 中元素<strong>线性相关</strong>，反之，则为<strong>线性无关</strong></li><li>对于集合 $B, S$ ，若 $S \subseteq span(B)$ 且 $B$ 线性无关，则称 $B$ 为 $S$ 的<strong>线性基</strong>，集合 $B$ 中元素的个数，称为线性基的<strong>长度</strong></li></ul><p>个人觉得对照这数学中的定义还是比较好理解的</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>若 $B$ 是 $S$ 的线性基，则 $S$ 中的任意元素都可以<strong>唯一</strong>表示为 $B$ 中若干个元素异或起来的结果，正确性显然</p><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p>设 $S$ 中最大的数在二进制下有 $L$ 为，我们用一个下标为 $0 \sim L$ 的数组 $a[]$ 来存储线性基，在接下来的构造中，我们称第 $i$ 位<strong>存在于</strong>线性基中，当且仅当 $a[i] \ne 0$</p><p>首先，线性基是动态构造的，我们只需要从空的，每次考虑在一个已存在的线性基中插入一个数 $t$ 即可</p><p>从 $t$ 最高位上的1开始考虑，设这是第 $j$ 位，如果这一位已经存在于线性基中，则我们需要将 $t$ 中的这一位消掉（将 $t$ 异或上 $a[i]$ ），才可以继续插入（因为要保证 $B$ 线性无关）；如果这一位不存在于线性基中，则可以将  插入到 $a[j]$ 的位置上</p><p>对于具体实现，我们采用逆序枚举 $t$ 所以为1的二进制位 $j$ ，对于每个 $j$ ：</p><ol><li>若 $a[j] \ne 0$ ，则 $t = t \oplus a[j]$ </li><li>若 $a[j] = 0$ ，则 $a[i] = t$ ，结束</li></ol><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>线性基支持一下操作：</p><ul><li><p>求集合的最大异或和：</p><p>只需倒序枚举每一个 $a[i]$ ，贪心异或即可</p></li><li><p>求集合的最小异或和：</p><p>先特判能否为0，然后正序序枚举每一个 $a[i]$ ，第一个存在的就是答案</p></li><li><p>查询 $t$ 是否在值域中</p><p>类似于插入</p></li><li><p>查询第 $k$ 小的值</p><p>先特判减去0，然后从高到低处理线性基每一位，对于每一位向后扫，如果当前数第 $i$ 位为0，且线性基第 $i$ 位不为0，则将当前数异或上 $a[i]$ ，这一操作可以在 $O(L^2)$ 的时间内解决，我们称其为重构<br>经过这一步操作后，设线性基内共有 $cnt$ 个数，则它们共可以表示出 $2^{cnt}$ 个数<br>随后，我们考虑将 $k$ 二进制拆分，用与快速幂类似的方法就可以求出第 $k$ 小值</p></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>一定要注意long long</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">64</span>; <span class="comment">//这个N一定要开对，大了小了都不行</span></span><br><span class="line">LL a[N], tmp[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">a[i] = tmp[i] = <span class="number">0</span>;</span><br><span class="line">cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line"><span class="keyword">if</span> ((x &gt;&gt; i) &amp; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!a[i])</span><br><span class="line">&#123;</span><br><span class="line">a[i] = x;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">x ^= a[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">get_max</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">res = <span class="built_in">max</span>(res ^ a[i], res);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">get_min</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> _c = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line"><span class="keyword">if</span> (a[i])</span><br><span class="line">++_c;</span><br><span class="line"><span class="keyword">if</span> (_c &lt; n)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line"><span class="keyword">if</span> (a[i])</span><br><span class="line"><span class="keyword">return</span> a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> ((x &gt;&gt; i) &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">if</span> (!a[i])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">x^=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">()</span> <span class="comment">//重构线性基</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line"><span class="keyword">if</span> ((a[i] &gt;&gt; j) &amp; <span class="number">1</span>)</span><br><span class="line">a[i] ^= a[j];</span><br><span class="line"><span class="keyword">if</span> (a[i])</span><br><span class="line">tmp[cnt++] = a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i)</span><br><span class="line">a[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">get_k</span><span class="params">(LL k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (cnt &lt; n)</span><br><span class="line">--k;</span><br><span class="line">    <span class="keyword">if</span>(!k)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= (<span class="number">1ll</span> &lt;&lt; cnt))</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i)</span><br><span class="line">    <span class="keyword">if</span> ((k &gt;&gt; i) &amp; <span class="number">1</span>)</span><br><span class="line">    res ^= a[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个用vector实现，比较短的（太香了）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line">vector&lt;LL&gt; b;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (LL i : b)</span><br><span class="line">x = <span class="built_in">min</span>(x ^ i, x);</span><br><span class="line"><span class="keyword">for</span> (LL &amp;i : b)</span><br><span class="line">i = <span class="built_in">min</span>(x ^ i, i);</span><br><span class="line"><span class="keyword">if</span> (x)</span><br><span class="line">b.<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">get_max</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (LL i : b)</span><br><span class="line">res = <span class="built_in">max</span>(res ^ i, res);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">get_min</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (b.<span class="built_in">size</span>() &lt; n)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> b[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (LL i : b)</span><br><span class="line">x = <span class="built_in">min</span>(x ^ i, x);</span><br><span class="line">    <span class="keyword">return</span> x == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">get_k</span><span class="params">(LL k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (b.<span class="built_in">size</span>() &lt; n) <span class="comment">//减去为0的情况</span></span><br><span class="line">    --k;</span><br><span class="line">    <span class="keyword">for</span> (LL i : b)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span> (k &amp; <span class="number">1</span>)</span><br><span class="line">    res ^= i;</span><br><span class="line">    k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 一堆无意义的定义&lt;/p&gt;</summary>
    
    
    
    
    <category term="数论,数学" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
    <category term="线性基" scheme="https://dyd-true.github.io/tags/%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
    
  </entry>
  
  <entry>
    <title>斯特林数</title>
    <link href="https://dyd-true.github.io/2021/11/28/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"/>
    <id>https://dyd-true.github.io/2021/11/28/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/</id>
    <published>2021-11-28T07:40:53.000Z</published>
    <updated>2021-11-28T11:05:01.320Z</updated>
    
    <content type="html"><![CDATA[<p> 还是卡特兰数简单一点……</p><span id="more"></span><h1 id="斯特林数"><a href="#斯特林数" class="headerlink" title="斯特林数"></a>斯特林数</h1><h2 id="第一类斯特林数"><a href="#第一类斯特林数" class="headerlink" title="第一类斯特林数"></a>第一类斯特林数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>第一类斯特林数（Stirling）分为无符号第一类斯特林数 $s_s(n, m)$ 和带符号第一类斯特林数 $s_u(n, m)$ ，有无符号斯特林数分别表现为其升阶函数和降阶函数的各项系数（<del>反正我是没看懂</del>），形式如下：<br>$$<br>\begin{aligned}<br>x^{n\uparrow} = x(x + 1)(x + 2)…(x + n - 1) = \sum_{k = 0}^{n}s_u(n, k)x^k\\<br>x^{n\downarrow} = x(x - 1)(x - 2)…(x - n  + 1) = \sum_{k = 0}^{n}s_s(n, k)x^k\\<br>\end{aligned}<br>$$<br>对于有无符号斯特林数之间的关系有 $s_s(n, m) = (-1)^{n + m}s_u(n, m)$</p><p>组合数学中的第一类斯特林数一般指无符号的第一类斯特林数，以下的“第一类斯特林数”若无特殊说明，也指“无符号的第一类斯特林数”，无符号的第一类斯特林数还有一个组合数学上的定义，为： $n$ 个不同元素构成 $m$ 个圆排列（两个圆排列间没有顺序之分）的方案数，记作 $s(n, m)$ 或 ${n \brack m}$ </p><h3 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h3><p>第一类斯特林数有一个递推式：<br>$$<br>{n \brack m} = {n - 1 \brack m - 1} + (n - 1){n - 1 \brack m}<br>$$<br>证明：</p><p>考虑第一类斯特林数的定义，${n \brack m}$ 表示把 $n$ 个不同元素构成 $m$ 个圆排列的方案数，对于第 $n$ 个数，若它单独成为新的一个圆，则它前面的 $n - 1$ 个数构成了 $m - 1$ 个圆，方案数为 ${n - 1 \brack m - 1}$ ；若它加入到前面构成的圆中，则它前面的 $n - 1$ 个数构成了 $m$ 个圆，方案数为 ${n - 1 \brack m}$ ，而这 $n - 1$ 个数间有 $n - 1$ 空位可以选择，共 $(n - 1){n - 1 \brack m}$  种方案</p><p>两种情况综合，即得递推式</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>, P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> s[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">s[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">s[i][j] = (s[i - <span class="number">1</span>][j - <span class="number">1</span>] + (LL)(i - <span class="number">1</span>) * s[i - <span class="number">1</span>][j]) % P;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s[n][m]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul><li> ${0 \brack 0} = 1$ </li><li> ${n \brack 0} = 0$ </li><li> ${n \brack n} = 1$ </li></ul><p>以上三条由定义不难得到</p><ul><li><p>  ${n \brack 1} = (n - 1)!$ </p></li><li><p> ${n \brack n - 1} = \binom{n}{2}$ </p></li></ul><p>  证明：</p><p>  依然考虑定义，$n$ 个不同元素构成 $n - 1$ 个圆排列，必然有一个圆排列有两个数，其它圆排列只有一个数，有两个数的圆排列有 $\binom{n}{2}$ 种方案，对应其它都只有一种方案</p><ul><li> $\sum_{k = 0}^{n} {n \brack k} = n!$ </li></ul><p>  证明：</p><p>  令升阶函数中的 $x = 1$ ，即得原式</p><h2 id="第二类斯特林数"><a href="#第二类斯特林数" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>第二类斯特林数实际上是集合的一个拆分，表示将 $n$ 个不同的元素划分成 $m$ 个集合（两个集合间没有顺序之分）的方案数，记为 $S(n, m)$ 或 ${n \brace m}$ ，和第一类斯特林数不同的是，集合内是不考虑次序的，而圆排列是有序的</p><h3 id="求法-1"><a href="#求法-1" class="headerlink" title="求法"></a>求法</h3><p>递推式：<br>$$<br>{n \brace m} = {n - 1 \brace m - 1} + m {n - 1 \brace m}<br>$$<br>还是考虑定义，将 $n$ 个不同的元素划分成 $m$ 个集合，对于第 $n$ 个数，可以单独为一个集合，则前面 $n - 1$ 个数构成 $m - 1$ 个集合，方案数为 ${n - 1 \brace m - 1}$ ；也可以加入到原有集合中，则前面 $n - 1$ 个数构成 $m$ 个集合，方案数为 ${n - 1 \brace m}$ ，而第 $n$ 个数在 $m$ 个集合中选一个加入，方案数为 $m$ </p><p>两种情况综合，即得递推式</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>, P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> S[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">S[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">S[i][j] = (S[i - <span class="number">1</span>][j - <span class="number">1</span>] + (LL)j * S[i - <span class="number">1</span>][j]) % P;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, S[n][m]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算式：<br>$$<br>{n \brace m} = \frac{1}{m!} \sum_{k = 0}^{m} (-1)^k \binom{m}{k} (m - k)^n<br>$$<br>证明见<a href="https://baike.baidu.com/item/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0">百度百科</a></p><h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><ul><li> ${n \brace 0} = 0^n$ </li><li> ${n \brace 1} = 1$ </li><li> ${n \brace n} = 1$ </li><li> ${n \brace 2} = 2^{n - 1} - 1$ </li><li> ${n \brace n - 1} = \binom{n}{2}$ </li><li> $\sum_{k = 0}^{n} {n \brace k} = B_n$ ，其中 $B_n$ 是<a href="https://baike.baidu.com/item/%E5%80%8D%E5%B0%94%E6%95%B0/369479?fromtitle=%E8%B4%9D%E5%B0%94%E6%95%B0&fromid=9227873">贝尔数</a>  </li></ul><h2 id="两类斯特林数的关系"><a href="#两类斯特林数的关系" class="headerlink" title="两类斯特林数的关系"></a>两类斯特林数的关系</h2><p>其实就一个：<br>$$<br>\sum_{k = 0}^{n} {n \brace k}{k \brack m} = \sum_{k = 0}^{n} {n \brack k}{k \brace m}<br>$$</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.com.cn/problem/P4609">建筑师</a></p><p>以高度为 $n$ 的建筑为分界线，左边选择 $A - 1$ 个建筑让他们可以被看见，右边 $B - 1$ 个，如图：</p><p><img src="https://i.loli.net/2021/11/28/lhKaJEux2kpqHmW.jpg" alt="AB"></p><p>问题转化为将 $1 \sim n - 1$ 划分为 $A + B - 2$ 部分（即红框里的），对于每一个部分，将其中元素排成一个圆排列，放置时保证最高的在最左边（如果是放在 $n$ 右边，则最高的在最右边），故有 ${n \brack m}$ 种方案</p><p>然后将这些部分划分给  $n$ 两边，有 $\binom{A + B - 2}{A - 1}$ 种方案</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span> + <span class="number">5</span>, P = <span class="number">1e9</span> + <span class="number">7</span>, M = <span class="number">200</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> s[N][M], C[M][M];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pred</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">s[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; M; ++j)</span><br><span class="line">s[i][j] = (s[i - <span class="number">1</span>][j - <span class="number">1</span>] + (LL)(i - <span class="number">1</span>) * s[i - <span class="number">1</span>][j]) % P;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j)</span><br><span class="line"><span class="keyword">if</span> (!j)</span><br><span class="line">C[i][j] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">C[i][j] = (C[i - <span class="number">1</span>][j] + C[i - <span class="number">1</span>][j - <span class="number">1</span>]) % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">pred</span>();</span><br><span class="line"><span class="keyword">int</span> T, n, a, b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line"><span class="keyword">while</span> (T--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;a, &amp;b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (LL)s[n - <span class="number">1</span>][a + b - <span class="number">2</span>] * C[a + b - <span class="number">2</span>][a - <span class="number">1</span>] % P);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 还是卡特兰数简单一点……&lt;/p&gt;</summary>
    
    
    
    
    <category term="数论,数学" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
    <category term="Stirling数,斯特林数" scheme="https://dyd-true.github.io/tags/Stirling%E6%95%B0-%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"/>
    
    <category term="排列组合" scheme="https://dyd-true.github.io/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>luoguP4429 [BJOI2018]染色</title>
    <link href="https://dyd-true.github.io/2021/11/28/luoguP4429-BJOI2018-%E6%9F%93%E8%89%B2/"/>
    <id>https://dyd-true.github.io/2021/11/28/luoguP4429-BJOI2018-%E6%9F%93%E8%89%B2/</id>
    <published>2021-11-28T02:02:51.000Z</published>
    <updated>2021-11-28T06:23:17.876Z</updated>
    
    <content type="html"><![CDATA[<p> 结论题，靠手玩</p><span id="more"></span><p>拿到题就先被吓了一跳，然后又看了看数据范围，毫无提示性</p><p>先盲猜一手考的二分图，也就是每个点的颜色集合都相同，然后……<del>理所当然的</del> 错了，但还是给了我们一点希望，因为我们发现明显，存在奇环就是No</p><p>那就还有不存在环和存在偶环两种情况</p><p>不存在环，即 $m &lt; n$ ，考虑节点 $u$ 染为颜色 $A$ ，那么与它相连的节点 $v$ 最多只是有一个颜色不能染，此外便再无其它限制，明显是有染色方案的，故为Yes</p><p>再考虑偶环的情况，若只有一个偶环，即 $n = m$ ，我们将其断开，记断开处两个节点为根节点和尾节点，从根节点开始用无环的方法染色，设根节的颜色集合为 ${A, B}$ ，分三种情况：</p><ol><li>若尾节点的颜色集合为 ${C, D}$ ，则染色成立</li><li>若尾节点的颜色集合为 ${A, C}$ ，只要根节点染为颜色 $B$ 即可</li><li>若尾节点的颜色集合为 ${A, B}$ ，设根节点染为颜色 $A$ 如果要让尾节点也必须染颜色 $A$ 则与尾节点相连的另一个点必须染为颜色 $B$ ，以此类推，每个节点的颜色都是“必须染成颜色 $X$ ”，设于根节点相连的另一个点的颜色是必须染成颜色 $E$ （这个 $E$ 可以等于于任何颜色，包括 $A, B$ ），由于这个“必须”，该节点的颜色集合一定是 ${A, E}$ （这样才能用“根节点染成颜色 $A$ ”推出“该节点染成颜色 $E$ ”），那么只要将根节点染成颜色 $B$ ，该节点染成颜色 $E$ ，由于刚才的一系列“必须”，尾节点只能保持颜色 $A$ 不变，染色成立</li></ol><p>综上，若只有一个偶环，必定可以染色，故为Yes</p><p>那有多个偶环，即 $m &gt; n$ ，怎么办？</p><p>先考虑两个偶环没有公共边，看看下图：</p><p><img src="https://i.loli.net/2021/11/28/41UTVmnNBcKjADr.png" alt="偶环"></p><p>不难发现在这种构造下，最下方的点只能选颜色 $X$ </p><p>于是有下图：</p><p><img src="https://i.loli.net/2021/11/28/OhjP4dcNZMFwrt8.png" alt="卡"></p><p>明显为No</p><p>推广一下，考虑把节点 ${C, D}$ 拆成多个节点相连，换句话说，用多个节点连成的链作为广义的“交叉节点”，我们 <del>玄学的</del> 得出了结论：如果存在两个没有公共边但联通的环，那么答案是No，构造方法类似上图，可以证明（<del>我也不知道咋证</del>）这种情况的充分条件为 $m &gt; n + 1$ </p><p>最后只剩一种情况： $m = n + 1$ 且为偶环</p><p>这种情况下，要么有一个点度数为4，要么有两个点度数为3，度数为四的情况就和上图一样，明显为No</p><p>考虑两个度数为3的点，它们之间必定有3条路径，设路径长度（经过的边数）分别为 $(x, y, z)$ ，<del>手玩一下</del> 发现只有 $(2, 2, 2k), k\in \mathbb{N_+}$ 的情况为Yes</p><hr><p>最后总结一下：</p><ol><li> $m &lt; n$ 为Yes</li><li> $m = n$ 且无奇环为Yes，否则为No</li><li> $m = n + 1$ 且无奇环，若有两个度为3的节点且两点间路径为 $(2, 2, 2k), k\in \mathbb{N_+}$ 则为Yes，否则为No；若有奇环为No</li><li> $m &gt; n + 1$ 为No</li></ol><p>注意以上结论均是在保证图联通的情况下得出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VIT vector<span class="meta-string">&lt;int&gt;</span>::iterator</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, e, v;</span><br><span class="line"><span class="keyword">int</span> c[N], du[N];</span><br><span class="line"><span class="keyword">bool</span> f; <span class="comment">//true-No,false-Yes</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; to[N], cir;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">to[i].<span class="built_in">clear</span>(), c[i] = <span class="number">0</span>;</span><br><span class="line">f = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> _c)</span> <span class="comment">//染色法判奇环</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (f)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span> (c[x])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (c[x] != _c)</span><br><span class="line">f = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">c[x] = _c;</span><br><span class="line">++v;</span><br><span class="line">e += to[x].<span class="built_in">size</span>();</span><br><span class="line">cir.<span class="built_in">push_back</span>(x);</span><br><span class="line"><span class="keyword">for</span> (VIT i = to[x].<span class="built_in">begin</span>(); i != to[x].<span class="built_in">end</span>(); ++i)</span><br><span class="line"><span class="built_in">dfs</span>(*i, <span class="number">3</span> - _c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topu</span><span class="params">()</span> <span class="comment">//拓扑处理非环节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span> (VIT i = cir.<span class="built_in">begin</span>(); i != cir.<span class="built_in">end</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">du[*i] = to[*i].<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (du[*i] == <span class="number">1</span>)</span><br><span class="line">q.<span class="built_in">push</span>(*i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">x = q.<span class="built_in">front</span>(), q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (VIT i = to[x].<span class="built_in">begin</span>(); i != to[x].<span class="built_in">end</span>(); ++i)</span><br><span class="line"><span class="keyword">if</span>(--du[*i] == <span class="number">1</span>)</span><br><span class="line">q.<span class="built_in">push</span>(*i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> T, t, tt;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line"><span class="keyword">while</span> (T--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">to[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">to[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">if</span> (!c[i])</span><br><span class="line">&#123;</span><br><span class="line">e = v = <span class="number">0</span>;</span><br><span class="line">cir.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">dfs</span>(i, <span class="number">1</span>);</span><br><span class="line">e /= <span class="number">2</span>; <span class="comment">//存的是双向边,真正的边数要除以2</span></span><br><span class="line"><span class="keyword">if</span> (e &gt; v + <span class="number">1</span>)</span><br><span class="line">f = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (f)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (e &lt;= v)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">topu</span>();</span><br><span class="line">tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (VIT j = cir.<span class="built_in">begin</span>(); j != cir.<span class="built_in">end</span>(); ++j)</span><br><span class="line"><span class="keyword">if</span> (du[*j] == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (VIT k = to[*j].<span class="built_in">begin</span>(); k != to[*j].<span class="built_in">end</span>(); ++k)</span><br><span class="line"><span class="keyword">if</span> (du[*k] == <span class="number">3</span>)</span><br><span class="line">++t;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="number">2</span>)</span><br><span class="line">++tt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tt &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">f = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (f)</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 结论题，靠手玩&lt;/p&gt;</summary>
    
    
    
    
    <category term="图论" scheme="https://dyd-true.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="结论" scheme="https://dyd-true.github.io/tags/%E7%BB%93%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>luoguP2723 [USACO3.1]丑数 Humble Numbers</title>
    <link href="https://dyd-true.github.io/2021/11/28/luoguP2723-USACO3-1-%E4%B8%91%E6%95%B0-Humble-Numbers/"/>
    <id>https://dyd-true.github.io/2021/11/28/luoguP2723-USACO3-1-%E4%B8%91%E6%95%B0-Humble-Numbers/</id>
    <published>2021-11-28T00:47:16.000Z</published>
    <updated>2021-11-28T01:49:45.263Z</updated>
    
    <content type="html"><![CDATA[<p> 时间复杂度的计算是个技术活</p><span id="more"></span><p>第一次想到的是用一个小根堆，每次取出最小值，乘其它数的积插入堆中，最后取出的第 $n$ 个就是答案，然鹅，时间（ $O(n^2\log n)$ ）和空间（ $O(n^2)$ ）上都不允许（ $n \le 10^5$ 太艹了）</p><p>然后发现其实真正有用的跟新只有 $f[i] * a[i]$ 的形式，其中 $f[i]$ 表示第 $i$ 个丑数， $a[i]$ 表示质数，由于 $k$ 很小，用平衡树维护貌似可做？（<del>黄题啊，平衡树个寂寞啊</del>）</p><p>最后实在 <del>不想打平衡树</del> 想不出来，一看题解：艹，暴力求第 $n$ 个就好了，加个记录的优化，时间复杂度 $O(nk \xi)$ ，其中 $\xi$ 代表玄学因子（因为没人知道那层while会跑多少），空间复杂度 $O(n)$ </p><p>无语，这个故事告诉我们不要一看见 $10^5$ 就想 $n\log n$  </p><p>似乎要long long</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, K = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> LL INF = (LL)<span class="number">1e18</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> k, n;</span><br><span class="line">LL f[N];</span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;k, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"><span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + k);</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//有只有一个质因数的情况,所以从1开始</span></span><br><span class="line">LL mn;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">mn = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里是一个优化(不加会TLE),用b记录每个质数对应的最小的f[i]</span></span><br><span class="line"><span class="comment">下一次的i只会更大而不会更小</span></span><br><span class="line"><span class="comment">当然,也可以写二分查找f[i],时间复杂度更稳定一点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">while</span> (f[b[j]] * a[j] &lt;= f[i - <span class="number">1</span>])</span><br><span class="line">++b[j];</span><br><span class="line">mn = <span class="built_in">min</span>(f[b[j]] * a[j], mn);</span><br><span class="line">&#125;</span><br><span class="line">f[i] = mn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, f[n]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 时间复杂度的计算是个技术活&lt;/p&gt;</summary>
    
    
    
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="USACO" scheme="https://dyd-true.github.io/tags/USACO/"/>
    
    <category term="暴力" scheme="https://dyd-true.github.io/tags/%E6%9A%B4%E5%8A%9B/"/>
    
    <category term="枚举" scheme="https://dyd-true.github.io/tags/%E6%9E%9A%E4%B8%BE/"/>
    
  </entry>
  
  <entry>
    <title>luoguP2991 [USACO10OPEN]Water Slides G</title>
    <link href="https://dyd-true.github.io/2021/11/26/luoguP2991-USACO10OPEN-Water-Slides-G/"/>
    <id>https://dyd-true.github.io/2021/11/26/luoguP2991-USACO10OPEN-Water-Slides-G/</id>
    <published>2021-11-26T14:23:15.000Z</published>
    <updated>2021-11-28T00:15:32.325Z</updated>
    
    <content type="html"><![CDATA[<p> 题目描述过于“清晰”</p><span id="more"></span><p>最开始理解了，以为是一个搜索，大概是预处理出每个点到终点的最长路，然后bfs，每个状态由位置、失误次数、权值和组成，不会TLE</p><p>但其实题目要求中失误是走“最坏的”，而不失误是走“最好的”；我理解的失误是走“除最好的以外的节点”（<del>太nm离谱了</del>）</p><p>再看原题，发现只有两种选择（最好的和最坏的），在暴搜的基础上加一个记忆化，令 $f[i][j]$ 表示从 $i$ 走到 $n$ 失误 $j$ 条边的情况下最大权值和，明显有 $f[n][0] = 0$ ， $Ans = f[1][k]$ ，由于是在一个DAG上，在搜索时转移，方程为<br>$$<br>f[u][j] =<br>\begin{cases}<br>    \min(f[v][j - 1] + w_{u,v})\\<br>    \max(f[v][j] + w_{u,v})<br>\end{cases}<br>$$<br>最后，记得开long long</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span> + <span class="number">5</span>, M = <span class="number">1.5e5</span> + <span class="number">5</span>, K = <span class="number">10</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line">LL f[N][K];</span><br><span class="line"><span class="keyword">bool</span> vis[N][K];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ne, ver;</span><br><span class="line">LL w;</span><br><span class="line">&#125; e[M];</span><br><span class="line"><span class="keyword">int</span> h[N], idx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, LL z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx] = (Edge)&#123;h[x], y, z&#125;, h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[x][j])</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="built_in">dp</span>(y, j);</span><br><span class="line">f[x][j] = <span class="built_in">max</span>(f[y][j] + e[i].w, f[x][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="built_in">dp</span>(y, j - <span class="number">1</span>);</span><br><span class="line">f[x][j] = <span class="built_in">min</span>(f[y][j - <span class="number">1</span>] + e[i].w, f[x][j]);</span><br><span class="line">&#125;</span><br><span class="line">vis[x][j] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">h[i] = <span class="number">-1</span>;</span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> u, v;</span><br><span class="line">LL w;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line"><span class="built_in">add</span>(u, v, w);</span><br><span class="line">&#125;</span><br><span class="line">f[n][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">vis[n][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">dp</span>(<span class="number">1</span>, k);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, f[<span class="number">1</span>][k]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 题目描述过于“清晰”&lt;/p&gt;</summary>
    
    
    
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="USACO" scheme="https://dyd-true.github.io/tags/USACO/"/>
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="记忆化" scheme="https://dyd-true.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>luoguP5091 【模板】扩展欧拉定理</title>
    <link href="https://dyd-true.github.io/2021/11/26/luoguP5091-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%89%A9%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/"/>
    <id>https://dyd-true.github.io/2021/11/26/luoguP5091-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%89%A9%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/</id>
    <published>2021-11-26T03:56:02.000Z</published>
    <updated>2021-11-26T14:23:59.439Z</updated>
    
    <content type="html"><![CDATA[<p> 我太弱了</p><span id="more"></span><p>本来以为可以秒杀的（<del>毕竟是板子</del>），但遗忘的比我想象的严重，主要是当 $b &lt; \varphi(m)$ 时，不能让 $b = (b \mod \varphi(m)) + \varphi(m)$ 这个特判改了 ${\color{red} \text{三次}}$ </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20000000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a, m, phi, p;</span><br><span class="line"><span class="keyword">char</span> b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">res = (LL)res * x % p;</span><br><span class="line">x = (LL)x * x % p;</span><br><span class="line">y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%s&quot;</span>, &amp;a, &amp;m, b + <span class="number">1</span>);</span><br><span class="line">phi = p = m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j; i &lt;= m; ++i)</span><br><span class="line"><span class="keyword">if</span> (m % i == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">phi = (LL)phi * (i - <span class="number">1</span>) / i;</span><br><span class="line"><span class="keyword">while</span> (m % i == <span class="number">0</span>)</span><br><span class="line">m /= i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">strlen</span>(b + <span class="number">1</span>), bb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">8</span>) <span class="comment">//特判</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">bb = bb * <span class="number">10</span> + b[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (bb &gt;= phi)</span><br><span class="line">bb = bb % phi + phi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">bb = (bb * <span class="number">10</span> + b[i] - <span class="string">&#x27;0&#x27;</span>) % phi;</span><br><span class="line">bb += phi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">qpow</span>(a, bb));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 我太弱了&lt;/p&gt;</summary>
    
    
    
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="模板" scheme="https://dyd-true.github.io/tags/%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="扩展欧拉定理" scheme="https://dyd-true.github.io/tags/%E6%89%A9%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>生成函数</title>
    <link href="https://dyd-true.github.io/2021/11/24/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    <id>https://dyd-true.github.io/2021/11/24/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/</id>
    <published>2021-11-24T09:05:49.000Z</published>
    <updated>2021-11-24T09:27:28.910Z</updated>
    
    <content type="html"><![CDATA[<p>too difficult for me</p><span id="more"></span><h1 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>任给我们一个序列 ${ a_i } ( i \in [ 0, n ] )$ ，可以定义一个函数 $g(x) = a_0 + a_1x + a_2x^2 + … + a_nx^n$ （一般为了使函数可以收敛，定义 $x \in ( -1, 1 )$ ），则称 $g(x)$ 为序列 ${ a_i }$ 的生成函数</p><p>我们将序列转化为函数的原因是为了用函数的知识（一般是数学知识，数学不好的慎用）使问题变的简单</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.acwing.com/problem/content/3135/">食物</a></p><p>本题是一个常用的转换，即将乘法原理转化为多项式的乘法，具体如下：</p><p>先将每一种食物当作一个子问题，如，对于食物1 ，定义序列 ${ a_i }$  为只选食物1能够选出 $i$ 个食物的方案数，由于食物以只能选偶数个，故 ${ a_i } = { 1,0,1,0,1…}$ ，定义其生成函数为 $f_1(x) = 1 + x^2 + x^4 + x^6 + … (x \in (-1, 1))$ 由等比数列求和公式有 $f_1(x) = \frac{1 - x^n}{1 - x^2}$ ，又因为 $n \rightarrow \infty$ ，所以 $x^n \rightarrow 0$ ，则 $f_1(x) = \frac{1}{1 - x^2}$ </p><p>同理，有：<br>$$<br>\begin{align}<br>f_2(x) &amp;= 1 + x = \frac{1 - x^2}{1 - x}\\<br>f_3(x) &amp;= 1 + x + x^2 = \frac{1 - x^3}{1 - x}\\<br>f_4(x) &amp;= x + x^3 + x^5 + … = \frac{x}{1 - x^2}\\<br>f_6(x) &amp;= 1 + x^4 + x^8 + … = \frac{1}{1 - x^4}\\<br>f_6(x) &amp;= 1 + x + x^2 + x^3 = \frac{1 - x^4}{1 - x}\\<br>f_7(x) &amp;= 1 + x = \frac{1 - x^2}{1 - x}\\<br>f_8(x) &amp;= 1 + x^3 + x^6 + x^9 = \frac{1}{1 - x^3}\\<br>\end{align}<br>$$<br> 设 $Ans(x) = \prod_{i = 1}^{8} f_i(x)$ ，则答案即为 $Ans(x)$ 展开后 $x^n$ 项的系数，证明可以考虑乘法原理，每一个多项式 $f_i(x)$ 中选一项 $ai_jx^j$ ，代表用第 $i$ 种食物凑成 $j$ 个的方案数有 $ai<br><em>j$ 种，乘起来方案共有 $\prod</em>{i = 1}^{8} ai_j$ 种，这些方案共献到 $x^{\sum j}$ 中，最后 $x^n$ 的系数就是最终方案数，正确性显然</p><p>现在考虑如何求系数<br>$$<br>\begin{align}<br>Ans &amp;= \prod_{i = 1}^{8} f_i(x)\\<br>    &amp;= \frac{1 - x^2}{1 - x} \frac{1 - x^3}{1 - x} \frac{x}{1 - x^2} \frac{1}{1 - x^4} \frac{1 - x^4}{1 - x} \frac{1 - x^2}{1 - x} \frac{1}{1 - x^3}\\<br>    &amp;= \frac{x}{(1 - x)^4}\\<br>    &amp;= x (1 - x)^{-4}\\<br>\text{又由} &amp;\text{牛顿广义二项式定理（广义二项式定理）：}\\<br>(x + y)^\alpha &amp;= \sum_{k = 0}^{\infty} \binom{\alpha}{k} x^{\alpha - k} y^k , \text{其中} \binom{\alpha}{k} = \frac{\alpha (\alpha - 1) (\alpha - 2) … (\alpha - k + 1)}{k!} , (\alpha \in \mathbb{R})\\<br>\text{有：} &amp; \\<br>(1 - x)^{-4} &amp;= \sum_{k = 0}^{\infty} \binom{-4}{k} 1^{-4 - k} (-x)^{k}\\<br>\text{又因} &amp;\binom{-k}{n} * (-x)^n = [(-1)^n * \binom{n+k-1}{n}] * [(-1)^n * x^n] = \binom{n+k-1}{n} x^n\\<br>\text{故} &amp; (1 - x)^4 \text{展开后} x^n \text系数为 \binom{n+k-1}{n}\\<br>\text{所以}\\<br>Ans &amp;= x (1 - x)^{-4}\\<br>    &amp;= x (\sum_{n = 0}^{\infty} \binom{n + 4 - 1}{4 - 1} x^n)\\<br>    &amp;= \sum_{n = 0}^{\infty} \binom{n + 4 - 1}{4 - 1} x^{n + 1}\\<br>\end{align}<br>$$</p><p>由上， $x^n$ 项的系数为 $\binom{n + 2}{3} = \frac{(n + 2)(n + 1)n}{6}$ ，问题得以解决</p><p> 代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500</span>, P = <span class="number">10007</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>, l = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l; ++i)</span><br><span class="line">n = (n * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>) % P;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (LL)n * (n + <span class="number">1</span>) * (n + <span class="number">2</span>) / <span class="number">6</span> % P); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;too difficult for me&lt;/p&gt;</summary>
    
    
    
    
    <category term="数论,数学" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
    <category term="生成函数" scheme="https://dyd-true.github.io/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>斜率优化dp</title>
    <link href="https://dyd-true.github.io/2021/11/22/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96dp/"/>
    <id>https://dyd-true.github.io/2021/11/22/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96dp/</id>
    <published>2021-11-22T08:42:46.000Z</published>
    <updated>2021-11-24T09:25:44.091Z</updated>
    
    <content type="html"><![CDATA[<p>然而我dp废的一比</p><span id="more"></span><p>用例题开讲：<br><a href="https://www.luogu.com.cn/problem/P2365">P2365 任务安排</a><br>明显<del>看题解</del>可知，dp方程为：<br> $f_i=min(f_j+sumt_i*(sumc_i-sumc_j)+s*(sumc_n-sunc_j),f_i)$<br> 故标程如下：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//P2365</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> t, c;</span><br><span class="line">&#125; sum[N];</span><br><span class="line"><span class="keyword">int</span> n, s;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;t, &amp;c);</span><br><span class="line">        sum[i].t = sum[i - <span class="number">1</span>].t + t;</span><br><span class="line">        sum[i].c = sum[i - <span class="number">1</span>].c + c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">            f[i] = <span class="built_in">min</span>(f[i], f[j] + sum[i].t * (sum[i].c - sum[j].c) + s * (sum[n].c - sum[j].c));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，康康这个——<a href="https://www.luogu.com.cn/problem/P5785">P5785 SDOI2012任务安排</a><br>令人惋惜的是，在数据加强后， $O(n^2)$ 的时间复杂度似乎确凿过不了，为此，我们<del>看题解后</del>想到救星——</p><h2 id="斜率优化"><a href="#斜率优化" class="headerlink" title="斜率优化"></a>斜率优化</h2><p>我们先假设所有的 $t$ 都大于0。<br>我们来康康转移方程：<br>$f_i=min(f_j+sumt_i*(sumc_i-sumc_j)+s*(sumc_n-sunc_j),f_i)$<br>不妨去掉 $min$ 看成：<br>$f_i=f_j+sumt_i*(sumc_i-sumc_j)+s*(sumc_n-sunc_j)$<br>它等价于：<br>$f_i=f_j-(sumt_i+s) * sumc_j+sumt_i* sumc_i+s* sumc_n$<br>设 $f_j=y,sumc_j=x$ （这是所有的关于 $j$ 的变量），然后化为直线表达式 $y=kx+b$ 的形式：<br>$f_j=(sumt_i+s)* sumc_j+f_i-sumt_i* sumc_i-s* umc_n$<br>不难发现 ：</p><ol><li><p>$k=sumt_i+s$ ，故 $0&lt;k&lt;\infty$ 。</p></li><li><p>且 $0 \le j \le i-1,j \in Z$  </p></li><li><p>而直线上的点为：$(f_0,sumc_0)$ 、 $(f_1,sumc_1)$ 、 … 、 $(f_{i-1},sunc_{i-1})$ </p></li><li><p>我们的目标是让 $f_i$ 最小  </p></li></ol><p>我们带着目标，看看图像：<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/u8nbza21.png" alt="xoy"><br>对于一个已知的 $i$ ， $k=sumt_i+s$ 是固定的，而若点 $(x_0,y_0)$在 $y=kx+b$ 上，那么截距 $b$ 是可以算出来的，又因 $b=f_i-sumt_i* sumc_i-s* umc_n$ ，故 $b$ 最小时 $f_i$ 最小。<br>那么，我们康康下图：<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/14w4y6tp.png" alt="xoy2"><br>图中绿色的点是所有可能的 $(x_0,y_0)$ ,红色的线是 $y=kx+b$ （只有 $k$ 确定，所以在从下往上平移）。<br>不难发现，凸包（绿线）内部的点对于 $b$ 的最小值毫无意义。换句话说，<strong>最小值的点只会在凸包上</strong>。<br>那么在凸包上哪一点呢？<br>还是上图，令构成凸包的三条直线斜率为 $k_1,k_2,k_3$ ，由凸包性质可得 $k_1&lt;k_2&lt;k_3$ 。再看看上图中我们要找的那个点（不妨设它为点 $A$ ）， $A$ 所在的两条直线斜率为 $k_2,k_3$ ,且 $k_2&lt;k&lt;k_3$ 也就是说，<strong>对于一个给定斜率为的直线 $y=kx+b$ 让它的截距 $b$ 取得最小值的点就是凸包上第一个斜率大于 $k$ 的线段的下端点</strong>。<br>由此，我们想到在单调队列中维护第一个大于某个数的点。<br>我们又发现，因为 $t$ 大于0，所以：<br>斜率是单调递增的，且新加的点的横坐标也单调递增。<br>所以：<br>在查询的时候，可以将队头小于当前斜率的点全删除掉。<br>在插入的时候，可以将队尾所有不在凸包上的点全删除掉。<br>我们便得到以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll t, c;</span><br><span class="line">&#125; sum[N];</span><br><span class="line">ll n, s;</span><br><span class="line">ll f[N];</span><br><span class="line">ll q[N], hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//除法会损失精度，故改成乘法</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_slopeh</span><span class="params">(ll x, ll y, ll o)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (f[y] - sum[y].c * s - f[x] + sum[x].c * s) &lt;= sum[o].t * (sum[y].c - sum[x].c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_slopet</span><span class="params">(ll x, ll y, ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (f[y] - sum[y].c - f[x] + sum[x].c) * (sum[b].c - sum[a].c) &gt;= (f[b] - sum[b].c - f[a] + sum[a].c) * (sum[y].c - sum[x].c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;s);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ll t, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;t, &amp;c);</span><br><span class="line">        sum[i].t = sum[i - <span class="number">1</span>].t + t;</span><br><span class="line">        sum[i].c = sum[i - <span class="number">1</span>].c + c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x7f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">check_slopeh</span>(q[hh], q[hh + <span class="number">1</span>], i))</span><br><span class="line">            hh++;</span><br><span class="line">        ll j = q[hh];</span><br><span class="line">        f[i] = f[j] + sum[i].t * (sum[i].c - sum[j].c) + s * (sum[n].c - sum[j].c);</span><br><span class="line">        <span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">check_slopet</span>(q[tt - <span class="number">1</span>], q[tt], q[tt], i))</span><br><span class="line">            tt--;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是——60分！哦可恶！题目中的 $t$ 可以为负数，咋办？</p><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><p>我们来看看 $t$ 可以为负数的情况：</p><ol><li><p>$k=sumt_i+s$ ，但 $sumt_i$ 可能小于0，故 $ -\infty &lt;k&lt; \infty$ 。</p></li><li><p>$0 \le j \le i-1,j \in Z$  </p></li><li><p>而直线上的点为：$(f_0,sumc_0)$ 、 $(f_1,sumc_1)$ 、 … 、 $(f_{i-1},sunc_{i-1})$ </p></li><li><p>我们的目标是让 $f_i$ 最小 </p></li></ol><p>其实只有 $k$ 的范围变了， $k$ 可以小于0了，所以：<br>斜率不再具有单调性，但新加的点的横坐标仍然单调递增。<br>所以：<br>在查询的时候，只能用二分来查找了。<br>但在插入的时候，仍可以将队尾所有不在凸包上的点全删除掉。<br>终于，正解如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//P5785</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll t, c;</span><br><span class="line">&#125; sum[N];</span><br><span class="line">ll n, s;</span><br><span class="line">ll f[N];</span><br><span class="line">ll q[N], hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//除法会损失精度，故改成乘法</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_slopeh</span><span class="params">(ll x, ll y, ll o)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (f[y] - sum[y].c * s - f[x] + sum[x].c * s) &lt;= sum[o].t * (sum[y].c - sum[x].c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_slopet</span><span class="params">(ll x, ll y, ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (f[y] - sum[y].c - f[x] + sum[x].c) * (sum[b].c - sum[a].c) &gt;= (f[b] - sum[b].c - f[a] + sum[a].c) * (sum[y].c - sum[x].c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">work</span><span class="params">(ll o)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll l = hh, r = tt;</span><br><span class="line">    <span class="keyword">int</span> ans = l;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        ll mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">check_slopeh</span>(q[mid], q[mid + <span class="number">1</span>], o))</span><br><span class="line">            r = mid - <span class="number">1</span>, ans = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q[ans];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;s);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ll t, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;t, &amp;c);</span><br><span class="line">        sum[i].t = sum[i - <span class="number">1</span>].t + t;</span><br><span class="line">        sum[i].c = sum[i - <span class="number">1</span>].c + c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x7f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ll j = <span class="built_in">work</span>(i);</span><br><span class="line">        f[i] = f[j] + sum[i].t * (sum[i].c - sum[j].c) + s * (sum[n].c - sum[j].c);</span><br><span class="line">        <span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">check_slopet</span>(q[tt - <span class="number">1</span>], q[tt], q[tt], i))</span><br><span class="line">            tt--;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;然而我dp废的一比&lt;/p&gt;</summary>
    
    
    
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="斜率优化" scheme="https://dyd-true.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>线段树</title>
    <link href="https://dyd-true.github.io/2021/11/22/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>https://dyd-true.github.io/2021/11/22/%E7%BA%BF%E6%AE%B5%E6%A0%91/</id>
    <published>2021-11-22T08:41:35.000Z</published>
    <updated>2021-11-24T09:25:29.699Z</updated>
    
    <content type="html"><![CDATA[<p>有点久远了，有点丑</p><span id="more"></span><h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>对于一个区间 $[x,y]$  , 我们将其分为两个区间 :  $[x,mid]$ 和 $[mid+1,y]$  , 在对这两个区间进行同样操作 , 直到无法继续 , 如图 :<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/yiorodlt.png" alt="例子"><br>不难发现 , 线段树除去最后一层后 , 一定是一颗满二叉树 , 深度为 $O(\log{}{N})$  。 所以我们用<strong>父子二倍</strong>的节点编号法:</p><ol><li><p> $root=1$ </p></li><li><p> $x$ 的左节点编号为 $x * 2$  ， 右节点编号为 $x * 2+1$ </p></li></ol><p>一个 $N$ 个叶节点线段数最多有 $4N$ 个节点 , 所以数组要开 $4$ 倍 。  </p><h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><ul><li> $sum$ ：当前区间的总和</li><li> $add$ ：懒标记，表示给以当前节点为根的子树中的每一个节点都加上 $add$ 。不难发现，为维护 $add$ ，我们用一个 $push_down()$ 来下传 $add$ 。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ST</span>&#123;</span></span><br><span class="line">ll sum,add;</span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line">&#125;tr[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[u].add)&#123;</span><br><span class="line">tr[u&lt;&lt;<span class="number">1</span>].add+=tr[u].add;</span><br><span class="line">tr[u&lt;&lt;<span class="number">1</span>].sum+=(ll)(tr[u&lt;&lt;<span class="number">1</span>].r-tr[u&lt;&lt;<span class="number">1</span>].l+<span class="number">1</span>)*tr[u].add;</span><br><span class="line">tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].add+=tr[u].add;</span><br><span class="line">tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum+=(ll)(tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].r-tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].l+<span class="number">1</span>)*tr[u].add;</span><br><span class="line">tr[u].add=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">tr[u].sum=tr[u&lt;&lt;<span class="number">1</span>].sum+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tr[u].l=l,tr[u].r=r;</span><br><span class="line">tr[u].sum=a[r];</span><br><span class="line">tr[u].add=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">tr[u].l=l,tr[u].r=r;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">push_up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)&#123;</span><br><span class="line">tr[u].sum+=(ll)(tr[u].r-tr[u].l+<span class="number">1</span>)*d;</span><br><span class="line">tr[u].add+=d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">push_down</span>(u);</span><br><span class="line"><span class="keyword">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>,l,r,d);</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid) <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,d);</span><br><span class="line"><span class="built_in">push_up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line"><span class="built_in">push_down</span>(u);</span><br><span class="line"><span class="keyword">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">ll as=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) as+=<span class="built_in">ask</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid) as+=<span class="built_in">ask</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">return</span> as;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> l,r,d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;d);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,l,r,d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">ask</span>(<span class="number">1</span>,l,r));</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用1——扫描线"><a href="#应用1——扫描线" class="headerlink" title="应用1——扫描线"></a>应用1——扫描线</h2><p><a href="https://www.luogu.com.cn/problem/P5490">P5490 【模板】扫描线</a>  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line">ll n;</span><br><span class="line">vector&lt;ll&gt;ys;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment</span>&#123;</span></span><br><span class="line">ll k;</span><br><span class="line">ll x,yl,yr;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Segment &amp;t) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&lt;t.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ll _x,ll _yl,ll _yr,ll _k)</span></span>&#123;</span><br><span class="line">x=_x;</span><br><span class="line">yl=_yl;</span><br><span class="line">yr=_yr;</span><br><span class="line">k=_k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;seg[N*<span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LineTree</span>&#123;</span></span><br><span class="line">ll l,r;</span><br><span class="line">ll cnt;</span><br><span class="line">ll len;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ll _l,ll _r,ll _cnt,ll _len)</span></span>&#123;</span><br><span class="line">l=_l;</span><br><span class="line">r=_r;</span><br><span class="line">cnt=_cnt;</span><br><span class="line">len=_len;</span><br><span class="line">&#125;</span><br><span class="line">&#125;tr[N*<span class="number">8</span>];</span><br><span class="line"><span class="function">ll <span class="title">find</span><span class="params">(ll y)</span></span>&#123;</span><br><span class="line"><span class="comment">//lower_bound()函数用于在指定区域内查找不小于目标值的第一个元素。</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">lower_bound</span>(ys.<span class="built_in">begin</span>(),ys.<span class="built_in">end</span>(),y)-ys.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(ll u)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[u].cnt) tr[u].len=ys[tr[u].r+<span class="number">1</span>]-ys[tr[u].l];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(tr[u].l!=tr[u].r)</span><br><span class="line">tr[u].len=tr[u&lt;&lt;<span class="number">1</span>].len+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].len;</span><br><span class="line"><span class="keyword">else</span> tr[u].len=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll u,ll l,ll r)</span></span>&#123;</span><br><span class="line">tr[u].<span class="built_in">init</span>(l,r,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(l!=r)&#123;</span><br><span class="line">ll mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(ll u,ll l,ll r,ll k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)&#123;</span><br><span class="line">tr[u].cnt+=k;</span><br><span class="line"><span class="built_in">push_up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">ll mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid) <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">        <span class="built_in">push_up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">ys.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">ll xr,xl,yr,yl;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld&quot;</span>,&amp;xl,&amp;yl,&amp;xr,&amp;yr);</span><br><span class="line">seg[j++].<span class="built_in">init</span>(xl,yl,yr,<span class="number">1</span>);</span><br><span class="line">seg[j++].<span class="built_in">init</span>(xr,yl,yr,<span class="number">-1</span>);</span><br><span class="line">ys.<span class="built_in">push_back</span>(yl),ys.<span class="built_in">push_back</span>(yr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(ys.<span class="built_in">begin</span>(),ys.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//unique函数功能是去除相邻的重复元素</span></span><br><span class="line"><span class="comment">//它并不真正把重复的元素删除,而是将无重复的元素复制到序列的前段,</span></span><br><span class="line"><span class="comment">//从而覆盖相邻的重复元素.unique返回的迭代器指向超出无重复的元素范围末端的下一个位置.</span></span><br><span class="line"><span class="comment">//erase:删除</span></span><br><span class="line">ys.<span class="built_in">erase</span>(<span class="built_in">unique</span>(ys.<span class="built_in">begin</span>(),ys.<span class="built_in">end</span>()),ys.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">0</span>,ys.<span class="built_in">size</span>()<span class="number">-2</span>);</span><br><span class="line"><span class="built_in">sort</span>(seg,seg+n*<span class="number">2</span>);</span><br><span class="line">ll res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n*<span class="number">2</span>;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;<span class="number">0</span>) res+=tr[<span class="number">1</span>].len*(seg[i].x-seg[i<span class="number">-1</span>].x);</span><br><span class="line"><span class="built_in">modify</span>(<span class="number">1</span>,<span class="built_in">find</span>(seg[i].yl),<span class="built_in">find</span>(seg[i].yr)<span class="number">-1</span>,seg[i].k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>以下是一个维护最值的线段树的修改操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//单点修改,将[x,x]的值改为z</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l[p]==r[p]) dmax[p]=z,<span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> mid=(l[p]+r[p])&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) <span class="built_in">Modify</span>(p&lt;&lt;<span class="number">1</span>,x,z);</span><br><span class="line"><span class="keyword">if</span>(y&gt;mid) <span class="built_in">Modify</span>(p&lt;&lt;|<span class="number">1</span>,x,z);</span><br><span class="line"><span class="comment">//从下往上跟新信息,也叫push_up </span></span><br><span class="line">dmax[p]=<span class="built_in">max</span>(dmax[p&lt;&lt;<span class="number">1</span>],dmax[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125; </span><br><span class="line">   <span class="comment">//调用入口: st.Modify(1,x,z);</span></span><br></pre></td></tr></table></figure><p>以下是一个维护区间和的线段树，支持区间增加，区间乘法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//洛谷P3373 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[N],mod;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ST</span>&#123;</span><span class="comment">//SegmentTree</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dat[N*<span class="number">4</span>];<span class="comment">//维护区间和</span></span><br><span class="line"><span class="keyword">int</span> l[N*<span class="number">4</span>],r[N*<span class="number">4</span>];<span class="comment">//区间 </span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> add[N*<span class="number">4</span>],mul[N*<span class="number">4</span>];<span class="comment">//懒惰标记(lazytag) </span></span><br><span class="line"><span class="comment">//建立区间ll-rr,编号为p </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> ll,<span class="keyword">int</span> rr)</span></span>&#123;</span><br><span class="line"><span class="comment">//初始化lazytag </span></span><br><span class="line">add[p]=<span class="number">0</span>;</span><br><span class="line">mul[p]=<span class="number">1</span>; </span><br><span class="line">l[p]=ll;r[p]=rr;<span class="comment">//以p为编号的节点维护的区间为ll到rr</span></span><br><span class="line"><span class="comment">//ll==rr的话,这个区间就只有一个数,直接让区间维护的值等于a[ll]</span></span><br><span class="line"><span class="keyword">if</span>(ll==rr)</span><br><span class="line">dat[p]=a[ll];</span><br><span class="line"><span class="comment">//否则维护的值等于左儿子加右儿子</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(ll+rr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">Build</span>(p&lt;&lt;<span class="number">1</span>,ll,mid);</span><br><span class="line"><span class="built_in">Build</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,rr);</span><br><span class="line">dat[p]=dat[p&lt;&lt;<span class="number">1</span>]+dat[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];<span class="comment">//当然,具体的维护视题目而定</span></span><br><span class="line">&#125;</span><br><span class="line">dat[p]%=mod; </span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//懒惰标记,规定乘法优先</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Spread</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="comment">//如果懒标记不为0,就将其下传,修改左右儿子维护的值 </span></span><br><span class="line"><span class="keyword">if</span>(add[p]!=<span class="number">0</span>||mul[p]!=<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//根据我们规定的优先度,儿子的值=</span></span><br><span class="line"><span class="comment">//此刻儿子的值*爸爸的乘法lazytag+</span></span><br><span class="line"><span class="comment">//儿子的区间长度*爸爸的加法lazytag</span></span><br><span class="line">dat[p&lt;&lt;<span class="number">1</span>]=(dat[p&lt;&lt;<span class="number">1</span>]*mul[p]+add[p]*(r[p&lt;&lt;<span class="number">1</span>]-l[p&lt;&lt;<span class="number">1</span>]+<span class="number">1</span>))%mod;</span><br><span class="line">dat[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(dat[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]*mul[p]+add[p]*(r[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]-l[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1</span>))%mod;</span><br><span class="line"><span class="comment">//为该节点的左右儿子打上标记,</span></span><br><span class="line">mul[p&lt;&lt;<span class="number">1</span>]=(mul[p&lt;&lt;<span class="number">1</span>]*mul[p])%mod;</span><br><span class="line">mul[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(mul[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]*mul[p])%mod; </span><br><span class="line"><span class="comment">//由于乘法优先,加法打标记时要先乘一下 </span></span><br><span class="line">add[p&lt;&lt;<span class="number">1</span>]=(add[p&lt;&lt;<span class="number">1</span>]*mul[p]+add[p])%mod;</span><br><span class="line">add[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(add[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]*mul[p]+add[p])%mod;</span><br><span class="line"><span class="comment">//下传之后将父节点的懒标记清0</span></span><br><span class="line">mul[p]=<span class="number">1</span>;</span><br><span class="line">add[p]=<span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//区间修改,将区间[x,y]都加上z </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Change_add</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=l[p]&amp;&amp;y&gt;=r[p])&#123;<span class="comment">//被覆盖的话,就对其进行修改</span></span><br><span class="line">dat[p]+=(<span class="keyword">long</span> <span class="keyword">long</span>)z*(r[p]-l[p]+<span class="number">1</span>);</span><br><span class="line">dat[p]%=mod;</span><br><span class="line">add[p]=(add[p]+z)%mod;<span class="comment">//打上懒标记</span></span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果没有被覆盖,就继续向下找,但儿子所维护的区间可能因为</span></span><br><span class="line"><span class="comment">//懒标记的存在而没有修改,因此将懒标记下放</span></span><br><span class="line"><span class="built_in">Spread</span>(p);</span><br><span class="line"><span class="keyword">int</span> mid=(l[p]+r[p])&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) <span class="built_in">Change_add</span>(p&lt;&lt;<span class="number">1</span>,x,y,z);<span class="comment">//如果要修改的区间覆盖了左儿子</span></span><br><span class="line"><span class="keyword">if</span>(y&gt;mid) <span class="built_in">Change_add</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,y,z);<span class="comment">//右儿子同理</span></span><br><span class="line"><span class="comment">//维护值</span></span><br><span class="line">dat[p]=(dat[p&lt;&lt;<span class="number">1</span>]+dat[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])%mod;</span><br><span class="line"><span class="keyword">return</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//区间修改,将区间[x,y]都乘上z</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Change_mul</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=l[p]&amp;&amp;y&gt;=r[p])&#123;</span><br><span class="line">dat[p]=(dat[p]*z)%mod;</span><br><span class="line">mul[p]=(mul[p]*z)%mod;</span><br><span class="line"><span class="comment">//乘法优先,故加法标记也要乘</span></span><br><span class="line">add[p]=(add[p]*z)%mod;</span><br><span class="line"><span class="keyword">return</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//否则同加法,向下找</span></span><br><span class="line"><span class="built_in">Spread</span>(p);</span><br><span class="line"><span class="keyword">int</span> mid=(l[p]+r[p])&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) <span class="built_in">Change_mul</span>(p&lt;&lt;<span class="number">1</span>,x,y,z);</span><br><span class="line"><span class="keyword">if</span>(y&gt;mid) <span class="built_in">Change_mul</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,y,z);</span><br><span class="line">dat[p]=(dat[p&lt;&lt;<span class="number">1</span>]+dat[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])%mod;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//区间查询,查询[x,y]的和 </span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=l[p]&amp;&amp;y&gt;=r[p]) <span class="keyword">return</span> dat[p];<span class="comment">//如果被覆盖，就返回维护的值</span></span><br><span class="line"><span class="comment">//下传懒标记，并查询左右儿子</span></span><br><span class="line"><span class="built_in">Spread</span>(p);</span><br><span class="line"><span class="keyword">int</span> mid=(l[p]+r[p])&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) ans=(ans+<span class="built_in">Ask</span>(p&lt;&lt;<span class="number">1</span>,x,y))%mod;</span><br><span class="line"><span class="keyword">if</span>(y&gt;mid) ans=(ans+<span class="built_in">Ask</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,y));</span><br><span class="line"><span class="keyword">return</span> ans%mod;</span><br><span class="line">&#125; </span><br><span class="line">&#125;st;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;mod);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">st.<span class="built_in">Build</span>(<span class="number">1</span>,<span class="number">1</span>,n); </span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="keyword">int</span> q,x,y,z;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line"><span class="keyword">if</span>(q==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">st.<span class="built_in">Change_mul</span>(<span class="number">1</span>,x,y,z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(q==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">st.<span class="built_in">Change_add</span>(<span class="number">1</span>,x,y,z);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,st.<span class="built_in">Ask</span>(<span class="number">1</span>,x,y));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注：打线段树的时候一定要注意两端取等 </span></span><br><span class="line"><span class="comment">//如51行两端取等，61、62行单边取等 </span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;有点久远了，有点丑&lt;/p&gt;</summary>
    
    
    
    
    <category term="数据结构" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树" scheme="https://dyd-true.github.io/tags/%E6%A0%91/"/>
    
    <category term="线段树" scheme="https://dyd-true.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>网络流</title>
    <link href="https://dyd-true.github.io/2021/11/22/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    <id>https://dyd-true.github.io/2021/11/22/%E7%BD%91%E7%BB%9C%E6%B5%81/</id>
    <published>2021-11-22T08:36:17.000Z</published>
    <updated>2021-11-24T09:25:05.825Z</updated>
    
    <content type="html"><![CDATA[<p>老有用了</p><span id="more"></span><h2 id="网络流的基本概念："><a href="#网络流的基本概念：" class="headerlink" title="网络流的基本概念："></a>网络流的基本概念：</h2><p>一个有向图 $G=(V,E)$ ，每条有向边 $(x,y)$ 都有一个给定的<strong>容量</strong>记为 $c(x,y)$ （若 $c(x,y)=0$ ，就说明不存在边 $(x,y)$ ），图中还有两个特殊节点<strong>源点</strong>、<strong>汇点</strong>分别记为 $S$ 、 $T$ 。 $S$ 会源源不断地流出无穷的水流，但每条边只能通过 $c(x,y)$ 的水流， $T$ 可以容纳无穷的水流，而其余个点无法容纳水流（即流入就必须全部流出）。<br>任意一种满足条件的流水方法（即让水流从 $S$ 流到 $T$ ）叫做<strong>流函数</strong>，记为 $f(x,y)$ （表示从点 $x$ 流向 $y$ 的水流），明显，流函数具有如下性质：</p><ul><li><p>$0 \le f(x,y) \le c(x,y)$</p></li><li><p>$f(x,y)=-f(y,x)$ （即从 $x$ 流向 $y$ 的流量也就是从 $y$ 流向 $x$ 的流量的相反数）</p></li><li><p>$\forall x \ne S,T, \sum\limits_{u,x\in     E}^{}f(u,x)= \sum\limits_{x,v\in     E}^{}f(x,v)$ （即除 $S$ ， $T$ 外其余点流入流量等于流出流量，流量守恒）</p></li></ul><h2 id="残量网络"><a href="#残量网络" class="headerlink" title="残量网络"></a>残量网络</h2><p>对于任意合法的流函数 $f$ ，都可构建一个新图 $G2$ （其实应该记做 $G’$ 但这里为了方便记为 $G2$ ），构建方法如下：</p><ol><li>将原图每条边容量变为 $c(x,y)-f(x,y)$ （即减掉已经用掉的流量）</li><li>对于每条边 $(x,y)$ ，创建它的反向边 $(y,x)$ 并令 $c(y,x)=f(x,y)$ （即以流的流量让它可以反悔再流回来）</li></ol><p>该图G2被我们叫做<strong>残量网络</strong><br>需要注意的是,反向边是我们新加的,原图中并不存在,若原图中本就有边 $(x,y)$ 和边 $(y,x)$ （即原图就有反向边），应在构建原图 $G$ 时就新建一点 $z$ ，使得 $(y,x)$ 变为 $(y,z)$ ， $(z,x)$ 。<br>如图（画的丑求你憋着吧！）<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/2fzwiq9k.png" alt="输入"><br> $\uparrow$ 这是输入的有向图。<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/qp8a10w5.png" alt="G"><br> $\uparrow$ 这是去掉反向边的原图 $G$ 。<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/eri7qydk.png" alt="f"><br> $\uparrow$ 这是一个合法的流函数，图中绿色代表 $f(x,y)$ 。<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/pq7ur9ym.png" alt="G2"><br> $\uparrow$ 这是该流函数的残量网络，蓝色为原图边容量（已改变），紫色为加入的反向边。</p><h2 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h2><p>给定一个网络 $G$ ,对于所有合法的 $f$ ,从 $S$ 流出的流量最大的记为该网络的最大流，如上图中最大流为 $7$ （即是绿色的流函数）<br>最大流的求法很多,但基本思路大体相同：</p><ol><li><p>先找到任意的一个流函数 $f$ ，并构建它的残量网络 $G2$ </p></li><li><p>在 $G2$ 中寻找 $G2$ 的合法流函数（我们一般记其为 $f’$ ，文中称其为 $f2$ ， $f2$ 也叫做<strong>增广路</strong>）</p></li><li><p>将找到的增广路加上原图的流函数构成新的流函（即 $f_{now}=f+f2$ 并将 $G2$ 更新成为 $f_{now}$ 的残量网络）</p></li><li><p>重复第 $2$ ， $3$ 步直到无增广路，此时的 $f$ 即是最大流</p></li></ol><p>该思路的证明比较简单，想了解的可以自己百度，下面放两种算法（都已通过<a href="https://www.luogu.com.cn/problem/P3376">P3376</a>）：</p><h3 id="一-Edmonds-Karp-EK算法"><a href="#一-Edmonds-Karp-EK算法" class="headerlink" title="一.Edmonds-Karp(EK算法)"></a>一.Edmonds-Karp(EK算法)</h3><p>该算法就是以上思路的直接实现，（未优化版）几乎不会用，仅了解即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Edmonds-Karp    O(nm^2)</span></span><br><span class="line"><span class="comment">//n+m = 10^3~10^4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000</span>+<span class="number">5</span>,M=<span class="number">20000</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,S,T;</span><br><span class="line"><span class="keyword">int</span> q[N],incf[N],pre[N];<span class="comment">//q队列,incf残留网络流量,pre前驱边 </span></span><br><span class="line"><span class="keyword">bool</span> vis[N]; </span><br><span class="line"><span class="keyword">int</span> h[N],e[M],f[M],ne[M],idx=<span class="number">0</span>;<span class="comment">//e目标编号,f该边流量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> c)</span></span>&#123;<span class="comment">//使用成对储存的技巧i^1及是i的反向边,不懂的请看第二大部分</span></span><br><span class="line">e[idx]=y,f[idx]=c;</span><br><span class="line">ne[idx]=h[x],h[x]=idx++;</span><br><span class="line"></span><br><span class="line">e[idx]=x,f[idx]=<span class="number">0</span>;</span><br><span class="line">ne[idx]=h[y],h[y]=idx++;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;<span class="comment">//寻找增广路 </span></span><br><span class="line"><span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">q[<span class="number">0</span>]=S,vis[S]=<span class="literal">true</span>,incf[S]=INF;<span class="comment">//初始化,把S的出流量定为无穷大 </span></span><br><span class="line"><span class="keyword">while</span>(hh&lt;=tt)&#123;</span><br><span class="line"><span class="keyword">int</span> t=q[hh++];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i])&#123;</span><br><span class="line"><span class="keyword">int</span> ver=e[i];</span><br><span class="line"><span class="keyword">if</span>(!vis[ver]&amp;&amp;f[i])&#123;<span class="comment">//未到过且还有流量 </span></span><br><span class="line">vis[ver]=<span class="literal">true</span>;</span><br><span class="line">incf[ver]=<span class="built_in">min</span>(incf[t],f[i]);<span class="comment">//最大流量为各边流量最小值 </span></span><br><span class="line">pre[ver]=i;<span class="comment">//记录前驱边 </span></span><br><span class="line"><span class="keyword">if</span>(ver==T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">q[++tt]=ver;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">EK</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> maxflow=<span class="number">0</span>;<span class="comment">//这里仅是本人习惯开了long long</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;<span class="comment">//若存在增广路 </span></span><br><span class="line">maxflow+=incf[T]; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=T;i!=S;i=e[pre[i]^<span class="number">1</span>])&#123;<span class="comment">//pre[i]为前驱边-&gt;pre[i]^1为前驱边的反向边 </span></span><br><span class="line">                                                        <span class="comment">//-&gt;e[pre[i]^]为该反向边的目标点,即是前一个点</span></span><br><span class="line"><span class="comment">//更改残留网络 </span></span><br><span class="line">f[pre[i]]-=incf[T];</span><br><span class="line">f[pre[i]^<span class="number">1</span>]+=incf[T];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;S,&amp;T);</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line"><span class="keyword">int</span> x,y,c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;c);</span><br><span class="line"><span class="built_in">add</span>(x,y,c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld&quot;</span>,<span class="built_in">EK</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二-Di-nic算法"><a href="#二-Di-nic算法" class="headerlink" title="二.Di#nic算法"></a>二.Di#nic算法</h3><p>通过构建<strong>分层图</strong>来使增广时一次性增广多条增广路,是以上思路的优化,本人较为偏爱该算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dinic   O(n^2m)</span></span><br><span class="line"><span class="comment">//n+m = 10^4~10^5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll; </span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1000</span>+<span class="number">5</span>,M=<span class="number">20000</span>+<span class="number">5</span>;<span class="comment">//有方向边M要开2倍 </span></span><br><span class="line"><span class="keyword">const</span> ll INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">ll n,m,S,T;</span><br><span class="line">ll q[N],d[N],cur[N];<span class="comment">//q队列,d高度,cur当前弧优化 </span></span><br><span class="line">ll h[N],e[M],f[M],ne[M],idx=<span class="number">0</span>;<span class="comment">//h,e,ne,idx邻接表,f流量 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll x,ll y,ll c)</span></span>&#123; </span><br><span class="line">e[idx]=y,f[idx]=c;</span><br><span class="line">ne[idx]=h[x],h[x]=idx++;</span><br><span class="line"></span><br><span class="line">e[idx]=x,f[idx]=<span class="number">0</span>;</span><br><span class="line">ne[idx]=h[y],h[y]=idx++;</span><br><span class="line"><span class="keyword">return</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;<span class="comment">//寻找有无增广路并建立分层图 </span></span><br><span class="line">ll hh=<span class="number">0</span>,tt=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">q[<span class="number">0</span>]=S,d[S]=<span class="number">0</span>,cur[S]=h[S]; <span class="comment">//S初始高度为0,当前弧初始为第一条出边 </span></span><br><span class="line"><span class="keyword">while</span>(hh&lt;=tt)&#123;</span><br><span class="line">ll t=q[hh++];</span><br><span class="line"><span class="keyword">for</span>(ll i=h[t];i!=<span class="number">-1</span>;i=ne[i])&#123;</span><br><span class="line">ll ver=e[i];</span><br><span class="line"><span class="keyword">if</span>(d[ver]==<span class="number">-1</span> &amp;&amp;f[i])&#123;<span class="comment">//一定要判断容量大于0 </span></span><br><span class="line">d[ver]=d[t]+<span class="number">1</span>;<span class="comment">//层数 </span></span><br><span class="line">cur[ver]=h[ver];<span class="comment">//当前弧初始为第一条出边 </span></span><br><span class="line"><span class="keyword">if</span>(ver==T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">q[++tt]=ver;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">find</span><span class="params">(ll u,ll limit)</span></span>&#123;<span class="comment">//找到增广路,find(u,limit)表示从点u开始,</span></span><br><span class="line"><span class="comment">//从S到u的最大容量为limit </span></span><br><span class="line"><span class="keyword">if</span>(u==T) <span class="keyword">return</span> limit;</span><br><span class="line">ll flow=<span class="number">0</span>;<span class="comment">//flow表示从u向T流的最大流量 </span></span><br><span class="line"><span class="keyword">for</span>(ll i=cur[u];i!=<span class="number">-1</span>&amp;&amp;flow&lt;limit;i=ne[i])&#123;<span class="comment">//从未满的路径开始搜</span></span><br><span class="line"><span class="comment">//flow&lt;limit是很重要的优化! </span></span><br><span class="line">cur[u]=i;<span class="comment">//当前弧优化,搜到i就意味着i前的边已用完,将当前弧更新 </span></span><br><span class="line">ll ver=e[i];</span><br><span class="line"><span class="keyword">if</span>(d[ver]==d[u]+<span class="number">1</span>&amp;&amp;f[i])&#123;<span class="comment">//保证当前点在上一点的下一层,同样要注意f&gt;0 </span></span><br><span class="line">ll t=<span class="built_in">find</span>(ver,<span class="built_in">min</span>(f[i],limit-flow));</span><br><span class="line"><span class="keyword">if</span>(!t) d[ver]=<span class="number">-1</span>;<span class="comment">//若t到终点无增广路径,就删去点ver(把ver高度定为-1) </span></span><br><span class="line"></span><br><span class="line">f[i]-=t;</span><br><span class="line">f[i^<span class="number">1</span>]+=t;</span><br><span class="line">flow+=t; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">ll maxflow=<span class="number">0</span>,flow;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">bfs</span>())<span class="comment">//若存在增广路 </span></span><br><span class="line"><span class="keyword">while</span>(flow=<span class="built_in">find</span>(S,INF)) <span class="comment">//找出当前图上所有增广路 </span></span><br><span class="line">maxflow+=flow;</span><br><span class="line"><span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld&quot;</span>,&amp;n,&amp;m,&amp;S,&amp;T);</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">ll x,y,c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;x,&amp;y,&amp;c);</span><br><span class="line"><span class="built_in">add</span>(x,y,c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="built_in">Dinic</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="无源汇上下界可行流"><a href="#无源汇上下界可行流" class="headerlink" title="无源汇上下界可行流"></a>无源汇上下界可行流</h2><p>在这类问题中不在仅存在容量上界 $c$ ，还存在下界（不妨记为 $l$ ），并且不存在 $S$ ， $T$ 两点。<br>对于此类问题，我们可以用如下操作变为网络最大流：</p><ol><li><p>新建源点和汇点</p></li><li><p>为满足性质1（忘了的上去看），将 $c$ 变为 $c-l$ ，即原来 $(x,y) \le f(x,y) \le c(x,y)$ 变为 $0 \le f(x,y) \le c(x,y)-l(x,y)$ </p></li><li><p>经过第2步后我们发现流量不守恒，故用一个数组 $ve$ （Virtual Edge）储存每个点的流量变化量，即对于边 $(x,y)$ ，经第2步变化后， $x$ 的出流量少了 $l(x,y)$ ， $y$ 的入流量少了 $l(x,y)$ ，故 $ve(x)-=l(x,y)$ ， $ve(y)+=l(x,y)$ </p></li><li><p>利用第3步统计的 $ve$ 数组，新建虚拟边使流量守恒，即若 $ve(x)&gt;0$ ，新建边 $(S,x)$ 并令 $c(S,x)=ve(x)$ ；若 $ve(x)&lt;0$ ，新建边 $(x,T)$ 并令 $c(x,T)=-ve(x)$ ；</p></li><li><p>跑一遍 $S$ 到 $T$ 的最大流，若 $S$ （或 $T$ ）的所有边都可以流满，就说明存在可行流</p></li></ol><p>经过如上操作，就将其变为一个基本的最大流问题，我们把这样建成的图称作虚拟图（仅是本人习惯），记为 $G3$ 。</p><h2 id="有源汇上下界可行流"><a href="#有源汇上下界可行流" class="headerlink" title="有源汇上下界可行流"></a>有源汇上下界可行流</h2><p>终于步入正题了<br>此类问题相比于上一类区别在于原题中就存在源点和汇点（为以示区别记为 $s$ 、 $t$ ）。<br>而解决方式与上类问题类似，区别仅在于我们要将点 $s$ 、 $t$ 这两个不满足流量守恒的点变为普通点，再用新建的 $S$ 、 $T$ 当为源点。<br>而使其守恒的方式即是新建一条边 $(t,s)$ 并令<br> $c(t,s)= \infty$ （正无穷）。</p><h2 id="有源汇上下界最大流"><a href="#有源汇上下界最大流" class="headerlink" title="有源汇上下界最大流"></a>有源汇上下界最大流</h2><p>好，现在问题来了，我们求解可行流时就是求的 $G3$ 的最大流，那么如果我们现在要求原图 $G$ 的可行流中的最大流我们该怎么办？<br>仔细思考，发现我们还有一个图没用——原图的残量网络 $G2$ ！辣么，我们可否使用这三个图求出答案呢？<br>当然是可以的，<del>不然我讲个屁啊</del>，而方法如下： </p><ol><li>同上类问题跑出 $G3$ 的最大流记为 $flow3$ ，并将此时原图中的流函数记为 $f3$ 。</li><li>构建原图 $G$ 关于 $f3$ 的残量网络 $G2$ ，求出 $G2$ 中的曾广路，我们发现这就等价于求出 $G$ 的最大流 $flow$ （注意此时用的是原图 $G$ ，故应删去边 $(t,s)$ ）</li><li>最后答案即是 $flow+flow3$ </li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有 $n$ 天， $m$ 位少女，至少为她们每人拍 $G(i)$ 张照片，每天总的最多拍 $D(i)$ 张，且每天只能为特定的少女拍照，张数为 $x \in [L,R]$ 。</p><h3 id="建立模型"><a href="#建立模型" class="headerlink" title="建立模型"></a>建立模型</h3><p>我们可以很轻松的<del>由题目标题</del>得出应使用网络流，并在稍微，<del>指3天</del>，思考后得出如下方法：</p><ul><li>建立原图 $G$ ：<ol><li>建立源点 $s=1$ ，汇点 $t=m+n+2$ ，并将少女建为点 $2 \sim  m+1$ ，天数建为点 $m+2 \sim n+m+1$ </li><li>将少女至少要拍的照片数 $G(i)$ 定为下界，无穷大定为上界，让少女 $x$ 与源点 $s$ 相连，即建立边 $(s,x)$ （ $x \in [2,m+1]$ ）并使 $c(s,x)=\infty -G(i)$ </li><li>将每天的最大拍照量定为上界， $0$ 为下界，让天数 $y$ 与汇点 $t$ 相连，即建边 $(y,t)$ （ $y \in [m+2,m+n+1]$ ）并使 $c(y,t)=D(i)-0$ </li><li>将少女与天相连，定上下界为 $[L,R]$ ，即建边 $(x,y)$ （ $x \in [2,m+1],y \in [m+2,m+n+1]$ ）并使 $c(x,y)=R-L$ </li><li>在构建原图的同时维护 $ve$ 数组</li></ol></li><li>构建虚拟图 $G3$ ：<ol><li>建立源点 $S=0$ ， $T=n+m+3$ </li><li>用 $ve$ 数组建立连接 $S$ ， $T$ 与其他点的边</li><li>增加边 $(t,s)$ ，并使 $c(t,s)=\infty$ </li><li>并同时维护 $outflow$ （记录从S流出的流量,用于判定是否满流）</li></ol></li><li>求解 $G3$ 的最大流<ol><li>直接用Dinic求解</li><li>判断 $Dinic()$ 是否等于 $outflow$ ，若不等，则说明原图无可行流（原题无解）</li><li>若相等，用 $res$ 记录此时 $s$ 到 $t$ 的流量，并进入下一步</li></ol></li><li>求解 $G$ 的最大流（即是 $G2$ 中的曾广路）<ol><li>删去边 $(t,s)$ </li><li>使 $S=s$ ， $T=t$ （即将 $G3$ 变为 $G$ ）</li><li>Dinic求解最大流，答案即为 $Dinic()+res$ </li></ol></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000000</span>+<span class="number">5</span>,M=<span class="number">1000000</span>+<span class="number">5</span>,INF=<span class="number">2147483647</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;<span class="comment">//如题意 </span></span><br><span class="line"><span class="keyword">int</span> nn,s,t,S,T;<span class="comment">//nn:原图中的点数,s:原图的源点,S虚拟图的源点,t,T同理 </span></span><br><span class="line"><span class="keyword">int</span> q[N],d[N],cur[N],ve[N];<span class="comment">//q:队列,d:高度,cur:当前弧优化,ve(Virtual Edge):虚拟边 </span></span><br><span class="line"><span class="keyword">int</span> h[N],e[N],f[N],ne[N],idx=<span class="number">0</span>;<span class="comment">//h,e,ne,idx:邻接表,f:流量 </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">e[idx]=y,f[idx]=c,ne[idx]=h[x],h[x]=idx++;</span><br><span class="line">e[idx]=x,f[idx]=<span class="number">0</span>,ne[idx]=h[y],h[y]=idx++;<span class="comment">//使用成对储存的技巧 </span></span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&lt;b? a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;<span class="comment">//寻找有无增广路并建立分层图 </span></span><br><span class="line"><span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">q[hh]=S,d[S]=<span class="number">0</span>,cur[S]=h[S];<span class="comment">//S初始高度为0,当前弧初始为第一条出边 </span></span><br><span class="line"><span class="keyword">while</span>(hh&lt;=tt)&#123;</span><br><span class="line"><span class="keyword">int</span> p=q[hh++];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[p];i!=<span class="number">-1</span>;i=ne[i])&#123;</span><br><span class="line"><span class="keyword">int</span> ver=e[i];</span><br><span class="line"><span class="keyword">if</span>(d[ver]==<span class="number">-1</span>&amp;&amp;f[i])&#123;<span class="comment">//一定要判断容量大于0 </span></span><br><span class="line">d[ver]=d[p]+<span class="number">1</span>;<span class="comment">//层数  </span></span><br><span class="line">cur[ver]=h[ver];<span class="comment">//当前弧初始为第一条出边 </span></span><br><span class="line"><span class="keyword">if</span>(ver==T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">q[++tt]=ver;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> limit)</span></span>&#123;<span class="comment">//找到增广路,find(u,limit)表示从点u开始,</span></span><br><span class="line"><span class="comment">//从S到u的最大容量为limit </span></span><br><span class="line"><span class="keyword">if</span>(u==T) <span class="keyword">return</span> limit;</span><br><span class="line"><span class="keyword">int</span> nowflow=<span class="number">0</span>;<span class="comment">//nowflow表示从u向T流的最大流量 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=cur[u];i!=<span class="number">-1</span>&amp;&amp;nowflow&lt;limit;i=ne[i])&#123;<span class="comment">//从未满的路径开始搜</span></span><br><span class="line"><span class="comment">//nowflow&lt;limit是很重要的优化! </span></span><br><span class="line">cur[u]=i;<span class="comment">//当前弧优化,搜到i就意味着i前的边已用完,将当前弧更新 </span></span><br><span class="line"><span class="keyword">int</span> ver=e[i];</span><br><span class="line"><span class="keyword">if</span>(d[ver]==d[u]+<span class="number">1</span>&amp;&amp;f[i])&#123;<span class="comment">//保证当前点在上一点的下一层,同样要注意f&gt;0 </span></span><br><span class="line"><span class="keyword">int</span> tflow=<span class="built_in">find</span>(ver,<span class="built_in">min</span>(f[i],limit-nowflow));</span><br><span class="line"><span class="keyword">if</span>(!tflow) d[ver]=<span class="number">-1</span>;<span class="comment">//若t到终点无增广路径,就删去点ver(把ver高度定为-1) </span></span><br><span class="line">f[i]-=tflow,f[i^<span class="number">1</span>]+=tflow,nowflow+=tflow;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nowflow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> maxflow=<span class="number">0</span>,inflow;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">bfs</span>())<span class="comment">//若存在增广路 </span></span><br><span class="line"><span class="keyword">while</span>(inflow=<span class="built_in">find</span>(S,INF))  maxflow+=inflow;<span class="comment">//找出当前图上所有增广路 </span></span><br><span class="line"><span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m))&#123;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="built_in">memset</span>(ve,<span class="number">0</span>,<span class="keyword">sizeof</span> ve);</span><br><span class="line"><span class="comment">//构建原图 </span></span><br><span class="line">s=<span class="number">1</span>,t=n+m+<span class="number">2</span>;<span class="comment">//原图中s=1为源点,t=n+m+2为汇点 </span></span><br><span class="line">nn=n+m+<span class="number">2</span>;<span class="comment">//nn:原图的点数 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m+<span class="number">1</span>;++i)&#123;<span class="comment">//将少女编号为2~m+1,并和源点连通 </span></span><br><span class="line"><span class="keyword">int</span> G;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;G);</span><br><span class="line"><span class="built_in">add</span>(s,i,INF-G);</span><br><span class="line">ve[i]+=G;</span><br><span class="line">ve[s]-=G;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=m+<span class="number">2</span>;i&lt;=m+n+<span class="number">1</span>;++i)&#123;<span class="comment">//将天数编号为m+2~m+n+1,并和汇点连通 </span></span><br><span class="line"><span class="keyword">int</span> C,D;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;C,&amp;D);</span><br><span class="line"><span class="built_in">add</span>(i,t,D);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=C;++j)&#123;<span class="comment">//将天与少女连通 </span></span><br><span class="line"><span class="keyword">int</span> TT,L,R;<span class="comment">//TT即为题中的T</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;TT,&amp;L,&amp;R);</span><br><span class="line">TT+=<span class="number">2</span>;<span class="comment">//注意输入中的少女是从0编号的</span></span><br><span class="line"><span class="built_in">add</span>(TT,i,R-L);</span><br><span class="line">ve[TT]-=L;<span class="comment">//一定要减L,别减R！ </span></span><br><span class="line">ve[i]+=L; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构建虚拟图 </span></span><br><span class="line">S=<span class="number">0</span>,T=n+m+<span class="number">3</span>;<span class="comment">//S=0为虚拟图源点,T=n+m+3为虚拟图汇点 </span></span><br><span class="line"><span class="keyword">int</span> outflow=<span class="number">0</span>;<span class="comment">//记录从虚拟源点出流量,用于判断是否是满流 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nn;++i)&#123;<span class="comment">//创建虚拟边保证虚拟图中流量守恒 </span></span><br><span class="line"><span class="keyword">if</span>(ve[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">add</span>(S,i,ve[i]);</span><br><span class="line">outflow+=ve[i]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ve[i]&lt;<span class="number">0</span>) <span class="built_in">add</span>(i,T,-ve[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">add</span>(t,s,INF);<span class="comment">//增加一条从t到s的边,保证流量守恒 </span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Dinic</span>()&lt;outflow) <span class="built_in">printf</span>(<span class="string">&quot;-1\n\n&quot;</span>);<span class="comment">//务必两个\n </span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=f[idx<span class="number">-1</span>];<span class="comment">//最后加的边的反向边的流量</span></span><br><span class="line"><span class="comment">//即是当前(虚拟图的)满流中s-&gt;t的流量</span></span><br><span class="line">f[idx<span class="number">-1</span>]=f[idx<span class="number">-2</span>]=<span class="number">0</span>;<span class="comment">//删除该边</span></span><br><span class="line">S=s,T=t;<span class="comment">//因为现在求的是s-&gt;t的最大流量,</span></span><br><span class="line"><span class="comment">//所以重新初始化源点和汇点 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n\n&quot;</span>,res+<span class="built_in">Dinic</span>()); <span class="comment">//ans即为虚拟图中s-&gt;t的流量+</span></span><br><span class="line"><span class="comment">//新增加的可行流量 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="网络流二"><a href="#网络流二" class="headerlink" title="网络流二"></a>网络流二</h1><p>临时复习一下网络流，顺便学习一点新东西</p><h2 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h2><p>不多说，以前的模板太丑了，这里给一个符合我现在（2021/11/16）码风的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200</span> + <span class="number">5</span>, M = <span class="number">5000</span> + <span class="number">5</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> S, T, n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ne, ver, w;</span><br><span class="line">&#125; e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> h[N], idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> dep[N], cur[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx].ver = y, e[idx].w = z, e[idx].ne = h[x], h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> <span class="comment">//add-double</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(x, y, z), <span class="built_in">add</span>(y, x, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">dep[i] = <span class="number">-1</span>;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(S);</span><br><span class="line">dep[S] = <span class="number">0</span>;</span><br><span class="line">cur[S] = h[S];</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">x = q.<span class="built_in">front</span>(), q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (dep[y] == <span class="number">-1</span> &amp;&amp; e[i].w)</span><br><span class="line">&#123;</span><br><span class="line">dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">cur[y] = h[y];</span><br><span class="line"><span class="keyword">if</span> (y == T)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">q.<span class="built_in">push</span>(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == T)</span><br><span class="line"><span class="keyword">return</span> limit;</span><br><span class="line"><span class="keyword">int</span> flow = <span class="number">0</span>, y, t;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = cur[x]; i != <span class="number">-1</span> &amp;&amp; flow &lt; limit; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">cur[x] = i;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (dep[y] == dep[x] + <span class="number">1</span> &amp;&amp; e[i].w)</span><br><span class="line">&#123;</span><br><span class="line">t = <span class="built_in">find</span>(y, <span class="built_in">min</span>(limit - flow, e[i].w));</span><br><span class="line"><span class="keyword">if</span> (!t)</span><br><span class="line">dep[t] = <span class="number">-1</span>;</span><br><span class="line">e[i].w -= t;</span><br><span class="line">e[i ^ <span class="number">1</span>].w += t;</span><br><span class="line">flow += t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL maxflow = <span class="number">0</span>, flow;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">bfs</span>())</span><br><span class="line"><span class="keyword">while</span> (flow = <span class="built_in">find</span>(S, INF))</span><br><span class="line">maxflow += flow;</span><br><span class="line"><span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;S, &amp;T);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">h[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, w; i &lt;= m; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line"><span class="built_in">addd</span>(u, v, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">dinic</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="费用流"><a href="#费用流" class="headerlink" title="费用流"></a>费用流</h2><p>我们已经解决了网络最大流的问题，但是，如果边不仅有容量限制，还有“价格”，也就是说，流单位容量的流还要付出一定代价该怎么办呢？</p><p><strong>最小费用最大流(mcmf)<strong>简称</strong>费用流</strong>就可以解决这样一个问题：给定一张网络，有源点和汇点，网络上的每条边 $(u,v)$ 都有一个流量限制 $w(u,v)$ 和单位流量的费用 $c(u,v)$ ，在满足流量守恒的前提下，求出<strong>使流量最大的最小费用</strong></p><p>其实非常简单，考虑我们Dinic的过程，其实就是不断一个寻找增广路的过程，那么我们在每次寻找增广路的时候，贪心的寻找<strong>单位费用最小</strong>的增广路，正确性显然，考虑具体实现，只需将每条边 $(u,v)$ 的反向边的费用定为 $-c(u,v)$ ，每次寻找增广路的bfs换成一个最短路即可</p><h3 id="spfa实现"><a href="#spfa实现" class="headerlink" title="spfa实现"></a>spfa实现</h3><p>使用spfa可以简单，高效（<del>前提是spfa没死</del>）的实现费用流，但需要注意的是，费用流的时间复杂度是 $O(nmf)$ ，其中 $f$ 代表最大流量，这个复杂度是<strong>伪多项式</strong>的，因为 $f_{max}=2^{\frac{n}{2}},m_{max}=n^2$ ，所以最坏为 $O(n^32^{\frac{n}{2}})$ ，当然实际上远远达不到这个上界</p><p>这里用Dinic+spfa实现了一个费用流：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5000</span> + <span class="number">5</span>, M = <span class="number">50000</span> + <span class="number">5</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> S, T, n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ne, ver, w, c;</span><br><span class="line">&#125; e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> h[N], idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> dis[N], cur[N];</span><br><span class="line"><span class="keyword">bool</span> v[N];</span><br><span class="line"><span class="keyword">int</span> maxflow, mincost;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx].ver = y, e[idx].w = z, e[idx].c = c, e[idx].ne = h[x], h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z, <span class="keyword">int</span> c)</span> <span class="comment">//add-double</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(x, y, z, c), <span class="built_in">add</span>(y, x, <span class="number">0</span>, -c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">dis[i] = INF, cur[i] = h[i];</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(S);</span><br><span class="line">dis[S] = <span class="number">0</span>;</span><br><span class="line">v[S] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">x = q.<span class="built_in">front</span>(), q.<span class="built_in">pop</span>();</span><br><span class="line">v[x] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (dis[y] &gt; dis[x] + e[i].c &amp;&amp; e[i].w)</span><br><span class="line">&#123;</span><br><span class="line">dis[y] = dis[x] + e[i].c;</span><br><span class="line"><span class="keyword">if</span> (!v[y])</span><br><span class="line">&#123;</span><br><span class="line">v[y] = <span class="literal">true</span>;</span><br><span class="line">q.<span class="built_in">push</span>(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dis[T] != INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == T)</span><br><span class="line"><span class="keyword">return</span> limit;</span><br><span class="line">v[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> flow = <span class="number">0</span>, y, t;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = cur[x]; i != <span class="number">-1</span> &amp;&amp; flow &lt; limit; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">cur[x] = i;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (!v[y] &amp;&amp; dis[y] == dis[x] + e[i].c &amp;&amp; e[i].w)</span><br><span class="line">&#123;</span><br><span class="line">t = <span class="built_in">find</span>(y, <span class="built_in">min</span>(limit - flow, e[i].w));</span><br><span class="line"><span class="keyword">if</span> (!t)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">e[i].w -= t;</span><br><span class="line">e[i ^ <span class="number">1</span>].w += t;</span><br><span class="line">flow += t;</span><br><span class="line">mincost += t * e[i].c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">v[x] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mcmf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">maxflow = mincost = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> flow;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">spfa</span>())</span><br><span class="line"><span class="keyword">while</span> (flow = <span class="built_in">find</span>(S, INF))</span><br><span class="line">maxflow += flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;S, &amp;T);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">h[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, w, c; i &lt;= m; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w, &amp;c);</span><br><span class="line"><span class="built_in">addd</span>(u, v, w, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">mcmf</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, maxflow, mincost);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dijkstra实现"><a href="#Dijkstra实现" class="headerlink" title="Dijkstra实现"></a>Dijkstra实现</h3><p>由于dij不能处理负全，必须像Johns全源最短路一样用一个势能来转换为正权</p><p>首先跑一次最短路，求出源点到每个点的最短距离 $h_i$ （也是该点的初始势能），接下来和Johnson算法一样，对于一条从 $u$ 到 $v$ ，单位费用为 $w$ 的边，将其边权重置为 $w+h_u-h_v$          </p><p>可以发现，这样设置势能后新网络上的最短路径和原网络上的最短路径一定对应，不妨设一条从 $S$ 到 $T$ 的路径为 $S\rightarrow p_1\rightarrow p_2\rightarrow…\rightarrow p_k\rightarrow T$ ，则其重表权值后，路径权值和为<br>$$<br>\begin{align}<br>&amp;(w(S,p_1)+ h_S-h_{p_1})+ (w(p_1,p_2)+ h_{p_1}- h_{p_2}) + … + (w(p_k,T) + h_{p_k}-h_T)\\<br>=&amp;w(S,p_1) + w(p_1,p_2) + … + w(p_k,T) + h_S - h_T<br>\end{align}<br>$$<br>可以发现 $S$ 到 $T$ 的所有路径的相对大小不变</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5000</span> + <span class="number">5</span>, M = <span class="number">50000</span> + <span class="number">5</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> S, T, n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ne, ver, w, c;</span><br><span class="line">&#125; e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> dis, id;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;t) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> dis &gt; t.dis;</span><br><span class="line">&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">int</span> h[N], idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> dis[N], cur[N];</span><br><span class="line"><span class="keyword">bool</span> v[N], vfind[N]; <span class="comment">//为find单独开一个v</span></span><br><span class="line"><span class="keyword">int</span> pe[N]; <span class="comment">//potential energy,势能</span></span><br><span class="line"><span class="keyword">int</span> maxflow, mincost;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx].ver = y, e[idx].w = z, e[idx].c = c, e[idx].ne = h[x], h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z, <span class="keyword">int</span> c)</span> <span class="comment">//add-double</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">add</span>(x, y, z, c), <span class="built_in">add</span>(y, x, <span class="number">0</span>, -c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">pe[i] = INF;</span><br><span class="line">q.<span class="built_in">push</span>(S);</span><br><span class="line">pe[S] = <span class="number">0</span>;</span><br><span class="line">v[S] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">x = q.<span class="built_in">front</span>(), q.<span class="built_in">pop</span>();</span><br><span class="line">v[x] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (pe[y] &gt; pe[x] + e[i].c &amp;&amp; e[i].w)</span><br><span class="line">&#123;</span><br><span class="line">pe[y] = pe[x] + e[i].c;</span><br><span class="line"><span class="keyword">if</span> (!v[y])</span><br><span class="line">&#123;</span><br><span class="line">v[y] = <span class="literal">true</span>;</span><br><span class="line">q.<span class="built_in">push</span>(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dij</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">priority_queue&lt;Node&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">dis[i] = INF, v[i] = <span class="literal">false</span>, cur[i] = h[i];</span><br><span class="line">dis[S] = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push</span>((Node)&#123;<span class="number">0</span>, S&#125;);</span><br><span class="line"><span class="keyword">int</span> x, y, nc;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">x = q.<span class="built_in">top</span>().id, q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span> (v[x])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">v[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver, nc = e[i].c + pe[x] - pe[y];</span><br><span class="line"><span class="keyword">if</span> (dis[y] &gt; dis[x] + nc &amp;&amp; e[i].w)</span><br><span class="line">&#123;</span><br><span class="line">dis[y] = dis[x] + nc;</span><br><span class="line"><span class="keyword">if</span> (!v[y])</span><br><span class="line">q.<span class="built_in">push</span>((Node)&#123;dis[y], y&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dis[T] != INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == T)</span><br><span class="line"><span class="keyword">return</span> limit;</span><br><span class="line">vfind[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> flow = <span class="number">0</span>, y, t, nc;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = cur[x]; i != <span class="number">-1</span> &amp;&amp; flow &lt; limit; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">cur[x] = i;</span><br><span class="line">y = e[i].ver, nc = e[i].c + pe[x] - pe[y];</span><br><span class="line"><span class="keyword">if</span> (!vfind[y] &amp;&amp; dis[y] == dis[x] + nc &amp;&amp; e[i].w)</span><br><span class="line">&#123;</span><br><span class="line">t = <span class="built_in">find</span>(y, <span class="built_in">min</span>(limit - flow, e[i].w));</span><br><span class="line"><span class="keyword">if</span> (!t)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">e[i].w -= t;</span><br><span class="line">e[i ^ <span class="number">1</span>].w += t;</span><br><span class="line">flow += t;</span><br><span class="line">mincost += t * e[i].c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">vfind[x] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mcmf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">maxflow = mincost = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> flow;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">dij</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (flow = <span class="built_in">find</span>(S, INF))</span><br><span class="line">maxflow += flow;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="comment">//记得每次更新势能</span></span><br><span class="line">pe[i] += dis[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;S, &amp;T);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">h[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, w, c; i &lt;= m; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w, &amp;c);</span><br><span class="line"><span class="built_in">addd</span>(u, v, w, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">spfa</span>();</span><br><span class="line"><span class="built_in">mcmf</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, maxflow, mincost);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>然鹅实测spfa不被卡的话和Dijkstra差不多，反而是开了O2两个都快的飞起</del></p><h2 id="最高标号预流推进"><a href="#最高标号预流推进" class="headerlink" title="最高标号预流推进"></a>最高标号预流推进</h2><p>最高标号预流推进（High Level Preflow Push，即HLPP）是另一种网络流算法，该算法较Dinic更为高效，<del>然而常数更大</del></p><p>HLPP并不是像Dinic和EK一样基于增广路的算法，它用另外一种更直观的方法求最大流</p><h3 id="预流推进"><a href="#预流推进" class="headerlink" title="预流推进"></a>预流推进</h3><p>想象一下，如果给到一个网络流让你手算，你咋办？当然是贪心地从源点开始往死里流，尽可能的把每条边流满，如果超过容量就减掉超过部分，一直推到汇点（应该很好理解，可以自己手推试试）</p><p>PP也是基于以上思想，用一个队列储存待维护的点（初始时只有 $S$ ），对于每一个当前点，把它有的流量尽可能地推往与之相连的点，然后将相连的点也加入队列</p><p>但这样明显有一个问题：可能出现两个点一个推过来一个推回去，结果就死循环了，为了不死循环，我们类似Dinic，引入一个<strong>高度</strong> $hi$ ， $hi[S]=n,hi[T]=0$ 规定只能由高为 $hight$ 的点流向高为 $hight-1$ 的点，如果遇到一个点有多余的流量无法流出，就尝试将其抬高一个高度（我们把这个操作叫做<strong>重贴标签</strong>），直到最后高为 $n+1$ 流回 $S$ </p><h3 id="最高标号"><a href="#最高标号" class="headerlink" title="最高标号"></a>最高标号</h3><p><del>令人讨厌的、让人无奈的、使人疯魔的</del><strong>Tarjan</strong>和他的同事Goldberg在1986年提出了最高标号（HL）预留推进算法，即把普通队列换成<strong>优先队列</strong>，每次取出高度最高的那个来推进，可以理解为先将高处的点的水移到低处，那么给低处节点推流时可以顺便带走，Cheriyan和Maheshwari在1988年证明了这样做的复杂度为 $O(n^2\sqrt{m})$ </p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>虽然上述的算法是正确的，并且复杂度是稳定的（<del>不像某玄学Dinic</del>），但是因为缺少一些优化，使得其上界比较紧，因此在随机数据下可能不如增广路算法，所以下面介绍一些优化</p><p>首先是喜闻乐见的gap优化：如果我们发现在给一个点抬高一的高度的时候，这个点原来的高度已经没有点了（出现断层），那么我们直接把大于这个高度的点的高度全部设 $n+1$ ，让他们回流到源点去，因为有了断层，他们无法再有机会把水推到汇点（为什么不能有下面一个点抬上来形成路径呢？因为一个点的高度是所有相邻点高度最小值加一，所以不可能出现这种情况）</p><p>其次，我们发现将所有非源点的高度设置为0是有些浪费的。我们不妨通过一遍bfs将每个点的初始高度设置为它到汇点 $T$ 的最短距离，这样就节省了大量重贴标签操作。当然，源点 $S$ 的高度还是应该设置为 $n$ </p><p>然后，我们发现完全没有必要用优先队列的 $O(\log{n})$ 来求最高点，因为高度最大也就 $n+1$ ，完全可以用一个桶存下所有高度的节点，$O(1)$ 得到最高点</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><a href="https://www.luogu.com.cn/problem/P4722">模板</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1200</span> + <span class="number">5</span>, M = <span class="number">120000</span> + <span class="number">5</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, S, T;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ne, ver, w;</span><br><span class="line">&#125; e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> h[N], idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> hi[N], ex[N], gap[N]; <span class="comment">//hi:高度,ex:超额流,gap[i]:高度为i的节点的数量</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; B[N]; <span class="comment">// 桶B[i]中记录所有hi[x]=i的x</span></span><br><span class="line"><span class="keyword">int</span> level = <span class="number">0</span>; <span class="comment">//溢出节点的最高高度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx] = (Edge)&#123;h[x], y, z&#125;, h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(x, y, z), <span class="built_in">add</span>(y, x, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">hi[i] = INF;</span><br><span class="line">hi[T] = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push</span>(T);</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">x = q.<span class="built_in">front</span>(), q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (e[i ^ <span class="number">1</span>].w &amp;&amp; hi[y] &gt; hi[x] + <span class="number">1</span>) <span class="comment">//从T倒着搜回去走的是反向边,^1以后就变回正向边</span></span><br><span class="line">hi[y] = hi[x] + <span class="number">1</span>, q.<span class="built_in">push</span>(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> hi[S] != INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//尽可能通过能够推送的边推送超额流</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> init = x == S;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y, k; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (!e[i].w || (init == <span class="literal">false</span> &amp;&amp; hi[x] != hi[y] + <span class="number">1</span>)) <span class="comment">//初始化时不考虑高度差为1</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">k = init ? e[i].w : <span class="built_in">min</span>(e[i].w, ex[x]); <span class="comment">//取到剩余容量和超额流的最小值初始化时可以使源的溢出量为负数</span></span><br><span class="line"><span class="keyword">if</span> (y != S &amp;&amp; y != T &amp;&amp; !ex[y])</span><br><span class="line">B[hi[y]].<span class="built_in">push_back</span>(y), level = <span class="built_in">max</span>(level, hi[y]);</span><br><span class="line">ex[x] -= k, ex[y] += k, e[i].w -=k, e[i ^ <span class="number">1</span>].w += k;</span><br><span class="line"><span class="keyword">if</span> (!ex[x]) <span class="comment">//如果已经推送完就返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">relabel</span><span class="params">(<span class="keyword">int</span> x)</span>  <span class="comment">//重贴标签(高度)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  hi[x] = INF;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">    <span class="keyword">if</span> (e[i].w)</span><br><span class="line">hi[x] = <span class="built_in">min</span>(hi[x], hi[e[i].ver]);</span><br><span class="line">  <span class="keyword">if</span> (++hi[x] &lt; n) <span class="comment">//只处理高度小于n的节点</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="comment">//新的高度,更新gap</span></span><br><span class="line">  B[hi[x]].<span class="built_in">push_back</span>(x);</span><br><span class="line">  level = <span class="built_in">max</span>(level, hi[x]);</span><br><span class="line">  ++gap[hi[x]];  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_max</span><span class="params">()</span> <span class="comment">//选出当前高度最大的节点之一,如果已经没有溢出节点返回0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (B[level].<span class="built_in">empty</span>() &amp;&amp; level &gt; <span class="number">-1</span>)</span><br><span class="line">--level;</span><br><span class="line"><span class="keyword">return</span> level == <span class="number">-1</span> ? <span class="number">0</span> : B[level].<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hlpp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">bfs</span>())</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i)</span><br><span class="line">gap[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">if</span> (hi[i] != INF)</span><br><span class="line">++gap[hi[i]];</span><br><span class="line">hi[S] = n;</span><br><span class="line"><span class="built_in">push</span>(S); <span class="comment">//初始化预流</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">while</span> (x = <span class="built_in">find_max</span>())</span><br><span class="line">&#123;</span><br><span class="line">B[level].<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">push</span>(x)) <span class="comment">//仍然溢出</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!--gap[hi[x]])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">if</span> (i != S &amp;&amp; i != T &amp;&amp; hi[i] &gt; hi[x] &amp;&amp; hi[i] &lt; n + <span class="number">1</span>)</span><br><span class="line">hi[i] = n + <span class="number">1</span>;  <span class="comment">// 这里重贴成 n+1 的节点都不是溢出节点</span></span><br><span class="line">      <span class="built_in">relabel</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ex[T];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;S, &amp;T);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">h[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, w, c; i &lt;= m; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line"><span class="built_in">addd</span>(u, v, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">hlpp</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>一般来说好用又好打的Dinic已经足够，但HLPP在加上优化后完虐Dinic，但不管是哪个，需要注意有可能的最大流炸int的情况</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;老有用了&lt;/p&gt;</summary>
    
    
    
    
    <category term="图论" scheme="https://dyd-true.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="网络流" scheme="https://dyd-true.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
    <category term="Dinic" scheme="https://dyd-true.github.io/tags/Dinic/"/>
    
    <category term="HLPP" scheme="https://dyd-true.github.io/tags/HLPP/"/>
    
    <category term="费用流" scheme="https://dyd-true.github.io/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>拓展欧几里得</title>
    <link href="https://dyd-true.github.io/2021/11/22/%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
    <id>https://dyd-true.github.io/2021/11/22/%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/</id>
    <published>2021-11-22T08:35:18.000Z</published>
    <updated>2021-11-24T09:24:45.316Z</updated>
    
    <content type="html"><![CDATA[<p>拓欧</p><span id="more"></span><h1 id="欧几里德算法（辗转相除法）"><a href="#欧几里德算法（辗转相除法）" class="headerlink" title="欧几里德算法（辗转相除法）"></a>欧几里德算法（辗转相除法）</h1><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p> $\forall a,b \in \mathbb{N},b \ne 0,$ 有 $gcd(a,b)=gcd(b,a \bmod b)$</p><p>证明：</p><ul><li>若 $a&lt;b$ ，则 $gcd(b,a \bmod b)=gcd(b,a)=gcd(a,b)$</li><li>若 $a \ge b$ 设 $a=q \times b +r$ ,其中 $0 \le r &lt;b$ ,则 $gcd(b,a \bmod b)=gcd(b,r)$ 。对于 $a,b$ 的任何公约数 $d$ ，必有 $d|a,d|b$ ，故 $d|q \times b$ ，故 $d|(a-(q \times b))$ ，即 $d|r$ 。因此， $d$ 也是 $r,b$　的公约数，于是 $gcd(a,b)=gcd(r,b)$</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为 $O(\log{(a+b)})$ </p><h1 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h1><h2 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h2><p>$\forall a,b,c \in \mathbb{Z}$ 关于 $x,y$ 的不定方程 $ax+by=c$ 有整数解当且仅当 $gcd(a,b)|c$ ，且一定存在 $x,y$ 使 $c=gcd(a,b)$</p><p>该定理的正确性初中就学过了，这里再简要证明一下：</p><p>设 $d=gcd(a,b)$ ，则 $d|a,d|b$ ，故 $d|(ax+by)$ 。<br>再设 $s$ 为 $ax+by$ 当 $x,y\in \mathbb{Z}$ 时能取得的最小正值。设 $r=a \bmod s=a-\left \lfloor \frac{a}{s} \right \rfloor \times s=a-\left \lfloor \frac{a}{(ax+by)} \right \rfloor \times (ax+by) =a(1-\left \lfloor \frac{a}{ax+by} \right \rfloor x)+b(-\left \lfloor \frac{a}{ax+by} \right \rfloor y)$ ，这里的 $x,y$ 是常量，使 $ax+by=s$ 。<br>可见 $r$ 是 $a,b$ 的线性组合，由于 $r= a \bmod s$ ，故 $0 \le r&lt; s$ 。<br>而 $s=ax+by$ 是 $a,b$ 线性组合的最小正值，故 $r=0$ 。因此 $s|a$ 。<br>同理， $s|b$ 。<br>故 $s$  是 $a,b$　的公约数，故 $s|d$ 。<br>又因为 $d|(ax+by)$ ，故有 $d|s$ ，那么只能 $d=s$ ，命题得证。</p><h2 id="特解"><a href="#特解" class="headerlink" title="特解"></a>特解</h2><p>有了裴蜀定理，我们就可以解出 $ax+by=gcd(a,b)$ ，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span>&amp; x,<span class="keyword">int</span>&amp; y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!b)&#123;</span><br><span class="line">   x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> a;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">int</span> d=<span class="built_in">exgcd</span>(b,a%b,y,x);<span class="comment">//这里交换了x和y</span></span><br><span class="line">   y-=(a/b)*x;</span><br><span class="line">   <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们调用函数 $d=exgcd(a,b,x_0,y_0)$ 时，由于 $x,y$ 是实参，结束后 $x_0,y_0$ 即为一组特解， $d$ 为 $gcd(a,b)$ 。</p><p>那么，由于 $d|c$ , $ax+by=c$ 的通解为：</p><p>$$<br>\begin{align}<br>x=\frac{c}{d}x_0+k\frac{b}{d} \\<br>y=\frac{c}{d}y_0-k\frac{a}{d}<br>\end{align}<br>$$</p><p>其中 $k$ 取遍 $\mathbb{Z}$ ，$d=gcd(a,b)$ ，$x_0,y_0$ 是方程 $ax+by=gcd(a,b)$ 的一组特解</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><a href="https://www.luogu.com.cn/problem/P1082">P1082</a><br>我们发现 $ax \equiv 1 \pmod{b}$ ，就等价于 $ax=by+1$ 移项得 $ax-by=1$ 。</p><p>代码如下：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line">LL a,m; </span><br><span class="line">LL exgcd(LL a,LL b,LL&amp; x,LL&amp; y)<span class="comment">&#123;</span></span><br><span class="line"><span class="comment">if(!b)&#123;</span></span><br><span class="line"><span class="comment">x=1,y=0;</span></span><br><span class="line"><span class="comment">return a;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line">LL d=exgcd(b,a%b,y,x); </span><br><span class="line">y-=a/b*x;</span><br><span class="line">return d;</span><br><span class="line">&#125;</span><br><span class="line">int main()<span class="comment">&#123;</span></span><br><span class="line"><span class="comment">scanf(&quot;%lld%lld&quot;,&amp;a,&amp;m);</span></span><br><span class="line"><span class="comment">LL x,y;</span></span><br><span class="line"><span class="comment">exgcd(a,m,x,y);</span></span><br><span class="line"><span class="comment">x=(x%m+m)%m; </span></span><br><span class="line"><span class="comment">printf(&quot;%lld&quot;,x);</span></span><br><span class="line"><span class="comment">return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;拓欧&lt;/p&gt;</summary>
    
    
    
    
    <category term="数论,数学" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
    <category term="拓展欧几里得" scheme="https://dyd-true.github.io/tags/%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>数位dp</title>
    <link href="https://dyd-true.github.io/2021/11/22/%E6%95%B0%E4%BD%8Ddp/"/>
    <id>https://dyd-true.github.io/2021/11/22/%E6%95%B0%E4%BD%8Ddp/</id>
    <published>2021-11-22T08:33:32.000Z</published>
    <updated>2021-11-24T09:24:32.519Z</updated>
    
    <content type="html"><![CDATA[<p>简单写写</p><span id="more"></span><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>思考以下问题：<br>对于给定范围的整数 $x \in [a,b]$ ，有多少个 $x$ 满足性质 $p$ （ $p$ 与数的各个位都有关，如“该数中有3个1”）。<br>对于此类问题，我们可以考虑如下方法：  </p><ol><li><p>用 $f[i]$ 表示对于所有的整数 $x \in [0,i]$ 中，满足性质 $p$ 的数的个数</p></li><li><p>则 $ans \ge f[b]-f[a-1]$ </p></li></ol><p>那么，我们来考虑如何去求 $f[N]$ 。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>设数 $N$ 是一个 $n$ 位数，且 $N=\overline{a_{n-1}a_{n-2}a_{n-3}…a_0} (a_<br>{n-1} \ne 0)$ 。<br>辣么，对于 $\forall x \in [0,N],x=\overline{b_{n-1}b_{n-2}b_{n-3}…b_0}$ ，有两种情况：</p><ol><li><p>$b_{n-1}=a_{n-1}$ </p></li><li><p>$0 \le b_{n-1} &lt; a_{n-1}$ </p></li></ol><p>我们发现，对于第二种情况，当 $b_{n-1}$ 确定时，方案数可以直接计算。如当 $N=7654321$ ， $p$ 为“该数中有3个1” 时，若 $0 \le b_6 &lt; 7$ 那么 $b_6=1$ 时，有 $C_{6}^{2}$ 种方案，而当 $b_6 \ne 1$ 时，有 $C_{6}^{3}$ 种方案。<br>对于第一种情况，我们只需继续讨论 $b_{n-2}$ 。<br>如图：<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/6zh87oc2.png" alt="dp顺序"></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/w0g1xgw3.png" alt="题"><br>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">35</span>;</span><br><span class="line"><span class="keyword">int</span> k, B; <span class="comment">//B进制数</span></span><br><span class="line"><span class="keyword">int</span> C[N][N];</span><br><span class="line"><span class="comment">//预处理组合数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j)</span><br><span class="line">            <span class="keyword">if</span> (!j)</span><br><span class="line">                C[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                C[i][j] = C[i - <span class="number">1</span>][j] + C[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算0到n中的数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">        nums.<span class="built_in">push_back</span>(n % B), n /= B;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = nums[i];</span><br><span class="line">        <span class="comment">//求左边分支</span></span><br><span class="line">        <span class="keyword">if</span> (x)</span><br><span class="line">        &#123;</span><br><span class="line">            res += C[i][k - last];</span><br><span class="line">            <span class="keyword">if</span> (x &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (k &gt; last)</span><br><span class="line">                    res += C[i][k - last - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                last++;</span><br><span class="line">                <span class="keyword">if</span> (last &gt; k)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加上最右侧分支上的方案</span></span><br><span class="line">        <span class="keyword">if</span> (!i &amp;&amp; last == k)</span><br><span class="line">            res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r &gt;&gt; k &gt;&gt; B;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dp</span>(r) - <span class="built_in">dp</span>(l - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单写写&lt;/p&gt;</summary>
    
    
    
    
    <category term="数论,数学" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>树状数组（BIT）</title>
    <link href="https://dyd-true.github.io/2021/11/22/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%88BIT%EF%BC%89/"/>
    <id>https://dyd-true.github.io/2021/11/22/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%88BIT%EF%BC%89/</id>
    <published>2021-11-22T08:31:56.000Z</published>
    <updated>2021-11-24T09:24:19.288Z</updated>
    
    <content type="html"><![CDATA[<p>BIT常数小！（<del>然并卵</del>）</p><span id="more"></span><h2 id="思想铺垫"><a href="#思想铺垫" class="headerlink" title="思想铺垫:"></a>思想铺垫:</h2><p>将一个数$x$化为二进制数$(\overline{a_{k-1}a_{k-2}…a_1a_0})<em>2$ , 并设其中等于1的位是${a</em>{i_1},a_{i_2}…a_{i_m}}$ , 则$x=2^{i_1}+2^{i_2}+…+2^{i_m}$ , 不妨设$i_1&gt;i_2&gt;…&gt;i_m$ , 那么区间$[1,x]$可以拆分成$O(\log_{}{x})$个小区间:  </p><ol><li><p>长度为$2^{i_1}$的小区间$[1,2^{i_1}]$</p></li><li><p>长度为$2^{i_2}$的小区间$[2^{i_1}+1,2^{i_1}+2^{i_2}]$</p></li><li><p>长度为$2^{i_3}$的小区间$[2^{i_1}+2^{i_2}+1,2^{i_1}+2^{i_2}+2^{i_3}]$; </p><p>……</p></li><li><p>长度为$2^{i_m}$的小区间$[2^{i_1}+2^{i_2}+…+2^{i_{m-1}}+1,2^{i_1}+2^{i_2}+…+2^{i_m}]$ </p></li></ol><p>而这些小区间的共同特点是:对于$\forall[x,y ]$ , 其区间长度(记为$|[x,y]|$)就等于”y的二进制拆分下的最小的2的次幂” , 即$lowbit(y)$ .<br>例如大区间$[1,7]$ , 因为$7=2^{2}+2^{1}+2^{0}$ , 所以被分为三个小区间 : $[1,4]$、$[5,6]$、$[7,7]$ . 而其长度分别是$lowbit(4)=4$、$lowbit(4)=4$、$lowbit(4)=4$<br>补充——$lowbit()$:<br>$lowbit(n)$定义为”非负整数$n$在而进制表示下最低位的1及其后的0构成的数的值”. 如$n=22=(10110)_2$ , 则$lowbit(22)=(10)_2=2$<br>则其代码实现如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本思路："><a href="#基本思路：" class="headerlink" title="基本思路："></a>基本思路：</h2><p>对于给定的原序列$a$ , 我们建立一个数组$c$ , 其中$c[x]$保存<strong>原序列$a$的区间$[x-lowbit(x)+1,x]$中所有数的和</strong> , 即$\textstyle\sum_{i=x-lowbit(x)+1}^{x}a[i]$<br>不难发现 , 数组$c$可以看作一个树形结构 , 且满足如下性质:</p><ol><li>每个节点$c[x]$保存以它为根的子树中所有叶节点的和.</li><li>每个节点$c[x]$的子节点个数等于$lowbit(x)$的位数 , 如$lowbit(4)=(100)_2$ , 其位数为$3$ , 故$c[4]有3个子节点$.</li><li>除树根外 , 每个节点$c[x]$的父节点就是$c[x+lowbit(x)]$.</li><li>树的深度为$O(\log_{}{N})$.</li></ol><p>如果$n$不是$2$的整数次幂 , 那么树状数组就是一个具有同样性质的森林.<br>如图:<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/4yowzx8l.png" alt="树状数组"><br>而树状数组支持的操作有两个:<br> <strong>查询前缀和</strong> : 即找到序列$a$第$1 \sim x$个数的和.  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;x;x-=x&amp;-x) ans+=c[x];<span class="comment">//x&amp;-x即为lowbit(x)</span></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若要查询$a$的区间$[l,r]$ , 只需计算$ask(r)-ask(l-1)$.<br><strong>单点增加</strong> : 给序列中一个数$a[x]$加上y , 不难发现至多只有$\log{}{N}$个节点包含$a[x]$ , 故时间复杂度为$O(\log{}{N})$.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(;x&lt;=N;x+=x&amp;-x) c[x]+=y;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在执行操作前 , 我们先要构造出$c$数组.<br>简单方法是 , 先让$c$全为$0$ , 然后对每个$x$执行$add(x,a[x])$ , 时间复杂度为$O(N\log{}{N})$ , 通常用这种方法就已足够.<br>更高效的方法是 , 从小到大依次考虑节点$x$ , 借助$lowbit$运算扫描它的子节点求和.若采用这种办法 , 上面树形结构的每条边只会被遍历一次 , 时间复杂度为 $O(\sum_{k = 1} ^ {\log{N}}k * N / 2 ^ {k}) = O(N)$<br>另外 , 若是题目需要<strong>区间增加</strong> , 可以改存$a$的差分数组.</p><p><a href="https://www.luogu.com.cn/problem/P3374">树状数组1</a><br><a href="https://www.luogu.com.cn/problem/P3368">树状数组2</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;BIT常数小！（&lt;del&gt;然并卵&lt;/del&gt;）&lt;/p&gt;</summary>
    
    
    
    
    <category term="数据结构" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树" scheme="https://dyd-true.github.io/tags/%E6%A0%91/"/>
    
    <category term="树状数组" scheme="https://dyd-true.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>树套树</title>
    <link href="https://dyd-true.github.io/2021/11/22/%E6%A0%91%E5%A5%97%E6%A0%91/"/>
    <id>https://dyd-true.github.io/2021/11/22/%E6%A0%91%E5%A5%97%E6%A0%91/</id>
    <published>2021-11-22T08:30:47.000Z</published>
    <updated>2021-11-24T09:24:06.699Z</updated>
    
    <content type="html"><![CDATA[<p>禁止套娃！</p><span id="more"></span><h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p>顾名思义，树套树就是用一个树套进另一个树，即一个外层的树、一个内层的树。</p><h1 id="简单版"><a href="#简单版" class="headerlink" title="简单版"></a>简单版</h1><p>思考如下问题：<br>维护一个长度为 $n$ 的序列，数列中的位置从左到右依次标号为 $1∼n$ ,其中需要提供以下操作：  </p><ol><li><p>$1\ pos\ x$ ，将 $pos$ 位置的数修改为 $x$ 。</p></li><li><p>$1\ a\ b\ x$ ，查询整数 $x$ 在区间 $[a,b]$ 内的前驱(前驱定义为小于 $x$ ，且最大的数)。  </p></li></ol><p>这个问题发现，第二个操作可以用 $set$ 完成，但 $set$ 仅支持查询整个区间，无法完成在区间 $[a,b]$ 上查询，所以我们考虑用一个线段树套在 $set$ 外层。  </p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50000</span> + <span class="number">5</span>, M = N * <span class="number">4</span>; <span class="comment">//线段树空间开4倍</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="comment">//multiset是&lt;set&gt;库中一个类型,可以看成一个序列,</span></span><br><span class="line">    <span class="comment">//插入删除数都能够在O(logn)的时间内完成,</span></span><br><span class="line">    <span class="comment">//而且能保证序列中的数是有序的,而且序列中可以存在重复的数。</span></span><br><span class="line">    multiset&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inint</span><span class="params">(<span class="keyword">int</span> _l, <span class="keyword">int</span> _r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        l = _l;</span><br><span class="line">        r = _r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; tr[M];</span><br><span class="line"><span class="keyword">int</span> w[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].<span class="built_in">inint</span>(l, r);</span><br><span class="line">    tr[u].s.<span class="built_in">insert</span>(-INF), tr[u].s.<span class="built_in">insert</span>(INF); <span class="comment">//防止越界</span></span><br><span class="line">    <span class="comment">//将线段树该节点(即该段)内的所有点插入该节点下套的set中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i)</span><br><span class="line">        tr[u].s.<span class="built_in">insert</span>(w[i]);</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//删除w[p],注意不能写erase(w[p]),否则会把所有值为w[p]的都删除</span></span><br><span class="line">    tr[u].s.<span class="built_in">erase</span>(tr[u].s.<span class="built_in">find</span>(w[p]));</span><br><span class="line">    tr[u].s.<span class="built_in">insert</span>(x);</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l == tr[u].r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (tr[u].l + tr[u].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= mid)</span><br><span class="line">        <span class="built_in">change</span>(u &lt;&lt; <span class="number">1</span>, p, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">change</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, p, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//若tr[u]在完全在区间[a,b]内</span></span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= a &amp;&amp; tr[u].r &lt;= b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//注意it的类型,it是地址,类型得记</span></span><br><span class="line">        std::multiset&lt;<span class="keyword">int</span>&gt;::iterator it = tr[u].s.<span class="built_in">lower_bound</span>(x);</span><br><span class="line">        <span class="comment">//it是&quot;大于等于x的最小数&quot;,减一后就是&quot;小于x的最大数&quot;</span></span><br><span class="line">        --it;</span><br><span class="line">        <span class="keyword">return</span> *it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (tr[u].l + tr[u].r) &gt;&gt; <span class="number">1</span>, res = -INF;</span><br><span class="line">    <span class="keyword">if</span> (a &lt;= mid)</span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, a, b, x));</span><br><span class="line">    <span class="keyword">if</span> (b &gt; mid)</span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, a, b, x));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m); <span class="comment">//数列长度以及操作次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> op, a, b, c, ans;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>, a, b);</span><br><span class="line">            w[a] = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">            ans = <span class="built_in">query</span>(<span class="number">1</span>, a, b, c);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (ans &gt; -INF &amp;&amp; ans &lt; INF) ? ans : <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="正常版"><a href="#正常版" class="headerlink" title="正常版"></a>正常版</h1><h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>问题加强如下（也可见<a href="https://www.luogu.com.cn/problem/P3380">P3380</a>）：<br>维护一个长度为 $n$ 的序列，数列中的位置从左到右依次标号为 $1∼n$ ,其中需要提供以下操作：  </p><ol><li><p> $1\ l\ r\ x$ ，查询整数 $x$ 在区间 $[l,r]$ 内的排名。</p></li><li><p> $2\ l\ r\ k$ ，查询区间 $[l,r]$ 内排名为 $k$ 的值。</p></li><li><p> $3\ pos\ x$ ，将 $pos$ 位置的数修改为 $x$ 。</p></li><li><p> $4\ l\ r\ x$ ，查询整数 $x$ 在区间 $[l,r]$ 内的前驱(前驱定义为小于 $x$ ，且最大的数)。</p></li><li><p> $5\ l\ r\ x$ ，查询整数 $x$ 在区间 $[l,r]$ 内的后继(后继定义为大于 $x$ ，且最小的数)。</p></li></ol><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>本题的四、五操作与简单版类似，可以用 $set$ 完成，但对于操作一、二， $set$ 却不支持排名，因为它不记录子树大小，so——我们只好手打平衡树。</p><p>而手打的平衡树可以完成操作一，但对于操作二，因为线段树会把区间 $[l,r]$ 分成最多 $\log N$ 个区间，每个区间内的平衡树互不联通，且通过简单的计算每个区间的答案并不能得到最终答案，所以我们思考其他方法——二分。<br>对于每个 $mid$ 用操作一找出它的排名，若排名小于等于 $k$ ，则答案小于等于 $mid$ ，反之则大于等于 $mid$ 。</p><p>由此，操作一、三、四、五的时间复杂度为 $\log^2 N$ ，操作二的时间复杂度为 $\log^3 N$ ,总时间复杂度为 $O(m\log^3 n)$ ，空间复杂度为 $O(N* 4* 2+N\log N)$ ,故空间约需 $50000* 4* 2+50000* 18 \le 1500000 $ 。</p><p>另外，一定要注意，有几个函数传的是实参！（ $update$ 、 $splay$ 和 $insert$）。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">15e5</span> + <span class="number">5</span>, INF = <span class="number">2147483647</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Splay</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s[<span class="number">2</span>], fa, size, v;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inint</span><span class="params">(<span class="keyword">int</span> _v, <span class="keyword">int</span> _fa)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        v = _v;</span><br><span class="line">        fa = _fa;</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; tr[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Seg_Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> rt;        <span class="comment">//root,对应的Splay的根</span></span><br><span class="line">&#125; ttr[N];          <span class="comment">//ttr表示外层树</span></span><br><span class="line"><span class="keyword">int</span> n, m, idx = <span class="number">0</span>; <span class="comment">//idx:记录Splay的节点</span></span><br><span class="line"><span class="keyword">int</span> w[N];</span><br><span class="line"><span class="comment">/*------------------------Splay------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].size = tr[tr[x].s[<span class="number">0</span>]].size + tr[tr[x].s[<span class="number">1</span>]].size + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = tr[x].fa;</span><br><span class="line">    <span class="keyword">int</span> z = tr[y].fa;</span><br><span class="line">    <span class="keyword">int</span> k = tr[y].s[<span class="number">1</span>] == x;</span><br><span class="line">    tr[z].s[tr[z].s[<span class="number">1</span>] == y] = x, tr[x].fa = z;</span><br><span class="line">    tr[y].s[k] = tr[x].s[k ^ <span class="number">1</span>], tr[tr[x].s[k ^ <span class="number">1</span>]].fa = y;</span><br><span class="line">    tr[x].s[k ^ <span class="number">1</span>] = y, tr[y].fa = x;</span><br><span class="line">    <span class="built_in">push_up</span>(y), <span class="built_in">push_up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> &amp;root, <span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> <span class="comment">//一定注意这里传实参</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (tr[x].fa != k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y = tr[x].fa;</span><br><span class="line">        <span class="keyword">int</span> z = tr[y].fa;</span><br><span class="line">        <span class="keyword">if</span> (z != k)</span><br><span class="line">            (tr[y].s[<span class="number">1</span>] == x) ^ (tr[z].s[<span class="number">1</span>] == y) ? <span class="built_in">rotate</span>(x) : <span class="built_in">rotate</span>(y);</span><br><span class="line">        <span class="built_in">rotate</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!k)</span><br><span class="line">        root = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在splay中插入v</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;root, <span class="keyword">int</span> v)</span> <span class="comment">//实参!</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = root, p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (u)</span><br><span class="line">        p = u, u = tr[u].s[v &gt; tr[u].v];</span><br><span class="line">    u = ++idx;</span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">        tr[p].s[v &gt; tr[p].v] = u;</span><br><span class="line">    tr[u].<span class="built_in">inint</span>(v, p);</span><br><span class="line">    <span class="built_in">splay</span>(root, u, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在该splay中找到比v小的数的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_k</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = root, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (u)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tr[u].v &lt; v)</span><br><span class="line">            res += tr[tr[u].s[<span class="number">0</span>]].size + <span class="number">1</span>, u = tr[u].s[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            u = tr[u].s[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在该splay中更新x为y</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;root, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">//实参!</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//删除x(忘了去看Splay)</span></span><br><span class="line">    <span class="keyword">int</span> u = root;</span><br><span class="line">    <span class="keyword">while</span> (u)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tr[u].v == x)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (tr[u].v &lt; x)</span><br><span class="line">            u = tr[u].s[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            u = tr[u].s[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">splay</span>(root, u, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> l = tr[u].s[<span class="number">0</span>], r = tr[u].s[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (tr[l].s[<span class="number">1</span>])</span><br><span class="line">        l = tr[l].s[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (tr[r].s[<span class="number">0</span>])</span><br><span class="line">        r = tr[r].s[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">splay</span>(root, l, <span class="number">0</span>), <span class="built_in">splay</span>(root, r, l);</span><br><span class="line">    tr[r].s[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">push_up</span>(r), <span class="built_in">push_up</span>(l);</span><br><span class="line">    <span class="comment">//插入y</span></span><br><span class="line">    <span class="built_in">insert</span>(root, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在该splay中找到比v小的数中最大的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_pre</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = root, res = -INF;</span><br><span class="line">    <span class="keyword">while</span> (u)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tr[u].v &lt; v)</span><br><span class="line">            res = <span class="built_in">max</span>(res, tr[u].v), u = tr[u].s[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            u = tr[u].s[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在该splay中找到比v大的数中最小的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_suc</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = root, res = INF;</span><br><span class="line">    <span class="keyword">while</span> (u)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tr[u].v &gt; v)</span><br><span class="line">            res = <span class="built_in">min</span>(res, tr[u].v), u = tr[u].s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            u = tr[u].s[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*------------------------Segment tree------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ttr[u].l = l, ttr[u].r = r;</span><br><span class="line">    <span class="built_in">insert</span>(ttr[u].rt, -INF), <span class="built_in">insert</span>(ttr[u].rt, INF); <span class="comment">//防止越界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i)</span><br><span class="line">        <span class="built_in">insert</span>(ttr[u].rt, w[i]);</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到比x小的数的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ttr[u].l &gt;= l &amp;&amp; ttr[u].r &lt;= r)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_k</span>(ttr[u].rt, x) - <span class="number">1</span>; <span class="comment">//因为多插入了-INF</span></span><br><span class="line">    <span class="keyword">int</span> mid = (ttr[u].l + ttr[u].r) &gt;&gt; <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">        res += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r, x);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">        res += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, x);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将w[p]变为x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">update</span>(ttr[u].rt, w[p], x);</span><br><span class="line">    <span class="keyword">if</span> (ttr[u].l == ttr[u].r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (ttr[u].l + ttr[u].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= mid)</span><br><span class="line">        <span class="built_in">change</span>(u &lt;&lt; <span class="number">1</span>, p, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">change</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, p, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到比x小的数中最大的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query_pre</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ttr[u].l &gt;= l &amp;&amp; ttr[u].r &lt;= r)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_pre</span>(ttr[u].rt, x);</span><br><span class="line">    <span class="keyword">int</span> mid = (ttr[u].l + ttr[u].r) &gt;&gt; <span class="number">1</span>, res = -INF;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="built_in">query_pre</span>(u &lt;&lt; <span class="number">1</span>, l, r, x));</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="built_in">query_pre</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, x));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到比v大的数中最小的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query_suc</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ttr[u].l &gt;= l &amp;&amp; ttr[u].r &lt;= r)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_suc</span>(ttr[u].rt, x);</span><br><span class="line">    <span class="keyword">int</span> mid = (ttr[u].l + ttr[u].r) &gt;&gt; <span class="number">1</span>, res = INF;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">        res = <span class="built_in">min</span>(res, <span class="built_in">query_suc</span>(u &lt;&lt; <span class="number">1</span>, l, r, x));</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">        res = <span class="built_in">min</span>(res, <span class="built_in">query_suc</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, x));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> op, a, b, x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;x);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(<span class="number">1</span>, a, b, x) + <span class="number">1</span>); <span class="comment">//query是&quot;比x小的数的个数&quot;,加1为x的排名</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;x);</span><br><span class="line">            <span class="comment">//二分答案</span></span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">1e8</span>, ans;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">query</span>(<span class="number">1</span>, a, b, mid) + <span class="number">1</span> &lt;= x)</span><br><span class="line">                    ans = mid, l = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;x);</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>, a, x);</span><br><span class="line">            w[a] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;x);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query_pre</span>(<span class="number">1</span>, a, b, x));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;x);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query_suc</span>(<span class="number">1</span>, a, b, x));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="变式"><a href="#变式" class="headerlink" title="变式"></a>变式</h1><h2 id="问题：-1"><a href="#问题：-1" class="headerlink" title="问题："></a>问题：</h2><p><a href="https://www.acwing.com/problem/content/2308/">AcWing2306</a>：<br>你需要维护 $n$ 个可重整数集，集合的编号从1到 $n$ 。<br>这些集合初始都是空集，有 $m$ 个操作:</p><ol><li><p>$1\ l\ r\ c$ ：表示将 $c$ 加入到编号在 $[l,r]$ 内的集合中</p></li><li><p>$2\ l\ r\ c$ ：表示查询编号在 $[l,r]$ 内的集合的并集中，第 $c$ 大的数是多少。</p></li></ol><p>注意可重集的并是不去除重复元素的，如 ${1,1,4} \cup {5,1,4}={1,1,4,5,1,4}$ 。</p><h2 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h2><p>先尝试上题思路：外层树线段树，套内层平衡树。<br>但很快啊，啪的一下，我们就发现，这样的话区间修改非常麻烦，操作一（在区间 $[l,r]$ 中的每一个集合里加一个数 $c$ ）的实现过于复杂。<br>于是，我们（听别人说）可以用权值线段树。</p><h2 id="权值线段树："><a href="#权值线段树：" class="headerlink" title="权值线段树："></a>权值线段树：</h2><ol><li><p>将数值离散化</p></li><li><p>以数值（即权值）为节点建立线段树</p></li><li><p>线段数的每一个节点上，再用一棵线段树来维护权值在该节点内的所有数的下标</p></li><li><p>对于操作一，我们在外层数上找到包含 $c$ 的节点，最多有 $\log n$ 个，然后再个节点内层的线段树上找到区间 $[l,r]$ ，打上懒标记</p></li><li><p>对于操作二，我们用类似二分的思想，每次找一半区间（即外层线段数左右节点中的一个），求该区间下套的内层树上 $[l,r]$ 的和 $k$ ，若 $k \ge c$ 就进入（外层树的）右节点，否则进入左节点</p></li></ol><p>时间复杂度为 $O(\log^2 N)$</p><h2 id="标记持久化："><a href="#标记持久化：" class="headerlink" title="标记持久化："></a>标记持久化：</h2><p>我们发现的区间增加也好、区间求和也好，都是在内层树上，而且只有这两个<strong>同类型</strong>（必须同类，例如有加有乘就不行）的操作，所以我们考虑更改 $sum$ 和 $add$ 的含义，使这些标记不必向下传（即省略 $push_down$）。<br>（以下定义都是针对内层树）<br> $sum$ ：定义 $sum$ 为“只考虑本节点及以下节点懒标记的情况下的区间和”。<br> $add$ ：定义 $add$ 为“本节点的所有子节点都要加上一个 $add$ ”。<br>对于区间求和，只需用本节点的 $sum$ 加上所有祖宗节点的 $add$ 和与区间长度的积即可，具体实现的话，只需在递归时顺便累加 $add$ 即可。</p><h2 id="线段树的动态开点："><a href="#线段树的动态开点：" class="headerlink" title="线段树的动态开点："></a>线段树的动态开点：</h2><p>我们发现，直接开线段树套线段树，空间复杂度为 $O(N^2)$ ，对于本题来说无法接受，因此，我们自然想到，只开出用到的节点，即动态开点，空间复杂度为 $O(M\log N)$ </p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50000</span> + <span class="number">5</span>, Nn = N * <span class="number">17</span> * <span class="number">17</span>, M = N * <span class="number">4</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Seg_Tree1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LL l, r, rt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(u) tr[u].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(u) tr[u].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rt(u) tr[u].rt</span></span><br><span class="line">&#125; tr[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Seg_Tree2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LL l, r, sum, add; <span class="comment">//由于动态开点,内层数的l、r表示的是节点下标</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll(u) ttr[u].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr(u) ttr[u].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(u) ttr[u].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> add(u) ttr[u].add</span></span><br><span class="line">&#125; ttr[Nn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Question</span> //为了离散化,需要保存问题</span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    LL op, a, b, c;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> op(u) q[i].op</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> a(u) q[i].a</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> b(u) q[i].b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> c(u) q[i].c</span></span><br><span class="line">&#125; q[N];</span><br><span class="line">vector&lt;LL&gt; que;</span><br><span class="line">LL n, m;</span><br><span class="line">LL idx = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//离散化的对应</span></span><br><span class="line"><span class="function">LL <span class="title">get</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(que.<span class="built_in">begin</span>(), que.<span class="built_in">end</span>(), x) - que.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//intersection,求两区间的交集</span></span><br><span class="line"><span class="function">LL <span class="title">inter</span><span class="params">(LL l1, LL r1, LL l2, LL r2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(r1, r2) - <span class="built_in">max</span>(l1, l2) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更新内层树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(LL u, LL l, LL r, LL pl, LL pr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sum</span>(u) += <span class="built_in">inter</span>(l, r, pl, pr);</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= pl &amp;&amp; r &lt;= pr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add</span>(u)++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pl &lt;= mid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">ll</span>(u))</span><br><span class="line">            <span class="built_in">ll</span>(u) = ++idx; <span class="comment">//动态开点</span></span><br><span class="line">        <span class="built_in">update</span>(<span class="built_in">ll</span>(u), l, mid, pl, pr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pr &gt; mid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">rr</span>(u))</span><br><span class="line">            <span class="built_in">rr</span>(u) = ++idx;</span><br><span class="line">        <span class="built_in">update</span>(<span class="built_in">rr</span>(u), mid + <span class="number">1</span>, r, pl, pr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">get_sum</span><span class="params">(LL u, LL l, LL r, LL pl, LL pr, LL add)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= pl &amp;&amp; r &lt;= pr)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(u) + (r - l + <span class="number">1</span>) * add;</span><br><span class="line">    LL mid = (l + r) &gt;&gt; <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    add += <span class="built_in">add</span>(u);</span><br><span class="line">    <span class="keyword">if</span> (pl &lt;= mid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ll</span>(u))</span><br><span class="line">            res += <span class="built_in">get_sum</span>(<span class="built_in">ll</span>(u), l, mid, pl, pr, add);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            res += <span class="built_in">inter</span>(l, mid, pl, pr) * add; <span class="comment">//如果未开ll(u),说明它未修改过</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pr &gt; mid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">rr</span>(u))</span><br><span class="line">            res += <span class="built_in">get_sum</span>(<span class="built_in">rr</span>(u), mid + <span class="number">1</span>, r, pl, pr, add);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            res += <span class="built_in">inter</span>(mid + <span class="number">1</span>, r, pl, pr) * add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(LL u, LL l, LL r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">l</span>(u) = l, <span class="built_in">r</span>(u) = r, <span class="built_in">rt</span>(u) = ++idx;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    LL mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(LL u, LL l, LL r, LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">update</span>(<span class="built_in">rt</span>(u), <span class="number">1</span>, n, l, r);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">l</span>(u) == <span class="built_in">r</span>(u))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (<span class="built_in">l</span>(u) + <span class="built_in">r</span>(u)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid)</span><br><span class="line">        <span class="built_in">change</span>(u &lt;&lt; <span class="number">1</span>, l, r, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">change</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(LL u, LL l, LL r, LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">l</span>(u) == <span class="built_in">r</span>(u))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">r</span>(u);</span><br><span class="line">    LL mid = (<span class="built_in">l</span>(u) + <span class="built_in">r</span>(u)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    LL k = <span class="built_in">get_sum</span>(<span class="built_in">rt</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>), <span class="number">1</span>, n, l, r, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= x)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r, x - k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (LL i = <span class="number">0</span>; i &lt; m; ++i) <span class="comment">//为了配合vector,循环也都从0开始</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld&quot;</span>, &amp;<span class="built_in">op</span>(i), &amp;<span class="built_in">a</span>(i), &amp;<span class="built_in">b</span>(i), &amp;<span class="built_in">c</span>(i));</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">op</span>(i) == <span class="number">1</span>)</span><br><span class="line">            que.<span class="built_in">push_back</span>(<span class="built_in">c</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//排序,去重</span></span><br><span class="line">    <span class="built_in">sort</span>(que.<span class="built_in">begin</span>(), que.<span class="built_in">end</span>());</span><br><span class="line">    que.<span class="built_in">erase</span>(<span class="built_in">unique</span>(que.<span class="built_in">begin</span>(), que.<span class="built_in">end</span>()), que.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, que.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (LL i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">op</span>(i) == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>, <span class="built_in">a</span>(i), <span class="built_in">b</span>(i), <span class="built_in">get</span>(<span class="built_in">c</span>(i)));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, que[<span class="built_in">query</span>(<span class="number">1</span>, <span class="built_in">a</span>(i), <span class="built_in">b</span>(i), <span class="built_in">c</span>(i))]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;禁止套娃！&lt;/p&gt;</summary>
    
    
    
    
    <category term="平衡树" scheme="https://dyd-true.github.io/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
    <category term="数据结构" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树" scheme="https://dyd-true.github.io/tags/%E6%A0%91/"/>
    
    <category term="树套树" scheme="https://dyd-true.github.io/tags/%E6%A0%91%E5%A5%97%E6%A0%91/"/>
    
    <category term="线段树" scheme="https://dyd-true.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>树链剖分</title>
    <link href="https://dyd-true.github.io/2021/11/22/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    <id>https://dyd-true.github.io/2021/11/22/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/</id>
    <published>2021-11-22T08:29:50.000Z</published>
    <updated>2021-11-24T09:23:43.285Z</updated>
    
    <content type="html"><![CDATA[<p>线段树进化！</p><span id="more"></span><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>线段树，DFS序</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>树链剖分的核心思想是将一棵树的节点重新排序，再将树转换为一个序列，使得树上的任意一条路径可以被最多 $\log{n}$ 段区间表示出来，由此我们可以将树上的路径操作化为区间操作。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li><p>重儿子（节点）：子树结点数目最多的结点</p></li><li><p>轻儿子（节点）：除了重儿子以外的结点</p></li><li><p>重边：父亲结点和重儿子连成的边</p></li><li><p>轻边：父亲节点和轻儿子连成的边</p></li><li><p>重链：由多条重边连接而成的路径，如果一个点没连接重边，那该节点也可以是一条重链</p></li><li><p>轻链：由多条轻边连接而成的路径</p></li></ul><p>如图：<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/7g3wqit1.png" alt="例子"><br>可以看到：对于节点1，节点4的子树的节点比2,3的多，所以4是重儿子，对于4节点9的子树的节点比8,9的多，所以9是重儿子，以此类推，图中黑色的节点是重儿子，其余的节点是轻儿子。  </p><p>红边是重边，黑边是轻边</p><p>1 - 4 - 9 - 13 - 14；<br>8；<br>10；<br>3 - 7；<br>2 - 6 - 11；<br>5；都是重链</p><p>我们发现：叶节点没有重儿子，非叶节点有且只有1个重儿子</p><p>但要注意，并不是轻儿子之后全是轻儿子，比如2后面就有6和11两个重儿子，也就是说，<strong>当一个节点选了他的重儿子之后，我们并不能保证它的轻儿子就是叶节点，所以我们就以这个轻儿子为根，再去选这个轻儿子的轻重儿子</strong></p><h2 id="化树为列"><a href="#化树为列" class="headerlink" title="化树为列"></a>化树为列</h2><p>我们先用dfs序来实现将树化为序列，但dfs时我们优先搜索重儿子，这样的好处是可以保证一段重链在区间上是连续的，如上面的图上，dfs序应为：1-4-9-13-14-8-10-3-7-2-6-11-5</p><p>那么一条路径就可以拆分成最多 $\log{n}$ 条重链，对应到序列上是最多 $\log{n}$ 个区间。</p><p>现在，问题就是如何找到一条路径对应的区间。</p><h2 id="寻找区间"><a href="#寻找区间" class="headerlink" title="寻找区间"></a>寻找区间</h2><p>对于节点 $x,y$ 若要求 $x$ 到 $y$ 的路径对应的区间，可以用如下方法： </p><ol><li><p>找到 $x,y$ 中所在重链的顶点较低的点（即层数较深的点），不妨设为 $x$ ，并设 $x$ 所在重链顶点为 $z$   </p></li><li><p>对区间 $[z,x]$ 操作，更新 $x$ 为 $z$ 的父节点</p></li><li><p>重复2、3步，直到 $x,y$ 在同一条重链上（这条重链一定是它们的最近公共祖先所在重链）  </p></li><li><p>对区间 $[x,y]$ （或 $[y,x]$ ）操作即可</p></li></ol><p>如上面的图中，要找节点13到节点5的路径，可以让 $x=13$ , $y=5$ 过程如下：  </p><ol><li><p>第一步后，找到较低的点是 $y=5$ ，顶点 $z=5$ </p></li><li><p>第二步，操作区间 $[z,y]=[5,5]$ ，更新 $y=2$</p></li><li><p>第三步，重复，操作区间 $[z,y]=[2,2]$ ，更新 $y=1$ </p></li><li><p>第五步, $x,y$ 已在一条重链上，操作区间 $[y,x]=[1,13]$</p></li></ol><p>一般来说，对于每个区间，我们用线段树、分块等方式去维护，最多有 $\log{n}$ 个区间，故一般时间复杂度为 $O(log^2{n})$ </p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.com.cn/problem/P3384">P3384</a><br>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> n,m,root,p;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ver,ne;</span><br><span class="line">&#125;e[N*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> h[N],idx=<span class="number">0</span>,w[N];</span><br><span class="line"><span class="keyword">int</span> id[N],nw[N],cnt=<span class="number">0</span>; <span class="comment">//id:节点在dfs序中的编号,nw:dfs序列每个编号对应的权值</span></span><br><span class="line"><span class="keyword">int</span> dep[N],size[N],top[N],fa[N],h_son[N]; <span class="comment">//dep:节点深度,size:节点为根的子</span></span><br><span class="line">                                          <span class="comment">//树的大小,top:节点所在重链的顶点</span></span><br><span class="line">                                          <span class="comment">//fa:父节点,h_son:重儿子</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ST</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    LL add,sum;</span><br><span class="line">&#125;tr[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    e[idx].ver=y,e[idx].ne=h[x],h[x]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> father,<span class="keyword">int</span> depth)</span></span>&#123; <span class="comment">//求每个的重儿子</span></span><br><span class="line">    dep[x]=depth;</span><br><span class="line">    fa[x]=father;</span><br><span class="line">    size[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[x];i!=<span class="number">-1</span>;i=e[i].ne)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=e[i].ver;</span><br><span class="line">        <span class="keyword">if</span>(y==father) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(y,x,depth+<span class="number">1</span>);</span><br><span class="line">        size[x]+=size[y];</span><br><span class="line">        <span class="keyword">if</span>(size[h_son[x]]&lt;size[y]) h_son[x]=y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> t)</span></span>&#123; <span class="comment">//求dfs序,t:当前节点所在重链的顶点</span></span><br><span class="line">    id[x]=++cnt;</span><br><span class="line">    nw[cnt]=w[x];</span><br><span class="line">    top[x]=t;</span><br><span class="line">    <span class="keyword">if</span>(!h_son[x]) <span class="keyword">return</span> ; <span class="comment">//若是叶节点,直接返回</span></span><br><span class="line">    <span class="built_in">dfs2</span>(h_son[x],t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[x];i!=<span class="number">-1</span>;i=e[i].ne)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=e[i].ver;</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x]||y==h_son[x]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(y,y); <span class="comment">//轻儿子一定是其所在重链的顶点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    tr[u].sum=tr[u&lt;&lt;<span class="number">1</span>].sum+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">    tr[u].sum%=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].add)&#123;</span><br><span class="line">        tr[u&lt;&lt;<span class="number">1</span>].add+=tr[u].add;</span><br><span class="line">        tr[u&lt;&lt;<span class="number">1</span>].add%=p;</span><br><span class="line">        tr[u&lt;&lt;<span class="number">1</span>].sum+=tr[u].add*(tr[u&lt;&lt;<span class="number">1</span>].r-tr[u&lt;&lt;<span class="number">1</span>].l+<span class="number">1</span>);</span><br><span class="line">        tr[u&lt;&lt;<span class="number">1</span>].sum%=p;</span><br><span class="line">        tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].add+=tr[u].add;</span><br><span class="line">        tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].add%=p;</span><br><span class="line">        tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum+=tr[u].add*(tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].r-tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].l+<span class="number">1</span>);</span><br><span class="line">        tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum%=p;</span><br><span class="line">        tr[u].add=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    tr[u].l=l;</span><br><span class="line">    tr[u].r=r;</span><br><span class="line">    tr[u].add=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tr[u].sum=nw[r];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">push_up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)&#123;</span><br><span class="line">        tr[u].add+=k;</span><br><span class="line">        tr[u].add%=p;</span><br><span class="line">        tr[u].sum+=k*(tr[u].r-tr[u].l+<span class="number">1</span>);</span><br><span class="line">        tr[u].sum%=p;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">push_down</span>(u);</span><br><span class="line">    <span class="keyword">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="built_in">push_up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">ask</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line">    <span class="built_in">push_down</span>(u);</span><br><span class="line">    <span class="keyword">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    LL res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) res+=<span class="built_in">ask</span>(u&lt;&lt;<span class="number">1</span>,l,r),res%=p;</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) res+=<span class="built_in">ask</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r),res%=p;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify_path</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[u]!=top[v])&#123;  <span class="comment">//当这两个点不在同一重链</span></span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>,id[top[u]],id[u],k); <span class="comment">//注意在dfs序中top[u]在u前面</span></span><br><span class="line">        u=fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&lt;dep[v]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">    <span class="built_in">modify</span>(<span class="number">1</span>,id[v],id[u],k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">ask_path</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    LL res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">        res+=<span class="built_in">ask</span>(<span class="number">1</span>,id[top[u]],id[u]);</span><br><span class="line">        res%=p;</span><br><span class="line">        u=fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&lt;dep[v]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">    res+=<span class="built_in">ask</span>(<span class="number">1</span>,id[v],id[u]);</span><br><span class="line">    <span class="keyword">return</span> res%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify_tree</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="built_in">modify</span>(<span class="number">1</span>,id[u],id[u]+size[u]<span class="number">-1</span>,k); <span class="comment">//在dfs序中,以一个节点为根的子树一定</span></span><br><span class="line">                                       <span class="comment">//跟在这个节点后面</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">ask_tree</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ask</span>(<span class="number">1</span>,id[u],id[u]+size[u]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;root,&amp;p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line">        w[i]%=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="built_in">add</span>(x,y);</span><br><span class="line">        <span class="built_in">add</span>(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(root,<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(root,root);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,cnt);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> op,u,v,k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;op,&amp;u);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;v,&amp;k);</span><br><span class="line">            <span class="built_in">modify_path</span>(u,v,k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;v);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">ask_path</span>(u,v));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line">            <span class="built_in">modify_tree</span>(u,k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">ask_tree</span>(u));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;线段树进化！&lt;/p&gt;</summary>
    
    
    
    
    <category term="数据结构" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树" scheme="https://dyd-true.github.io/tags/%E6%A0%91/"/>
    
    <category term="线段树" scheme="https://dyd-true.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    <category term="树链剖分" scheme="https://dyd-true.github.io/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>期望DP和概率DP</title>
    <link href="https://dyd-true.github.io/2021/11/22/%E6%9C%9F%E6%9C%9BDP%E5%92%8C%E6%A6%82%E7%8E%87DP/"/>
    <id>https://dyd-true.github.io/2021/11/22/%E6%9C%9F%E6%9C%9BDP%E5%92%8C%E6%A6%82%E7%8E%87DP/</id>
    <published>2021-11-22T08:27:49.000Z</published>
    <updated>2021-11-24T09:23:13.486Z</updated>
    
    <content type="html"><![CDATA[<p>${\color{red} 快跑啊}$</p><span id="more"></span><h1 id="期望DP和概率DP"><a href="#期望DP和概率DP" class="headerlink" title="期望DP和概率DP"></a>期望DP和概率DP</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><p>随机变量：有多种可能值的变量，一般记为 $X$</p></li><li><p>概率：一个事件发生的可能性，一般记为 $P(A)$ ，以下简记 $P(X==x_i)$ 为 $P(x_i)$ </p></li><li><p>期望：一个事件发生的概率乘上权值，记为 $E(X)$ </p></li><li><p>方差：用于描述一组数据的波动程度，记为 $Var(X)$ ，有<br>$$<br>Var(X)=\frac{\sum(x_i-\bar{x})}{n}<br>$$</p></li><li><p>依赖：一个随机变量 $X$ 的取值取决（或有关）于变量 $Y$ ，或者说在保证 $Y$ 发生的情况下发生 $X$ ，记为 $X|Y$ ，一下简记 $P(X==x_i|Y==y_i)$ 为 $P(x_i|y_i)$</p></li><li><p>并：两个事件同时发生（即“且”），记为 $A\cap B$（也可以记为 $AB$ ）</p></li><li><p>交：两个事件分别发生（即“或”），记为 $A\cup B$</p></li><li><p>区分下列概念：</p><p>$E(X)$ ：一个数，是 $x_i$ 的<strong>加权平均值</strong>；</p><p>$E(X|Y)$ ：随机变量，关于 $Y$ 的函数，没有固定的 $y$ 值；</p><p>$E(X|Y==y)$ ：一个数，是局限在 $\omega\in{\omega|Y(\omega)==y}$ 时， $X(\omega)$ 的取值的<strong>局部加权平均值</strong></p></li></ul><h2 id="定理-公式"><a href="#定理-公式" class="headerlink" title="定理/公式"></a>定理/公式</h2><ul><li><p>对于两个独立事件 $A,B$ ，有：<br>$$<br>\begin{align}<br>P(AB)=P(A)P(B)\\<br>E(AB)=E(A)E(B)<br>\end{align}<br>$$<br>正确性显然</p></li><li><p>期望的线性性：</p><p>（1）对于两个随机变量 $X,Y$ （可以相关），有：</p><p>$$<br>E(X+Y)=E(X)+E(X)<br>$$</p><p>证明：</p><p>$$<br>\begin{align}<br>E(X+Y)<br>&amp;=\sum_{i}\sum_{j}P(X==i\wedge Y==j)\times(i+j)\\<br>&amp;=\sum_{i}\sum_{j}P(X==i\wedge Y==j)\times i+\sum_{i}\sum_{j}P(X==i\wedge Y==j)\times j\\<br>&amp;=\sum_{i}i\sum_{j}P(X==i\wedge Y==j)+\sum_{j}j\sum_{i}P(X==i\wedge Y==j)\\<br>&amp;=\sum_{i}iP(X==i)+\sum_{j}jP(Y==j)\\<br>&amp;=E(X)+E(Y)<br>\end{align}<br>$$</p></li></ul><p>  （2）对于一个常量 $C$ 有：<br>$$<br>  E(CX)=CE(X)<br>$$</p><ul><li><p>前缀和技巧：对于离散变量（取值只有整数） $X$ ，有<br>$$<br>P(X==k)=P(X\le k)-P(X\le k-1)<br>$$</p></li><li><p>关于方差的性质:：</p><p>（1）概率与方差的关系：<br>$$<br>\begin{align}<br>Var(X)<br>&amp;=\frac{\sum_{i}(x_i-\bar{x})}{n}\\<br>&amp;=\sum_{i}\frac{(x_i-\bar{x})}{n}\\<br>&amp;=\sum_{x_k\in X}(x_k-\bar{x})P(x_k)<br>\end{align}<br>$$<br>因为一个值出现的次数除以 $n$ 就是选它的概率</p><p>（2）期望与方差的关系：</p><p>首先，明显有 $\bar{x}=E(X)$ ，然后，我们再考虑对于一组数据 $X$ ，令 $y_i=(x_i-E(X))^2$ ，那么明显概率不变，有 $P(y_i)=P(x_i)$ ，则：<br>$$<br>\begin{align}<br>E(Y)<br>&amp;=\sum_{y_k\in Y}y_kP(y_k)\\<br>&amp;=\sum_{x_k\in X}(x_k-E(X))^2P(x_k)\\<br>&amp;=Var(X)<br>\end{align}<br>$$<br>故有：</p><p>$$<br>Var(X)=E((X-E(X))^2)<br>$$</p><p>（3）比较常用的一个性质：</p><p>$$<br>Var(X)=E(X^2)-E(X)^2<br>$$</p><p>需要注意 $E(X)=\bar{x}$ 是一个常数，故  $\sum2E(X)xP(x)=2E(X)\sum xP(x)=2E(X)^2$ ，另外谨记 $\sum P(x)=1$ ，则上述性质证明如下：<br>$$<br>\begin{align}<br>Var(X)<br>&amp;=E((X-E(X))^2)\\<br>&amp;=E(X^2-2XE(X)+E(X)^2)\\<br>&amp;=E(X^2)-E(2XE(X))+E(E(X)^2)\\<br>&amp;=E(X^2)-\sum2E(X)xP(x)+\sum E(X)^2P(x)\\<br>&amp;=E(X^2)-2E(X)^2+E(X)^2\sum P(x)\\<br>&amp;=E(X^2)-2E(X)^2+E(X)^2\\<br>&amp;=E(X^2)-E(X)^2<br>\end{align}<br>$$</p></li><li><p>全期望公式：<br>$$<br>E(E(X|Y))=E(X)<br>$$<br>证明如下：<br>$$<br>\begin{align}<br>E(E(X|Y))<br>&amp;=\sum_{y}E(X|Y==y)P(y)\\<br>&amp;=\sum_{y}{\huge(}\sum_{x}xP(x|y){\huge)}P(y)\\<br>&amp;=\sum_{y}\sum_{x}xP(x|y)P(y)\\<br>&amp;=\sum_{y}\sum_{x}xP(y|x)P(x)\\<br>&amp;=\sum_{x}\sum_{y}xP(y|x)P(x)\\<br>&amp;=\sum_{x}xP(x){\huge(}\sum_{y}P(y|x){\huge)}\\<br>&amp;=\sum_{x}xP(x)\\<br>&amp;=E(X)<br>\end{align}<br>$$</p></li><li><p>全概率公式：<br>$$<br>P(B)=\sum_{a_i\in A}P(a_i)P(B|a_i)<br>$$</p></li></ul><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>对于一些比较难找到递推关系的数学期望问题，可以利用期望的定义式，根据实际情况以概率或者方案数（也就是概率乘总方案数）作为一种状态，而下标直接或间接对应了这个概率下的变量值，将问题变成比较一般的统计方案数问题或者利用全概率公式计算概率的递推问题</p><p>一般来说，概率DP找到正确的状态定义后，转移是比较容易想到的。但状态一定是“可数”的，把有范围的整数作为数组下标。事实上，将问题直接作为状态是最好的。如问“ $n$ 人做 $X$ 事的期望次数”，则设计状态为 $f[i]$ 表示 $i$ 个人做完事的期望。转移一般是递推，即从上一个状态转移得（填表）或转移向下一个状态（刷表），后者更为常用</p><p>有时期望DP需以最终状态为初始状态转移，即逆推。如 $f[i]$ 表示期望还要走 $f[i]$ 步到达终点，这种状态的转移是刷表法，形如 $f[i]=\sum p[i\rightarrow j]f[j]+w[i\rightarrow j]$ ，其中 $p[\ ]$ 表示转移的概率， $w[\ ]$ 表示转移对答案的贡献，一般来说，初始状态确定时可用顺推，终止状态确定时可用逆推</p><p>还有些时候，要结合高斯消元来考虑</p><h2 id="例题一"><a href="#例题一" class="headerlink" title="例题一"></a>例题一</h2><p><a href="https://www.luogu.com.cn/problem/P4284">概率充电器</a></p><p>考虑算出每个点充电的概率 $P(i)$ ，利用期望的线性性， $\sum P(i)$ 就是答案</p><p>利用树形DP，考虑先求出每个点通过自己或是子树冲上电的概率，定为 $f[\ ]$ ，转移为<br>$$<br>\forall v\in son(u)\\<br>f[u]= f[u]+f[v]* P(v\rightarrow u)-f[u]* f[v]* P(v\rightarrow u)<br>$$<br>这里用了一个容斥：<br>$$<br>\begin{align}<br>P(A\cup B)\\<br>=P(A)+P(B)-P(AB)\\<br>=P(A)+P(B)-P(A)P(B)<br>\end{align}<br>$$<br>正确性显然：两个事件至少发生一个的概率就是分别发生的概率减去都发生的概率 </p><p>然后再来考虑 $u$ 如何从父节点转移，转移方程类似于上面，但此时我们需要的是父节点不通过 $u$ 充上电的概率，令 $A$ 为“父节点不通过 $u$ 充上电”， $B$ 为“父节点通过 $u$ 充上电”，利用 $P(A)=\frac{P(A\cup B)-P(B)}{1-P(B)}$ 计算，注意特判 $P(B)==1$ 的情况</p><p>事时间复杂度 $O(n)$ </p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IL inline</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> E = <span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ne, ver;</span><br><span class="line">    <span class="keyword">double</span> p;</span><br><span class="line">&#125;e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> h[N], idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> f[N], ans = <span class="number">0</span>;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">double</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx].ver = y, e[idx].p = z, e[idx].ne = h[x], h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">    &#123;</span><br><span class="line">        y = e[i].ver;</span><br><span class="line">        <span class="keyword">if</span> (y == fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dp</span>(y, x);</span><br><span class="line">        f[x] = f[x] + f[y] * e[i].p - f[x] * f[y] *e[i].p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">dp2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (e[i].ver == fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">double</span> pa, pb;</span><br><span class="line">        pb = f[e[i].ver] * e[i].p;</span><br><span class="line">        <span class="keyword">if</span> (pb + E &gt; <span class="number">1</span> &amp;&amp; pb - E &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">dp2</span>(e[i].ver, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pa = (f[x] - pb) / (<span class="number">1</span> - pb);</span><br><span class="line">            f[e[i].ver] = f[e[i].ver] + pa * e[i].p - f[e[i].ver] * pa *e[i].p;</span><br><span class="line">            <span class="built_in">dp2</span>(e[i].ver, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">        h[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y, z; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">        <span class="built_in">add</span>(x, y, (<span class="keyword">double</span>)z / <span class="number">100.0</span>), <span class="built_in">add</span>(y, x, (<span class="keyword">double</span>)z / <span class="number">100.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, q; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q), f[i] = (<span class="keyword">double</span>)q / <span class="number">100.0</span>;</span><br><span class="line">    <span class="built_in">dp</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">dp2</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        ans += f[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.6lf\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题二"><a href="#例题二" class="headerlink" title="例题二"></a>例题二</h2><p><a href="https://www.luogu.com.cn/problem/P3239">亚瑟王</a></p><p>依旧利用期望的线性性，考虑求出每张卡被出掉的概率，不难发现，一张卡被出的概率与被经过的次数有关，于是设 $f[i][j]$ 表示 $r$ 轮后，前 $i$ 张卡被选了 $j$ 张的概率，那么 $f[i-1][j]$ 就是 $i$ 被考虑 $r-j$ 次的概率（因为还有 $r-j$ 张在 $i$ 及以后的牌中选），于是 $i$ 被选到的概率为 $\sum_{j&gt;0}f[i-1][j]\times(1-(1-p[i])^{r-j})$ ，则转移就是枚举选不选 $i+1$<br>$$<br>\begin{align}<br>&amp;\text{选：}\\<br>&amp;f[i + 1][j + 1]+=f[i][j]* (1-(1-p[i+1])^{r-j})\\<br>&amp;\text{不选：}\\<br>&amp;f[i + 1][j]+=f[i][j]* (1-p[i+1])^{r-j}\\<br>\end{align}<br>$$<br>时间复杂度 $O(Tnr)$ </p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IL inline</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">220</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Card</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> p, d;</span><br><span class="line">&#125; a[N];</span><br><span class="line"><span class="keyword">double</span> f[N][N], ans;</span><br><span class="line"><span class="function">IL <span class="keyword">double</span> <span class="title">qpow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">            res = res * x;</span><br><span class="line">        x = x * x;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">int</span> n, r;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;r);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>, &amp;a[i].p, &amp;a[i].d);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= r; ++j)</span><br><span class="line">                f[i][j] = <span class="number">0</span>;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> <span class="keyword">_t</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="built_in">min</span>(i, r); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">_t</span> = <span class="built_in">qpow</span>(<span class="number">1</span> - a[i + <span class="number">1</span>].p, r - j);</span><br><span class="line">                f[i + <span class="number">1</span>][j] += f[i][j] * <span class="keyword">_t</span>;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; r)</span><br><span class="line">                &#123;</span><br><span class="line">                    f[i + <span class="number">1</span>][j + <span class="number">1</span>] += f[i][j] * (<span class="number">1</span> - <span class="keyword">_t</span>);</span><br><span class="line">                    ans += f[i][j] * (<span class="number">1</span> - <span class="keyword">_t</span>) * a[i + <span class="number">1</span>].d;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.10lf\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题三"><a href="#例题三" class="headerlink" title="例题三"></a>例题三</h2><p><a href="https://www.luogu.com.cn/problem/P3232">游走</a></p><p>明显，被经过次数多的边编号要小，这启发我们去求每条边期望被经过的次数，但 $m$ 的范围过大，直接求时间复杂度无法接受，于是考虑将边的期望转换为点的期望</p><p>设 $du[i]$ 表示第 $i$ 个点的度， $f[i]$ 表示它的期望经过次数，则有<del>有个鬼啊，我想不到啊！！！</del> ：</p><p>$$<br>f[i]=<br>\begin{cases}<br>&amp;\sum_{(i,j)\in E,j\ne n}\frac{f[j]}{du[j]}+1&amp;i=1\\<br>&amp;\sum_{(i,j)\in E,j\ne n}\frac{f[j]}{du[j]}&amp;1&lt;i&lt;n<br>\end{cases}<br>$$</p><p>需要注意：到 $n$ 点就停止了，所以不考虑从 $n$ 转移过来</p><p>那么第 $i$ 条边的期望经过次数 $g[i]$ 就是<br>$$<br>\begin{align}<br>&amp;g[i]=\frac{f[u]}{du[u]}+\frac{f[v]}{du[v]}&amp;E_i=(u,v),u\ne n,v\ne n<br>\end{align}<br>$$<br>那么只需求出 $f$ 就好了，然鹅，由于是DAG，转移的顺序无法解决（怎么转都有后效性），所以，高斯消元解决<del>不会就和我一样愣着吧</del></p><p>超级毒瘤的代码<del>我尽量标准化了</del>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IL inline</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500</span> + <span class="number">5</span>, M = <span class="number">125000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-12</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x[N][N];</span><br><span class="line">&#125; a;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ne, from, ver;</span><br><span class="line">&#125; e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> h[N], idx = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> du[N];</span><br><span class="line"><span class="keyword">double</span> g[M], ans = <span class="number">0</span>;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx].from = x, e[idx].ver = y, e[idx].ne = h[x], h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">int</span> <span class="title">gauss</span><span class="params">(Matrix &amp;x, <span class="keyword">int</span> _n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c, r, <span class="keyword">_t</span>;</span><br><span class="line">    <span class="keyword">for</span> (c = <span class="number">1</span>, r = <span class="number">1</span>; c &lt;= _n; ++c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">_t</span> = r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &lt;= _n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(x.x[i][c]) &gt; <span class="built_in">fabs</span>(x.x[<span class="keyword">_t</span>][c]))</span><br><span class="line">                <span class="keyword">_t</span> = i;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(x.x[<span class="keyword">_t</span>][c]) &lt; eps)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = c; i &lt;= _n + <span class="number">1</span>; ++i)</span><br><span class="line">            <span class="built_in">swap</span>(x.x[<span class="keyword">_t</span>][i], x.x[r][i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = _n + <span class="number">1</span>; i &gt;= c; --i)</span><br><span class="line">            x.x[r][i] /= x.x[r][c];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r + <span class="number">1</span>; i &lt;= _n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(x.x[i][c]) &gt; eps)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = _n + <span class="number">1</span>; j &gt;= c; --j)</span><br><span class="line">                    x.x[i][j] -= x.x[r][j] * x.x[i][c];</span><br><span class="line">        ++r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= _n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &lt;= _n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(x.x[i][_n + <span class="number">1</span>]) &gt; eps)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = _n; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= _n; ++j)</span><br><span class="line">            x.x[i][_n + <span class="number">1</span>] -= x.x[i][j] * x.x[j][_n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">        h[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u, v), <span class="built_in">add</span>(v, u);</span><br><span class="line">        ++du[u], ++du[v];</span><br><span class="line">    &#125;</span><br><span class="line">    --n; <span class="comment">// 构建矩阵时注意第n个点不转移,所以只有n-1个点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n + <span class="number">1</span>; ++j)</span><br><span class="line">            a.x[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        a.x[i][i] = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = h[i], k; j != <span class="number">-1</span>; j = e[j].ne)</span><br><span class="line">        &#123;</span><br><span class="line">            k = e[j].ver;</span><br><span class="line">            <span class="keyword">if</span> (k == n + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            a.x[i][k] = <span class="number">-1.0</span> / du[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a.x[<span class="number">1</span>][n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">gauss</span>(a, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        u = e[i &lt;&lt; <span class="number">1</span>].from;</span><br><span class="line">        v = e[i &lt;&lt; <span class="number">1</span>].ver;</span><br><span class="line">        g[i] = a.x[u][n + <span class="number">1</span>] / du[u] + a.x[v][n + <span class="number">1</span>] / du[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(g + <span class="number">1</span>, g + <span class="number">1</span> + m);</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        ans += g[i] * (m - i + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.3lf&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题四"><a href="#例题四" class="headerlink" title="例题四"></a>例题四</h2><p>最后来看一道毒瘤题</p><p><a href="https://www.luogu.com.cn/problem/P5299">Slay the Spire</a></p><h3 id="贪心策略"><a href="#贪心策略" class="headerlink" title="贪心策略"></a>贪心策略</h3><p>明显，得排个序，由于强化卡的数字至少为 $2$ ，在可以打出的 $k$ 张牌中，尽可能多的打强化卡可以使伤害最大化（当然，至少得剩下一张攻击牌，不然没伤害）</p><p>另一个方面，根据期望的线性性（<del>又是它</del>），期望造成的伤害等于<strong>强化牌的期望乘积</strong>乘上<strong>攻击牌的期望和</strong>（<del>好乱</del>），而答案乘了一个奇奇怪怪的东西后分母没了，分子的化其实就是方案数乘价值</p><h3 id="dp方程设计"><a href="#dp方程设计" class="headerlink" title="dp方程设计"></a>dp方程设计</h3><p>如此，答案就跟强化牌和攻击牌分别独立相关，这启发我们分开计算：令 $f[i][j][0]$ 表示在前 $i$ 张强化牌中取 $j$ 张且第 $i$ 张<strong>被选</strong>的选法的<strong>乘积之和</strong>， $f[i][j][1]$ 表示前 $i$ 张强化牌中取 $j$ 张（不管选没选 $i$ ）的<strong>乘积之和</strong>，令 $g[i][j][0]$ 表示在前 $i$ 张攻击牌中取 $j$ 张且第 $i$ 张<strong>被选</strong>的选法的<strong>和之和</strong>， $f[i][j][1]$ 表示前 $i$ 张强化牌中取 $j$ 张（不管选没选 $i$ ）的<strong>和之和</strong></p><p>可以看到上面的定义非常的痛苦，所以好心的我在这里写点提示：</p><ol><li>为什么要强迫选第 $i$ 张呢？这是因为<del>讨厌的</del>九条可怜是随机选的卡，若不保证选了第 $i$ 张，统计答案时会有重复（或者不好统计）</li><li>为啥都是个<strong>…之和</strong>呢？这是因为最后算的是期望（当然，它乘了个玄学的东西把分母弄没了），期望本身就该算和</li><li>那为啥还要定一个不管选没选 $i$ 的情况呢？其实是为了方便求出强迫选的情况，换句话说，是当辅助的，而在统计答案时我们也靠它们可以去掉一个循环</li></ol><p>如果理解了以上定义（没理解就看看下面的转移和统计答案辅助理解一下），则可以发现转移方程如下（ $a$  是强化牌， $b$ 是攻击牌）：<br>$$<br>\begin{align}<br>&amp;f[i][j][0]=a[i]\times f[i-1][j-1][1]\\<br>&amp;f[i][j][1]=f[i][j][0]+f[i-1][j][1]\\<br>&amp;g[i][j][0]=b[i]\times \binom{i-1}{j-1}+g[i-1][j-1][1]\\<br>&amp;g[i][j][1]=g[i][j][0]+g[i-1][j][1]<br>\end{align}<br>$$<br>需要注意的是， $g[i][j][0]$ 的转移中， $\binom{i-1}{j-1}$ 表示在 $i-1$ 个数中选择 $j-1$ 个数的方案，即从 $g[i-1][j-1][1]$ 转移到 $g[i][j][0]$ 共有 $\binom{i-1}{j-1}$ 种情况，而每种情况卡牌权值和加上了 $b[i]$ </p><p>预处理组合数，推得 $f,g$ 都可以在 $O(n^2)$ 内解决</p><h3 id="统计答案"><a href="#统计答案" class="headerlink" title="统计答案"></a>统计答案</h3><p>来看看如何计算答案！分类讨论！</p><ul><li><p>若抽出来的 $m$ 张牌中，强化牌的数量少于 $k-1$ </p><p>此时当然是把强化牌全出了，然后攻击牌从大到小依次出，可以枚举 $i,j$ 表示被选中的强化牌<strong>有</strong> $i$ 张，最后一张被选中的攻击牌<strong>是</strong>第 $j$ 张</p><p>在强化牌中选择 $i$ 张的所有合法情况下的乘积之和，其实就是 $f[n][i][1]$ </p><p>而强化牌中选择 $i$ 张，攻击牌中就要选择 $k-i$ 张，又由于最后被选中的攻击牌是第 $j$ 张，所以所有合法情况下攻击牌的和之和，其实就是 $g[j][k-i][0]$ </p><p>但不要忘了，九条她的 $m$ 张牌是随机选的！为了保证最后打出的 $k$ 张牌是我们要的 $k$ 张牌，则剩余的 $m-k$ 张牌要满足不存在强化牌且攻击牌都要排在第 $j$ 张牌的后面（这也是我们必须要枚举 $j$ 的原因），因此共有 $\binom{n-j}{m-k}$ 种方案</p><p>总之，对于这种情况，我们枚举 $i,j$ ，每次答案加 $f[n][i][1]\times g[j][k-i][0]\times\binom{n-j}{m-k}$ </p></li><li><p>若抽出来的 $m$ 张牌中，强化牌的数量大于等于 $k-1$ </p><p>此时我们选则出积最大的 $k-1$ 张强化牌，再乘上一张最大的攻击牌，可以枚举 $i,j$ 表示最后一张被选中的强化牌<strong>是</strong>第 $i$ 张，被选中的攻击牌<strong>是</strong>第 $j$ 张</p><p>在前 $i$ 张强化牌中选 $k-1$ 张，且必选第 $i$ 张，其实就是 $f[i][k-1][0]$ </p><p>在攻击牌中选了第 $j$ 张，权值就是 $g[j][1][0]=b[j]$ </p><p>和上面一样，由于是随机选牌，剩余的 $m-k$ 张牌要满足强化牌都要排在第 $i$ 张牌的后面且攻击牌都要排在第 $j$ 张牌的后面，有 $\binom{2n-i-j}{m-k}$ 种方案</p><p>总之，对于这种情况，我们枚举 $i,j$ ，每次答案加 $f[i][k-1][0]\times b[j]\times\binom{2n-i-j}{m-k}$ </p></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IL inline</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3000</span> + <span class="number">5</span>, P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"><span class="keyword">int</span> C[N][N];</span><br><span class="line"><span class="keyword">int</span> f[N][N][<span class="number">2</span>], g[N][N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function">IL <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">pred</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">            C[i][j] = (C[i - <span class="number">1</span>][j - <span class="number">1</span>] + C[i - <span class="number">1</span>][j]) % P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pred</span>(); <span class="comment">//处理C</span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line">        <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n, cmp), <span class="built_in">sort</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + n, cmp);</span><br><span class="line">        <span class="comment">//处理f</span></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j][<span class="number">0</span>] = (LL)a[i] * f[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">1</span>] % P;</span><br><span class="line">                f[i][j][<span class="number">1</span>] = (f[i][j][<span class="number">0</span>] + f[i - <span class="number">1</span>][j][<span class="number">1</span>]) % P;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理g</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                g[i][j][<span class="number">0</span>] = ((LL)b[i] * C[i - <span class="number">1</span>][j - <span class="number">1</span>] + g[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">1</span>]) % P;</span><br><span class="line">                g[i][j][<span class="number">1</span>] = (g[i][j][<span class="number">0</span>] + g[i - <span class="number">1</span>][j][<span class="number">1</span>]) % P;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//情况1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">                ans = ((LL)f[n][i][<span class="number">1</span>] * g[j][k - i][<span class="number">0</span>] % P * C[n - j][m - k] + ans) % P;</span><br><span class="line">        <span class="comment">//情况2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">                ans = ((LL)f[i][k - <span class="number">1</span>][<span class="number">0</span>] * b[j] % P * C[<span class="number">2</span> * n - i - j][m - k] + ans) % P;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="废话"><a href="#废话" class="headerlink" title="废话"></a>废话</h2><p>啊啊啊我太弱了！同机房的 <a href="https://www.luogu.com.cn/user/342891"> ${\Huge{\color{Red}\mathfrak{dalao}}}$ </a>天天嘲笑我/(ㄒoㄒ)/~~</p><p>啊啊啊啊怎么办要被自己菜死了！┏┛墓┗┓…(((m -__-)m</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;${\color{red} 快跑啊}$&lt;/p&gt;</summary>
    
    
    
    
    <category term="数论,数学" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="期望" scheme="https://dyd-true.github.io/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>莫队</title>
    <link href="https://dyd-true.github.io/2021/11/22/%E8%8E%AB%E9%98%9F/"/>
    <id>https://dyd-true.github.io/2021/11/22/%E8%8E%AB%E9%98%9F/</id>
    <published>2021-11-22T08:26:41.000Z</published>
    <updated>2021-11-24T09:22:58.938Z</updated>
    
    <content type="html"><![CDATA[<p>然而还没写完（不想填了）</p><span id="more"></span><p>莫队其实是一种基于<strong>分块</strong>的<strong>暴力</strong>思想，是一种<strong>离线算法</strong>，下面用例题来讲</p><h1 id="例题一"><a href="#例题一" class="headerlink" title="例题一"></a>例题一</h1><p><a href="https://www.luogu.com.cn/problem/P1972">P1972</a><br>（本题正解不是莫队，但我们可以用莫队<del>玄学艹掉</del>得86分）<br>抽象出下面一个问题：</p><p>有一个长为 $n$ 的数列 $A$ 和 $m$ 个询问，每个询问格式为 $l,r$ ，表示查询区间 $[l,r]$ 中不同的数有多少个。</p><p>本题的暴力做法灰常简单——对于每一个询问，扫描一遍数列，用一个 $cnt$ 数组统计每个数出现的次数，再扫描一遍 $cnt$ ，统计有多少个非零。时间复杂度为 $O(m（n+S))$ （其中 $S$ 表示 $cnt$ 数组的长度，即数据范围）。</p><p>一个简单的优化可以把 $S$ 去掉：<br>在统计时 $a_i$ 出现，判定 $cnt[a_i]$ 若为0， $ans++,cnt[a_i]++$ ,否则只是 $cnt[a_i]++$ 。则时间复杂度优化为 $O(mn)$</p><p>可是时间复杂度还是太大了，为此，我们用一个类似双指针的优化。</p><h2 id="优化一"><a href="#优化一" class="headerlink" title="优化一"></a>优化一</h2><p>思考下面一种情况，上一个询问我们已经求出 $[i,j]$ （这里 $i,j$ 是两个指针）中不同的数的个数，储存在 $ans$ 中，并且 $cnt$ 已经跟新好了，现在我们要求 $[l,r]$ 。<br>求法当然是移动指针，具体如下：  </p><ol><li><p>将 $j$ 一步步向后走直到 $j=r$ ，并将 $cnt[a_j]++$ ，如果 $a_j$ 是新出现的，则 $res++$ 。</p></li><li><p>将 $i$ 一步步向后走直到 $i=l$ ，并将 $cnt[a_j]–$ ，如果 $cnt[a_j]=0$ ，则 $res–$ 。</p></li></ol><p>以上方法<strong>最坏情况下</strong>的时间复杂度仍为 $O(mn)$ ，可恶啊，<del>我们优化了个寂寞！</del></p><h2 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h2><p>像我一样的蒟蒻们可能到这里就放弃了，但<del>某国国家队的某莫涛队员</del>dalao们却开始思考起来：为啥这个优化<del>优化了个寂寞</del>会到最坏情况呢？当然是因为查询的问题不确定，本个查询和上个查询的区间可能完全没有交集，甚至相隔甚远，这使得指针移动耗费了大量时间。于是，dalao们提出了解决方法——<br>既然查询的顺序会影响时间复杂度，那么我们调整一下查询顺序不就好了！</p><h2 id="优化二"><a href="#优化二" class="headerlink" title="优化二"></a>优化二</h2><p>优化一的时间复杂度在 $O(n^2)$ ，而用了dalao的思路后可以优化为 $O(n\sqrt{n})$ 。  </p><p>先读入所有查询，将二元组 $(l_i,r_i)$ 以 $r_i$ （也可以 $l_i$ ）为关键字排序，完成后以 $r_i$ 有序来查询，这样指针 $j$ 的跳转次数不超过 $n$ 次（因为不会来回跳转）。但指针 $i$ 怎么办呢？dalao也给出方法——不会就分块呗。</p><p>我们在排序时加入第二个关键字——分块的编号。我们以 $l_i$ 所在块的编号为第一关键字， $r_i$ 为第二关键字来从小到大排序。</p><p>综上，我们将所有的查询操作分成长度为 $\sqrt{n}$ 的 $\sqrt{n}$ 块，每一块内的 $r_i$ 是单调递增的。则每一块内部 $j$ 的跳转次数不超过 $n$ 次，共 $\sqrt{n}$ 块；在块内时 $i$ 的移动次数不超过块的长度，即 $\sqrt{n}$ ，而在跨块时移动次数不超过两块的长度，即 $2\sqrt{n}$。那么时间总复杂度为 $O(n\sqrt{n})$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, len;</span><br><span class="line"><span class="keyword">int</span> w[N], ans[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Question</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, l, r;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> id(i) q[i].id</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(i) q[i].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(i) q[i].r</span></span><br><span class="line">&#125; q[N];</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            f = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x / len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Question &amp;a, <span class="keyword">const</span> Question &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="built_in">get</span>(a.l), j = <span class="built_in">get</span>(b.l);</span><br><span class="line">    <span class="keyword">if</span> (i != j)</span><br><span class="line">        <span class="keyword">return</span> i &lt; j;</span><br><span class="line">    <span class="keyword">return</span> a.r &lt; b.r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cnt[x])</span><br><span class="line">        res++;</span><br><span class="line">    cnt[x]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt[x]--;</span><br><span class="line">    <span class="keyword">if</span> (!cnt[x])</span><br><span class="line">        res--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        w[i] = <span class="built_in">read</span>();</span><br><span class="line">    m = <span class="built_in">read</span>();</span><br><span class="line">    len = <span class="built_in">sqrt</span>((<span class="keyword">double</span>)n * n / m); <span class="comment">//len的长度很玄学,会直接影响时间复杂度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        q[i].id = i;</span><br><span class="line">        q[i].l = <span class="built_in">read</span>();</span><br><span class="line">        q[i].r = <span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q, q + m, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>, j = <span class="number">0</span>, i = <span class="number">1</span>, res = <span class="number">0</span>; k &lt; m; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; <span class="built_in">r</span>(k))</span><br><span class="line">            <span class="built_in">add</span>(w[++j], res);</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="built_in">r</span>(k))</span><br><span class="line">            <span class="built_in">del</span>(w[j--], res);</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="built_in">l</span>(k))</span><br><span class="line">            <span class="built_in">del</span>(w[i++], res);</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="built_in">l</span>(k))</span><br><span class="line">            <span class="built_in">add</span>(w[--i], res);</span><br><span class="line">        ans[<span class="built_in">id</span>(k)] = res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="例题二（带修改的莫队）"><a href="#例题二（带修改的莫队）" class="headerlink" title="例题二（带修改的莫队）"></a>例题二（带修改的莫队）</h1><p><a href="https://www.luogu.com.cn/problem/P1903">P1903</a>  </p><h2 id="新指针"><a href="#新指针" class="headerlink" title="新指针"></a>新指针</h2><p>本题多了一种操作，即可以修改数列 $A$ 的元素。<br>为了解决该问题，我们给询问加一维 $k$ ，即询问 $l\ r\ k$ 表示“在第 $k$ 次修改后 $[l,r]$ 中不同的数的个数”，那么我们用三个指针（ $i,j,k$ ）来跳转。</p><p>指针 $i,j$ 都很好跳转，但 $k$ 的跳转我们必须认真分析一下了：<br>当 $k$ 从 $t-1$ 跳转到 $t$ 时，由于每次操作只会修改一个数的值（设为 $a_x$ ），那么如果 $x\in[l,r]$ 那么我们就必须更新 $cnt$ 和 $res$ 否则我们就不管它。跳转一次的时间复杂度为 $O(1)$ 。</p><p>但是，问题又双叒叕来了——重 $t$ 跳转会 $t-1$ 咋办？询问里面可没存原数列啊！不过，dalao有dalao的解决办法：设操作 $t$ 的修改是“把 $a_x$ 重 $y$ 修改为 $z$ ”，我们在修改完后交换 $y,z$ ，即让操作 $t$ 的修改变为“把 $a_x$ 重 $z$ 修改为 $y$ ”，这样，不管是加还是减，只要经过操作 $t$ 就执行即可。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>解决完新指针 $k$ 的问题后，聪明的dalao又开始思考新的问题了——该如何排序呢？</p><p>我们发现，只要以某一个指针为关键字，即让该指针单调，那么该扫描该指针的时间复杂度就会从 $O(n^2)$ 变成 $O(n)$ 。so，our思路还是让一个指针单调，其他指针分块。</p><p>所以排序变成一个三关键字排序：  </p><ol><li><p> $l$ 所在块的编号</p></li><li><p> $r$ 所在块的编号</p></li><li><p> $t$</p></li></ol><h2 id="块的大小"><a href="#块的大小" class="headerlink" title="块的大小"></a>块的大小</h2><p>然后，我们就来到了莫队里最玄学的地方——每一块该有多大呢？<br>像我一样的蒟蒻随便取个 $\sqrt{n}$ 或某个常数就可以了。<br>但总有像 <del>xyc</del> 一样的dalao喜欢<del>秀智商</del>严谨计算：</p><p>设每一块的大小为 $b$ ，则块的数量为 $\frac{n}{b}$ 。<br>那么，指针 $i$ （对应 $l$ ） 在块内移动的次数最大为 $b$ 有 $m$ 个问题，跨块的话每次最多移动 $2b$ （两个块的长度），有 $\frac{n}{b}$ 块，所以总的时间复杂度为 $O(b\times m+2b\times \frac{n}{b})=O(bm+n)$ 。  </p><p>指针 $j$ 的情况有点复杂。 $j$ 在块内和 $i$ 一样，最多为 $am$ 。但块间移动时，对于 $i$ 的每一个块， $j$ 最坏都会从第1块移动到第 $\frac{n}{b}$ 块，每次块间移动为 $O(2b \times \frac{n}{b})=O(n)$ ， $i$ 共有 $\frac{n}{b}$ 块，所以共为 $\frac{n^2}{b}$ ，总的时间复杂度为 $O(bm+\frac{n^2}{b})$</p><p>指针 $k$ 的在 $l,r$ 确定的情况下是单调的，最多移动 $t$ 次。而 $l,r$ 各有 $\frac{n}{b}$ 种情况，故总时间复杂度为 $O(\frac{n^2}{b^2}t)$</p><p>那么，如何取 $b$ 使 $max(O(bm+n),O(bm+\frac{n^2}{b}),O(\frac{n^2}{b^2}t))$ 最小呢？<br>由于 $m=n,bm&gt;n$ ，不妨化简为 $O(bn),O(bn+\frac{n^2}{b}),O(\frac{n^2}{b^2}t)$ 。<br>如果 $b\le \sqrt{n}$ ，则 $\frac{n^2}{b^2}t \ge nt$ 时间复杂度为 $O(n^2)$ 级别，过大，故必须保证 $b \ge \sqrt{n}$ 。<br>那么就有 $\frac{n^2}{b} \le bn$ ，故 $O(bn+\frac{n^2}{b})$ 可化为 $O(bn)$ 。<br>现在只需要比较 $bn$ 和 $\frac{n^2}{b^2}t$ ，使二者的最大值最小，只需解一个方程 $bn=\frac{n^2}{b^2}t$ ，解得 $b=\sqrt[3]{nt}$ 。</p><p>综上，当 $b=\sqrt[3]{nt}$ 时，时间复杂度最优为 $O(\sqrt[3]{n^4t})\approx 10^6\sim10^7$ 。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">133333</span> + <span class="number">5</span>, S = <span class="number">1000000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, mq, mc, len;</span><br><span class="line"><span class="keyword">int</span> w[N], cnt[S], ans[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Question</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, l, r, t;</span><br><span class="line">&#125; q[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Modify</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> p, c;</span><br><span class="line">&#125; c[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x / len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Question &amp;a, <span class="keyword">const</span> Question &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> al = <span class="built_in">get</span>(a.l), ar = <span class="built_in">get</span>(a.r);</span><br><span class="line">    <span class="keyword">int</span> bl = <span class="built_in">get</span>(b.l), br = <span class="built_in">get</span>(b.r);</span><br><span class="line">    <span class="keyword">if</span> (al != bl)</span><br><span class="line">        <span class="keyword">return</span> al &lt; bl;</span><br><span class="line">    <span class="keyword">if</span> (ar != br)</span><br><span class="line">        <span class="keyword">return</span> ar &lt; br;</span><br><span class="line">    <span class="keyword">return</span> a.t &lt; b.t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cnt[x])</span><br><span class="line">        res++;</span><br><span class="line">    cnt[x]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt[x]--;</span><br><span class="line">    <span class="keyword">if</span> (!cnt[x])</span><br><span class="line">        res--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span> (*op == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">            mq++, q[mq] = &#123;mq, a, b, mc&#125;;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            c[++mc] = &#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    len = <span class="built_in">cbrt</span>((<span class="keyword">double</span>)n * <span class="built_in">max</span>(mc, n));</span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + mq + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>, t = <span class="number">0</span>, k = <span class="number">1</span>, res = <span class="number">0</span>; k &lt;= mq; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> id = q[k].id, l = q[k].l, r = q[k].r, tm = q[k].t;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; r)</span><br><span class="line">            <span class="built_in">add</span>(w[++i], res);</span><br><span class="line">        <span class="keyword">while</span> (i &gt; r)</span><br><span class="line">            <span class="built_in">del</span>(w[i--], res);</span><br><span class="line">        <span class="keyword">while</span> (j &lt; l)</span><br><span class="line">            <span class="built_in">del</span>(w[j++], res);</span><br><span class="line">        <span class="keyword">while</span> (j &gt; l)</span><br><span class="line">            <span class="built_in">add</span>(w[--j], res);</span><br><span class="line">        <span class="keyword">while</span> (t &lt; tm)</span><br><span class="line">        &#123;</span><br><span class="line">            t++;</span><br><span class="line">            <span class="keyword">if</span> (c[t].p &gt;= j &amp;&amp; c[t].p &lt;= i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">del</span>(w[c[t].p], res);</span><br><span class="line">                <span class="built_in">add</span>(c[t].c, res);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(w[c[t].p], c[t].c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (t &gt; tm)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (c[t].p &gt;= j &amp;&amp; c[t].p &lt;= i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">del</span>(w[c[t].p], res);</span><br><span class="line">                <span class="built_in">add</span>(c[t].c, res);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(w[c[t].p], c[t].c);</span><br><span class="line">            t--;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[id] = res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= mq; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="例题三（回滚莫队）"><a href="#例题三（回滚莫队）" class="headerlink" title="例题三（回滚莫队）"></a>例题三（回滚莫队）</h1><p>看看下题<br><a href="https://www.luogu.com.cn/problem/AT1219">AT1219</a><br>本题中区间伸长的时候很好维护信息但区间缩短的时候不太好维护信息<br>于是我们遇到莫队的一个常见问题：当询问的不再是简单的计数，而是最值或其他带有比较性质的信息时，如何在指针移动时用可接受的时间实现答案的跟新（即“当前区间”的插入和删除时如何快速跟新答案）？<br>就本题而言，我们发现插入一个新数的跟新非常简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cnt[i]++;</span><br><span class="line"><span class="keyword">if</span>(cnt[i]*i&gt;res) res=cnt[i]*i;</span><br></pre></td></tr></table></figure><p>但是，删除操作会变得十分麻烦：原来 $res=cnt[i]$ ，但当 $cnt[i]-=i$ 后， $res$ 就必须要把整个 $cnt$ 数组扫描一遍才能确定。<br>当然，dalao可以用二叉堆来解决这个问题，但其实莫队有一种 <del>虽然时间慢些</del> 更好写的办法。</p><h2 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h2><p> 首先分块，把询问区间先按左端点（ $l$ ）的块排序，相同按右端点（ $r$ ）从小到大排序</p><p>若询问的左右端点在同一个块内，暴力解决， $O(\sqrt{n})$<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/a1h168qt.png" alt="同块暴力"></p><p>剩下的询问必然是跨块的，如图：<img src="https://cdn.luogu.com.cn/upload/image_hosting/5iuj9rtn.png" alt="跨块暴力"><br>由于排序，对于 $l$ 同块的询问 $r$ 一定是递增的，其指针在转移时不必考虑删除操作（如图中 $r_{i+1}$ 一定在 $r_i$ 右方），只需单独定一个 $cnt2$ 来记录即可；而 $l_{i+1}$ 有可能在 $l_i$ 左侧，但它们一定在同一块，即使涉及删除也不会多次使用。但，到底还是要删除，咋办？</p><p>想想你在玩 $galgame$ 玩出最坏的 $BE$的时候，你是不是会选择回档？想想为毛这东西要叫回滚莫队？想想到底是 $cnt$ 难删除还是 $res$ 那维护？于是，我们 <del>在dalao的提示下</del> 发现，我们也可以让莫队“回档”。<br>综上，操作如下：  </p><ol><li><p>先将指针移动到 $l$ 所在块的末尾（具体来讲，设块尾为 $q$ 则 $i=q+1,j=q$ ，保证初始为空）</p></li><li><p>将 $res$ 备份存档</p></li><li><p>每遇到一个询问，我们先移动 $j$ （对应 $r$ ），这里只会涉及添加操作,移动时跟新 $cnt$ 和 $res$ </p></li><li><p>移动 $i$ ，由于 $i$ 最初一定在 $l$ 右边，故只有添加操作，移动完毕后跟新询问的答案</p></li><li><p>将 $res$ 回复，将 $i$ 归位到 $i=q+1$ ，过程中回复 $cnt$ </p></li></ol><p>最后，如果我们当前这个询问的块是上一个询问的下一个块，即我们跨过了一个块，就直接清空 $cnt$ ，重新再来，重复上面的操作，只是块变成了下一个而已（有dalao说：“就相当于我们对于每一个块做一次莫队”）</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> n, m, len;</span><br><span class="line"><span class="keyword">int</span> w[N], cnt[N];</span><br><span class="line">LL ans[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Question</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, l, r;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> id(k) q[k].id</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(k) q[k].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(k) q[k].r</span></span><br><span class="line">&#125; q[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; nums; <span class="comment">//离散化用</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x / len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Question x, Question y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="built_in">get</span>(x.l), j = <span class="built_in">get</span>(y.l);</span><br><span class="line">    <span class="keyword">if</span> (i != j)</span><br><span class="line">        <span class="keyword">return</span> i &lt; j;</span><br><span class="line">    <span class="keyword">return</span> x.r &lt; y.r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, LL &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt[x]++;</span><br><span class="line">    res = <span class="built_in">max</span>(res, (LL)cnt[x] * nums[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    len = <span class="built_in">sqrt</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//离散化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        w[i] = <span class="built_in">read</span>(), nums.<span class="built_in">push_back</span>(w[i]);</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    nums.<span class="built_in">erase</span>(<span class="built_in">unique</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        w[i] = <span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), w[i]) - nums.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="built_in">read</span>(), b = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">id</span>(i) = i, <span class="built_in">l</span>(i) = a, <span class="built_in">r</span>(i) = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q, q + m, cmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; m;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y = x;</span><br><span class="line">        <span class="keyword">while</span> (y &lt; m &amp;&amp; <span class="built_in">get</span>(<span class="built_in">l</span>(y)) == <span class="built_in">get</span>(<span class="built_in">l</span>(x))) <span class="comment">//完成后x~y就是同块的</span></span><br><span class="line">            ++y;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="built_in">get</span>(<span class="built_in">l</span>(x)) * len + len - <span class="number">1</span>; <span class="comment">//本块右端点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//暴力求块内</span></span><br><span class="line">        <span class="keyword">while</span> (x &lt; y &amp;&amp; <span class="built_in">r</span>(x) &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            LL res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="built_in">l</span>(x); k &lt;= <span class="built_in">r</span>(x); ++k)</span><br><span class="line">                <span class="built_in">add</span>(w[k], res);</span><br><span class="line">            ans[<span class="built_in">id</span>(x)] = res;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="built_in">l</span>(x); k &lt;= <span class="built_in">r</span>(x); ++k) <span class="comment">//回复</span></span><br><span class="line">                cnt[w[k]]--;</span><br><span class="line"></span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求跨块</span></span><br><span class="line">        LL res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = right, i = right + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &lt; y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; <span class="built_in">r</span>(x)) <span class="comment">//右指针只增不删</span></span><br><span class="line">                <span class="built_in">add</span>(w[++j], res);</span><br><span class="line"></span><br><span class="line">            LL b_res = res; <span class="comment">//存档</span></span><br><span class="line">            <span class="keyword">while</span> (i &gt; <span class="built_in">l</span>(x))</span><br><span class="line">                <span class="built_in">add</span>(w[--i], res);</span><br><span class="line"></span><br><span class="line">            ans[<span class="built_in">id</span>(x)] = res;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//回复</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; right + <span class="number">1</span>)</span><br><span class="line">                cnt[w[i++]]--;</span><br><span class="line">            res = b_res;</span><br><span class="line"></span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt); <span class="comment">//换块,清空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="例四（树上莫队）有完没完"><a href="#例四（树上莫队）有完没完" class="headerlink" title="例四（树上莫队）有完没完"></a>例四（树上莫队）<del>有完没完</del></h1><p><a href="https://www.acwing.com/problem/content/2536/">AcWing2536</a><br>与例一类似，只是区间变成了树上的一个路径。<br>那要是可以把树变成一个序列，并且路径就对应一个区间，那该有多好啊！（好假，一看就是dalao告诉的）</p><p>于是 <del>dalao告诉</del> 我们想到，可以用<strong>欧拉序列</strong>！（那系个啥？）</p><h2 id="欧拉序列"><a href="#欧拉序列" class="headerlink" title="欧拉序列"></a>欧拉序列</h2><p>名字挺高级的，其实就是一个DFS遍历，遍历时经过的节点顺序就是欧拉序列。<br>for example：<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/zyak8ug3.png" alt="欧拉路径"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;然而还没写完（不想填了）&lt;/p&gt;</summary>
    
    
    
    
    <category term="暴力" scheme="https://dyd-true.github.io/tags/%E6%9A%B4%E5%8A%9B/"/>
    
    <category term="分块" scheme="https://dyd-true.github.io/tags/%E5%88%86%E5%9D%97/"/>
    
    <category term="莫队" scheme="https://dyd-true.github.io/tags/%E8%8E%AB%E9%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>莫比乌斯反演</title>
    <link href="https://dyd-true.github.io/2021/11/22/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    <id>https://dyd-true.github.io/2021/11/22/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</id>
    <published>2021-11-22T08:25:37.000Z</published>
    <updated>2021-11-24T09:22:42.238Z</updated>
    
    <content type="html"><![CDATA[<p>数学的恶魔</p><span id="more"></span><h1 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h1><h2 id="前置知识：数论分块"><a href="#前置知识：数论分块" class="headerlink" title="前置知识：数论分块"></a>前置知识：数论分块</h2><h3 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h3><p>数论分块可以快速计算一些含有除法向下取整的和式（即形如 $\sum_{i=1}^{n} f(i)g( \lfloor \frac{n}{i} \rfloor)$ 的式子），只要可以在 $O(1)$ 内计算 $f(r)-f(l)$ 或已经预处理出 $f$ 的前缀和时，可以用数论分块在 $O(\sqrt{n})$ 的时间内计算答案。</p><p>它主要利用<strong>富比尼定理（Fubini’s theorem）</strong>（<del>听起来很厉害但其实没啥</del>）：我们注意到，有很多的 $i$ 它们的 $\lfloor \frac{n}{i} \rfloor$ 是相等的，这启发我们分段打包计算。</p><p>举个例子，如果我们要求 $\sum_{i=1}^{n} \lfloor \frac{n}{i} \rfloor$ ，我们发现很多 $i$ 都对应同一个 $\lfloor \frac{n}{i} \rfloor$ ，它们呈块状分布，在<del>打个表</del>仔细观察（<a href="https://oi-wiki.org/math/number-theory/sqrt-decomposition/">证明</a>），发现对于每一个块，它的最后一个数是 $n/(n/i)$ （ $c++$ 自带下取整，一般我们称其这个式子的值为 $g(i)$ ），如对于 $\sum_{i=1}^{10} \lfloor \frac{10}{i} \rfloor$ ，分成： $(1)(2)(3)(4,5)(6,7,8,9,10)$ ，其中 $1=10/(10/1),2=10/(10/2),3=10/(10/3),5=10/(10/5),10=10/(10/10)$ ，于是，求解上述问题的代码如下（常用）：</p><p><a href="https://www.luogu.com.cn/problem/UVA11526">UVA11526 H(n)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">    r=n/(n/l);</span><br><span class="line">    ans+=(r-l+<span class="number">1</span>)*(n/l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的，我们可以用 $O(\sqrt{n})$ 计算 $g(\lfloor \frac{n}{i} \rfloor)$ 那么只要 $f$ 好求我们就能算了！</p><p>一般而言，我们可以统计一个前缀和（积），因为每当我们使用分块跳过一个区间的时候，其所对应的函数值也跳过了一个区间。所以此时，就需要乘上那一个区间的函数值（可以自己举个例子理解一下）。</p><p>但要是不一般（比如 $O(n)$ 的前缀和都会TLE），那……去死吧！（dalao可以用<strong>杜教筛</strong>试一试）</p><h3 id="引理一"><a href="#引理一" class="headerlink" title="引理一"></a>引理一</h3><p>$$<br>\forall a,b,c \in \mathbb{Z},\lfloor \frac{a}{bc} \rfloor=\lfloor \frac{\lfloor \frac{a}{b} \rfloor}{c} \rfloor<br>$$</p><p>证明：<br>$$<br>\frac{a}{b}=\lfloor\frac{a}{b}\rfloor+r(0\le r&lt;1)<br>\Rightarrow\lfloor\frac{a}{bc}\rfloor=\lfloor\frac{1}{c}(\lfloor\frac{a}{b}\rfloor+r)\rfloor=\lfloor\frac{\lfloor\frac{a}{b}\rfloor}{c}+\frac{r}{c}\rfloor=\lfloor \frac{\lfloor \frac{a}{b} \rfloor}{c} \rfloor<br>$$</p><h3 id="引理二"><a href="#引理二" class="headerlink" title="引理二"></a>引理二</h3><p>$$<br>\forall n\in\mathbb{N_+},{\LARGE|}{\lfloor \frac{n}{d}\rfloor|d\in\mathbb{N_+}\wedge d\le n}{\LARGE|}\le\lfloor2\sqrt{n}\rfloor<br>$$</p><p>其中 $|V|$ 表示集合 $V$ 的元素个数</p><p>该引理是时间复杂度的保证</p><p>证明：</p><p>对于 $d\le\lfloor\sqrt{n}\rfloor$ ，由于 $d$ 最多有 $\lfloor\sqrt{n}\rfloor$ 种不同取值， $\lfloor\frac{n}{d}\rfloor$ 也只有 $\lfloor\sqrt{n}\rfloor$ 种取值</p><p>对于 $d&gt;\lfloor\sqrt{n}\rfloor$ ，则 $\lfloor\frac{n}{d}\rfloor\le\lfloor\sqrt{n}\rfloor$ ，也只有 $\lfloor\sqrt{n}\rfloor$ 种取值</p><h2 id="前置知识：积性函数"><a href="#前置知识：积性函数" class="headerlink" title="前置知识：积性函数"></a>前置知识：积性函数</h2><p>若函数 $f(x)$ 为积性函数，则有 $\forall gcd(a,b)=1,f(ab)=f(a)f(b)$ </p><p>可以证明以下函数全是积性函数：</p><ul><li>$\varphi(n)$ －欧拉函数</li><li>$\mu(n)$ －莫比乌斯函数</li><li>$gcd(n,k)$ －最大公因子，当k固定的情况</li><li>$d(n)$ －正因子数目</li><li>$\sigma(n)$ －所有正因子之和</li><li>$\sigma k(n)$ －因子函数， $n$ 的所有正因子的 $k$ 次幂之和，当中 $k$ 可为任何复数</li><li>$1(n)$ －不变的函数，定义为 $1(n)=1$ （完全积性）</li><li>$Id(n)$ －单位函数，定义为 $Id(n)=n$ （完全积性）</li><li>$Idk(n)$ －幂函数，对于任何复数、实数 $k$ ，定义为 $Idk(n)=n^k$ （完全积性）</li><li>$\varepsilon(n)$ －定义为：若 $n=1$ ， $\varepsilon(n)=1$ ；若 $n&gt;1$ ， $\varepsilon(n)=0$ 。别称为“对于狄利克雷卷积的乘法单位”（完全积性）</li><li>$\lambda(n)$ －<a href="https://baike.baidu.com/item/%E5%88%98%E7%BB%B4%E5%B0%94%E5%87%BD%E6%95%B0">刘维尔函数</a>，关于能整除 $n$ 的质因子的数目</li><li>$\gamma(n)$ ，定义为 $\gamma(n)=(-1)^{\omega(n)}$，在此加性函数 $\omega(n)$ 是不同能整除<em>n</em>的质数的数目</li><li>另外，所有<a href="https://baike.baidu.com/item/%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E7%89%B9%E5%BE%81">狄利克雷特征</a>均是完全积性的</li></ul><p>积性函数一般可以用线性筛筛得</p><h2 id="前置知识：狄利克雷卷积"><a href="#前置知识：狄利克雷卷积" class="headerlink" title="前置知识：狄利克雷卷积"></a>前置知识：狄利克雷卷积</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>狄利克雷（ $Dirichlet$ ）卷积定义为：</p><p>对于两个<a href="https://baike.baidu.com/item/%E6%95%B0%E8%AE%BA%E5%87%BD%E6%95%B0">数论函数</a> $f,g$ ，有：<br>$$<br>(f*g)(n)=\sum_{d|n}f(d)g(\frac{n}{d})<br>$$</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>狄利克雷卷积满足以下运算律：</p><ul><li>交换律： $(f* g)=(g* f)$ </li><li>结合律： $((f* g)* h)=(f* (g* h))$ </li><li>分配律： $(f* (g+h))=((f* g)+(f* h))$ </li><li>$(f*\varepsilon)=f$ ，其中 $\varepsilon$ 为狄利克雷卷积的单位元 </li></ul><p>for example：</p><ul><li> $\varepsilon=(\mu*1)\Leftrightarrow\varepsilon(n)=\sum_{d|n}\mu(d)1(\frac{n}{d})=\sum_{d|n}\mu(d)$</li><li> $d=(1*1)\Leftrightarrow d(n)=\sum_{d|n}1(d)1(\frac{n}{d})=\sum_{d|n}1$ </li><li> $Id=(\varphi*1)\Leftrightarrow Id(n)=n=\sum_{d|n}\varphi(n)$ </li><li> $\varphi=(\mu*Id)\Leftrightarrow\varphi(n)=\sum_{d|n}d\mu(\frac{n}{d})$ </li></ul><h3 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h3><p>对于卷积的第 $n$ 项可以直接枚举约数，在 $O(\sqrt{n})$ 的时间内计算</p><p>但是对于狄利克雷卷积的前 $n$ 项<br>$$<br>h[i]=\sum_{d|i}f[d]g[i/d]<br>$$<br>如果一项一项算的话就需要 $O(n\sqrt{n})$ ，但实际上可以优化</p><p>设 $x=d,y=\frac{i}{d}$ 分别枚举 $x,y$ 对于 $h[xy]+=f[x]g[y]$ 即可。<br> 时间复杂度 $O(n\log{n})$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) h[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j*i&lt;=n;++j) h[i*j]=(h[i*j]+f[i]*g[j]%P)%P;</span><br></pre></td></tr></table></figure><p>对于 $k$ 次卷积，还可以快速幂优化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HanShu</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> f[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inint</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) f[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HanShu <span class="keyword">operator</span>*(<span class="keyword">const</span> HanShu <span class="keyword">_t</span>)&#123;</span><br><span class="line">    HanShu h;</span><br><span class="line">h.<span class="built_in">inint</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j*i&lt;=n;++j) h.f[i*j]=(h.f[i*j]+f[i]*<span class="keyword">_t</span>.f[j]%P)%P;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> HanShu <span class="keyword">_t</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) f[i]=<span class="keyword">_t</span>.f[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">HanShu <span class="title">H_qpow</span><span class="params">(HanShu x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    HanShu res;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">_t</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">    <span class="keyword">if</span>(y&amp;<span class="number">1</span>)&#123;</span><br><span class="line">    ++<span class="keyword">_t</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">_t</span>==<span class="number">1</span>) res=x;</span><br><span class="line">    <span class="keyword">else</span> res=res*x;</span><br><span class="line">    &#125;</span><br><span class="line">    x=x*x;</span><br><span class="line">    y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前置知识：莫比乌斯函数"><a href="#前置知识：莫比乌斯函数" class="headerlink" title="前置知识：莫比乌斯函数"></a>前置知识：莫比乌斯函数</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>设正整数 $N$ 分解质因数为 $N=p_1^{c_1}p_2^{c_2}…p_m^{c_m}$ ，定义函数<br>$$<br>\mu(N)=\left{\begin{matrix}<br> 0&amp;\exists i\in[1,m],c_i&gt;1\<br> 1&amp;m\equiv0(mod\ 2),\forall i\in[1,m],c_i=1\<br>-1&amp;m\equiv1(mod\ 2),\forall i\in[1,m],c_i=1<br>\end{matrix}\right.<br>$$<br>我们称 $\mu$ 为莫比乌斯（ $M\ddot{o}bius$ ）函数。</p><h3 id="性质和结论"><a href="#性质和结论" class="headerlink" title="性质和结论"></a>性质和结论</h3><ul><li><p>莫比乌斯函数是积性函数</p></li><li><p>$\sum_{d|n}\mu(d)=[n==1]$ ，其中 $[p]$ 表示 $p$ 为真时取 $1$ 其他时候取 $0$ ，该式也可表示为 $\sum_{d|n}\mu(d)=\varepsilon(n)$ ，也就是 $\mu*1=\varepsilon$</p><p>证明：</p><p>设 $n=\prod_{i=1}^{k}p_i^{c_i},n’=\prod_{i=1}^{k}p_i$ </p><p>那么 $\sum_{d|n}\mu(d)=\sum_{d|n’}\mu(d)=\sum_{i=0}^{k}C_k^i(-1)^i$ </p><p>又因为二项式定理： $(a+b)^k=\sum_{i=0}^{k}C_k^i a^i b^{k-i}$ </p><p>有： $\sum_{i=0}^{k}C_k^i(-1)^i=\sum_{i=0}^{k}C_k^i(-1)^i 1^{k-i}=((-1)+1)^k$</p><p>当且仅当 $k=0$ ，即 $n=1$ 时原式为 $1$ ，其余时候都为 $0$ </p></li><li><p>$[gcd(i,j)==1]=\sum_{d|gcd(i,j)}\mu(d)$ 该结论在反演中十分常用，正确性显然</p></li></ul><h3 id="筛法"><a href="#筛法" class="headerlink" title="筛法"></a>筛法</h3><p>若只求一项莫比乌斯函数，分解质因数即可；</p><p>若要求多项可以在线性筛素数时一并求出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> primes[N],mu[N],cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> v[N];</span><br><span class="line">mu[<span class="number">1</span>]=<span class="number">1</span>; <span class="comment">//1特判</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!v[i]) primes[++cnt]=i,mu[i]=<span class="number">-1</span>; <span class="comment">//质数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;primes[j]*i&lt;=n;++j)&#123;</span><br><span class="line">v[primes[j]*i]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i%primes[j]==<span class="number">0</span>)&#123; <span class="comment">//若有一个质因数指数大于1</span></span><br><span class="line">            mu[i*primes[j]]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mu[i*primes[j]]=-mu[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="正题：莫比乌斯反演"><a href="#正题：莫比乌斯反演" class="headerlink" title="正题：莫比乌斯反演"></a>正题：莫比乌斯反演</h2><h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><p>若 $F(n)$ 和 $f(n)$ 是定义在 $\mathbb{N}$ 上的函数，且有<br>$$<br>F(n)=\sum_{d|n}f(d)<br>$$<br>则：<br>$$<br>f(n)=\sum_{d|n}\mu(d)F(\frac{n}{d})<br>$$<br>我们称该定理为<strong>莫比乌斯反演定理</strong>（原来是用 $f$ 表示 $F$ ，现在反过来了）。</p><p>证明如下：<br>$$<br>\begin{align}<br>\sum_{d|n}\mu(d)F(\frac{n}{d})<br>&amp;=\sum_{d|n}\mu(d)\sum_{i|\frac{n}{d}}f(i)\\<br>&amp;=\sum_{i|n}f(i)\sum_{d|\frac{n}{i}}\mu(d)\\<br>&amp;=\sum_{i|n}f(i)[\frac{n}{i}==1]\\<br>&amp;=f(n)<br>\end{align}<br>$$<br>当然，不难发现，狄利克雷卷积也可以证明：</p><p>$$<br>\begin{align}<br>&amp;F(n)=\sum_{d|n}f(d)\\<br>&amp;\Rightarrow F=f* 1\\<br>&amp;\Rightarrow F* \mu=f* 1* \mu\\<br>\text{又}\because&amp;\mu* 1=\varepsilon\\<br>&amp;\Rightarrow F* \mu=f* (1* \mu)=f\\<br>&amp;\Rightarrow f=\mu* F<br>\end{align}<br>$$</p><p>然而，在莫比乌斯反演中更常用的是这个式子：</p><p>当 $F(n)$ 和 $f(n)$ 满足：<br>$$<br>F(n)=\sum_{n|d}f(d)<br>$$<br>则有：<br>$$<br>f(n)=\sum_{n|d}\mu(\frac{d}{n})F(d)<br>$$<br>其实就是枚举约数变成了枚举倍数，若用卷积证明，过程都一样，下面用定义证明：<br>$$<br>\begin{align}<br>\sum_{n|d}\mu(\frac{d}{n})F(d)<br>&amp;=\sum_{n|d}\mu(\frac{d}{n})\sum_{d|i}f(i)\\<br>\text{不妨设}d’=\frac{d}{n}\\<br>\text{原式}<br>&amp;=\sum_{n|i}f(i)\sum_{d’|\frac{i}{n}}\mu(d’)\\<br>&amp;=\sum_{n|i}f(i)[\frac{i}{n}==1]\\<br>&amp;=f(n)<br>\end{align}<br>$$<br>以上就是莫比乌斯反演的常用形式（要记住）</p><h3 id="例题一"><a href="#例题一" class="headerlink" title="例题一"></a>例题一</h3><p><a href="https://www.luogu.com.cn/problem/P2522">Problem b</a></p><p>分析：</p><p>若我们将数对 $(x,y)$ 对应到坐标系内，其实是要求在左下角为 $(a,c)$ 右上角为 $(b,d)$ 的矩形中有多少个点 $(x,y)$ 满足 $gcd(x,y)==k$ </p><p>由矩形考虑二维前缀和，设 $S(x,y)$ 表示以 $(x,y)$ 为右上角， $(0,0)$ 为左下角的矩形中满足要求的点的个数，则 $Ans=S(b,d)-S(a-1,d)-S(b,c-1)+S(a-1,c-1)$ </p><p>考虑用莫比乌斯反演，我们需要定义 $F,f$ 且让 $F(n)=\sum_{n|d}f(d)$ （即满足反演条件），要注意的是， $F$ 应该是比较好计算的函数（至少要比 $f$ 好计算，不然你反演用 $F$ 表示 $f$ 干嘛），还有就是 $f$ 要与答案有关系（不然求出 $f$ 干嘛）</p><p>那么，不妨令 $f(n)=\sum_{x=1}^{N}\sum_{y=1}^{M}[gcd(x,y)==n]$ 则我们要求的 $S(N,M)$ 就是 $f(k)$ </p><p>又因为 $F(n)=\sum_{n|d}f(d)$ ，故定义 $F(n)=\sum_{x=1}^{N}\sum_{y=1}^{M}[n|gcd(x,y)]$ </p><p>反演得： $f(n)=\sum_{n|d}\mu(\frac{d}{n})F(d)$ </p><p>又因为由 $F$ 的定义， $n|gcd(x,y)\Leftrightarrow n|x\wedge n|y$ ，故 $F(d)=\lfloor\frac{N}{d}\rfloor\lfloor\frac{M}{d}\rfloor$</p><p>所以 $f(n)=\sum_{n|d}\mu(\frac{d}{n})\lfloor\frac{N}{d}\rfloor\lfloor\frac{M}{d}\rfloor$ </p><p>枚举倍数比枚举因数要简单，所以我们令 $d’=\frac{d}{n},N’=\frac{N}{n},M’=\frac{M}{n}$ ，原式化为 $f(n)=\sum_{d’}\mu(d’)\lfloor\frac{N’}{d}\rfloor\lfloor\frac{M’}{d}\rfloor$ 预处理 $\mu$ 的前缀和后用数论分块可以求</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">50000</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> pri[N],cnt,mu[N];</span><br><span class="line"><span class="keyword">bool</span> v[N];</span><br><span class="line">LL sum[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pred</span><span class="params">()</span></span>&#123;</span><br><span class="line">mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i]) pri[++cnt]=i,mu[i]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;pri[j]*i&lt;N;++j)&#123;</span><br><span class="line">v[pri[j]*i]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>)&#123;</span><br><span class="line">mu[i*pri[j]]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">mu[i*pri[j]]=-mu[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sum[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i) sum[i]=sum[i<span class="number">-1</span>]+mu[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>&#123; <span class="comment">//得到(k/x)中x所在块的右端点</span></span><br><span class="line"><span class="keyword">return</span> k/(k/x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">S</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">LL res=<span class="number">0</span>;</span><br><span class="line">x=x/k,y=y/k;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">_t</span>=<span class="built_in">min</span>(x,y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=<span class="keyword">_t</span>;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">r=<span class="built_in">min</span>(<span class="keyword">_t</span>,<span class="built_in">min</span>(<span class="built_in">g</span>(x,l),<span class="built_in">g</span>(y,l))); <span class="comment">//每次在两个取整中找小的,注意不能超过_t</span></span><br><span class="line">res+=(sum[r]-sum[l<span class="number">-1</span>])*(x/l)*(y/l);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a,b,c,d,k;</span><br><span class="line"><span class="built_in">pred</span>();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c,&amp;d,&amp;k);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">S</span>(b,d,k)-<span class="built_in">S</span>(a<span class="number">-1</span>,d,k)-<span class="built_in">S</span>(b,c<span class="number">-1</span>,k)+<span class="built_in">S</span>(a<span class="number">-1</span>,c<span class="number">-1</span>,k));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题二"><a href="#例题二" class="headerlink" title="例题二"></a>例题二</h3><p><a href="https://www.luogu.com.cn/problem/P3327">约数个数和</a></p><p>分析：</p><p>先看原题给我们的函数，由于 $d$ 是积性函数（忘了的上去翻），所以有 $d(ij)=\sum_{x|i}\sum_{y|j}[gcd(x,y)==1]$ （<del>呃呃呃，鬼想的到啊！</del>）</p><p>简单证明：</p><p>设 $i=p_1^{\alpha_1}p_2^{\alpha_2}…p_k^{\alpha_k},j=p_1^{\beta_1}p_2^{\beta_2}…p_k^{\beta_k}$ ，则 $ij=i=p_1^{\alpha_1+\beta_1}p_2^{\alpha_2+\beta_2}…p_k^{\alpha_k+\beta_k}$ ，由约数个数定理 $d(ij)=(\alpha_1+\beta_1+1)(\alpha_2+\beta_2+1)…(\alpha_k+\beta_k+1)$ </p><p>再看等式右边， $x,y$ 的因数也一定是在 $p_1,p_2,…,p_k$ 中，对于质因子 $p_1$ ，若 $x$ 含 $p_1^t,(t\ne 0)$ ，则有意义的 $y$ 一定不含 $p_1$ ，此时 $t$ 有 $\alpha_1$ 种取值，同理，若 $y$ 含 $p_1^t,(t\ne 0)$ 有 $\beta_1$ 种取值，加上一种 $x,y$ 都不含 $p_1$ ，共 $\alpha_1+\beta_1+1$ 种有意义的取值，类似的，讨论其它质因数，乘法原理得左式等于右式</p><p> QED</p><p>我们发现 $Ans=\sum_{i=1}^{N}\sum_{j=1}^{M}\sum_{x|i}\sum_{y|j}[gcd(x,y)==1]$ ，类似与上题，令： $f(n)=\sum_{i=1}^{N}\sum_{j=1}^{M}\sum_{x|i}\sum_{y|j}[gcd(x,y)==n],F(n)=\sum_{i=1}^{N}\sum_{j=1}^{M}\sum_{x|i}\sum_{y|j}[n|gcd(x,y)]$ 那么 $Ans=f(1)$ </p><p>则 $F(n)=\sum_{n|d}f(d)$ ，反演得 $f(n)=\sum_{n|d}\mu(\frac{d}{n})F(d)$ </p><p>故 $f(1)=\sum_{d=1}^{N}\mu(d)F(d)$ ，为了求出 $f(1)$ ，我们来看 $F(n)$ ，由于 $[n|gcd(x,y)]$ 与 $i,j$ 无关，我们可以枚举 $x,y$ 计算有多少 $i,j$ 符合要求， $F(n)=\sum_{x=1}^{N}\sum_{y=1}^{M}\lfloor\frac{N}{x}\rfloor\lfloor\frac{M}{y}\rfloor[n|gcd(x,y)]$ </p><p>同上题一样，可设 $x’=\frac{x}{n},y’=\frac{y}{n},N’=\frac{N}{n},M’=\frac{M}{n}$ ，得 $F(n)=\sum_{x’=1}^{N’}\sum_{y’=1}^{M’}\lfloor\frac{N’}{x’}\rfloor\lfloor\frac{M’}{y’}\rfloor$ </p><p>调换循环顺序得 $F(n)=(\sum_{x’=1}^{N’}\lfloor\frac{N’}{x’}\rfloor)(\sum_{y’=1}^{M’}\lfloor\frac{M’}{y’}\rfloor)$ </p><p>令 $h(k)=\sum_{i=1}^{k}\lfloor\frac{k}{i}\rfloor$ ，有 $F(n)=h(N’)h(M’)$ ，故 $f(1)=\sum_{d=1}^{N}\mu(d)h(\frac{N}{d})h(\frac{M}{d})$ ，预处理所有的 $h(x)$ ，数论分块解决</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">50000</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> pri[N],cnt,mu[N];</span><br><span class="line">LL sum[N],h[N];</span><br><span class="line"><span class="keyword">bool</span> v[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> k/(k/x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pred</span><span class="params">()</span></span>&#123;</span><br><span class="line">mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i]) pri[++cnt]=i,mu[i]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;pri[j]*i&lt;N;++j)&#123;</span><br><span class="line">v[pri[j]*i]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>)&#123;</span><br><span class="line">mu[i*pri[j]]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">mu[i*pri[j]]=-mu[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sum[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i) sum[i]=sum[i<span class="number">-1</span>]+mu[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=i;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">r=<span class="built_in">min</span>(i,<span class="built_in">g</span>(i,l));</span><br><span class="line">h[i]+=(r-l+<span class="number">1</span>)*(i/l);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">pred</span>();</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">LL ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">_t</span>=<span class="built_in">min</span>(n,m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=<span class="keyword">_t</span>;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">r=<span class="built_in">min</span>(<span class="keyword">_t</span>,<span class="built_in">min</span>(<span class="built_in">g</span>(n,l),<span class="built_in">g</span>(m,l)));</span><br><span class="line">ans+=(sum[r]-sum[l<span class="number">-1</span>])*h[n/l]*h[m/l];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题三"><a href="#例题三" class="headerlink" title="例题三"></a>例题三</h3><p><a href="https://www.luogu.com.cn/problem/P2303">龙哥的问题</a></p><p>本题比较简单，甚至不用莫反</p><p>考虑答案：<br>$$<br>\begin{align}<br>Ans<br>&amp;=\sum_{i=1}^{n}gcd(i,n)\\<br>&amp;=\sum_{d|n}(d\times\sum_{i=1}^{n}[gcd(i,n)==d])\\<br>&amp;=\sum_{d|n}(d\times\sum_{i=1}^{n}[gcd(\frac{i}{d},\frac{n}{d})==1])\\<br>&amp;=\sum_{d|n}d\times\varphi(\frac{n}{d})<br>\end{align}<br>$$<br>对于每一个 $n$ 枚举约数（ $int$ 范围内最多的一个数约数只有 $1600$ 多个） ，再 $\sqrt{n}$ 求 $\varphi$ ，本题的范围可以通过</p><p>那可否继续优化呢？令 $k=\frac{n}{d}$ ，再继续化一下：<br>$$<br>\begin{align}<br>Ans<br>&amp;=\sum_{d|n}d\times\varphi(\frac{n}{d})\\<br>&amp;=\sum_{k|n}\frac{n}{k}\times\varphi(k)\\<br>&amp;=\sum_{k|n}\frac{n}{k}\times k\prod(1-\frac{1}{p_i})\\<br>&amp;=n\sum_{k|n}\prod(1-\frac{1}{p_i})<br>\end{align}<br>$$<br>其中 $k_t=\prod p_i^{c_{i,t}}$ ，又因为 $k|n$ ，不妨设 $n=\prod p_i^{\alpha_i}$  ，下面的变化比较常用，要记住：<br>$$<br>\begin{align}<br>&amp;k|d\\<br>\Rightarrow&amp;\forall k_t,0\le c_{i,t}\le\alpha_i\\<br>\Rightarrow&amp;\sum_{k|n}k=\sum_{t}\prod_{i} p_i^{c_{i,t}}=\prod_{t}\sum_{i} p_i^{c_{i,t}}\\<br>&amp;=(p_1^0+p_1^2+…+p_1^{\alpha_1})(p_2^0+p_2^2+…+p_2^{\alpha_2})…<br>\end{align}<br>$$</p><p>如果不理解的话可以这样想：每个括号里取一项作 $p_i^{c_{i,t}}$ 乘起来刚好对应一个 $k_t$ </p><p>那么考虑上式对答案的贡献，我们发现对于所有的 $k$ ，若取第 $i$ 个质因子的指数为 $0$ （即取 $p_i^0$ ）对答案贡献为 $1$ ，其他情况（即 $p_i^c,c\ne0$ ）对答案的贡献都是 $1-\frac{1}{p_i}$ ，故答案可化为：<br>$$<br>\begin{align}<br>Ans<br>&amp;=n\prod_{i}(1+(1-\frac{1}{p_i})+(1-\frac{1}{p_i})+…+(1-\frac{1}{p_i}))\\<br>&amp;=n\prod_{i}(1+a(1-\frac{1}{p_i}))<br>\end{align}<br>$$<br>分解 $n$ 的质因子，可以在 $O(\sqrt{n})$ 时间求解，但注意，本题对 $long\ long$ 卡的非常死，甚至在计算 $ans$ 时先乘再除都会炸 $long\ long$ </p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">LL n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">LL ans=n; <span class="comment">//最初的n </span></span><br><span class="line"><span class="keyword">for</span>(LL i=<span class="number">2</span>;i*i&lt;=n;++i)</span><br><span class="line"><span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">LL a=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n%i==<span class="number">0</span>) ++a,n/=i;</span><br><span class="line">ans/=i,ans*=i+a*i-a; <span class="comment">//一定要先除 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n&gt;<span class="number">1</span>) ans/=n,ans*=n+n<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题四"><a href="#例题四" class="headerlink" title="例题四"></a>例题四</h3><p>来看一道难题：</p><p><a href="https://www.luogu.com.cn/problem/P3704">数字表格</a></p><p>这道题要点很杂很多，我们慢慢看：</p><p>首先明确<br>$$<br>Ans=\prod_{i=1}^{n}\prod_{j=1}^{m}fb(gcd(i,j))<br>$$<br>其中 $fb(x)$ 表示Fibonacci数列第 $x$ 项</p><p>由于 $\prod$ 不好处理，考虑枚举 $gcd$ ：<br>$$<br>Ans=\prod_{d=1}^{N}[fb(d)]^{f(d)}<br>$$<br>其中 $N=\min(n,m)$ ， $f(d)=\sum_{i=1}^{m}\sum_{j=1}^{n}[gcd(i,j)==d]$</p><p>发现这个 $f$ 的定义我们非常熟悉，于是一通莫反：<br>$$<br>\begin{align}<br>\text{令}&amp;F(d)=\sum_{i=1}^{m}\sum_{j=1}^{n}[d|gcd(i,j)]\\<br>\text{则有}&amp;F(d)=\sum_{r|d}f(r)\\<br>\text{反演得}&amp;f(d)=\sum_{d|r}\mu(\frac{r}{d})F(r)\\<br>\text{又有}&amp;d|gcd(i,j)\Leftrightarrow d|i,d|j\\<br>\text{故}&amp;F(d)=\lfloor\frac{n}{d}\rfloor\lfloor\frac{m}{d}\rfloor\\<br>\text{带入得}&amp;f(d)=\sum_{d|r}\mu(\frac{r}{d})\lfloor\frac{n}{r}\rfloor\lfloor\frac{m}{r}\rfloor\\<br>\text{令}w=\frac{r}{d},\text{有}&amp;f(d)=\sum_{w=1}^{\lfloor\frac{N}{d}\rfloor}\mu(w)\lfloor\frac{n}{wd}\rfloor\lfloor\frac{m}{wd}\rfloor<br>\end{align}<br>$$<br>此时我们发现在莫反后， $f(d)$ 可以在 $O(\sqrt{n})$ 内计算，但是，我们观察 $Ans$ ，对于每个 $d$ ， $f(d)$ 都必须重新计算（因为 $f$ 与 $n,m,d$ 都有关），这样的时间负责度为 $O(Tn(\sqrt{n}+\log{n}))$ 直接爆炸好吧</p><p>必须考虑优化，但 $fb$ 和 $\prod$ 都太不好搞了， $f$ 也不好在变形（我在这里卡了好久），既然两个都不好搞，我们不妨把它们一起来看看：<br>$$<br>Ans=\prod_{d=1}^{N}[fb(d)]^{\sum_{w=1}^{\lfloor\frac{N}{d}\rfloor}\mu(w)\lfloor\frac{n}{wd}\rfloor\lfloor\frac{m}{wd}\rfloor}<br>$$<br>我们发现一个关键点：每次询问只修改 $n,m$ 而 $d,w$ 对于每次询问来说是一样的，这启发我们把几个与 $n,m$ 无关的项拿出来预处理：</p><p>$$<br>\begin{align}<br>Ans=\prod_{d=1}^{N}[fb(d)]^{\sum_{w=1}^{\lfloor\frac{N}{d}\rfloor}\mu(w)\lfloor\frac{n}{wd}\rfloor\lfloor\frac{m}{wd}\rfloor}\\<br>=\prod_{d=1}^{N}{[fb(d)]^{\sum_{w=1}^{\lfloor\frac{N}{d}\rfloor}\mu(w)}}^{\lfloor\frac{n}{wd}\rfloor\lfloor\frac{m}{wd}\rfloor}\\<br>\text{令}p=wd,\text{有}Ans<br>=\prod_{p=1}^{N}{[\prod_{d|p}fb(d)]^{\mu(\frac{p}{d})}}^{\lfloor\frac{n}{p}\rfloor\lfloor\frac{m}{p}\rfloor}\\<br>\text{令}h(p)=\prod_{d|p}fb(d)^{\mu(\frac{p}{d})},\text{有}Ans<br>=\prod_{p=1}^{N}h(p)^{\lfloor\frac{n}{p}\rfloor\lfloor\frac{m}{p}\rfloor}<br>\end{align}<br>$$</p><p>发现指数位置的 $\lfloor\frac{n}{p}\rfloor\lfloor\frac{m}{p}\rfloor$ 可以数论分块，而 $h$ 可以提前预处理出前缀积，如此，回答询问的总时间变为 $O(T\sqrt{n}\log{n})$ </p><p>下面考虑如何计算 $h$ ，由于因数不好枚举，我们改为枚举倍数：<br>$$<br>\begin{align}<br>h(p)<br>&amp;=\prod_{d|p}fb(d)^{\mu(\frac{p}{d})}\\<br>&amp;=\prod_{i=1}^{N}fb(\frac{p}{i})^{\mu(i)}\\<br>\text{变形得}h(ij)<br>&amp;=\prod_{i=1}^{N}\prod_{j=1}^{\lfloor\frac{N}{i}\rfloor}fb(j)^{\mu(i)}<br>\end{align}<br>$$<br>预处理时间为 $O(n\log{n})$ </p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000000</span>+<span class="number">5</span>,P=<span class="number">1000000000</span>+<span class="number">7</span>;</span><br><span class="line">LL pri[N],cnt,mu[N],fb[N],h[N],inv_fb[N],mul[N];</span><br><span class="line"><span class="keyword">bool</span> v[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> k/(k/x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">qpow</span><span class="params">(LL x,LL y)</span></span>&#123;</span><br><span class="line">LL res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(y)&#123;</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=(res*x)%P;</span><br><span class="line">x=(x*x)%P;</span><br><span class="line">y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pred</span><span class="params">()</span></span>&#123;</span><br><span class="line">mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i]) pri[++cnt]=i,mu[i]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;pri[j]*i&lt;N;++j)&#123;</span><br><span class="line">v[pri[j]*i]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>)&#123;</span><br><span class="line">mu[i*pri[j]]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">mu[i*pri[j]]=-mu[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fb[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">fb[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">inv_fb[<span class="number">1</span>]=<span class="number">1</span>; <span class="comment">//特殊处理</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i) fb[i]=(fb[i<span class="number">-1</span>]+fb[i<span class="number">-2</span>])%P,inv_fb[i]=<span class="built_in">qpow</span>(fb[i],P<span class="number">-2</span>); <span class="comment">//求逆元</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i) h[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!mu[i])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j*i&lt;N;++j)</span><br><span class="line">        h[j*i]=h[j*i]*(mu[i]==<span class="number">1</span>?fb[j]:inv_fb[j])%P; <span class="comment">//注意mu可能为负一</span></span><br><span class="line">    &#125;</span><br><span class="line">mul[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i) mul[i]=(mul[i<span class="number">-1</span>]*h[i])%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">get_ans</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">LL res=<span class="number">1</span>,as;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">_t</span>=<span class="built_in">min</span>(x,y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=<span class="keyword">_t</span>;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">r=<span class="built_in">min</span>(<span class="keyword">_t</span>,<span class="built_in">min</span>(<span class="built_in">g</span>(x,l),<span class="built_in">g</span>(y,l)));</span><br><span class="line">as=mul[r]*<span class="built_in">qpow</span>(mul[l<span class="number">-1</span>],P<span class="number">-2</span>)%P; <span class="comment">//前缀积得底数</span></span><br><span class="line">res=res*<span class="built_in">qpow</span>(as,<span class="number">1ll</span>*(x/l)*(y/l)%(P<span class="number">-1</span>))%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">pred</span>();</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">get_ans</span>(n,m));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="补充：变换方法"><a href="#补充：变换方法" class="headerlink" title="补充：变换方法"></a>补充：变换方法</h2><p>下面记录一些常见的变换方法：</p><ul><li><p>$$<br>gcd(i,j)==1\Leftrightarrow\sum_{d|i\wedge d|j}\mu(d)<br>$$</p></li><li><p>像例题四一样的完全展开预处理无关项</p></li><li><p>像例题二一样 $d(ij)=\sum_{x|i}\sum_{y|j}[gcd(x,y)==1]$ </p></li><li><p>改变未知数使得两个 $\sum$ 分离，预处理其中一个（也可以看作将两数积设出，继续化简）</p><p>如<a href="https://www.luogu.com.cn/problem/P2257">YY的GCD</a>，莫反后得<br>$$<br>\sum_{k\in prime}\sum_{d=1}^{\lfloor\frac{min(N,M)}{k}\rfloor}\mu(d)\lfloor\frac{N}{kd}\rfloor\lfloor\frac{M}{kd}\rfloor<br>$$<br>若直接计算，对于每个询问，最坏时间复杂度为 $O(n)$ 会TLE，可以变化如下：</p><p>$$<br>\begin{align}<br>\text{设}T<br>&amp;=kd\\<br>\text{则原式}<br>&amp;=\sum_{k\in primes}\sum_{d=1}^{\lfloor\frac{min(N,M)}{k}\rfloor}\mu(d)\lfloor\frac{N}{T}\rfloor\lfloor\frac{M}{T}\rfloor\\<br>&amp;=\sum_{T=1}^{min(N,M)}\sum_{k|T \wedge k\in prime}\mu(\frac{T}{k})\lfloor\frac{N}{T}\rfloor\lfloor\frac{M}{T}\rfloor\\<br>&amp;=\sum_{T=1}^{min(N,M)}\lfloor\frac{N}{T}\rfloor\lfloor\frac{M}{T}\rfloor\sum_{k|T\wedge k\in prime}\mu(\frac{T}{k})\\<br>\end{align}<br>$$</p><p>后面的 $\sum$ 与询问无关，可以预处理</p></li><li><p>注意卷积中的一些常用等式，如 $Id*\mu=\varphi$ ：</p><p>$$<br>\begin{align}<br>Ans<br>&amp;=\sum_{i=1}^{n}\sum_{j=1}^{n}gcd(i,j)\\<br>\text{莫反得}Ans<br>&amp;=\sum_{r=1}^{n}\lfloor\frac{n}{r}\rfloor\lfloor\frac{n}{r}\rfloor\sum_{d|r}d*\mu(\frac{r}{d})\\<br>&amp;=\sum_{r=1}^{n}\lfloor\frac{n}{r}\rfloor\lfloor\frac{n}{r}\rfloor\varphi(r)<br>\end{align}<br>$$</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;数学的恶魔&lt;/p&gt;</summary>
    
    
    
    
    <category term="数论,数学" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
    <category term="莫比乌斯反演" scheme="https://dyd-true.github.io/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>模拟退火和爬山法</title>
    <link href="https://dyd-true.github.io/2021/11/22/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E5%92%8C%E7%88%AC%E5%B1%B1%E6%B3%95/"/>
    <id>https://dyd-true.github.io/2021/11/22/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E5%92%8C%E7%88%AC%E5%B1%B1%E6%B3%95/</id>
    <published>2021-11-22T08:23:53.000Z</published>
    <updated>2021-11-24T09:22:21.146Z</updated>
    
    <content type="html"><![CDATA[<p>暴搜能过样例了！</p><span id="more"></span><h1 id="模拟退火（Simulated-Annealing）"><a href="#模拟退火（Simulated-Annealing）" class="headerlink" title="模拟退火（Simulated Annealing）"></a>模拟退火（Simulated Annealing）</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>模拟退火是一种启发式的随机暴力算法，主要用于解决最优化问题。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>温度：决定每次随机时我们随机的范围，温度越大，下一个点的随机区间越大，在模拟退火中，温度总是不断减小，一般把温度记为 $T$ ；</li><li>初始温度：最初的温度值；</li><li>终止温度：结束时的温度；</li><li>衰减方式：每次温度的变化，可以是一次（如 $T_i=T_{i-1}-c$ )，也可以是指数级（如 $T_i=T_{i-1}*c,c\in (0,1)$ )等，根据实际情况而定，但一般要保证 $T_i&lt;T_{i-1}$ ；</li><li>能量值：当前答案的“权值”，或者说“优秀程度”，能量值越小，答案越优，个人喜欢记答案 $x$ 的能量值为 $E(X)$ ；</li></ul><h2 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h2><ol><li>确定初始点（初始答案），初始温度为 $T_0$ (一般保证足够大)，终止温度 $T_e$ （一般保证足够小）,衰减方式；</li><li>在当前点（设为 $now$ ）温度范围内随机选择一个值 $np$ ，计算答案 $E(np)$ ，记 $E(np)-E(now)=\Delta E$  ；</li><li>若 $\Delta E &lt; 0$ ，说明 $np$ 比 $now$ 优，则跳转到 $np$ ;</li><li>若 $\Delta E &gt; 0$ ，则以一定的概率跳转到 $np$ ，一般来说，这个概率取成 $e^{-\frac{\Delta E}{T}}$ ，这样取的好处是 $np$ 比 $now$ 越差，我们跳转过去的概率越小 ;</li></ol><h2 id="例题一"><a href="#例题一" class="headerlink" title="例题一"></a>例题一</h2><p><a href="https://www.luogu.com.cn/problem/UVA10228">A Star not a Tree?</a></p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100</span>+<span class="number">5</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> T0=<span class="number">10000</span>+<span class="number">5</span>,TE=<span class="number">1e-4</span>,C=<span class="number">0.99</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">double</span> x,y;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inint</span><span class="params">(<span class="keyword">double</span> _x,<span class="keyword">double</span> _y)</span></span>&#123;</span><br><span class="line">x=_x;</span><br><span class="line">y=_y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line"><span class="keyword">double</span> ans=INF;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">rand_d</span><span class="params">(<span class="keyword">double</span> l,<span class="keyword">double</span> r)</span></span>&#123; <span class="comment">//随机得到一个[l,r)的浮点数 </span></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">double</span>)<span class="built_in">rand</span>()/RAND_MAX*(r-l)+l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_dist</span><span class="params">(Node x,Node y)</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> dx=x.x-y.x;</span><br><span class="line"><span class="keyword">double</span> dy=x.y-y.y;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>(dx*dx+dy*dy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">E</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) res+=<span class="built_in">get_dist</span>(x,q[i]);</span><br><span class="line">ans=<span class="built_in">min</span>(ans,res); <span class="comment">//记得更新ans</span></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simulate_anneal</span><span class="params">()</span></span>&#123;</span><br><span class="line">Node now;</span><br><span class="line">now.<span class="built_in">inint</span>(<span class="built_in">rand_d</span>(<span class="number">0</span>,T0),<span class="built_in">rand_d</span>(<span class="number">0</span>,T0));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">double</span> t=T0;t&gt;TE;t*=C)&#123;</span><br><span class="line">Node np;</span><br><span class="line">np.<span class="built_in">inint</span>(<span class="built_in">rand_d</span>(now.x-t,now.x+t),<span class="built_in">rand_d</span>(now.y-t,now.y+t));</span><br><span class="line"><span class="keyword">double</span> dt=<span class="built_in">E</span>(np)-<span class="built_in">E</span>(now);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">exp</span>(-dt/t)&gt;<span class="built_in">rand_d</span>(<span class="number">0</span>,<span class="number">1</span>)) now=np;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里exp(-dt/t)是求e的(-dt/t)次方,当dt&lt;0时,其值恒大于1,一定会跳转到np</span></span><br><span class="line"><span class="comment">当dt&gt;0时,其值恒小于1,且dt越小,其值越大,跳转的概率也就越大 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line">ans=INF;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>,&amp;q[i].x,&amp;q[i].y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;++i) <span class="built_in">simulate_anneal</span>(); <span class="comment">//多次模拟退火使答案正确的概率变大</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.0lf\n&quot;</span>,ans);</span><br><span class="line"><span class="keyword">if</span>(T!=<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题二"><a href="#例题二" class="headerlink" title="例题二"></a>例题二</h2><p>模拟退火不只能解决那些数学模型非常明显的题目，也可以解决一些其他最优化问题，只要保证答案具有“连续性”（即设 $\gamma$ 是大于 $0$ 且足够小的实数， $\forall x$ ，有 $|E(x)-E(x+ \gamma)|$ 足够小）。</p><p>看看这题<a href="https://www.luogu.com.cn/problem/P4044">保龄球</a></p><p>对于这种给数列 $A$ ，求 $A$ 的某种最优排列的问题，我们可以思考如何使用模拟退火：</p><ol><li>温度可以直接像上题一样设置，衰减也可以自设；</li><li>初始点（初始排列）就用题目给的原排列，每次转移时在原排列上随机两个位置交换，得到下一个排列；</li><li>依题意打估价函数 $E(x)$ ，估价并概率转移；</li></ol><p>由上，我们发现本题可以轻松用退火解决。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">50</span>+<span class="number">5</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> T0=<span class="number">1e4</span>+<span class="number">5</span>,TE=<span class="number">1e-4</span>,C=<span class="number">0.99</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> ans=-INF;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Try</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">&#125;q[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">E</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">res+=q[i].x+q[i].y;</span><br><span class="line"><span class="keyword">if</span>(i&lt;=n)&#123;</span><br><span class="line"><span class="keyword">if</span>(q[i].x==<span class="number">10</span>) res+=q[i+<span class="number">1</span>].x+q[i+<span class="number">1</span>].y;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(q[i].x+q[i].y==<span class="number">10</span>) res+=q[i+<span class="number">1</span>].x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans=<span class="built_in">max</span>(ans,res);</span><br><span class="line"><span class="keyword">return</span> -res;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&quot;优&quot;的答案,能量反而低</span></span><br><span class="line"><span class="comment">当然也可以返回res,在simulate_anneal里使dt=x-y </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simulate_anneal</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">double</span> t=T0;t&gt;TE;t*=C)&#123;</span><br><span class="line"><span class="keyword">int</span> a=<span class="built_in">rand</span>()%m+<span class="number">1</span>,b=<span class="built_in">rand</span>()%m+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> now=<span class="built_in">E</span>();</span><br><span class="line"><span class="built_in">swap</span>(q[a],q[b]);</span><br><span class="line"><span class="keyword">if</span>(n+(q[n].x==<span class="number">10</span>)==m)&#123;</span><br><span class="line"><span class="keyword">int</span> np=<span class="built_in">E</span>();</span><br><span class="line"><span class="keyword">int</span> dt=np-now;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">exp</span>(-dt/t)&lt;(<span class="keyword">double</span>)<span class="built_in">rand</span>()/RAND_MAX) <span class="built_in">swap</span>(q[a],q[b]);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里用小于号,代表若不跳转至np,就把a、b复原</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">swap</span>(q[a],q[b]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;q[i].x,&amp;q[i].y);</span><br><span class="line"><span class="keyword">if</span>(q[n].x==<span class="number">10</span>) m=n+<span class="number">1</span>,<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;q[m].x,&amp;q[m].y);</span><br><span class="line"><span class="keyword">else</span> m=n;</span><br><span class="line"><span class="keyword">while</span>((<span class="keyword">double</span>)<span class="built_in">clock</span>()/CLOCKS_PER_SEC&lt;<span class="number">0.8</span>) <span class="built_in">simulate_anneal</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题三"><a href="#例题三" class="headerlink" title="例题三"></a>例题三</h2><p>一道类似于上题的排列退火，但加入一定的优化</p><p><a href="https://www.luogu.com.cn/problem/P2503">均分数据</a></p><p>这道题直接模拟退火也能过，但略显的有点过于暴力，我们可以考虑模拟退火加一点贪心（当然也可以加DP，但那样还不如直接用DP，<del>我就是做不出DP才模拟退火的好吧</del>）：</p><p>先用退火得到数列的排列，计算当前答案时，对于当前数 $a_i$ ,我们每次都将 $a_i$ 放到当前和最小的集合中，贪心计算。可以证明，<del>虽然我不会证</del>，这样贪心是不会漏掉最优解的。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">20</span>+<span class="number">5</span>,M=<span class="number">10</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> T0=<span class="number">1e4</span>+<span class="number">5</span>,TE=<span class="number">1e-6</span>,C=<span class="number">0.99</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> w[N],s[M];</span><br><span class="line"><span class="keyword">double</span> ans=INF;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">E</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) s[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,k=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j) <span class="keyword">if</span>(s[j]&lt;s[k]) k=j;</span><br><span class="line">s[k]+=w[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> avg=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) avg+=(<span class="keyword">double</span>)s[i]/m;</span><br><span class="line"><span class="keyword">double</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) res+=(s[i]-avg)*(s[i]-avg);</span><br><span class="line">res=<span class="built_in">sqrt</span>(res/m);</span><br><span class="line">ans=<span class="built_in">min</span>(ans,res);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simulate_anneal</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">random_shuffle</span>(w+<span class="number">1</span>,w+<span class="number">1</span>+n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">double</span> t=T0;t&gt;TE;t*=C)&#123;</span><br><span class="line"><span class="keyword">int</span> a=<span class="built_in">rand</span>()%n+<span class="number">1</span>,b=<span class="built_in">rand</span>()%n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> x=<span class="built_in">E</span>();</span><br><span class="line"><span class="built_in">swap</span>(w[a],w[b]);</span><br><span class="line"><span class="keyword">double</span> y=<span class="built_in">E</span>();</span><br><span class="line"><span class="keyword">double</span> dt=y-x;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">exp</span>(-dt/t)&lt;(<span class="keyword">double</span>)<span class="built_in">rand</span>()/RAND_MAX) <span class="built_in">swap</span>(w[a],w[b]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line"><span class="keyword">while</span>((<span class="keyword">double</span>)<span class="built_in">clock</span>()/CLOCKS_PER_SEC&lt;<span class="number">0.8</span>) <span class="built_in">simulate_anneal</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上两个题都用了 $while((double)clock()/CLOCKS_PER_SEC&lt;0.8)$ 来控制退火次数，在实际做题时，一般计算好循环次数的代码会更稳定一些，但如果不好估算循环次数，这样也不失为一种选择。</p><h1 id="爬山法"><a href="#爬山法" class="headerlink" title="爬山法"></a>爬山法</h1><p>对于一个凸函数（单峰函数），我们可以用爬山法解决（当然，和退火一样，不是要求题目有明确的函数模型，只是需要答案对于每一维自变量你能感觉到一个单峰函数即可，<del>有点玄学</del>）。</p><p>爬山法的思路大体如图：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/v5q77sd9.png" alt="爬山"></p><p>对于点 $now$ 我们并不关心它对应的具体值是多少，我们只关心它去向答案的“方向”（如图中应该是蓝色箭头方向），然后我们只需要向着“方向”走即可，图中是一个维度，而多个维度就分每个维度单独计算“方向”即可。当然，走的“距离”视具体情况而定。</p><p>需要注意的是，爬山法局限较多，不太常用，但仍不失为一种很好的启发式算法。</p><h2 id="例题一-1"><a href="#例题一-1" class="headerlink" title="例题一"></a>例题一</h2><p><a href="https://www.luogu.com.cn/problem/P4035">球形空间产生器</a></p><p>本题正解是高斯消元，建立方程联立求解即可，但如果你和我一样高斯消元和矩阵学的不好，也可以用爬山法搞定。</p><p>我们发现对于 $n$ 维坐标的每一维，都是一个单峰函数（球心到各点距离相等），所以对于一个可能答案的一维，求它到各点的距离的平均值，距离大于平均值的点表现出拉力，反之为推力，将所有力合成即可。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">20</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> d[N][N];</span><br><span class="line"><span class="keyword">double</span> ans[N],dis[N],delta[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> avg=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;++i)&#123;</span><br><span class="line">dis[i]=delta[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">dis[i]+=(d[i][j]-ans[j])*(d[i][j]-ans[j]);</span><br><span class="line">dis[i]=<span class="built_in">sqrt</span>(dis[i]);</span><br><span class="line">avg+=dis[i]/(n+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;++j)</span><br><span class="line">delta[j]+=(dis[i]-avg)*(d[i][j]-ans[j])/avg;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;d[i][j]);</span><br><span class="line">ans[j]+=d[i][j]/(n+<span class="number">1</span>); <span class="comment">//先将初始答案定为重心 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">double</span> t=<span class="number">1e4</span>;t&gt;<span class="number">1e-6</span>;t*=<span class="number">0.99997</span>)&#123;</span><br><span class="line"><span class="built_in">calc</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) ans[i]+=delta[i]*t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%.3lf &quot;</span>,ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，此题用模拟退火也行，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10</span>+<span class="number">5</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> T0=<span class="number">1e4</span>+<span class="number">5</span>,TE=<span class="number">1e-6</span>,C=<span class="number">0.99995</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">double</span> x[N];</span><br><span class="line">Node <span class="keyword">operator</span>+(<span class="keyword">const</span> Node &amp;<span class="keyword">_t</span>) &#123;</span><br><span class="line">    Node res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) res.x[i]=x[i]+<span class="keyword">_t</span>.x[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;q[N],ans;</span><br><span class="line"><span class="keyword">double</span> as=INF;</span><br><span class="line"><span class="keyword">double</span> s[N];</span><br><span class="line">Node now,np;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">rand_d</span><span class="params">(<span class="keyword">double</span> l,<span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">double</span>)<span class="built_in">rand</span>()/RAND_MAX*(r-l)+l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_dist</span><span class="params">(Node x,Node y)</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) res+=(x.x[i]-y.x[i])*(x.x[i]-y.x[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>(res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">E</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> avg=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;++i)&#123;</span><br><span class="line">s[i]=<span class="built_in">get_dist</span>(x,q[i]);</span><br><span class="line">avg+=s[i];</span><br><span class="line">&#125;</span><br><span class="line">avg=avg/(n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">double</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;++i) res+=(s[i]-avg)*(s[i]-avg);</span><br><span class="line">res*=avg;</span><br><span class="line"><span class="keyword">if</span>(res&lt;as)&#123;</span><br><span class="line">as=res;</span><br><span class="line">ans=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simulate_anneal</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;++i) now=now+q[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) now.x[i]=now.x[i]/(n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">double</span> t=T0;t&gt;TE;t*=C)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) np.x[i]=now.x[i]+<span class="built_in">rand_d</span>(-t,t);</span><br><span class="line"><span class="keyword">double</span> dt=<span class="built_in">E</span>(np)-<span class="built_in">E</span>(now);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">exp</span>(-dt/t)&gt;<span class="built_in">rand_d</span>(<span class="number">0</span>,<span class="number">1</span>)) now=np;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;q[i].x[j]);</span><br><span class="line"><span class="built_in">simulate_anneal</span>(); </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">时间有限,且答案对C要求较高,我们只退火一次,</span></span><br><span class="line"><span class="comment">对应的,C调高</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%.3lf &quot;</span>,ans.x[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h2><p>对于维度少的单峰函数，除了用三分法求最值外，也可用牛顿迭代法（又名牛顿爬山法）</p><p>牛顿迭代法的核心公式是<br>$$<br>x_{i+1}=x_i-\frac{f(x_i)}{f’(x_i)}<br>$$<br>但牛顿迭代法有一个巨大的缺陷——我这么弱根本求不出导函数来，<del>笑死</del>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;暴搜能过样例了！&lt;/p&gt;</summary>
    
    
    
    
    <category term="暴力" scheme="https://dyd-true.github.io/tags/%E6%9A%B4%E5%8A%9B/"/>
    
    <category term="模拟退火" scheme="https://dyd-true.github.io/tags/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/"/>
    
    <category term="爬山法" scheme="https://dyd-true.github.io/tags/%E7%88%AC%E5%B1%B1%E6%B3%95/"/>
    
    <category term="随机数" scheme="https://dyd-true.github.io/tags/%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    
  </entry>
  
</feed>
