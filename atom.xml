<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dyd&#39;s Blog</title>
  
  <subtitle>He who has a strong enough why can bear almost any how.</subtitle>
  <link href="https://dyd-true.github.io/atom.xml" rel="self"/>
  
  <link href="https://dyd-true.github.io/"/>
  <updated>2022-06-15T06:46:21.289Z</updated>
  <id>https://dyd-true.github.io/</id>
  
  <author>
    <name>Dyd</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>luoguP7915 [CSP-S 2021] 回文</title>
    <link href="https://dyd-true.github.io/2022/06/15/luoguP7915-CSP-S-2021-%E5%9B%9E%E6%96%87/"/>
    <id>https://dyd-true.github.io/2022/06/15/luoguP7915-CSP-S-2021-%E5%9B%9E%E6%96%87/</id>
    <published>2022-06-15T03:58:30.000Z</published>
    <updated>2022-06-15T06:46:21.289Z</updated>
    
    <content type="html"><![CDATA[<p> 一直死想 dp ，结果是分讨 + 贪心</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P7915">回文</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>拿到感觉是 dp ，然后尝试把 $a$ 或者 $b$ 的状态压缩表示出来，一直没法，以为是自己没有找出关键信息，然后一瞟题解，第一句话：把第一步取 $L$ 和第一步取 $R$ 分类讨论……马上就开始打贪心</p><p>发现就是给 $a$ 分配一个单峰的下标，且保证对于 $a_i = a_j$ ， $i$ 的下标和 $j$ 的下标和为 $2n + 1$ ；那么当第一个取的确定了后，这个峰（最大值）就定了，用两个指针维护从小到大，两个指针维护从大到小，贪心尽可能取 $L$ 即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N &lt;&lt; <span class="number">1</span>], b[N], c[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">char</span> ans[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> bl, <span class="keyword">int</span> br)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; bl &amp;&amp; c[l] == bl)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[i] = <span class="string">&#x27;L&#x27;</span>, ans[(n &lt;&lt; <span class="number">1</span>) - i + <span class="number">1</span>] = <span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">            ++l, --bl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l &lt; br &amp;&amp; c[l] == br)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[i] = <span class="string">&#x27;L&#x27;</span>, ans[(n &lt;&lt; <span class="number">1</span>) - i + <span class="number">1</span>] = <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">            ++l, ++br;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (r &gt; bl &amp;&amp; c[r] == bl)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[i] = <span class="string">&#x27;R&#x27;</span>, ans[(n &lt;&lt; <span class="number">1</span>) - i + <span class="number">1</span>] = <span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">            --r, --bl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (r &gt; br &amp;&amp; c[r] == br)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[i] = <span class="string">&#x27;R&#x27;</span>, ans[(n &lt;&lt; <span class="number">1</span>) - i + <span class="number">1</span>] = <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">            --r, ++br;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (n &lt;&lt; <span class="number">1</span>); ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]), b[a[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (n &lt;&lt; <span class="number">1</span>); ++i) <span class="keyword">if</span> (b[a[i]] != i)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i] = b[a[i]];</span><br><span class="line">        c[b[a[i]]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[<span class="number">1</span>] = <span class="string">&#x27;L&#x27;</span>, ans[n &lt;&lt; <span class="number">1</span>] = <span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">work</span>(<span class="number">2</span>, n &lt;&lt; <span class="number">1</span>, c[<span class="number">1</span>] - <span class="number">1</span>, c[<span class="number">1</span>] + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    ans[<span class="number">1</span>] = <span class="string">&#x27;R&#x27;</span>, ans[n &lt;&lt; <span class="number">1</span>] = <span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">work</span>(<span class="number">1</span>, (n &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>, c[n &lt;&lt; <span class="number">1</span>] - <span class="number">1</span>, c[n &lt;&lt; <span class="number">1</span>] + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">solve</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ans[(n &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="built_in">puts</span>(ans + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 一直死想 dp ，结果是分讨 + 贪心&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="贪心" scheme="https://dyd-true.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
  </entry>
  
  <entry>
    <title>test2022/6/15总结</title>
    <link href="https://dyd-true.github.io/2022/06/15/test2022-6-15%E6%80%BB%E7%BB%93/"/>
    <id>https://dyd-true.github.io/2022/06/15/test2022-6-15%E6%80%BB%E7%BB%93/</id>
    <published>2022-06-15T03:40:47.000Z</published>
    <updated>2022-06-16T02:25:33.523Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="03b7e350a9b109c5453c346f26c37e0eed8f71f1e01a660763077ded0e1a596a">91be494885fcda4e29aacd3585d6ad0fa92a35d5ec39bdf587486ec49af4f721cbe1bbb18908537e1e676cda9e49ea25e317e9e254d9960d4c50494b14c17c35acc804d87ec86e24bc98e41b8244b150afbdc29f3060a8b0b3007ad499c5cc7a219d8c3a4a2b902971d0fbd1aa1f36b973f79ce611c291e8dd2228dc1a33b443fbad65782269ca49aa658b35887af024ddb1f847eb1bb7bad570582d61a440dd383f9eab8e5eda33f8fb8146c9119f8923640e23f6942ab315291c36df9b853cd89faf6089d630fc754a6d520fb1d7c4567ecaf9fe6d10e1c84fb1a0c666899f9377f212055e9ab6d214a63a979bcdc105b0c90162a3fcca7a4b5ccb1c407c0ebc2f8457ab63eb3ce0ccac4459b04d8d1f5eb8ef71e9faa0cca671f83ce49b7fe2b0224eb56a3bdc209f4d219669ee90ada6975bd5770f6b743c2fe05108158950fb343686891b1b6f1e76cfb2bfcd1afd3e8896dcc214055f149688ebcb8e4bababcf70761fbe715f584dcb738f745f734d9f21f65b62b665bd511479d9a821b6e8354feeb81101ed5c3a9e01ecab6224c71ea2d69c9360d317d5d213967d74917f322717b2e1b004e3a3819c82e15473c04f4a4273ccb3562310b0c33f0b3603fcc28bcf6c5104e584ae999ce420e1ff78d35b05eb0dc6dbe502db55e0ba3cfbd8eb3843e7022709547d5df15c0a3350a7de4735038d4f2ed35482d10f333c57d66ac9c7180a7fc83e51910ec0a9096e6569249f638e3e82ca488288edd577af150098ff65e37ee20b5fd692a08736e43b7c81acd121c6db206beb76d6181af33e0c86cc1698dfb930c33d74cba6931309f40ff109c07411930da5f3cc9cd675d5701af090a1fc26356462f2509c49d52cd7c3cdec67220de747dd41c9fcda08158b4020cd36ff6bf80959f27f3c83195ad32c85d8e240358e4654c27082b22375a0833ca37136f49461ed8159003895303a2c071db6e11bf93b3a898c153ad3dc9e3a13d780f8a1925f92b9e3e5bd7275d23e724c31f371f300577ced485e80c1e684b1cc7142ab38886919c58730c0e0d3e9f92c5e08df036dbc7bd214aa6373cf25737c8cf23c1c29c7dd319d832d09d9bcd9ac0191e024b4affa8503de999f6d836ddfb82304c6a8877d05d318f3c5c6ee7e62f489c6f97d0a7549b013f4b8a0eb407db6654564b95e6d0826dbd7745763738d9c73ad7c691568d25996097da2eaf6783562399acbc2118ac78bc7c26be2d792a9e9d7ba2962d25b4b5d877a153701ff58276b9768b51e8f19e1144645323801693bf4ea63f41b1e2c4b8d88d473a475614ac8ff0bd0afc5836d2931eeef0cd851ff42a08b935b63b0edb97c263899a41b66ed18a9949559528dfcbf7497e2019bbfeb6beac0a83d2e65aab0dba579ca9a9eed02d4540581fc67d7f42f48786dfe3950eb655585bb1d9e82fac5fbb7b617d93a5f78f07d86e9fde8502d1698af2cd7a02f4b3a1ff2b511e8f8b34777cb04c8b29b6e89c4629a7a9becfbfdaa6ea60b22151a8b25958304ee12fbbd3653812e10c868ed80c4b15864546da564eea33b955889db62abbfba595c8fc7b7f506510c1a7c56e19a0e51418192420136c5c2f6ad819f4187592fb153b977e2a71de87306aa0f923c155c7687850b7ee77955a6a43bcd2398bdfd8056080b4660d375796d8aea13ae9ec00dddd1e5b0c25b9f5d071ea403ddff80f30abffd5eec79c21d1b0ce09d2265b40b1507b0a8cdf4f2eae297b76ef6e6455e4e622c90b7b09314fd6685ddb63d7daf9a1f16d3422fc7d97ffa3a97a5e0382fbcc6d34fda826f7b512509cbb280972aad5daac16ecbd94e79220d2d093ae4360ef32311a28a6b2eead98f66ac92475b06d37094aa3e065258769b6e6e7e9f8d08663249762a4c6d594fe68582722b25e234874f0ad8d890c54bb102c46e1c66ba7287340153bfe4270ffde96bb48d8032cb4badcfcb780441bcf4979dd0a1b41f082599a08414ec5932527b874121faa450f7bb05795ac90550d4742a2e477a2fa7d5783fafa0f9ea7a8dce410f635a35eac50386abc664c299cf07680767c5fdc84a699db3ddaf66e9ca8e7e03af3f94b328a4393cb05e1ce3bb64cac83d4a274924d80fa1abf8a328bb82620b55e8fc9d4361da4cbd19de3fab42fac1305e49f7ea50ea7fef10eefefe387028a3a953d610cf1ab355f98a53e1a5c9d91a32d80a01d827ef7936860c3ff817317e386328f595d61bf4cf20f0123bc26dd69d32370a0dea5770fe1fb24dc703b9c3df8b253f132ce84b9f360ddee5a5128a39c3b28929ef8f18d265782dbc3bad26fa5b96808f0737136e11f397973711a1b5269234cc37cf1587565e8b19048b28ac6295f5668eef33eb6e22adea36693fbf204bd88c19619a26fb84e69dc53533c75a46bf274e85d9bbaf6e0a224915909e7caa6fb335cbb7a37e83d505f165ccaff84ec15b8c93e8fdf14b5051c21d086ee18f17d4b628e41a9d80ab641517ddcc717a645bddc4d2dbc014ae9664e41207f318543e091b39cdca8b43f933a265761620115185853c4bcc44eb2a196d70220ced0c33485d9f9c1798026c6e271737b2d6b0fcf7725e62a4b765c3fbcc7eda19e24e72a30b39fdcc038a3b9efaef130f569581b6ab7dcfd24f218879d7da875822f6d84e25ca3ef6c0fd74dde05ec0c730848767a46ea905991c25f6c8e43c7a431308a8e3b0a0673fc12a4a49456ef9387697c72f8e3a8baf330cd55d53b0c4025ad55ddd25222b6465897a0d58ecdfeaa8b607f62a9c8077ab06e3d37a3c511a9da635b2b6386f7b894f6306be272607996abd078fd9d9eafc4f1a1cb15b07c4b1c63a5039a415eb216952c828bb092846024c5d0a07968019305d48be7531749b266813399d6c132b5db4c066159d2f018c85536e756f6670d5ee4df6f04568e35b42c1134af7c6d550444e8eb4334097f5759eaf2f33bb9e62cf5fb0a8de7f1fcdfa33f64bdf7fa6b0d9807bb32e66d99b7612f361373f1b985402b70b420c49fe9325a6f38f1181283fdf6f2e8d954458b3d6c9099171836b6fd342c2b1f6a4db9a036b4e0a5eb4a44c501186019fe13ebf55e94cce667ffffa959f4a94ef5f8483766585ac672c6f3bf01772602e58580526cfde33e07b580bfe641218a019d7371a0bc45c6ce72786f6623b31c2ff78c8bec05cccd052d936aa77c782ae36a53f487df949ccb8e45467747b732fab5579c089d9c1b7af5db5d9e068591aac4ce37967a2a98b9741904be4cdbf5251b36c0bbc2ad09e621aef35c8e04b5e950790f54dc492fd2b094257ff06f9658ce276adcb125816b44c31e43bbf82745a2e4c5d6030718c069aa63de32bff90b816de320e1cc8f0f7c03e8e545d428c7d5f113b297b00ea2e6bf580b9f8f1e1aaf59fabb5937e8d92b005aa4edddd89bf648be08d7361219cf4e05b6d7cce92ed551591a316a9bedccfa6a20c9d0f194ef9aa4f6f009b7917a8886ad0a44b4308ef34d10b3d5457c961294712824711553d9b8a3dd719d0c3db653490e2dd02cf2194df3c41a547b9cfa906ea0efd7af1c95b4544731883321d94a65d438a837def890baedd53a88a6db8562cdeee80a410a33ddfffee285b2a515961831494783a09042a778e8822d4ff48edf03e3d527a9adaf657873671f8de6403afcefd8ff3b2783d1b92f71799dd1e932ec3f314dbaaea0d45094ac1f7332c9f5ee0f6742e4ed4783ca391bee421359bdadec3f71d84412cb9eb5655788f0c43e9aa30186afd6b4b8369476d7b5f5863a069acc8064f2fac5773d26c30027c048e28164453b3995fba43936211169a208188c0819153430fa61ef1f0910fbc6d11162966718419bf7759bd03ef0596dfbfc248618e9571c2210f15152d0f7e407076d81b336fc3438002cf44b62a0c34f9f195c3856b934295ba160c1918e23693ae945169cf5ee8ba2a9d7c7eff0e9d7fdf26ab3d87c4e5d817e31bff7a13f68aaf3f5a826b23ec3128ebafb705d430a790456f993def6e12d00902b3e3425661385fa0b6fd61060d7cc344abc1a2615e6cb988c8cea8225124fa9e986e5a9f5fb53793c972093afb9a035c94496baf23a45d3ec8a2d4cfcf63e905b4824b885f4e9e7d21ebf2aacf6f4f1ef62ce642be2ac2d53cc5843b22c1ba1b677d36df1d9483704dd5755d691e8d62fbe077921bb0393ad15f2ce0ae71a1ec3b24835a4777b3cec17c5e132ac2b25d4c26a4ca79996002cc08c8b4ae1346881e551f1c215057cff4f5826345eecb86bd9fb6b01dac33c1bf111ccf0f2c47add13daf0e3d2185df394615d3e9dc7eb44dc05c55416085932493ea2bcd671015fc4e0e1879f8b99a843204e5fcc347e4bed81ec35cde63de4db2f0ca5d24794e37d5db6ae1f0b5ed6823909c8cec0a01185faded140936f032901e230d003af739ed063b97abd53a9b4d98bfd61c213fe3b713748f6ef0d15794508ab4060e31610a7aeaf3f3b1dbd8d0d40213b267015861174759d86f483544730447220241e8219720d9120d96f2be14e04e609345ceb0c96e61ae17f62772420eddc471adaddc9409a3d03755d9d0df6d5c807aed6170705b7596e05280523e278bbaff514ad5b73f1c0dfadac445f14aa51a8185a8382791fcbed8dc712f15b56f8622aa3af8fbd354b20bdda8e3629cbc114e788b428d2a7d556f8fd20030e246c99b0bc410af88a9664ea865a457260edd0b628bf7b82f588a0af58dfaaaca3cb2b44b4445874ddb9183b4edb5a4240e0a6985872190adad0c9583d87c7c65a59be293d98898c6697c360cc22613e924dd65469ca91cd840ae713a5eb0520075ca92aa50a36a280fefef491a10f4d7bb048c6e465ea78b756201d6b0fdcefc3131c9957847d1a3b2f6d5727adde655444ec1ef7fbb738271cee442895396ce64621a2177b4a3a376d568907101086630db8e008b5922da091d181ec2cdb26385091378422184da9ebe2128f311eeaff6b5e9dad302e66eb4e6d3efd4501b7277a4bc840877b40af5f5e78643d62c1bcce3bc9e2c4d457fe47138e6da573af1e729db0d592128a5d45e3e9d89de075f7c670483641df5241e4f965c2b36458c560413c2b07a8070bdf03fa1616eba1ce6864210e481373a91b4316e91c96e28e112596f24751ca6d897336e31487ae98fcef5d2f45fe90edf163aa7df0efc2f552755aa979b6677b946f68381706a48011d84c4471d5eee9bdcadc889566d611d967b72ec344529a85b87c388e05b6109a9594600035be1b7a4a6e7e47fbc32cbf8bd39bea63ae5ad78d39632e784dd2d5f3fa4d3714f4e24f8ad112c1baeac14afafd79ff9dbd355c24ea37ab015f6d4062fbbe665a2aa301901a69e630abf7f95a99b9e5d5f2ae832dbeaea88dcb8e6ae506c4423924198ae7fe8c7be6d3cc61bbe608a56b6a50e55942de82940d48addd0102b1cfc84fe18fb5483b6fce736cc16c1ab3254174c3ac0d96b47b500d95abd3c9b6f7abc79ab995b9156d094bab39177f8befd9e585b9562e197bb2a1419a80e7e4818b45670695e964fced64902c2f6b387f0156ca6a35be90264d38ab3908942ba9f4e25d7177e1c3de8324683d0311025243957e1a75255bee2c5da78853607fe15cf3681f6fa78a65a35e34f526704dd31bb9b976b1b6f8b859292942aae43105923f0ee47cd1d7ad1cb67aa0d9bed5447396f38ca8e3efea9469fc1b2e1dc8a07cb9c6c5c4bc4d449bd4aeff97c1ebff92b18c8e4026ef583f436caf29f9101b2b72272bdbb828b9b41912fb85af3a304870872169ef62c38f1581ecae71e9d6745343eccce4f33ff68f843e97fb4ee3075d1d4c309b18f036537988eb59eac314f6e8ac1cc781485e26563735d63c6f300f1f7337154a18ebd35a8e41a884830de18d90f7e1ba864fc07ec62ddd3db02135d62b9aee1884a352666850041f99908bc6e4536d918aa3e18d3fc01e7e6a9044e25f417d724e4475238e77e10c7c78817902f1d54ec47dff6b3a960613bbc2536b459a66c24a6431287bcd990dbcaa5261ca89413225f129265038050823a92e8b491d8c390457ec0fd333d3670394af4bf57e63f847ecc31f9ac8b0c83d6f7521daf056980941560fc346b6f6de2bb1c6d5385551f3e0f9612d047cd89bc1b97d520148ba8a8634680705300f41a6ee5069d582b264ad7c036441d66d13984579c6faee96db0de7bd833a6224dfce09517858325ea74a49c729c7e565ff097ad20e9400485816a2796ad082177cf57778211c84feb89b931cf310dbe2b1aa4094942418d0cc5d5eee0ea22f5ce753652967a4e41816856efe9a1926230bb3e4e9a3b3867b8f382a9a318c5cabebec169a778ce36a7c6e301ecc8307c48ad2cdef5c20f32d4bda1c732f49a65b04a5d5c223a774deb7f07d1c996d2e668e461a7a64ec864c363ca03187941d8d55f2f3c09802f2b244212bb65d02ce9150e4f7a02db737024d7e7c007b878cbea46035962e5db267a2f8697bea81d5335276047bffc0a1317d6474ce4b9a90a389ac050d6ce632ee0becc5611ceb65a79e83f282950376096be6e0f3c1071a22e2fc2524c6142b3519533b4a6c9bba955e297651499f98c4627801c39656cdbfa110b95d16df7a61ba606981f7d46622622032b6cc02f567978c3c39024a0f1e1eb4afc1ba99103c14fd142ee41ef550f6b6f3c2d597e6d3de2baa57d428ac9637c4321bfa4fafdb236b994b0d20cb1d9bcbe2c468214b00fb9908beb9c20296f3ba6bc56df909588fa4159647a34e5d7117bfb40d1f0da3f7cbf43e266c583cd76d31038bf97190d4f7e2d5d088d0db825a2b6ce9c22770c68566445d08b38c72e41a1021849daa23ed15e646b56858727a345e30bcb33975bef2f6de990d550c74caaa54e4ac0c1eeef4a6e0c3a5a0477904e07d90d9b2dc77b264f3daf032d8d673c4b069ac1fcce9c223926698ae7e69ebbef326afc48a45146fd544ec3ba02cd410798b5b8692558f4bcc7f50beebd11419765b1d0a2f44b52d0e33ef86e47623389e7b824e33ebdd71b0a3e26c2dab834e2b44be919a4c975b9d82d516aa1dde8f3f832a91c8ac7491d202ab91460d461428588143902ea714d771861301ba9d761f94162367cffc277e12f0b98d280de314907cbadca8389ecd0bd135ab19cba0b6f34610f2fa0b7a363e16da094d3b1befc112f7d23d93fca2506d93ecd6feab0f4163cbddfe65201cf32281ce9484479e1a8db41d6d990876bc083dad109f4b4bdc94d9ef879bde2150604c10b73fde5778ca5c991c539e9d134798330fffcb70ff3390c53b69070624e20fe65c5757c8c07018eb01523868bba2ea58928085b1b1e7222ed21d623f968cff3474c2aaac2d8160eb78adab916a6e17fce21d18441029798dcfd8ca2067147cbc6bd463d55208f6d25f05c179f309494077a99267ce37663f5b69014c22e2b5173dd30a179fcb6dd647514e32595b7e359eb794c00eafd6f93f0b32f709ac820e0dea3da7c7ccb5aa354ac34c6dea9d3f5403feebcf7aa2f6e3ce5b132db42d63740c841105d6ab5780e74577e134757806fc76db243669a063db725cb2854e8e3289d7d66761b9908027f2ce4adf34f87746796347c79432111bf2fe8e43b0685c5ee43b34d32d70776e016bbb5e118e10c3be0c6ea0289b796af3ee870fb9557ade2124f7cc92cd464229f0817e35c63bc4bab49086ece7edb64d7c0c2b3a64503f3b28160794a3c9fae47bae3134f4b4c9ea17d9a3513ae6b98cec86c8a98930b34dddc5c5567889f6d0e7d5f9a221ab36206414eba4ab5e6fe324202f12cb39fd2bec60cd459c89b14ac5fbf84af94ffb0ebf7a7090a71e8185e436ba91c879a36e2636f58eabe817b5077094f3dfbc5ce1c76e7d9e4a016e9b46b9b10f32e9666213efc92601492464219575431923a195638c49330061c2ddc9369d2a6a57c92f07cc167af7fce0e86dce52593d7e82694d03e285ce591589c677aa7934d5121fedf5b5fec2832ca114fc02cd128cc18e2916fbe6529ea23cde86319801924009f8458383d9d76e67e1d328cfca48e028654d191eacda9f0a199af320fad8735e91276f41e793379e98c66e95be8368fc025c626c57a13c0899eb6e037defd8e39cc126ace03b0a76e1e001fcd353797c0376432a0cac6403d389a411d4a0924b1065e2ccdeb81ab13748ea347b6c13ce8db522272c85162fadaf6212b01a1d85e089e3cf6060382bd69b4b0470a3bfd6cb7fee2ec063149819b003dfc78d53a6ed38bcb3da861494ca22f7b59bbbab281172786f5eab436fb1f1edab1dacf9b4c9a7487a760c6c907f63d3c94bac74daf3aab8795ffd2c43889c7223ea21645f40cc44b2325051838a83b93b4bc2c4cc8099fb8e2bf3e5d28ea9db18c5a9eaa78a2ab9c73ca5e4d61883814a38fe0b886b52986fbc08828caa398b359eb516c0d2e2852971a94d1c59b35246dd569b8fd197a2024fe5cd238b4e0176a0572751f0f3457eddff68c40d7c3da765298bffbe7fb56e8e24b8af479c00563b4a96d7a417ca80f9e898407d3fa70bd2ee4252129bf1f55450b1c4c7964dc2b7494985292ee1b29a3b38dbad09103a4838d83455a9176c8640bdb08bc82245ce298a07fd10ccc1427be2f3a456cdd4f8d4169aee90212947d598a674551ab2b7e7ce6a3a14a27a0348c08893efe4b34f95fe1dff20bd198238362337efb5097ca8d5c0fed4a6938ab83510bac73599e97fc29eeb34050736fe2e74c4b9fa42bc8b78458414b17503d9ab2f39cdeb92066d961381d9eb6296a06088494188edebe1d96fedd2e084125f7aa0ac7032d59f23af05404d400ebf2ccad282e3424b3214859f1ee1ace5980bdf41646bbb04b1881efb5215b8d04e71237c2f3cd8c8b3f479298d3575b9a32583e4c9cd0b33c98979dc136f54016cb3aded64fe0f3ec1c320b8f5e300ee511067b407b85d5e1cab0409149a97b617d5979e1027a350aa52ac935e7d50f3402aed0ca317fa4ad8bdea4a7c7a19de2dd668bc9c51f4f4afe5233ff4cfe9b50d25e0ffad62b281296bbe4ca44ddae230fc8ff2faccb3bb05f8ebd5d7765123e164b1fefa70f3fb10a41505529ce0d4857d0c367def68acba2ec1298a4ddd14a7d5f236f227bc250b4b68cf2ecc7742588739444a4459db3681e38f51633a2f42f30b8add378a7607a43d4146c958d78955d64b973fe19fda1004f444ed98e5efdae7f43d35c517b18aada86534a812a8898d7630cc64ad93eab3e2dc9acdb1305aa033d4d8ff0ba524d4cfa5a9fdef526711f06df69b2b52ba43b297b314ad3b855f381222986f473fe8c626842aa6955edd4c9fcb69d58db5d91f9213b526318b03f11c8fd57558aaecbf5712a0a7cf422095f41c3be17884608104ba6e68df741d957cd378293acea4e9b0044075cf25f5567df566363f44796c00477d754473db53104a477c2d422dc96425443b308e4b2ee80e875c046c83e0c5d8eaee6b24603bfc9fbd0c178d86814601467ceae0ea8eb06c8c3cee8a61fb6c36d4de0d15524ea1e40689b68a6b83de905e2bb5ef161fbd749487a10a350b06d5d3af8e165f2e4bf92d293c174b6e2f7118c04c748e6882c338d607f70296b712b6c557f5a9467ab504034e773eeb57da0d380809ba714599b20742b42116ea4a189cb208f95d121b584fc5ac7ec3d39c4c06d4a9dac24a0e8d0feabfa8de375ec7ee6a7691ef4602b484a2cfcab8da6b25cd758445196f935ec03c3660d519f86fa32fdc87d95a31cff8688799632c752ca05d1f2557fb714f28badd8810b8987792ec732b29f69265531d630d720709273f1ed6dd081b19aaeba8c29bacd861a2d65b63254d57a754d6978bf816ff459b40718f9b03beeea93f4648005b5502828af288de54854268de0a1f8c81f94bc93521a5f10d11dd3e94135558bfaf9589f8cb5c43c7a289f0d6b52f0dee157bff349ef7faa42a5acd9bac48e80a8eb7fba9a47b0285b57d8ccf1d326c77eeaf52007b5987b04968a238f8d5183d912204a6eb43d9ae6717812e8793261b16f9a412f9f5fcdf5571990ae5984013dd799c9b7c866af28ae80bae564f6675a68731cc861edbe30c20a08ec8f85b0eee671cdd7a6c60bc0bf5f6e702ca39f1e5e5eb78b5c733532e243fe3a2968d16f545d1130ba5216ea8f936699028151ea02182291f2496a79cca406f7171326913c04ee674ffb7b9a500bb7bc70ba87cc71cc1b263f744125a7bf65772164968fdb1558020f9034398e1eb02b24e216264ca0f944773d9f049ee9162809d8a40932c94c613dbb7243fd6adda6180c6cb57d0ba8eeea91bad50c4b3bb8d0502a92593743a5ab49950add8bb427b62a82240301d671e10c3954d199d29db2e8447f5c8009e7dc4e95ff701db1364d854f1536def84369c4f93dde47e38b759bc4e4f5f10f292aa4363662af879a5baac81a68bfc29faa1b53de4c10cc5b91e078a89f3ae9dc65779840648551e18f03ff89af64699b7c06d6c1ae02a119c163a1be53a3561b9d9dccad04a7fcc8be26ca8762acd958565d7271829e42803201318e5b2f26e99d9c05c5a3a1081b2cb89d2a4727c344d8c69b48e390855732b3a421784e90a23f56d8923b2dde889f7242c28745ddd73e7606850d9b7cdb809db07b002f51f8a0e1b338abdad66bffe5228a3b79691548e84f281de3599650f299a29f71ffbf856154bd11ef5083fe89f226a7a395bb87c4a0dd1841650abd18711da1ce6586922e80cfdd5f63acd57180fb82a637027ed80522bdbb75568cd231c4a6b035684f95abbe344b223ecd0cc65af45d64d38405dd8f6b142db08a5de9097f2bc4a9c0e4fc9049016c199380765cc2c57d6d8c71cc2e2bf0fc05ba655e2311d18d10f9ed303de6ec140fb73abe763130da876f208abc36dacd226606ac5f5bc06c7ce3e993fc38a8f54a10fd6bb22822dba79bd5de1e780ef2a24a358fe1f7c196556f1d85d4665d375a8ed41793784d2aecc9b4115216087bf2887285a046da80da83bd867752987300342dda220645a9604d0bb5ac2c4d1ade836cf054621b46fe2f38019428d702111df0ee07aeb83cff681ef69868216220b05273261595054841dfd7b36d76ce42524071e524d72fa4ab0aa7ffa04db44356c845847086028faf91edb220b5fd3c6f1d9557a53db16101ee6ffd7acac31f2f5da58d8597fef2efbd147df068b771ff9916645cbed3ba239f19d0a0a39ff662436a0cc439dc3eabef10ff44d6e0e39e060614ce25ec0b8845ff1799e8b02cd351f36424c39f864e0d0df2bbba3a8caff929933a609b881ccfa2948c5653837544f7788502ec3918113caa4c0dc52de99575f83705df5808aae601a6e38caf0ba7687f6fcf907b2258ed01cd790373a82562c925d0fe607dd67f06dcc81251177ffbc560f7dff26d9193f06ff1d0297984f7f9b527cd279bd9387317c202a96e21baf1c9d9123283908d2aa3f4a4d7c3f0acb0bb3c2d70c09a002303f5116909fa1ee1642d92d9ef01f0693ed1fb216288f1d90ab0398d0d2b91ea59ab5658ae2aa7f200ac7ba374dc5ce02ccc451cf4f640bfd54e6ed8bed3819003f71aebb31d702a429034b0837c90b353f7b9cc786e48e6e99ba6bf26e1c9149f59d7992512a979b21fe1c195d9a14989270e2ff51440923c34d9ddb884dc6e0ef51810868b1d7f200f7cc33a57678953ba238b36211748bc88d91bc47a33c90c8748e221282c361801a4d8120180713d0504edc57fd92177f2818a9ed7c3549cc809b968eeb3633764e7102922ea9a36a2a3c12e106da0e3299ea8195dd438637a1523c1fef8590903900410633642b03af8fab681214f4585c240a4494f028344673a10c7c3949391219811ccb410dedcabb99b0089917f78ca872491ecac90105a4f343cfc862549679e602790da510ec8db7981bff9ce73b67ffd0ea6588b0c366f250ba8193a61632b19fbcbf803b872926dd6a4123fc71aa33d184d1093e51bd0cfe3ae87f21bc4bb223ea582f52206865393fc7043861203893a019476dde8207304d769d69e7552f011a0d044dea306bcceaa3a951f44560499a78cc5eb82ea1597225e88254ef8aa45b8c3c9a3c6849bce8bb850da710665e83bc9d4d100241a20a88bce6cd308958e94438f8f6690836a2726c06cee4835ee998762f18eb78e702419e13fa370672b51028876453fe846ceaf96043c8f7107cf69f6e1c53f2bced7f616dbe7882e5e21a4d3a98503692ce46653a9bcce3722c1e58acb3a217278ef88b24250e058783390cdd9fb3d49b33dca25b6ef1c04c4c263f11e1aa4f94d49953846fbcedd729d6275d63c5c8089bb435c03200653cea56402fe40c850fa0bb144874e766a4da3250d7f253b2485d0196caafa82a94838c14b6c6565c613c8340ac78e5e0730734683199e18936a7487d85d2b57b3a25440156ee239386f6ca2aaf9f27004df06f7084691d3d590aa5a9992a4462a90e85cb8e86cc2a0fd62fc7f8afb418304cb91247009d3a5b3c1cbd01ae1cd928d5a8f73d0e286d367d002bd43e586083343e87702ad16c9afa03ee1d89d49153d2a3d9575dbdb571af11181c0ab06f1c24af0b9a0732c142253ac717cad1d437ab105590ea474656af6a38e8e3386121cf0c352f26b00cd4eb0e34467505f881a1e9318aad1fd82969197ce097908b544519dee6c2bc5d27499cebcf32da1b7e87540debc24404a76adc680641ef8550928e522a33338d53d358e4efb3bc7d380bac9d61f05e3144a04cea9985862a1984f9406e1ad9161cb339fbafdb9602f9f961e2fe9258d9ccb97655c8fb29e7c97afc57e8af159b0f73f03e4d2da3fdf696b0f7cdd8946114f22558af3010a6426fc1a190afb605b45effb0866e3b9faf10d42cfc963ef0dd489aa66a3b14cc28a138a9508bf5031341e2f03d7588a303393c9fd93be6a0cc50e3086fac61a5573044dd308ff75a14ed060515a306138c6a5ee3c115cefc173645a36cd3ad62bd6d6eba3fa7447b174a52496758560285cca48f66f454c4d4760190589186a6b7352227caaa6f5224521c43f889f6a33a4f31fc169c49818dea32fd3c39114a712648445d640469e22ee3e549d78f6485b8df78d19110a4d3e96ace9431ccdef57e113bc34d8c13f71cf1059f368bc2a99a939d376017e2ac8f53e29a80bada61bc2079c0ec19bf63ca06b5050d7f2aadfcd71f761a31c3ed801e6ab5fc6263ae15612ec382314456064dc1248eaa1b077ed70ec1af49d420145a90b2cf65eeb198b7a31528e388c96eb4d4aa333eb4444ce881b2dac629a16dba60da932c1ad06ea4900a8b56dae77a0811f83b793167f139590081b5ce0b84c68da20259bc3aae205b5222d51e22f9a993a83c08eceb6d2d110258b2e44ad9f9aeb54a1c34fc273695021ed03a8db95985460c7502c50662871d1529ef68561961fe4033b587e4f4bd6295ae58cc3f4e4480a0405f90d1bd2a5a04e960a8b20ca6d92cfc794796d12e179b9b240631451992f87d842970d2d2bac8da66da822364a1014cc76efedb0d51ff9aad76179de3d77ba7cb8d4c584b1c3a5ec8ff43dc7fbc172898b6c130bb98d9aecd39046115cebb59f6942b38ee25a1c524149ecd8300f2eb27ea3b0c2e5143fba4ffb137a3cda4c13860f20eb503522c72f5decda39454239df3702ed40c505c00ed1f06079cc4d00dd41640fd770009545744b62f7f09f48a2b32c58de984c43f3605c068a5838977320ca1a1ba9e5f3988b24ae423f1e291f27b7bfad223025973832ac67f535f82968223a38eee10106bedda81674bdaf3febb19608ce155b1729262f7d7395f029edb7203e4c69a32a2bf18067fda847565ae85dd59b8184b392cffd22bae4a526c389206f2112ab8c23b08a0776b3bf3d77251751f3d61fcc786f6c9bf1c242064665c4b40225c28ca490669492f21c4e720d96a8dd15aec5521fe2e52b47c5f186c3d6e358d1e1851a58b13fcbb600a44f07dd837dce1a31d8468e88699944e9f04ae5ee40205711be65dc02d20dc3d78e6ffa06ba4b32a61fb991208f242b53eab42d336ebbfb5088d5fc62f53ba14b265cbe6f562d73a738e90a3175d0dd11e522f154e805cde89717a1bff56cb68adbf6838410d4108e916e79b28ac218e6f743cf12dfb1c4fa10b4328fda3b8ea7641618ac2dd78d9dbc12f0a0d5a6425a9dcce96cb6a57975dfba09df95d22b43dcc7c25fd894b69b0ed04a28ced2f9e1dce45c8413194903261015c7e9ce8df127425d905c4e3e0230e99c7a475b64ee4cf90b65ac730e4b4a63ea8d1e3d08830f7cb6515a96b8481ee673004c0afcd8a612a382fe3b64f0f248f86f0160dfdeec816ab80848d16bca034c3010eb954496e37f6f94a28202fe084c945d69bc1df489c6ea05f75d47d68927eff63dedf162a8bde36a5c10c42b78a825f9b52a9ff64ee1e78487b8bafca0c4758636e291c1bacaf9048030e7c981786e7fd101821964d125f6ef9d18cf3194e98a333f6f664349ddf29fd7ae61030d623226f03a31d86a69186f739f36505d8f6cfd00040159034a03e87c3347ed9df2703768ea33fbf39a04fc677dc4fef2622ace22799a5da0f2029b00e1139c21374e49fa869fd1d395f984c0b0852e3e6a7cf4f9998f8e86c75a2e4703f4a4eb4d54ba704add6e59a2b23340015fdcf905304785afc89d3ff986bdd7618612f29833f1f55eec2aef727e72bfb17a1ca298771de6b80282f94030e0f679a918ab1989c865535c6ab934def7e0a33ca06a616ebcbbb1653cbe901677630d42ca714ed8a60c0d6b975ef7473edcdc1d1b2f33799f3ec3db54860eddd5de580a14d5b1d43e44ec46cfb9ca03169388f86a21b1c21298f05c77ca214df385f11d2727f80a3ae98ed33db943855c996ad6708aa7357063a560639302f6f881057006f693797bd4ffece88b69acad38917965aff8fe3b4f3f8aed3ea0a9f4df64d2afed6eb701220f44f6e7f865258b6ab6ca6a3cc1b204b8b8cc406cba7549d5080d7ceb7c3783b1e42da7648aea68836774b982f1c7887f4b5bc60573b37dc8f9bd6977d20b55f4aa9766a689eeb6b68e0d4b6ba602921286a976503b26c771c7713e6d2fe8428eac21d1b58c3d0e70bd1da25bbd27c26ed2647e55b3c0134dd90aaa1dec933d7d564b49cf73d439659fdd602d24fdc2f5a2f74d9d6db720c4a98a8addaf1ff42b18f61d529b5324d5b80bc5724be7b78a5aceda5e96fd9adc16091d62ecbaafb764470deb88dab7ab5c6ffe12bf0fde309a292582a23d36f2854b7598cadc852d2c4effe179cf2080fc1e4aaff846b11cd71809c1be6da0903d6b0df90ca8106f78c7e0c1cf4f88b9d5b152acb66b6417b087e408acb00f55fb36699a4ac9b5545820aa3788a6c8a693c5ec6ad46cf669a483d125dd10f6fefb7301bd2cbcdaeff9d7b5b8760aff3c43913c4e0db68aaf1ac2457c68f6232bcf947b6cdf33d1104bbf22a739b5e4438c8e59339600ef3a4790489417eee7e2d28502dd12ba8efaeb44fdf1b370a6e9f3fc4a221d2eb3ed1fff46294f061db00ab5ffc213383f7442fd802316f713db3b22b189398ac06b757c5510c242f4f83ca2e43f441468f03dff6f7f3d599de45743011de3f09ff6e159f2ac6e975583f54a1b7a18c6c30cc4e9ba78a9bc0f952b61f221eda74e5f75293776002175b38c782b1f9eedacc5607dc5dac115727518fc7c9076c4a45445deea56a5cb5c15afcf216dc939239485cb45cb2e47a362751d0be3c58460aafa60752aac203c62157181b743f3974baea82dad0fe9988e2e415259b73db69581d16b6562b59d0abcef48a4f3c13ffc923bbad3a941232bba770de1dd5036a2bb833ef713734ae9eb6f7ce24147eee0922b5cea103c0bd5799d1bc6b935da9a9f7c8f9398a30c4f8bbb5c06529fe263abc97ccc790c0745850311391e9097fa03fe31721055b7cfbf23f473f51025e11ace4e5cc0575b5836bb627a6c565471ad10d463dc4b21f6c11c7b7dda9af128c25b9daa9b34301be47c46403091dc6718f2a2f8cac0f458ba5d276dd8fe1c508c9cef228fddd91685b06fb29ba3d6989c44dbde98c5f6edf8de7cf467e87cacdfa3071f1c63722fa8326ba80b201b710bacf67ac6a9c8f2def381b25b457bd6500a028fe81ed2b84f6a5efe24027f2b6abd833f9c09dc245fca07e1e0214bddc5e9fb76e5f64806d66f966bb914004fea9c42c6c7beaba33a7fa9097ce9012dd3504ba7cc3d4b5bc9e6e1e62d380afb0285390e9d6fc9d80265e987e4e3344668203166168668e783254b13db1b6ffd596b9ad92941655b9bbb7a668fb32c7773a2d8d59be8b3d7983619119e9e28f179d0f119af6ca85fc51ba2cb445817a0f64846e5b4c472ad3b764d47118892aff921d6e5eb5f17645c332167be8485ac87c6f518a8bd83fc376cb899b74c96aa6043940776fa0ad8880b28deaf3b417c299bada3f57095c1c5c5c849d543cd58f2ffc33b8a8961e7fd4cf6897912fca3fa6e9f4d7f287fa1ca90faecf393c7b7669c0b4cf017f9826c741f5c5ea319e221c7ea855089c44e40355b236e48d9f5c1be64c187bb1001035cb9a700cf94aa2ff8c0a3648dc600aff17f6985ac7685e2b4f2ef67105851ffb6a79f37808b430ec2b23b3d737acaace484b469d7061a47430dad18266cbb2e85c76af9acef5238f085d538138fb1f39506f4790cef445a96c48df904f11a80bf0ee078153e9cb78b77be18a813c21cdc6961185a3cad76d71233864b09561639b52f275fe58d4bf439f06b22b716d5baec5448f1ca43f94817b0d0f00ab162536a28b16fa0b6819008eb7fe8d9513ffac9956b0afd6be7d46f2c1ed1617d54e586d7553fab1c4d4fba282a9d0f5ffb8f32952a09862944d710898394d51cb9149f581a8d97cbf327a663635fdebc36682a9ceb181b1769909f7a0f2a311ef9dd6a9ca4350c7da833b482f7c9da39eb0a39411a3d0b3cad3d6643e17ad455f1cf76ce7f455bac636af716f29ff3c128d551cbf2c8ffd11168ff9efa7d85b57c31cba17c6efd9c27741930ce66a793f76240a1bab13c7ca891984fc299611a392f52cc11427f861932861789c00b939202368b280bca664b12ac485e476c4ca61bf3b3ba63abfb37d815b0c2fe2f9c82cde64079be49a50433aa018f4c256289bac3183aba2d2df6b20188392b378ab6f44495b08f852e6a0bbffaf4ae042ae95c641d996b0a5db96739048332134263543a73d31d060f4c12860f9783763207acf991280b34c8ba90d01f572af5b3ab90543b76a7dd775db81ee86250e14708c350a36d376871f25b30253c1a94922c4aeb2c0b10fde2c987c49c7c07478ecf433232efc0a1c52dbe6d03bf43a24a30a0e79dad5bd0cf9a05f83013fee38bbe6cd6ae72c6051b82b283338c5de73ac0ccbc403a893ff66cf7ea30524af901181e5b8ab9484ed45a97d4b6768abc1277f4ce9020adf72e11445869262bdb5592495345e2f3fa64801304c346b7e9b5eff3f5bcb0fd593f36aac82699986d35bf3edfaf2e409b632c15c550675c8bc6983c2c6425e468e5bbc21ab059bd2ac7e91594e175387ba94b5a5d918ba52c03ddd4fd0fb0685fb23f5f768125eba59a1d49823684054a5e62c62e717b85777d96265bc7762509d168c516564ffa83cfcb7402caeb3de2427acca74ef26223945456d5bf34ec88d6d07ccd004e1837a15488f1247da0d5ec6291646b8b923892dd69b2e873d91c73be6edd911d3c05fbf1d41b08601df6ac22824f14be8231c703a27c70f290b50859e05f5600ab049348a5889e20e95dbbae9ce052dcf63bb7410506cdbb31f89194fa3d71d3807cc4ef8c13039925c1986ffd0994557c28674deddffd33ad91248ed07bbf56352fceb7929316e645ac0da90312f2273f65f7173214847ed843c6bbc493c7dffec81ccf0a6de74042892e10c8c258a6d98dac9701fbb31039b5e4efb9e117a51b07138ed4bf0943849c8e01ac92029dc8eb77297b73dc7567b19039c5496720eb63b20a09853cfc5d55a4623e2dd2bbeda5ea435df0a2fa80315bfd70577b916ea5511fe1933d1eb7deb608de2a62fbf12fe4f6318a96de4ccc2c81ecd4fa3906bd38cc4b4f3ad6147c682f2e742f5a98da1f13e69a834af9ecd667490bf9853237a6891192dbd36f46197d8fa42d92b516548beae3ef8a95a74ceab6e799f1eb47d96d02b35901ced4ee2b5097d3639a0eddfb5fa592fa9b278e43e19abe7c789380d40a0794431adbaf2d25dbc4be26fe2fbe5526efeabaecf40e370fd0a48c918db1010e109bb447dd7f8e2cd99a0d2f18a57be158b5c726888a7e4ea0a78b123ca30f8b912b4b3c623261735c83d6fd635a1272d27edb18066e1bb314a0fad964d619cab915ff2b48c6305d2450bd5a9ac488e4d0f5fd9e7782f4a0fdbc3df7c754a895547664772f63babeed7500a30f9f47102d44f90f050dfd8682c6f9faece3debe8eaf2fed34389d4b06710a68e978bb7e2f74e21fb07fb3d2f5e271ba75af8435e0d19a14f0de7bf745394c0f76c533ee578010117cf86645bae21cd36b341598fdc0d36c805d5f004f84316d30d430e72350d7e2dc5dc41fa3f14e51857a35295dd98290425fd0070e4c90607d28008b381da5d4bc00a7f004fb9e33f81692231bba2afb7d61996cb9f3c7f15b10272501342ecc07ad2ddccd835210616905e44a6280e8d58e4b026577654babf40f71005d1b846964b5144aaa243147f9ee947278b1d92640ebac793cd39bcf2b3bf5183f9194215ec7c46b383c5d71a416b777831696e322322a63002176177e00feb7fd5edd722f52ca2a9bc46806bbd5e6fc59189f047978ac886867979d74ff6413a8f7df10d362e9117535c361488623e38618bb8277ad9dcbad81168109258fa17acdabba23ebd9a6b4be70c7ca9f820fda2907be82ff51df9959c21f3daa82be0a173b001c1fbd851126c96a173586768a7c5a976c4266491bf86dd055efa81d0cee00f65ea3c6cba80977344415fabae39e9fa571d757bf2df6f5ba21349696bbbe3db176e4eb13b9a27a20aec7cdbc2c9c4a0a36586c1a2404f6b7d71fc6d225182a4838d83888c1b876bc582f1caf9e016c441f7aef56edc3bd5060ad453aec5483312d1f7ea12d00a0f8d8694ac99d7c7cae036fc90289c12bab5d9622bc4f0f152c42e86a2eaa785b505d7b6e601182a7f10998ed6b5ec57ef496b4ebb435d6008ad48434bf1fa71f0cc25a89c9fa8fb3e68cac292b3d12c0b26f0da9cd5a842357bcf7156d4a287a26c1d9f5b27f55ee78f66a57c4952340b0b9b67b487c6c47f7762d8e803b7e96d0db09caa865a53266bf90ac7ad513fb494c9f176257955413e394564db5d2da675ec1eeb34f742b5344649662fb36fff1eed9d806888784052908247efccee098fb62f6456fb1033a5826db20bfbce0a75179115a6d32ffbc9d04e47e27530bbd8415cd9edfae75e1941b2b72b858c9b09b48dcdc272c04b849070d4a44817c4d5f855c23752700d8f0d5a4f5cc3436d16395db35fd68eb1beeefcf167d53aea826cb91cd37f541f8e7c04abdba32da2aa1ebfcd1e305dac43e7cbfefcd3e9ee45610dd42cc8b23e459c7944d4d4b7422a0d1eff3b15dc484c1736b4c9dd7f0d17f40baa116103ce49cf3d7d53f6b10b6a182be1de72ca4eb9fd387b127015df6550f76f3c9a3c25ff5dadd6b585ae8f7bda3f6188024790b85b65bef7bb7fd59c2c4bb1b955837f4a5a4f44466baf9af307aaa785b55a832e09a200f3385a9d81c34f2b768fc18e53d5bc4cc6045a8d9c407b68a0de3a8dfaa3f25aeb0850a1e07c4cca8187e06b745a19803a27d71f42a3b37985908549a9cd1179d86669d6db23aece02871eafb00d88adb6a6be784bbc3bc3fea1c6478a6d9bf7949d0d40bed23733e42ce348a2789342f467f18a495a7a2a7e46ffe071bf23055946fad8a0053916518899cb26914aa5a68cb790832d60a9f799ebe2418c60b803e9c549617e7009486bb7b6d76b82d15991ebc9c305f806af80c7266dbadca9ee74aaabd95f8955d8136791053d0c405cbd7cdb18facfa9dce87b25a22c52369279b007d12acb2e41df635349010e9b1b1a71115ace12e0820283020e5444bb98717bfc480ae34f68eb73f841607e61e8c3371e55bc3e700631ed650b5f9a1bf0760478eb61f961592d2729980a388a95e02f631d190f1363d0650041406b3b4ccc804fcb53e6809a199fb0b26352e1e8b59f2d84da956133d18842115cce91a8ba936c32934a094f29d1e87a1d3426df88d8954c31d42e3301143922189a48648687772c4a4588aabc716fcec9775aae0b3e068cf49d7128c2135da443b0030323a4042c633282335063d9a14a9b989d9e57584b18e5a816906d7f1d6c24e71d8e43090233770c2c585381efd237852907ba47568e9e1e5e9b2db0c1d5f8f4ba22ee34578acd1fec389da98e439c6e23482c7e0b5d49e97564e5e538af5a266267c8efec3ca9023958fd33a27d0c0770edc86958242e50fdd0b12fa431bedc1cf4e283ecc78eddafe88b5bbf98184b8e4540159098d469df01deec5a793be48ef3ce4a50967235d399f7f25e9d553e877a09ae6be8b10f92eab6f08a4477db45e828658ff798be4611695973a361bbc538d98e256181b4834276528bb96f4bd89f7aca78313ffb245b178a67fe6676ea7d817984979fd545969f687ff49f704ed2642966c2357f6fe8f522b814669d5cd0916263714d5a230733b86542c837a29d93ae73bfb07136de5f9240ff70470b264894111b48c74f83697ba622e61568a4cba6cb1c659c1f7417cf6ea659e9272018fca5298c9f76248d0d8141bba6dbba8c0eeb02328c4f834467b9107016e8dc31feb4e510db9adb3a45f8f75608c34c1ad32e6b23c99889c28d8d9ed951c064d1dcddb6f13704c838e74507cbe028c14ce860bf2eb805c81fa8f66b26299cd19a2043a8827678bf9a01391c0979f5713a9caf338aab0f85adad1202f205e93e3f45e33a5cb681da3b115b1b35723bdb1d37d4ff6c07d5c1e1d97359f5597e66641c13842271967eb717bf528849b672444d1a795fabc39aec403f1aedb09a555f6bef8a4f025d7d98013077bba26162c759307749158a040b13b495b412603ef6d5319b0078e7e085646770d79970a918cc9920b5e3b48ed886d9df972e95f6da21700e602ee409b3c2c7d62dd38ba2de8b156f6c59ca407593f4265b1d0ea674f5164267fcf66cc7a8b101c8eb5d3b9e9a5f620a3748c81ae0f555b4a9d279777ef682272deac35a7797baf95caaafe8a12ef9ab4a04afdaeb7c868342d60d9906ec1adff093ae8f95dfb618fe3e679fdff111902facbff9e9718bb8be12c37aea7ad5885ed582a032d8d980e746975ee544d62f87a853dddb07ffe0f6cc4eb5cd19d2cf162c87b7cfab8285ddb0752a579f73a16e4a1eb60e1cf41bd2cbd22c1cc828bf8d76131d63cc4cbe30ceb370f2a219bfa5ba1fe12c437bfcd4d685aeaae04e0c8ef72092969e48e796cc25c0bb9ba2f5b1899fe08944fdef4672aa304de5ab03007f6d468c729b3cb16576b942b92b95a35160c8fdbf7e2e3ee019804c5fde4f946fe7725ae03c0a2cafec02d5737829e6a377c7bbf0fbbb06fe535e5a388505a449c47f30d2c36214a1e3b087b9cacca97d47fc67b8db3698fc01bb9e6208ecefb3b675ab3bf0e404297f95c57993971641dca4636a9bed6d02efff54fa90f5bbea85cf0ce0f826a32febaab9d6f96dfafbeb1857f2685bdde89ce58a382ba479040a9d21b106813e49ac6dc2e2914f9627a6f155d360d882672212a4669476d1da92b6fb311e7bf4443b34b65bf70a989388941fc29dacaf4089f1cb83ce7f764336682e92294668624538a296416f47e3412b5f68947ebfb77c2e78c0b37128fe43b5a58c625a459a8f16f50704d6e7a679063925aa4e37a4e8f23fc45f9261d97024e4f7db309f85231e7bf1a4d108038a40cb8a866285d3ac8a3bbd08124b2dbcf4442840b314153462d0776c9920b51eaa4d9c82ef7f2af358f7565bd66115803563122eee54cd670bd46f859a4420f03d36f4869ca2ae879d1f046b833b7015c16ef88d04b61ea562b95a7b466f12d40ce54b50c68e29c185687556afb6d601d48b4c54893ef77ee64def79f1ee57ff3b1a5421b8f75c068c949608a9b73138df3491c519dd7e3ee1a7cfcfe6239c517e770d956ce0835d54315d51fba63a47c7dbdb4b67b188f052d7ef584937518062fc757a00e544ee4b36ea78c76e4bd0011bea172133792609948ab8d2225ddb900a35f6b328b387763ccbb84fd21a9bf015c02189905046e3ef00605ee9fb58b759b2ab776e8f4f1fdff97b98bd635cbb4f8e261426bc20fa97e105d5095f30faab14ee166ccccdf1a0e86ac41a2b4af361156e6ee127a6fb7fcdcd20276674e9bbfdb0f8ebef2387e39efc64fb812bc280e88f8e6dc7077c364939e237e984302af4c20b23b8e1f2829cbddeeda87393851c77b624f69d4b5291d5813b1fa1d19f3390cef23714cc89c3b374c2f5f8a29767ef740591966cfa7991c20b353d0c6500f04af11e7a9fc31065188d7a02a63d9bbf3951c3d1490a601e28d1b5998f01e7d076b759c5faf8256373779be9c7b27695041eee0054d2d2017e6a0e9c270ac7d3462aa87b0e74fa64f1cbd57ad7c99b5679581bf75ef63124bd89c19f82b7cf57ed4bf098a28698ca0e7fb50a834fce4dd8859d540a198fefae21a200de1313971128197077b8a653882ab982731affc8ae9adc14af3281632f8813862c1b509ab5343bcf5c9c7a8aa645fa746bae42fa9781f042b1a727a974c27e1f46e3a92767fd313e85a62f936079c3e76ddd7e1964fab537a5f1a3d7979a53cd05c4fabbb79b59a301e6421552b0cabc4e02a97ac3da884398ca6c5950970bd718e33835f42a2b47646145dc5140a318868ce29fc98c7028a2e5c539c567bd1b2dce872de7b44f47b4c80dc45bddbc4357868a5475be5396654a1942be1457769a69de29d1c394efa19f5571fd81d558a02cdb8db8d5f5faa16cb6ac2458fda4ab9d6ae248562253540efa24436671c5ba047a67e635402ef30852302af20ac2ce30a09ed869068b0a7ad7390502c2a333b3fd0b44660a9afcf9477d264fd2f000cba912869809417383bbd90dac36dbdba6da22f3130b2528d5578098ac0bcb20441027d77ea0a7537c73ef68246afee3a4a4d66c01012ce1e2247bb7ddd7037d9f02fdfadc6872694ade6b6d49a549b795b2c20a6d0471b1499eb4e6601debc7955ea4449b55ea1366ea3532aabdd0f467b0a535234eea4a5ec3423d7dc04462d68381ff895c2bfd5a8a4b0917d8e55c840e1e73e9535c85e7f78e026ed6e9b1a93657b1ad003a62a6da60ccce28c8e4d6d45038fb5b192622997de877d95c8d6951a7612f6ccb3447cb9ef25163243c5cf07b3f74a36c52e36dbb204574093e17416a03ded44cfe4ee9ccff6d384599e11d384c72d262807cfb023b5c27f2dc3de31b80171209ca296cc5265a97bfb6e1ea997f8330d42f461095dd98c260d5d754c760449ce9016f4ca280d800562f7f64b8459a131344a0687a53d242328236c8c2fcb1ae19cd8b743e4c0efcae7ba47f4fe5b74ebf753c29f663d8c583e5f21ace9e865a5b4708776d784babb59222a70dfa419d4ef1ebec94a86a01437da17901315240a1b5073f977a374c8cca807e209e1e247b241aadc1c83f1241a3669534c1d5d9f72ba505a38623cb91018ed7c1c634a9b12d50af93acb35fe30016548e9e517b5b50bdb7f2a972db29e2eeb40bb9ccb5ea611e33b21fdfa3600cfdbd861d634dac1d9e3c7b84e49338b2f20c1b71bbb0bea42a45bca15bd1202dd333ce03a3b6c90d9793d32de8b5cb65648eb9dcb3b497576db72b2fe83e707b5ddd5ec44f358ff2e68371dc7cb6c9bec384db4ce92a871064d49743d1163d0df87f66467afa263fc916dc68e65289bfe1b6a0c74e77721682cfdfb5c75d73f20acb8b80b712881006d403981cca9fc7a474e98999931d774a5725c7691dde8b043f37410751988343e0170369d2240152988b11a18d56bdef07cff0713fc64a4886290907fc1705488ae209daa37550e13facb9b8c6f2f7d1f0ee89e3a1ffc6bb81ce3e0d4febec3cbfa0b2a4a1c91135f2d3115043a95321ce391ee5efc366d6378d7ceb6e7466d3626f6bfaf90beef18d0bd3c2a4ba547063a915030249cd2a22fbc56d37531e0cfee095eaefdcc9735f40086ccf954f343e8f1d47a43bc43c5eb3ba8b02bf11a14e185499d887323b405095451fbac1049471c108c967884dc4e00eb0007d75283d569d96dcdb0c13c20d14d1725cbc2b87535dc3b0788f481d669cc57babb34e268f1056ea5dc5e6bbb92e923be6c340bb86a0f689bead162bf9973789b5c30e346c6a994a9dba41a9c8633d42f9361d70f04474ae6aea7ae28f8b74f582c19c12e35679c7534e1025e4e77e7facf6580f6cc1eb35102af649b8746f19851dec38735054e414baff928b6c601de6812212d51f83812b47a1250bd752306267da0fcb8194e5c3d4e036ebaa34c467ad1eac286bea7fe590c799e4b72a5b97bd74f66098a22035cb4adfee31dd49604355742ec4d08d033c7803af318f5a316bb1f316152901035e9076614a4bd4ed2ede9bc947b026422c65e5bc195aeb58ab8b4ea9d5e0f2a5e3013dfacd8196148b8a058524b2a4266d1c5bcf30cfb547c265d0ab3abd1c7d4fb05a628779b4638e53d4725c2b6fde68065435b94ed3ce1ebd35abc7dd298baa8ee44b0f0b4799997e70acfe9a781e325300a34ca176677acf1f2ba33f4f142cf33566661787c9a63322e795afb586982615a083821fa32a1be97ea366e45e3ff35941497efc2f5c92b8ac6a04f10d1fc9242ac56256e9c55b2ba4b11ec0d65df7f739ab547242664ee9f821c743b366abfe21e8672313feb85abe444e60ebe38b773a245e8bdd08e4fc944b5aa3c17b889672f96f441dafc1ba2a0ca20b0cf4acaf5c89db2dca59593420ff128a43ac7e5aca8941eae965a1cb9c2e8aa10ad9f79342ba94863f14831f0e4b2a619a5d370d6bd7dd7e7fe674cc78f453746c545702f29960bb1e07d989d034dc06bd87ad221c689a1d79c688b84f60bf82d51f3aaa2f5cb6bb9a67ff047a5531645e9ac5ff485b55ec70c6856f099e5dc5229f1efe1ef50ccf29017f91dfe9cbc104c754068b748995fd13b8876101645e32fc01a029a1f23e61e3979818c11065a99c7b9cc8d43c926b6507fe42d5b620f3f3fbfec39d0f507bccea6e8da0b7dd41e9d1e9f06577951e27f3f4469403647ba6a51e0f4180d3571815b646debacc67fe21693a5c703dc6ca47150f221b03a12bdf2e5e0bd9f038c218a41755d576b7f46e1b80ef6b36a6ce200b988a7b09d094f591b15771b9fdba5b0c2548f91dfc4626bf0b89c63efc94da5803d398b9a3e7d4931f3b4f338f5762145efb2860a9f7de8f91cf2daef70be078bbb7de2521d687f894faa87ee922bae9023199033f34154c954caaa60c41d951a735e706a08152f28f95d8cbe924a5b6965ff7b01add696224de0a927a15764ca8d221d0402e0cc3eaae9cc44e35e6f78b25b9a1305de2f3135cea259b9dd672824b721030854e45590f920698f06ac05d5095993a54ad223f7f9f164c1f71197ccd28b76181f7c9d1ba335ecf0e63bb17b990c431feaa47471b0470915c1c26a03d1bbf530a908949b90d5d465c97ddecc85d743b35b55b2213f8b45c0b07799c31bcf002ef321f450f5612564f23c0a4f1a6317596681698900132786e9c2030bca699124e3863500bddbd7bd9efba9e39336989a45e08adae5e0e284b18de25e9da9ab67c96b18c7b42edc32f0d5691ecd519b0b8662db2948e9e479481254e29644eec68cd700c7b4bce09f86f21d6a8fb84af4f31c6740f458e9dd863e1543636a68aa8601e9787a565ca5e6c58c9d9d9bede0f7e28de9ac17f82cee730c1936060b61c9bc7fcaa5840e20bfb0fa32a446de78d04301a628c70aa11edebf12b70f21f5504ee7c30f26fc518439b4d901e0564fe8aa0074cb5129f318f1cf4b4ebae69f33c84de0c26dfccab215f5f91af3910cd6f79cb24bcace91eafc6377b3778f3e428cfa1dab60f059756fbf273f702aaf3ac4b50be2d25e0494ab613c618614a4b7a549473d5bc0252e095abbf7145141a69a52a8af9eeebb43daaa52270d33f8eb28d986e290edf88c2062e7661071d89e297161713c8bb85d19e2e9b5af7b2e3b6c32551ab16225cf85d77ae99c12bb3a66536dfbecc2e4f4309222f2d1315d3932ebb5a50d26f8457d05d53024144adf656eacffaddc0b0fc70569a7f05e4ec2d677b80b6d3c851bd823b4ea72c647924cf316091dc9c57d868e242a91b47a430d5f1947655198b4c8b7a0938a8a310286886cab1a66313610bed674ac1266298fb08b5a9cc09f4a5a866af726b87812146ba2f983bd366e67d7b657245d3d1afcb3ddd6685840a04c841ae4dcdf105e127b83c0c0d2e9b3d0c01e8ee3186a284a7b569c33b7815c0cf3c3e632098621230f5a9b0f282c3f1be0ebaeb92f4513c9715c6cd372d1db554d11e729b9a65bc61376c367af941f1717430176cc23a6f0d7aa4e0b6ef96e157b6dbba9504cb30c3d6c1ad1906b2ba54cff1c7582206e19ec66d457bfb9335ec6a72723fdd40c54436344fdac1a4dd3ba0ceb2467d431e9caef5b89b7565972caf4b0fd8854fc696e05c4ef530250e9ab326927f42276af1f1e44614af0a7d187eb5a3c9fcc2c54963ec451e3e9bedc0c81df32f2c6808c35d9e5032603a4d82916cef2821e76f7980d14f7fcad78e55668ee015c877f85ee3cf622368c5722b49bdc4a0f06ce8a71e245c7cbdfd8e266016a3b8b7705d9ffabe2a1f65fbff1f2b5e593e7a01e0c1e9b01b6e1723d78cd33e0e64477b23fef39323254df516a44da975db73749dd79a856d467e2b6e749730eb29134fe0c4dba833a51f311eaf1a8192167321e0d939f6022f921a2db5eb80d9ff3026118bccd7006e8f74118c08ee7e18c3c90457ebf22d725fc4b142c9cfc92aa513fa17daf977f41f7597893c331596e57ecc1990f18652df5577470e291947e3451c2589ba797acaaf117c9400ca3ddf1114c70011a298d53b8a35e74a06ab6715226bebcfb7489b552c24e08bfb98a0f1f4cc8761b6dec981b129c6c22775f2dfa2fe71f1e1fb984a72d86333850ac5f836d6715bc534e4677976a79c0aa836194d136da0fe45ce764a89824df2dc471ba2550df0f559df95e7a3e861fd8ec701cafd82ee4d7462fa921a02a59fcbbf03fb8e52c87b60c014eed1ce3efb2ad1d091e37c67410248f3d8e23009cacb93af0d521b90ef0afaf1de40dd61ec5c55e1e69ff5eb337001198ea544441d04db783c8c373d973d4b2c0e49cb4ef88cbeea2a0941f181bd2baefbe2f67a093fbe3394e8fba9d6ddeb0d86b0b2a5098aa829a00c32b6dbcc22b99bc557143171fd06ca8244d4d8f946764d9087fa4dd99dcd7bd3c8f613cd6f1563b74d277e40ca2a5477464a0b4ba63c5f00ff950e469decab4cde1ed3ff9bcf74e6f82b985fc5073cbfca852ad192aa4a8dd764931d303f7d6b3032029d81e206a3147f6b8fcdb5e3c3593c32d07ab096695dc88dc45de78eff03c4c6ed5b115a34f39beeae84a2c1eeb4044add03fb2299528097a9a3bb24c3989d6881f75a03acab0e8d2d4e6e0f9a9d4c980523a18844b4d33f45ac21d314c0f295fe55499145dcde96a8f57ca22aa0cd90ed2dadb826735fd6918cd6c6ac4dced843d7a8b900be2c3e42fbd4d811a5f12d1d7ebe312789b42da59679b4a4cad587fd0015ff57b5c2fd4dd1c916adfd011af89a6c2bb57c17ee08286ed2ad0e7e589e0f57cd9ef16c26bc3356cfc1e8571dba114b00837e7ddf9575aa06d7e4aa7f6f980a535b080b2ca0f42658fcddfd807145dd6ed54bd6b7d6fe4a12866f546d2e9c4aa36e1f3e4e1e3f508dc8e3f33f3541bafec080a5e2c11784b5d0a52bac4e46c17b5a8570d5493ff480f33d421b03d862fa2896cec1c012e0f9118fe1f44163166daf53b080846306b1fe0fe0f9db7f5bb89477bc3657e98f153dd3319e56eee5eabcea1740fc43c6e3f52883a8a490083d2f3e9beb70d7181242fe3831670d02b60dd36f9b3838b913b4f2b88fb9202143571e6e82408c9ce46adfbdc6ad6da3162f1be5bf32040ae2b9eab3343cdbc21586af524eae1352f041fc41dea039e1e8f3583a968b3173268a6be33e0230fa2e89e0fdd7f4cf3eb0c2b4953d8ee4321e054cece6bf6f6c93961b3396b209bef7f4724beb2b178ca20a0a015f3e9c68a335a1cb1ab07982eeab45a0b3cb6cdadfb9403860ed4be932343e334a4dd1daeccfbb552548e4d914972ffeecbb313f5cdca521921ac5896eb1624a0dc779931ac097cdf919f3881e39bee0ae2d2e118dbc6c8fc1a540ab4b6c47aabbcf4ddc98153cb2e96512fbfae0d6f3c74022f76ad76ce83f644e29e53e25ad18a9efa6efe99b09bac92f0644aec315e872a8ebd6da53704235f4359a7f351400b31679b9186e22c0544748c055647f1f18d4ca350107943b545ada14466eae15c4474e8dff3af2cf403fc1e7dac19ae64884816ac2f05396f4d7b584b1d9a8067565dc4565fd6c67674b5e386555de403606ca228d778c449bbd2d3d4f26c48b846f978bd4760af6b7682201bc1c454e5d5e855c4972e112f1cf7f80d1f6618cdfb27104728c039cad2634f661364632699487e5e0ad96c7fc65c9c28d8636474115fe4caaf2f7a9253d691c3e015a64189c8d4b22be5de0825d189985bd7668ff0a40cf1405fdc31f58e5714245367250474fa6726b3254e6d53f39841ae783f793eb825a26cf5915c576f1d87e4e6991873b7b156a1067d75b16f0da5294cb94bfc0eefeaf364e76b815cd582a4fac02991957fc25953f5c4946ba8be44dd5acc2e396af534242a59568b65364cd696e3d5f86eb21262e33489e20101edbc0b3807cafd12983c36a13fb1bd24a9ba482759eb967e89f3355f19057b5bacd08eb9ae6b68addf64883e1a6864a4f8b84dbcd869fb0b3783d7085286378ab4f97bdcaa11c12ab2d1460a373d25c4b33fbb07f5fb99778b15e5949de850c1121dbdd060c76bbbc62d252e7deb4b2d684085a979a54f833315700b817f693a54347afecb006910f5e864ee483d149b061a2e244e25a55c0758c43800eddd26803a88bd97a547bbe55e830fec3c3a46ef5a0978a7e0e163b2789f4373202e202205e9f7eec5cf0a33f526210f14452d068479d078fd05d572e671fd1cc87534db2c51bce9da62cd4a8e8c74d79e7eb77aa31a153c67a1f71c900a49eaa79410b50a9f57c88c13ea0fc75d102a12d66c998f7028369a393d2bdb6b9f8b2ee2562392d675f05dbc2b3443a80ac21e0412d5602a1d62964b4b41419b0fc3286495f7d37a31a3d821b4a42e505558b83b8bb1e890f494c72777779c15fb83b171e1b3961902aaed3481005830973af77250d01a4f85266c093263af0c6e17e15d7aa20fda243b070e10868669d9d228a70f5bb0bf6058f1639bfbb9aa31fa8ba8090f9fa81478a348aa8dd232565a775bbc5f44d0fc34b0a416dc0e3848b944382c7146b1a0d34aed281dabef71a539cfe37f82bd6c1336095bd86ea73cef83b7dc5d1f31988fa12f65ba9aac156b40c2986f13d3d1bfb9edbb39b894d7d25106cdcc87997cf9db9d9817dd1c873fec664b42e21f1180c849ad102e6c338767c1cc58880972c77847bf490c25abdac096e36292637a5ae9e0a2cbca0c1fb12e25016896cfb2b545fbff74aa0ab3813dcb351d285c6b6c35fdf014bfc9a6b0af1a20d83aed96ea29a4ca2a6eddc05c801052694ee1aa6e3595bf3d74aff515292bc48e1854c207f16a8f60bd928fb17fe8a64040a3030fff0dae21c0089d2543026a22313517fe014dc814740460e96171d2101ca08ac9527e14ae5fd74b4e7f988f91abefca562799ba9e170dc354026cbc3c1b1fc5a6cc7ecb1cf03664bdf71036fc6f7276e985811564446143909ffee9b22425e784555cfd4ba498deb1d9a05b828b3b18d72a070a7ef4dad9fca530e0fb4ccf711f45e060de0aa254b270925ae9142c55e23705d30ae64468dc484f1d364e1ccd7261e274f5372c140402d73e1d0b6b2c0956a239e28637996afa2a498442003d02193249f8ef47eb3760fb3b6c7f3de33d5bff126a734568fa998386bf52b5ba7272cfaf21a6d0bb2a49a44b1e6456145617aa15eb670b30613e508112b2faecb7a77eb0434b5b3d547860831deaaef0f7fb79664903ff03bae639fe84f9efb602acfb9b6ff125263e20879fc258f19bd1fd905a7831caad60127b5167aed993ce61bfaacdc3b8447b407e2efcb241bf83d4c2b0b698f72e33f4e445b0211f49a8f67342bd853edc2dd7148d30f5ca960581db18b547844a947041baaf01b5fe20f30dd6affbfabef51b2adc86ea2a682fd09b8b76184dbdec101133ce644ed58900b5faa5ed2be371aaa8c18fe0c952e8c2065bc10f7d7da5125edcbbfe84a506f11a9b39943c39c726efa622681147ce6208f11e4b02173d39728a2f31147a756046e4c1c9c67c310ac74684b6b80aaab54ced5c44f270967ec51252681efaabc9ca6272763b9a64bfd0ac4f39f692066113206712835891ab965e9090e018269e82cabde8ef2f155563aaaaf80b3d1685ae44139a6d3a5db7cf020b971b9fd06c6b561261e9a8bbc2921692dbd7bd6129e1dbd816b6b208101cab092a25d69b70c074b58f4e56c8d642df2af0b215cea7f1ac83520204c173698469dc3c480369145ed744eb6f346c84e3d1e4acb35039bea7f48125ea013b033eca69ce409a9b57a33445139cba7366856a8c4aa876da9b4646766023fee25d3e039538f3a0149ce482789f87e5b536d87e82fbc7eae7ecaecbf624a7de31a5b8a4d97d9be5e2f14d0f7cc70060341160c47eab41c981860564ce86c26c9c0d3b31d2af2bdbbf73a828cc54fa8d506f6a3917f6c686a5b6779aca031d722adb370febcf335277df0119f6215f89f2c35eecca09338760e196b66e47a2d159b139db3fd4904d3a34689c927276f62415c55d6b08bd757c729642b820fb644c9c910efbdfe027bcd10207ca7a9161f41237ad5b5eecfd5b3d4ef04544ee2186c8d71a6eaa6947f2f556e3caa483cc452fe2c03e4eb76c0d45a44a6c6e97012c05612433537c9f2c68247491f62d0f067a94f5d2a468e14a4ceb35a452fd7b3fd90a7e71fbd872963d93dafd61f28995ac70f2e3679fb4b1426abc7430802e26a2ea64a11ee5bf2ed73f07d6fef8c5c4bb1a8cc1de945d1f8c6e1941045c222b43dea132149950defd165b5dc0717f450ce0d2fdb4aa34da93f0f7c53f82a871a5a123d736fa0aa93c9db8c2fbd5d8e9a28f5d3755976753a7365a92761b94d8acc9c596a961522a17b7c6c0ec60481e670e05d3220f7656a546369e91754fdf3c7d352bb84d852b294f93fec448534068b9e132dcfab5eaf307ea16292e41b52b3ab6d074eedff5a9a3d2635528bdb07fa5f6d001f5d0b6a38838739fd5021ea7680c7f37a59d259a4da1d2eca0aa93cb9b9abb0acf1d743ac590b4becc9653654c5c8fa783c1cdd36fabb6479eb4d179f2f3c694d22446e1ea4e4a4b04c416c59d2888bc7b1ef44874cad0761433f10c82553646b9249f8bde373faa99390541a5455d20a3c5266356c38301a2e12c6ccecf60ec39f07dd12e401287b52899542d95d30f51fe806b1142ffabd84dde3215a431891ab99a02299dedc77f528c5b46afaa8c5851ea99d082afdbffcd2aa55bbfd5a7450b45183bbe454203c82bfd304244c2cad4152165777b474e5208a2db7ed84471970eebc77884feeb7ac8facb216b0ad5745394240265950b2d833d5284ee8c686f5f13a2546229490bc55b97d20704034d55fbff39438a9543c2f0bf16afcc44ba38e77de2d2fe4409fec2e452302cb39c240ebe98747e91aeadf37d838294eb8a4ebe39fcad83f723f311f6205246c13fdd7667c136ecf82f06b612e6685500d3b977144a4e1520f1be92d790aab0cb8826e11b514c70f48c32c9f529391d556be62d12ffbffe19f1774ca628c91a2607ca55a4e94f8bba2dedf62819d37784712b7db4877f691875f0df268dbfd3c03102f615c8d512e273226eae17904c00bbb8b72132616e382dc4e9f1ba74a9a1de16f93773e8ffff54cfb232822ce53949e3d1edefacf8994d0a5fd42c185e0d7b2be75404d86f9020f2f42b5e24e09e9d5ac1328e36e7925736d976329329359a1217e8bc4ce97406cc4efdd68bf0819799dad4c3d9b85c29441b42b41f6392f65fff13da2cef52d23068bfddb4caddd76f2a335c0b56d477f3a517449c9a15f8b6b24aacaec7f0857967ec15dc7a261e506d8d3fdc4b95391ee222a788848208912523f12b773382466a930600a40db78c55c56bebd2bf51f6ca64f1db97db56281a051c58feedb2c0b8ed57b761e939c6af09a32aa8f3d4c461ebe4726bea703024b4a65fc0df83f9c5bd7c162f9d1bd54a32661c54c85a47abef86fd216dcfff9deedb495bb43ae7b45cd44cdb46ca77096c6a9b1587854622cdafa2b6bb93958ba1170b6ef20e4838da49d67927c169a397c7a8f412a3cb323a6c15897f9eedf880e8fd82d6431c13237d5f1fb6dc8ad6f81a27d1d3a9e550a90ae3e41efd089f42a0812ecb23eac817a90a17875070668e0a6d4bf752247f6dad102caae4141a28dbcf4d8ccd3fc499ff16843a876949464a58039ba8ecca8b4ce964849161c83e32d047ed38dfa0dbf4e37f7db9b8254c9beb1b56661e5e4ef05a97a7c219843961694cae1ca39bbad841c3670f67c817f18ef4a5a137ea5cfbb15e1b2754ac048a69652f459bf940331f0461cb1ba3c411a7e7f9f8e9ab1862e590350d76ba1488b4125d0aa75bff5bd37fce71e26cd61dd3e94b5ef51ad1155dc8971d5833d6df372c96b2fa5b63033f5fc24d14f3254459ff34a8718739ecaac457912fd65d61c3125c46fb623d1d9d04286e10539aca1430b58f25b0138b7e4cf98fca68d0332469aed927fc2100705a170c924c250b1919cb47b5c262c0f378f4e3c2c43098815b51ea8a8466bbc72fdf242c18388797e38d8a9b4f60506363caa7080c4dcf644b77b2a78f46d6278b970f5ef49be3347a8d6607f1835f37242d39db41244c5bfbf399b039f66da79e937e242fb56d169159ac53c7f0116a307aefeb0b8fe9cad1626f2277d71616b0f9d1fcdebec427409355e489e3474c05b9a806e90c1ccefa26ca747ab2805eec8f6ac8fc08ba3016e969c4d94285521ef0baf29765b38b9311e287aff89937015c30f31ac80aad2e736837c2fed5dd248c23dcc24a3017bc5ba920a5050b41f48d1e06cfc7576f14001336d925fdd3afcf1184e01a5db1099533ecbb00c09df8fa6e252031a23f0ef6de855f14680bdfeb52550fea4dc1af0b7357c9225132005fc89049e893c0bd86e1dad14d50b6c56df8d59cf4f3e620098b56146e10920110ce45d40c7df3b15115edda0e313a54beb7ba02020727eceadc4a8dc99e3e951a1a37a4ac38265ffb0336a94502150bd98b2f994ba8810d796313486ee584fa345c12b0e126ce443197d8dc634b0e54bd85ec14f9c045843fe32c06452551fc98e127d771cd5545322ff86938b2072961c7c421c852f8303f45d488993a830436b4c76fabce978ffc29e495a86ec53c1f15c047a8146c386e9e544665a4d60afd699b636a05e753a3c034270672fd1275e07ce09bb4cb70db58b91b8e9eb0403e412970b114cfa17c83c12f9973ae9b977a6bc92dc8b8114327f2e5b8f4b49de55d33c6946cdeadc9a87c00d3f39aa342c9153fda4ba39a843e35b079be299b915bfc7ccfca80c7ee5a172c74928c192321ab871e101378f4f8ba392a2cb5dc742b46d6b180bb7c9bb6e21f87375b0dc58ba3f2f4c68ac7eb1c135fc0cf3e3ce909df8655f472d64da2f2a4c7b23cb5dea0eb55eb27e4952a4764e48bb3b998a53b2070d490eeacf1dffd3f7ff887617f1dfeb2ec1abce7d0d3f1206e65ce71921ac6c74d10a0c60a4d8b58c023e30b9861ecc20460c5c6aadb7b664797487bb402b1eee46b02aa37ac3c5860fbcccf78c0636784b20d51ac092214ab1654babd8f4f163e75e5c0b9424610f16afc5fa37f4bd255124dfa5582b1e8f4466f45ac57a0553475401088c64fe6ef2fc200478fd11c02c832ac2471855c5a17fb94a9c9df935ac4c084c5d4927ae773f7d5b8d156eb9decc596c63edd2a1c65e5f14939ec50547cbdf4049d0a1855ce0bf0074e1102dfb39c69d3dce049a191873986b7b6d4355c454af271dd808766e85b465e170787764dc0da0e4af1ccede277ba2e5f7e537afac0a36433171a393ce6d23d36b75124234df970bc658767026784b5e0066a89406cda20644e6f2f1194c4522f46242b5af3cf988d9c7506782fa5c57adc234f0220e0440dbd81427ecf44b3cd3046abf038e4f63b5c7cddb34fae84693dc666ada27cb49f3843a225bdf5339d7790cac891ecab69512d4b9f95d68392e44eeba223fffc4d4cf634527bd6700ff39fe0b76880d1597c0ccda106427bd6078ed65e0edcd92afd77326dc73d7b784188682eea8069316ebc162c22f71f7e77e4194e7f26f9b8d83ce99bd62d0277bf99875f6ad216a88975f2efef8f6813dd4420d15fe6f3b64d1107d15af77d62c2722e8de8485a3952bf415e6cd5032cbe6cba37ca3bf08ee3afb711faf1e4ded33ccdd6e417cc83676ec573f5dc89b6478f00a6851d9b9a2212105b45763f430840847c72aa582ab717f6d64b78e189c48b7ec4f225ae1385fb4c6fa71b581740481b0ad3f7853d9484ba7daeca4b985ec8ba8b7f9b03ad568d10e1b1983686160ca5d68fefc63ea46b55d96ae910b615295c569c60a95235abd3363f731e96e0057aeecc86df5a474f2dddcc60aca7cdfb3df4b40210a815eceed9930e3ecb672296d12a72697fdd56977c66052e10de0b03d2e4c0a7f3a64f04f28a8c78bce7617981d54f5b2d2a95d4c70b64d28930549abdb422d6b6fdb2a04745198e58d3533540d649af3265f2cab94185d64687551392c8a9f10cd30601a376f4c4fd49294efb718b7c7165fdb6e837ae54275ad1beb28589cc71df6244cba0c8d6bba32f716cc883465a51711ea2cb9ccf7cea5897f27ec6f7c0b3de7a8bd0be8b89952e344950a87cba18a275612c18be6706e73387e9dacb62343a4703714a2676ba5004a41853ab2ffe8685e93af1f2140fb55da768ba84559c5d6b7fab8131d1544d601889c8021171781f9c2e5b17b3b4fac0710d206872eba9688aded82eccfcae4183870df200c3eca6de13b1a1e88b793582c24bad2602a27e955e2a8bdfbc06e2a561e006fc97367db19a9d7504a5bd0229d23568a450f3d1df9e0e67c6bd85fefa806d291264facbb8e4009499b170211b68595f3e74b8ba85c3bd468dceee79fcbbd6b89b39433a36da6d9c76a0bd734af15c0fa8cd695f7a0c7c49563863fcb5b2fcc3c5867b21e45d9eec51b18a25b4ebe378725ea8527f60d95ed4f7e34354113e9fa3190c7ee097721255b95e9a093be74a84bdbf898a580f397fc55216f98acc941ecaf70aeecee3ab36a58c7d6d604ee605bd498bc2c4040ad7c6e641bf8b96789142c10f0fd152f3fbd710450c5e0575f1cc051e19bb23e756ab55a88df11390c773b7a0506a088363871b0614d749cb87dcb515a186ea903a459d4fed77442b514d67312f2c0054b2bc0ff839af5ab1a1a7a0c4812a3577656bfd05c7544cabb052c587c7f6fedc19b54bfb7ba2bbd0ea1a759fbd5840d4c56db309c5d85bda4614e75b03dd58f193c28b6237e4a76104bfff47dfaf064f9fdd11f2b7f76a85d35f8bb0a22956e51b15a2983f509ba0612dc53f55252daa8ca4a7aa0de49b5677151ca52ce192c0ba8ce8ec165dca228c99968c33098ee2a5c7fff042a63ebc0c9d1f6721fd0a9885f20b64491bd0089133409fc8cc7e9af078a7c9b05d7546d15214c81f75c9d1d9c521f84519a4abbe3fb4213e2b587dbfd3880f842724d4497525daca2d9f84d2605748f450f84b8736d14dac68b8d731a25ea860f3c3eefe48c97d8a4c2095b10b758b04c5a9c97a9f94e4d6ed3a086349f465165538806cd3d89049b92f8019085a6ffb7ecbc29e61c68cb747ab12e05930af14d095ccceb10d01e691ffbdc8df1c8fe8504fffb8e6b67974415ff99d8f0eb2b0966d9c1239c4c79b4a485a1e533db46725a456d2d524aba061befec0d8875631be875251c8d2fcc08715d3000f4000441cc09099da72f089baf7628764da1687f8ae11bbb838cd33d2ce4e4af6c780e7973381a8ff3bcc069cc6149211e441d75e343bf5867d42eccd74c1c14dfaee1c955b98c5c7e13e43bddf1d2fd7750ca6f63bd1b2f574eb2e87e2ab9e13e170de863bb3c667283b05bf509413f62dfca3ec9f3a96337364feebed1b392e630dff2dccba690e81d043b5aa2c70a013b5a36051d7d4bebadee30f6e340eb066ddf8740f9ff41c1e8c8fda691a221f8b0b0158e7d02929f94b70fb376721cee7dbc9eec2b53a12fead3b4df8510e2db5c685221692e14d6ec0243fdd4041f917906d9179b0cde09b14fa65e6362fceaae00e48865f1928a2d0a5d2cd6bc50b18dad2ccf23963622f10b95b299306de8592cfde80b3e1b01e5c7c43316bab7f90fb2d7767a7ddf42d4966d170c34682c9789528d67bc6fc65199e78f8f00fb85b0ef3b9cff95cde98b6e6c5f8089a8d088560b345764b7bc1404c46b6aa31b25a73c3c6c611ea0bbaa49a5c0be54e9ece680f76adf3217a8299f4788a0d819b00e5a72518ba860f821631f4f5298c1d88b32ded132c6f549f46e6c3a864d3e41b785e7d22445e1d9e5e408a9ba0c46a4367cd9644b7d96b5ab8109c31e2350cc3f90aee54f84bbd8155cf9aa87b5344576d8e2b57d74229269fb7433aedadcc2155c07b5806204fc4660d2f551d62722adb7e738b3ae9ba28fdb93157a39b76c3a027db5c6a15adac8802894a4af39001b92d15898d27190ace7831adde0fec4b2654cba4af0f3b802d893a6f03a82f54b8f4e3b33f9b353c31246b7d57712ee0c884be68c264c3dcd722ea9284dfdabf2fbb8aaced01ab6851c1f483a21d409664f8a9b6e961a44f23f2093666af51293026fba4bb4f02474530bf810fcba2dcf59f2e2bf506ee65829f63f4f2ebef1ae8a561db75aa379ed57ab4b49e50c3ca4e1c9b0066c176431fff516d9824191d9448c9b67b72dbc5a6529f369f971cba8f53ad41bc2e697a74695cbab7b950a4422385158e4d0c8fc5cba74fcc55153324a5dff0c3c093e472c125304a0f77a2b4a4719647bdea4270b57b292a3c8f53729b10374b002922811fbf00c11af0080ed6bffc6d1032dfd5734a931d352273c9a8bf35223ab4e5fe24bad1e995651b57ec3c112effeb6e308ad44bb0876e0c179747f09701b9351b5aaacdd2dc08918570320bc1dba88dca85c8eadee62fbf762af55e5631c40f43931e2e2d3e6671f13858e33ef2ed744cf98ecd84f641604920c548531a3b8e4a6cb44e69c2c82f5ef2813b8d3e6b25cf0b8ce95bdf4537e1e2e278b901a1e37936da98f607d8d6e9df7e9feb205b179dc829ad8e6a6becd737b02638e4754e08d7adee69f645ad35f489b1dadea79b92c36a236638cdc2a6df2e98b9a2fc65a722c05715a26c7b0b64c0fd388d17a168b914da6115acc65fd5cc095a185d87a267a1eb48fe2991f095dde7846526b76872065be3be032d9722918b655c86829beda7e4b1d686215837e703477c96b2a29304763b1ffb1cc6c943691a813f47af3995fe2ec2c6d077a74929053a68828324b8912f3123397da542f147e41f98d2575c33fd218e674642ecf06805893b8696eee29b8645138b4588506954e257ddadef06736b218ee7798313fc744328bb8445bc6e0e32dd0530be42c1c4b972cf297446c5422d41ca7d276a62fd59e61262a3f87c8f81223a6431901b91243e5214cb432b2ed242130c057124be16cfbfdfddd9d4daaf6383f5515134bb47a222b91a2c588f745bf00cd8b587af7d4531bcbeba5c28253bf7a09a55b86d95be42f55e1efb265844fd14932b449d93aa44829c4d95e73ac6ee87c9f8748e4ccc1abaffc53f4f4a37ed4b11f0825e03e99abc9b2114b948d39d20b5c46da7da27b22db295df63ce14ebb3ba03e5c11f7ed9579b4e82edd150cdfd114c1494afef8dc4306c8c8104c4850aaea40c8163b1b2b2260feb057231915be48577ccd7b9d8e37de53ea4b70f782c2f7fd0818896f76ae54c2da6b4105e3d27318b6f89874371ae839b982e1b424b28ee96c13110451a3f814e415e56ac52e10a73468b78cdf6311b7648789cddc1e785391b61c2b0d9abd083a3ac53c77ceb123b7744e3cec1473070f0332209f7c25b94c6a8cd37ad7652e9a6f72588f7d039682fe8d5706a736935fa738bc97f79b3d3e15b3dcac3b864b1a0ee66ab7f90073ea33c3bd7689c71ace385a2490f074d7a72dd2118089cecd1cd0d6700608bd62abfc7cad490591b6e56bc8c038b9081d4f29b47f63ac77f4fde30c7d3ec48b1503e66c095c1d092c03a6423be911930c3998d6235e6cc7e97cf1f56e966c8cba16bc3802bce514253aa0b963b7e528db831130164cf9e2a61b994b0fcfaa1e93158826a438758e9736eae2c16af14d6e12f2e87698b70128e351cfe43cc9d52c1ba679e638748012e23b7e002bed960150b061b7386521613ffbb1bb6db6ad52b531cdef43043410249c493d17aca9aec65754bc4a1e0bb623762a66401922ac6cb23f365021f0beefc1228bf25b656244d3d43b431fc05f4c2cdb7165caf4a82b58a3fcb019c9ee8c418cebb9d700c62218f8cdbd7b1edb94726f58c3d7fe0927cf7232e2065421b4aa1e13122107a7f5f35b89d51ee703cfcf6f4a5205dd7a29cfc3e530b7d79f234e1e96ba8faaeb08181bae942ef2e2cc3edfabc3f280b5cf57bcd086f7647b372dcacb1a95dccc2c48e2daee44e8ad8143bb22054883cee0a496f25138851d6aeb4a31d3b26e6e3f3f35c68073e11e6f3abb22b71c5510c60c1306b595bd1a77b8e5368498f987f2fe788ea4eeb74212ac37310e560d599176e83d2622864bb210d2a0fafe1350df9b595d03e13581fc4fd138915a76d5930e2b71b0ac8b5cbea9f8e2d1fbb358756af743038b78ba9e860d8f5e71c5d29a4d2e23d25db87ed8f9d634504f6e2b12a205470903c5c11bdd2f56a7da7e861a7df1b4a2a9c82527e22976e34e8b36c79422130f300e7856e98cbc1c02991b22fd89992b6baa09cf02f0391fd94a8731a4e8aaffbbc7edc34c21e5f1554f1261f4c0c3490427fdad35b8d3e250dfa47e08602dc4a9d65683b98c692d799adf5a2d5c7ec29985031ca78c811c21004b2c9e7da1f94ac9de542fbc379f2f7b2e1899a8d0acba03d8607aaa83c054c5bc01595c63b68bff74c829229c4be83ad6545ccfe1adc211dfa13ce6fc95ad1bc963936ff0f6907a8809f881ef94a265374ebcf82c50d5e2169b3d643fbe70ba3f60da1b069a76277820fbd5029660808a78ad4909e8a55fd091a7b24d6bf6f4550a7aaea106116090c9f98d6227147de958cace9f0a4e54b8b9515db64667d189cc8f4fb9fd15a0db22b20cc25cb3e0cafaf017d8fe1afbdc39282bfacdf3966a6cffbb2436d3a7e9c1a6e7d5db5de77adb0014621d132cfd6ad2d86c644b26901d1c53876fba030c6c468a482d7cb539c8a210ea60c2d1d5c31090821a9369abbc6b69f5551bd6469e2c87ce011bed7ff85ac315566fe9304f6594a8d11f10d694c4d37415e546600917a43da6398ba01ff8670090bc01dc76925b24a396c8857da29a2dfd1239575ae62ed6911ef59b2d3c8be18cb4871337a9ac453db71c4829eed9640adfb51b264a8b05e514ed2012a28433b8768cdd165198122500261819a4e46d55c0733df842e409c0a3d13336ddd210196ef4bc09a60d8c2c60283f139e2032553177f568b9d5c4c0ba34d36353764d46e89a9c9b0ae986cb5e0b4582cd2e5436ad8f9516a2f8ade1d12a797fb69e3e0cc61f75a43ba0b11c9970bef98e08097f7d6393d96ba756040416bdce207a13108bb5f374fbf968de5fd48b5948773ff61910ffee0d120268fa4d5caae12efe6fa208f32b9d85f42f0844d768d74be56302575422cd6342e979ffb3170e9ef4e4f4a34868271aa2cdf3189851ec4f984a76f07aac97e45716dd570a825f5194a9ec476edb83763dfc7cef776db045f563b374a38b99c5973e359a1fe48c7296828b04063fc81147701c6555122c8f4594384ac3fd6e0faa55fd4e7c7aa101ccd2c25e28d06b341fb04090baed05b8741eccf5836402d6dcd62742580be3d82d5e188e8472f2cbc96b30deb7ef0cd888c55a79d6d4ee80f9081facfad19f5bdb161d940dbc31cec89e2fc0ea60a32ec032098a361e773736bc0f3d797c28a2bd12f628d45f2af62bc177003401d1c6a41f62cb256f68b07906af54beb5babde4a0afdbc36c38f243db34ddff25f74268c2b028cd2b4f4551635795f2a5a6729ba6f7866f079b951627593092f08fcf906661faa8e82da1b632ffe214dffde181cb5da53e42864e98a60b1ded5fb76a654dfdf5085a281ff421ec35ffa866757bfd1a1fbd86b481c426e5b9b1b8a234ffdcab3fd78e353a851d7dc16acad3bfa7b774b0bfa5f26a1f4c656c825a07f3d95cb0ec9774d649f71a80aed8ab8fb38be16f598002955cc967ada1222746f94417303a0d8f24e0ecb7dfb177c637cde2d29e56dca27b2cf13893bc03a981691071bc2e6e751d970195d2de9f47e11d6929bcdd5abc78f679fbdfbc49b92c2a44143d0f1ef1c018ef6ed60b3e0984af5c15c4440941be09bdf9a41b0b0424f0b0cf1d752d921e77c49ddf89e4464cbb70f4267e1e5255b29c855074d8f6ecbc5fe587392ab637c576e3c1bbf9915d7323144c0b9d10abcd2d413afb9869455fec92adb849c4c0200f75c14aeadc10d7b2d2db95422efe9ffd1db29d0e567f38c21e93d9ee6997d92a8789bc2516e419ca21f3ad1c09ddb49fbd786e3901e3f70a2d229a3856bf9f296a7b465f6836eb641421a71d69dd94b40d7352355bc3f6e1702c514f5b3e088107ede1771cd0e0809f27fc0f02f8dc92e21047d027b22744eab88ee3bb4ebc81d858cde3c05d53a51aaf317f9f8863ecbe2a673b5904a18b4fbe524242871e78566d5d256a94692ee6d8ee7cf137c60a6d129a577ec6536d85cce16155723450d4334f5c76418e4959eeadf129192d145f6bae5380cc4d97978cc871d91cee19665a9018e53015f520cafbd63a85a671b3712c03eeee5362a44dd6f0fa73759079f592e57c17d1833d1381e72c3635296f487bdc70b5493c2044b72a4aa2458ae52813e3c7de9fb6c10ef4f5cea256295a6c231bb90d0c2535ff5534e9487f8e96e8947b81548c1df31e0a3e63b22fe18a59438c384b09bfc8c91eaf099e7460775d847143fda1304204b5dd019db757bd841fb474ffbe2b750263cc8ea5caec6867b6f5d9b1e4ca4dab77711c17d3c8b71e81629526124876bf941980a2f4a3d575cb135937b7dd1ab3f824c717135b52b89a90f00aaba3dcd126a6f2ddf0892df5a2794a133fd8e50977887de6645596dfaaa4ee170a97bd3ec151d10894442a8a87020ceb14f92b4240b5898c1ae747d09257a3ba8da032b172c35806d3e49db5cb0023b9e9123b76289f92c128550ac3124c69e0fb60b939e87652396a18cd6eaaf0948a4b3250d9f7a7f053557de6311eeaf7080d1b5c12773ce9f7dbb7010178e8c80b39fca4b37ba0e1dd083e7bfc039fdda49244e46c189cfc72fec85c4bbe9eca9856e0c16f90e98081610eb3324cf3af928961cfce47979dc77d4777fca9a720229a941d93f08a173932c88841d528b19228b31baa1ccb8bbcabe55a20d5cd7a3990ea539909c4bf8e4075c336c93e094d0a8d8f93206388f0e322c33ade5285a07635c4dbef0d25050fe9a33fb78365306865601a4be53feaff2a084e222f48e35298e0f119d9a444fde033bb01761d638a99e405bcc776e2664da3e23c33db8e0761fa9fed3963ebd518d10851a3aad479d867c4ae5d0f0e74c60490dc2ea555e54ccf43740342e20d8d575e3867f2ab4ae21885b287cb5d7c7a2aa432b76f3188e692a51b19282f4d8470c16a1432d1cf1f0eb63d0af67d32a630b6a4d252802303d2826c00aa9266f2eb59ac2627ecdedd54f30285203806d48646ba3c43db4ecd85ad3d4fd9d973ae434753f866e86aeeaee3348ac9a1862c863c4505f7b617e7cea99f2f8f54b5bef6738b56e7f6695197f70dd9e8340e55f7642d37a3aff7c0269d530912d767c01ae4b3a7d03d230f47e124dfd1c9c8a4d84a6c3651d30a37092834c169a6a8912c5f9d20ca45fc4384a44f16f618beb19270ff583c69aa736b974f737d818357d2815b28e7b42f56de0ce18deead612efb06fae55ae3f01ecf72b601714d596de03b24e99dddd581a59284ae67a1761d974a15ca01f517561f2bf22033a1670de82b48e51603adc7faea7ad9bed9447c9d54c4ebab29047fdfed7ee467a3e3df7cd696d0b70e1c73a4cb66fda09129ca02e21383d68b1c0cac201007e74006516add3f064fcbf596a15d9fc6c12a8ba50290501eca9256580724f5be23f76550e64df9704b2540883ddfd466926ccddceab17887362b77ea45e367f1964fdf8c54e3b5f97f02acbc111a7dcee7cb377e4bdad9d6dc914f15f9bfdefa470a8a1f4724fd92ee89b0a36db5eb2f2fe153934307e42b89a038443cf2a35c61fe1049a975e724cc9f4ddbd74f8fcac9e4ff92b39f22d932c48cd13ceaf8e25524e50a99ba1f470dc69ffc97a6599c3d92c0b7f9f52a6808f8e3000d4423ff54a56338b670a3d235476f2c5d778ea13e7df2608dff8a47215403085f8aee1b685d905fd4d3f8fd107c09cf3ebcb94fbf4199f2bf6e7fed0bcf9861230503d595f06a4f49694e3fbd55301118d0c86cd2ab3987aa6f427c8785eb3fd9c95a43a364d7ce3502ddf7181c92323d58a5046778c1c74eea682676c0ce0c92af54e8823ab7ce5f4378bb38e8300435dddf26bfd9894261f864d48d93e1d7319e44af66fbe083d5312f93e6afa2cf2212de6dbb33cf12a407556f46fa4a39c8de40e6f608254b2b700341070a478d1f5387baf1a0147a2757eff710e8ae1154746c8ea415ea7de49eff7ae6653f759fbc70d26d359a34b57eb183538c50e3ae33fdfd0b686be40ff46aad7d5e677f30fefc43d47b3caf1e1868621963cdd757905764b07a7add407ba4f4f09eddf552882624f6a6e3944409525cf0ab750dfbb33c3231f3b3b0916e77d30afa8e5e0297d210878f0e6413fbf737eb13407a768a05b05df5b25c1cccf659e4c2b49862e2bfc30df0ec4bb1bb29d8fc283084606e22c772d9c96bf54511b29742b1edd63c7277e04bea8070e8d66dbac194dbe4dca423d132bed7365c18397451cac29082bc0b0ef05dd767df2b28556d3d525fe1dc2239e73f7500f53fd6c94b2605e4b69161f309a07098f0ccf2656e6eb64f33ce4d33f95297b2d5c026e9933fd99fde67ebd9c6eb2916417fe96678f621b93c2a0077825d84c577dae319181dc2ca5282b7d6d181bee31eb5c209bb513c8c1da70c3c00b4d00607cee289d488a223c5c29a5031d38c9dc7bd4c2c9cd12d1395ee7215e2a0b547cd5357e201ab950e6a97d44a856b16dc55bc74676239f4fe8fa37901f9f9c07db0809d10b59596bb11c03efa57ff42046ffe29c88fa05a8330fa94cf5d9483b850806bb5bf37ccc00154f8457af18ba73449d02d90d6edb243ec9fdf89cdee533534e494d1abccccf895f76f7d94f8c88e669bf0172ad63c86ac173a9a980056f14e25cce5e8993654683e8241469870c925accee6806b4437032a1b2f7f415341c7128d1ea171c566d03fe9a34018ff5274b6b5ab8481b17b859c56e9d9476191902baada92cdc92d27429f53ce9b83980162734d210c85eccf6fedbcd2f0a6710f984874be28857af2050711e7f2c89008bf18d29e229be2dff319ca81be1178f44e8172ae9b1457c2867a925f4c8557c8d8c9ef6d4df5ca4d4a65694650994b10a94506a5d389cfd6151e52e8e5df9c725eb122534c3043ad983929850f706d64e616ff728acb08d78bb3b8ef039a5783453e3158ca937e4033eaf51b0b80c80166f9ca46a568b3afc523c3328aeac1d8c1caefe88ba665f420888ec509cf75488410288bfcd8d6c87e758794c02f10d69e3fa1bb05dea93fdb3e7c123d50c3aa17e913e39855aecd4212e9d75b4d093da8c36de252d8e8f83b9b8754a8ee67e9891f2321908549b63f4230d44d7d67e2f93cd05b93c48af0479946e58f158f6b37adbb9e665bc0a89cc9df9a10b8e102926995fabd2e38db803b8722170a6b10da8f7cd25b0f5aa1a6591a16b1ca72774cc9bf392ee0a02c322768f23962f2a3065de7df48ca7607b72669a624e88991e020ace622b3602b5bc277681820f77cfdcff42dd9713a0db3adce606a4b738a75396389bfe26661e0c2d92d88156f84cc279c693710ad789fa8ec15b0d5a6a1b37e08d1727423ecf763aa14f87b17fb54b37266143f89e2b1487ae255f93d6c3f64a5232c1475a727831af4e1f126aa74b90837746dadefe11c0ba5b1d34aac5ddfa77bd0eb2c766c7a4f971302157db2e611d002f3d044557840ec08f76b7ac5979b0c9b3b4632fe7879e1ec7d4c18414725c495953694a480f8e0aecfcb18c6f79806d37a7ae65328a90059b401dd3c792656d46d31949685ee3db6e0be0196608696120542ff8f07df6e94d486fc3a773459c0e2158b2ca3870a38eaf7e517a9c79cbf4ff3dd5143d32a37c433be8c49bd731f919b8b187dc39e397f493b7175b74be46216d098483d0e71c125a69fe4f8d1e9ca1e4e1e67c941087984623321d8bef84be5156ccadef8fe6e20ab460ca8cd20c6fa06fef8938de54db404ee8bf54d8d937ef3a5e0eca0ea44efb2d6d7631ca2cda179424d9e8ce4046e56881bb17259963f08f499e20178b928abf20b65bae7bf2476bdccdc526815a74aeaff5902f6217625b93c6631ab69a38b547f675104c656854dec5edce1f7e5c726711efe52b16795ac05ef8bad4481d4257e40a9fbe959fb56481003d368138b377bbc98162295ba63740c463bc2b320b15356e1ddf5c4bbe92e883fb919b8f544ec5b3ed3743042a9e2d856d9bcde72c5d603c02fd54182ebd91c24437f4b17d41336a910050526d82f85db029d36f6adf3355be556ef596a99cfd4b6052df9f5f923dd0b0ce7936432c8d125fc464399936d05e33e7702cd485c3fa3d2a1276a791d85e5edd0e0d0ca31f250612c77c83de196737dbc4d2d001bc1d0e49c562a117e5d1d010fca26eecef8369566acd5c0b9979ae20c209fb63c8be995a10069e130299e2433fc3614397cee7706e05f80be51ce82aa93d3d4c6652461f3bda7d0c81d970a186a994ae433235091ffd4377bea25a76d11650c7005e422b949475c8ccd6abb5f4bcf350ad44ebc1654c6692c5992107bdf2b5823cebb2abae2a631104443ab99be15083a20a5f657c602b5cecb77bbb8c2abceda575e125010d47250f28e339b9a1f906af189d5dda39487587933fb01844eefe75a1b7f8f6a4f0c5f6f5bfc3dfc0cc844b281a2c434d598ba2812a168b31f8c789c5c81f9b478dca7efdc673c2087b2dd707e5c7a5d3b104d03a5f5f2c69e4d41a5395d1bd7f054a456f0f4cb3b7b9b0d5e55ae9c3215b7b2e17acf992dbe99f9501b452635d1d4151f8c5af1f57bcbf058e999d495517c4d77fa5bc96eb1f922b9aad3a6aa3187a5429aae7645c86c4184d5394b6a4752f586b96efcdd0ae5a636c4a72e01d9605088a160e8655acbed6595bacd401b629b1d3b9c0b48268f59b19978dac2fbd09f3212525c5256e59bddae224e9dea0892d89dd747c1c55ebe087d4fe03b1bdcbbf0b202f281d6cae3316006482e7c8697963c54d12e3bf16d7f2a4d38ecbe3923e231c64c1669f0713a32055b7a93188fcba8c5ca5be45b1e60c1f5f62f748b76d9740bde1ea8758f6b1f6909b33bf63e33f4c5f3643ac6c8cf8c310ab0b9ace9610906042d39a1a51adbe3e2c476082ef78d628115d698a24b7cc930861b25474ec3630935cc033bc047db18abff5909b97c41149bf051752631fc95882b9fb173143b13daebbe7989dffe6ad76bbec7adf246afdc2767be48ae5b5045ea55ea39c47b78e1705a69c8ae17915042519651fec95cdc52d94447cf210b6def3d1fecd9dd5d6296d712d13aff1709b3f48c821e3bd2dabafe4ec6d170ea138ef24c93c5e95d975ebe01952f2433c31445f592e45f7e6139cf55bd93df89607954587d748a9dd9927fdc510bda0f416b1f291d6f67c1a41c6a24b39a837f015d4968c6db22a9e8eff1bf8da447088f02159f086af89fa7dbd57fc386b1a1f3a5434eca9ca79c308ba46ada51f38d3b4e3de4f253089aff35401208de8da9badd591e86baea30fa803b6a9bb141cdd7c9a53e19fe9cc7eba58a90cf89b3decf1243f5c38065880bc45faf9b15f9748156ab13ff8f7794812f6da9a179b696dd4c3ecbd5e6a57280709028e33fedec6035770ad06134f2cee293a06894137aeb12e04b911d9e1617ee0e4786337f054cf690e35a30e999834b25896291f977f0f071bc8150a195e3e66880ba5c64fd6ed1db4e043f43d63333fe80a4983c5de8106c6f5c8200f376363723be636d761ac3fb95b34a75f77d6b2a9d25e83bdc9b604f509927cace316723f21fa604b2516103c82f7811a79de7fe42376bb890b99a3aa45a47016e4f8a806865a27e05fc590d21659759dcc305a92c0360d610e1489b2f1fa7fc6dde4efc374d122e58899d0f68c559e8e6a426e7555956cba924907ef9364ec54df289ea75dfed704e3c974eda585941d8b1e3f9c7a108ebd433bf987c96c6e8a13a8a56ef62916482f4c09627e07b3f91d343341154035909d334b0a887034418bc1c63c7b60e12d1895f49666d1ece6b8ef2db1bae2d6879538df52430fbbd1ffb253df561b0bd098c3a0f5e52b58efead0d495298a27d9278bdcda0aef4c1fe6c8306bb40256cbfeca1a2946c25bdefa55a5d2892e92142e870aa6cbbd19d9fcb682ad0d2eb7f09653d5b296ea06c72be3ffba8b2679a79645a27c5934f6aa167b9c838b3891995d5d5ea1abdc3bd7b695687a7729a801b71b67c0847f2b22d97b89145909d1972629d140bd0ac07d8906f82cd69b1d5952ea865430e874b5714bf4e3c3c411eff942a29c7ea6cefa48777e8f14a59b43056848c75b0b54767338749bf92e9fa7653a682a1146a34f7bd92095ed6032b15a7655bab4eb841d1ed6eb8ddb9a0c1a142c90a713b7155b79a1840651dd895d41bf729d813a0795635fa56ae117313f4c3b0e75c2d61e84087443a690a6123cbdf91452ef4cd3c81b78c80f3208c4ee4e44d862f463da23f44c21ff4a2fb94370fe87dce51659f35fe2a0c039c605d68f08a5497686764b6408272167aa412375e93016070f77ee017a5aafdcfb7e4ae2cc5fe37027bdd87248fa2af5093f2c91d7aa90919b26041971c0e99a6031bc09b809b39cf5bb287eee252ef645e44a680574da4c9527168734ca55eb77c25e6d9b72ecb2e1f479421efa67e5afb541faba274198113f1a2e935d8f5c6725dc451a91b7a4a1c159d461cff9db1f819a1033a01df6662b601a35d33894d368ec7c498fba852c0e8ab81ac60e53a660dd5f656cf608171f4acf3336c4ad4b39268d4f95f6f56749324e56ed65a90db055d4b9bc05a8c34812cbefc9cb0211481948d4cd923c86400a36a8723aef2da86e65cc119a1e7f2f1162fe701b07ef8fa31a53d84a61888f21f8013dc1694e46f8f708894a68e8717191d7600f8a6e83ad12a3e07d8e4d3009dc24b4bdc09ba3d7f55c5d4c40d9f6736be371cba8b07589ca04841d8ff2d56046ed0340cefdf360e880db699d95b46cfec4974b901cf36646faa5faf4372ba117f31cb9a18f044fb38ac5b657a4153d822cf00e6aaace72fea169afa535f3d2eb99c959bed37c171f230760d92691de209ce1df8233e6e7bee7c1447f238ec12c3f6159a4907920e8010ea80425d90b0e4df3dead30e57049283967185946ad3c3c7de32351e4fccc4721d291a2a835ce56fcacaa7dfccd34188410130d50423d8450cc8f3cfd6ed0834920a3cb82904dc44db87e9c23fbbd67160b46b4de8bc9ffb150b285d1bee292cd6987f3e81e86750f1c4948d91334c212bc244ae20535b806ec8425b3649e003cb507b8538896d51bb38103f3eaffd313c609b96f3eb7e5bc390d2c7f1791dbe3de997d9fde45336dc83eb3b32c5ae764fbe6b518e225555fbd81cd6d020a1a4c155bc6f804c91eafe99975b1e6cd92fd4b748e5eda6ead8d022deb38efcff1d3aa5d119512ae9a3157b1adaf835b92df2cf35f3d789e868564477d4232772c407959bbee673429e926802e971758952e9330bbff86358223e7712adbdd1208480146547f1b0da0c509088f0a33c2034e4bf50dfd26433be487b60180f0c6b4ce4439fcd46fc54bf4e54ae977d33bf2dcac5db51c4129dfe4301accfde26dc63595df77798faf0d85471c39154769558044eebbe5ec22fc1133df80eed4da7625173a31a336ed09f0cea4d50e02d540390bb8a4852e9147c55fd83c31cea0587765bc4478cefcf93b31ac0d7b495c2eda25b1c30c230b62259ccc024eb3b7c98d3cf41a13174d4f443be0cbab7c23cdc980f50c117cbf1af332289cb412f8c922ddbf8076d7a8c7684989f773379e665653d0e48d3b704e511f3ec4d294e429cb775a9406ad3a805eda55f8d6a83ed29f37e0d4ccb357e6eb5578db4d6a2d147b8bd2dcc6329a0b0faa9b7d8566d10e3d07016c3889d329e110600a635abdd6405f96156a731995783aaa4553056c3358e6ef2febe4988014dde63559b8d0986ea6c1250c08e0e9881854ebef40af954cd6e1f623c8c445aeebcf765e8039011010a78f940b3e49d06caa9a9eda186767346faa6d29b7022e3484126c5b60a7e652c727642e216b5080e9d7c35f8c55068b63cf9de2befdf3fa4fc3a85e1eb83ce60636261c9ec32261ed947e189da69b9fd6d79e49ecff0e46ab249e694037eb26da2ba25f2bfb943b16804a00fbf5e766fb3bafbcbcc28c83a01ff769b93c1f8af99e7830056da13faab5496cbee1bd1e24bac95af4503599be176da4f311f987513d0a04b182a6135627168b61b7c46f6a83560c9d105d62239db1344d33be71241ed69634a21fa311cc71d2688270259ce9f7f298476099502cd9db7451ea2852477aa40a0689efdbd04cb22f1628e190c5dbdc70a888324a86d53b6a21d65f55bd3813ff8a47ae1692596cc06bf26cf36c34657300798792d81eb78e3b7a62fd5a312e61729cf1b8bf6d912fb91bbb9d0c885313e83055cac8d71ed9b321d999f77e14572fe430fb7b9aaecbb4af8af35af029e11cc066523a6744547125c047104646a651c3943afb202c272efd24733d84d2a22c317b58c300f1f25645c15d07a93303e01c3edd2935ac520e0efa8841cd8c44129333a85a3fe8c46f9e6fa23ea5a8e956aa4b840fbfb3727cdc832735ecc5d58a2e9addddb667c7c421524f589e0409b018af3aa398c7f731530e96629742cbd36474c07beca0b7ae21beb4e3c963abb852093d72f0985a96158eb6835beb87e7e36a6b79e7c3d85542b669395274ba8a50c7b20601d84eeefbe83cab3d519ef1c45b8d3ea5c93b2af475b7139ae118d3f42964987dfd359878e2658561749dd33b29673fa0f543e03f1baf85b9862ab1c7b2d7170b1e42af5c443ff40a292e00e3ec992b0e09aba081e506ae9d36488fc44373a62e0b892cfabdd133983c6924bf8609554dc440ad6c1b8ea66fba07048197eab4aace88eb659bf93df3e600ce87f137223dce99b840906906b80acf42de70bbcb37ec0a25b3016ce957859182964443217253d55ba515807e7e689d732c3d18b1758c4b878a2eb14bffeef9fda4684bd53043eab691a104677856257d31de35f18016b47996d2da281f7698ce17203b13bca8d40863a24d4f458995cae752116fb4bcbbe236e8688c7625fce569ab8a2b977047a90f84619c67c4a60c386b4f1e48454f76152035e478730d96f83f4ae4c45594690b426b6a35fa8c281d69d4e0c88756384275159366c14783828ce61438f2fe358b2ee5e628d9855c7da68a41c2959983362e3d53d259e0930926de02af2aaced173ed3c54a19d9d0a42771a337dbdc0ae43fb4a9a67ed5052e90903e0ec38b2a8aa6447cfe9f4ce65de0212a168970f5f7b1fa69a32cbffe0b90df38b2beb6c4d06cee44c780fb857a9388a05272a89d57c3db7f4507a13796d5fc8360dbf99dbcee962e38f8458544d95ba7408b9acf332c9aec62e8dcf4034f8a693013ced086b0dde72dc55838c6e15a5f9ad347960341fe7b1aa7ac6bd1de4ddd2b835b26358cddac81543b2036e8e5ed9adbb71678555e5ce0ee30ab6e0ca5ea524e9602767c7005e4c08c6ff4ca6d3bc67ed0bfd9dadadadabf627084461078a210ed894840ab1f6aee0fad284e31cba8c06b726e0b5a97bc2b55713082276a87aeb3d4875e2f91850ff85024c563bb94ede486de0ad3bc9014a1501e607d95d5ae1ac36a091b0c39d376a0e5e629dbf716009c5cef245f6f615a69ed39d621284bbf33e430c96879ff58b3a6a1d395082e8b1280fff2ed333fc2da9800540115491bc965153201be6feb79cc82ee29ac8593a9ad720c1618060bd1a72c1eaa3dd3eb92c08d14bad63c49d41c3f708d677959f046811eb92bc5f6827250bafb4bb81098ac0cbd1c8da5260dfd2419e69af344c2b44bc95709fad7a4b03e1120c6574299b581d398055c1c87bf767b611aba04e892bce687714bb14faecef9371c68eeff979f2b22847951085d36de3618986756e0680f7d403e9df0e54b1de8a04f80d51b493bee7da9c81d0f03509b2079b7253f57eb9055533118051aa520823b0b1eb98c6357c4325d77149a4e7a497f5dd7b45ce1724f6ff186488990bcc1cbfbc4082e750e577fab0486b92537de98bae465aa77c40c6ca9b488f999669597c4a3efc79897c7556a58f9b9a78278b2b120ed9ee11e3278f4b7693aec71da20ca55680c521252aebccd5fbbf1f00f37456567641e758ed5ec183f4258c5262d4dc2804ebc5dc5e82e698013fba15d5d844df123851ec1e11c8f593b42df30d95e1f19eea7d77f52afdf249b84d6f56d330b01d780164a7c0941c1f82712e8a1dde9dcd0089518fd30da587271f444aa1d2d720d71aa7bb38619360ed48a0c6a75a4bd85b1efff09a661c3d2dfe56b5e375f5bd5d0c229e6610547b9735af9d04a8eb8daf638cb02ef845b589906a514e5f60e0ba625d3d86ce02a957870a416136d0126ff6939bf7ee5efa285ad8f6c20d43cd6e9b4308b6eaf4010772198d1ee11ce7c8bb3cc26d4e6f04745b35eb2f2396db136300470d13d7045bafe8690bdcb72c18e4ec68eceee3dbf20014204b032529c24ee501e492cdf4e1989e8735bf76a13eb790d26117edcd4b27ca6f7b145a883a11c2934a498d389e8195fac844d540d9ce32a21eba655fa73d154272b69aa6d5e077e4afa76c069886249bb32d7a0cf6d4ab5a91f4e1e43e51cf2dfd83344baf25e279b2742cace4e893ef6bad40d02d2cfc9237d4396998fec256814f7633104fb826907c0ee7eb2e2114d67ed02834a7a7e714d28cd236b73840f34c4508912ab5b6bf97501d0c20f024b8df78a3b45875b09382b263857fe8a0fc7cfb0075368fd8852882b16794ab9f4293627df69af7c6ca315c8ad1309272e1d63ba0c64ec8ee6e51714757b5f332a20033b5f9e68912c0a898665cf9ec9528a5d691ed92d29009749b74d814243f2e060a585e5c58647894586e78ce983bccaea6daaedc2481a12f177343855c33939083e0c84707480a2a473939520a506b4d873ddfbd0f473167399b3e8cf122ddf4b49408d64957a578f7bdc45234cae82476e1199e19925eb377664d865269e87b8c4e819011d9d0f3f150d5b28f38be52f9f932404059110df2f580936625e65870f25757d7cca1b4c6c913d39c959c2a6626fcf344682536c20e7e2d17b811a43547ba723f6e26603de3da3a7e48142de8b5eea6d247a8b6c476d9f2960723be8e7bdbaca69c3e1891c7ee9b28dcaa1a3af75b83032a36a3781a9796498f32b5b1250db844e78c9cad3febec6f7cc05ccbb219abc82c8d02233f742d00e841f463e9b8bd901ba844ef4d7c36bb076f56e917436e715d338b1f7013ae934d99ee192255ad0b0d64ebe1250883624fe0eef85b93f06b3421a8040163fc766c5392f5b610cf38dfd6e40fcccc85bfcec108718a565ee047b9eaae31b889ccee0482eb258863edef4c48871a0deefa8162c9e7de4d94c078420008632f23e5c74944fffea2a862be118945cdb417e6d6fbb863b8adc37b1898823dbc69da4bc559eb1762ff9c00ceff8ca327161df6e9cfd20222582a3b31142216832c4b520dc77daa07167211c10f9b01ee1b4d005b21bed00ba36a95dbd6d217b1b638323a6298ffed1a493463bee88aaa61b7031c17397cb7957e152ff8b446bee20eb0da7bc6348c37533b0b37a5673bf7f42a752618dfd0a821faabce354110b79a5ab9bb412a728ca9254a8c89fbf4b683cff16046ba004c93c4452374de8039157f046b870868bdfafa6c042360b791e65a6c50019ec5e7b6524ce4d4cae4f48b83904f478755d058ebae899a826c3840d4a329cd96faf78d712bf238c5cf35524f91e268b2da64e4d0bf2d9bfe83fe4f1097108744d450865f37132dcb0e26d5f5cd3c9a36caaf3e05e0c465cde87c6bfee7ad42e8c1d15bbeb958e98b21f4e019393e918cde368f24259cda0d119f8298dc9027d05670788cbfcba945476413616bf5169ff71131d29a20234d7d83a986b51ab150b3aeb6875cbb7ddb73c65e861e7a7ac4eac149a5d243b306882b6d3ac0ca9e80de229e7f7526d79b2d9917476ded868ba22442bdc7550f0bce745f1dcd4965a5876f1e78f4abadd98d238f4f7f8d0edab8db43258ba8c7ce039ea195e7dbc2841b40436f86f4ffa4be6aeaf12c5540fc1d2b6e603679d9b629b2e241c9de6cded5f5a4f1de84c171e448542bdcccef1d6659e6a956c0f6a408f812a690d0bd6829d54efa291436e1544e2b863410543878caaf58a15ba3c959290d2aa03c8dd892c6cf019083220c3bb648e544578c07fa864fc677457a418610604591771a046a9d3cead0f7c6cbf0a331dc3d744cdf842c94438d0feeb113381cd182f6093502fc8a87ab047d4f7eefa29023e3b450befb63a188199e96c3d41160cec0fd115f0d4849c111133ab9d75430c6593c690455e00a96d19481af58f3da37dc111725138a3f97eecb4b182ffe25d99c317a684ef3f5a209fb05ff5f21ed1ace1c6de9180a5dcdda11870f3d94750438906fd79d601f826c6d644e7e5c17f8d302073f05fad8023f6600c8a811b7b69cdf63703dfd49cc8aaac79e809f5995fe4d2b0a0c3db5f48ca44e10d9f1637e3a6bfd82d11d5f1773c6a7a274f2e15d7f00f3295d7b53e17a054a29b17e23f35699291344e6bd4b059ef0a75a731c3465915c6467316397cfc83413b6663f8f6c2d028808e16c5d8a28663f74da414d741224b212535b762b050de81c7c2fd25be9bca7c4db38b420cfccb6e78cb952942a4cac6efe9813ac758c97b6656c7ef0b2e5b7889a4f71ee3a3269918c5a7ca95fa9b4a5f360ebecbda1c6c684429887ce94ed6940378dd9f88b8d9c90740488fb58a21f818d6c13b63836eb254ec31f6ec0e16872543614e8066098f10b13143f1f91752047a8ecfd8c7e343a929ad5bb5fc75cde140a0877e3cfd4787cb6b65121fbc25ea7f82a3bae2a5c364b10debcd92029371335cbec96d68081aff0e7d2b7107ccf31d4ad015731eaa4047fc717c8219507469882b2cc58a614947d5a8eec183721fe697755f9d4ee1535a1f42574e79852e3dda8c0d4c51c5bafa226d90a632a87f9a9abfe34bbcc4254865252832e32619f85fb865123ef8584953dd06c8288344c16d082b9702c89bc87ce5d4c6c93460d9324a2a206b0e534c1cda828dd61dd15cd3f5c1ef8670fcb9ca85b5c3a463897e377ec7e4ee94e6a558fe3f128d6f7c91001db96e861bd1a755b35ec0520f935c98553beaea25d351f414a4ca15f0f91a1c17b5a1a3c38a92624bb5519221e78d62a4bf34bf8f46ea4af2bbaeaf5b015b0bf48539f3085a22f7b16ac8bd1ffbdd1b6712e71e3a69923d4fa0449367c4eb045a379f3d359fbe9ddee2761f5f55e424e1198f479668efbe1fe003cb7f2796428e05ba708380f7661f3ae92c161e2cbcbdec5052b942cf3ac28bb9609133e21b24fd4faa24332031857dbcf1293813146c174c98457ce2dfdeea808bddd7fab627ea08c3c1ae045639b0159939ca58d2778de969e09bf77ed0598659779db9e9e673702de6be782a192c8d88d9139c24618e0c90c6f8143a584c1ea3695c8a50d6a39a00d705c9d97009fc8bd38d05c04654668fe25102bb25b0dfc7bc98cdd28f403ec67d537105831a7e8a1a9aa7b4ca46ed8018e3b6506ea1745c13f1df37a34398dba52eb88a2edce96eb9bcd06fb3266898e8405344e13f99b8638ed1cd4be346d96db17e49912b0dbe86fc50c2776a6bb70726c25bf067648a58ca2037beb059fc3e6e39abf8eb9d6c28c3ac73dedaa61b7ae79339b2b0ad2acecda027ae7f3dd42dd95222726f8cb2480cd644ef9c47784cbad5e2b38ecb99d0e56eeca45fa4d32e3ad67066ebbb5abbb92fe891011115202f86d21f9719e1b98acc17b880bb59786d951d428289baa5e3471927ba51d87076558d9f58dda687518ab4d1a82647787c2445fa97980379728656e61eea6f8d590d21cb89e0ecc0192ffe48c33ee2b12cd0aff51b87e3b1d099eb92a0915989a94dae184e444b44586dc68d76cecbdb9d4b3298fb7a61e85c57097eb6255d30211c15b80ca7c8da7cb408ca107c372eb19fa878e684d0ccb20ba490f0844009c7155eae614ed146fec34588a9022892795dd5f064c4280ae81032c1ffef3854745067a45eb3b3732c779bd38e2bf33d10e81110c02bf1649ae4f77774fa11ab9b0de9b89fc9d62ac491b4dcca208d8748f8893f30c707bb1dfac1ca6dc8ec3b56e5f090bf1935b872ca878d88945383b2f4fafbe1b95553fa94e4372a4ea734abd24c1f86d9891a9dae6af6c4829f67c6163efd1fce39fc2688b285206b0acefa9e00a978b4617f98e78b93adf115e9625c0bfec0d3fc24d9d5cb3153345b3456b1bec3e44572bb94bd93fa253688b0366396358d288116a1fee12cedb121ce91c164c58f702c248ab531f54fdf7e6c02d0255bc141c77155712b67a1d43d1ce8660d66f6a4f3ec877f153fb2acc1eca6b05bfeba677c469f1654154be1a797958202b6f053913ce2484d4e7cde1067a056c580ba76f92ad9d4b1df160bad40283f94e979ad05edf165e984f518286a00e2c585316131cd4be3df6bfe54c2e60bbf49e5c635707220454da2fdb5c43431e9f9d11e0a0654f6e5fcb15ebf1469cd96e75d56560b12b424c2f5e273ba8320470c639fe442ccd0baf92ae8e88c27ea6cfe28541f52ea71bebee61703df97856f007c7d30fc5babe69e18a2bccd09ee29120ca037fc72110ea686308cb6de3903bbcc9e36adb5777b8800cbcc8dac7adcd38115e5628eececf9cb96623e8d1d2ddfb237662bdef45d6331aefc3705b22e9d2d6ea67fa280f8395517ba3e546eed7f160158d3a5016ff9faa620df9ae9fa39832b7b206d2fbc8e1cb1fe4382ed3558eefe1304622df62346acd08ad353fedf50d94c562ab63531efdd77781551a8e2fd59a7466b53a3412c10991332ea1ec66e2861faf0c801124be8b67c9af283faa30cf14c0e1645903deda849c3de71cfa3573547c8cb8824f9e7c48905ae6413b5c4e8e2a0c42c718e5a8a1bc813b3f9b019ba816ba7824fdc61bc69bf8ddd63bbd35627ac3ee76063723c6c0937e71a66266053638459da6478bb2c6cd825ee570a2cc894c71eaa507fd2bee500761ece5f53d850ea8aa5502551dbe9aee2cf3ddc59a1c3722898d6b1b8c061f657d25710a6dc214e32189bc9e8bf2b445b8d7287244b3f98ea2a89f6f535dfd718d500d448e8699b070c38fc07bb8fc806e7759a3a502fb292a92353a641e9e7d544f0b621c48e0f714b8035718d949b960c87ba2e46ef8223ad5c76f1e8c0df5f0eab85908508f286b1f7c46cf5510fa808de99aa7b20916bbf4f95c1cf709126ea9a8f6ebbb8b6518bcc3d520468b7b0fbf3145984606cb804cb49be2e5a2a7f9d602ab7ed5ec0c05014cfdc7a209c8fb12f64df5766ff5eae223f1c0f0c5c2a34716df9a150dfae4528ced805e9e4ec4b236e5f1db15589693e69d148dfd0f5a6abe80819479df874e34393dcdc551d7c503be1c1535dbfd83a56d8dc0bf10559f673d04e75540293a149d3d332a5830057f06062ff61d0f2d03ec08be4a6375f214aa9a1485ef8d21aa89efe6b2da4efaf0e3b87e18aee379b61a8680f2fdd49cd0b0d292f6bc2934e7a1f83bc4012b06414bbb3c2589f19e9f32a1648b4384b754fc1a4827bd9e33f89a3c75e2c400ff514946983a197c5e7a7e391176abfb76a58d1fb731c8d9e8a21006450db8ed38bd663dc0906abf9e2e2475f3a3fd52a7c696a7fb6a6786a8211b4120fbd76537a0f6dbc35a5c58ae95ccc50a153a0200304359581d28168189674fa715d5396601f2a43222e415a093941a7c87da7b5345d22f01b30aa94122ab3cb5a0ed13fa0055843c4da7e83cad7172d38af60b2243ab9235acc1782ad2dfc7c2944b16cde202a9b8fb15b1e6f800486bf12b341e102b2612db16b1e2a578820acf13cd062b60b4444b8489bca0896549576bd3237efb998e52e97012676b72be3f5038436f2b135caef9bf70d8313db3d26747e88da7c6e5002c3511bddef6eacd9b7fc0a6d2c2ac611f4ecbfe78298f2458d8f1a7bede502ad720f3b05621590d37d8dc694335b16b5f057d6ce2f60eaaddda3a4497e759bc96f1ee34e41075c03fa1b449fc79be18148e9d30ae30db21d001e83499209b6b0fe8995b148f9c2c7d55cd8f8876e4e162cb15cf388c3e254c34aaa572798eb412aafe65e6ddb8149a2caf8e103cbde0173eaaeab9a629827c62f1dda0eff6d86d71578cfe4dad18fddf0d98df0c78a4c6b57d6c92957bba48440ff3263b3c7491ee66006cd36c896e5c71ce73f3324c763ffb2179324da3ace1f07186a327035b64a269c7406d4e9f77585b11d8e87726e8be5d7206cf3a005835b641ccc9391dd1874ea316149c402377672ca376192d2afc846d97b6570b338fa43ab8985cd2418dc983854f38d03309206ba8de3eaae32b359f817b7d780e64f35c73e82174ba0501204560d7ce0171ba3bf3ebeb2ba9ed72ef95ee90bd4c3677a3d7eb09b0ab013ac86a130e71dc65e37c0f9ed49a36079ed94cb4e83bbf355a376444f3cde83384466b707dd6bea5a84ba11f3b240ba513db6b1da16372853ad9171f959714b115e4d18852fac41e356efd7a33320261b6fba5d738ced468f0f4d47027ce547396409b5e1b802bc350d5dae8a702c4953fec8f12f042778e32356f39a8817e8386de9f692fcf5732f0cfec41b30a7a7c178e698c1fcf66e3eb8cdbe891fc81d4f053fe9465e8cda1f85a665fac713d742e414825b3fee0b53f755636a0b98f53a514f079909be77270b8e403fabca0dd00ddd72745d59695385f7ccf885803a52f971ab945b6c029ffe9e49e1d136f5c7fffab20eb3db6ce4942080867c5e871baf6d2b79d0ed955dab6816c812477e384539802638bd78b38c5c6e441cd072b697f49c2dfaf8d201b208eda4b68d8439172be948a50cf939922e068617b914ee8ecf56c07935ac621ef1aa081b8a15326012878bdd3a7120feeb56f92b261940acfc0eb2fd210281e161261c47927e4f88a5c9f32d6bbf387789483d0af2d06e494f9ce25ae6d035a7ff879e1b99372b51d418c10e127f4c7f0486a0c9358c3ccea92feba60d4f32e5040d98914e74f369bcfdbd1c47c818f82430ddeeb101fbd66ff9ad63631a8caa42dd4d738bddd27a5f74b774a2bc41f1abf197e336ecd21589a47da5c39b35decad857bf2486794c610f3f348e6ea178a56ff3f7faa09e93c87e2f597892b68dffc5b23e94017a907cdcabeea34803f8abd2cba2017e704209adaf3f0dda417812557125f0259fba4458f4db9f8a2aa9b4fd26bdd62203f3e3162609826877193e1140602d654a6fc5604c0d6ce85d1f11872084e65d3874cb0bf2a68c3f1fd8491f4da3a053e412093318a3cd9bf0e6b0c65367e5a594ee495e0c98f8227c6625fe214c8d1f1338f01a58d72c5b52e80c35a6e8c1594917a4bae3a97d1a9269772595731ee2c69c041faf4b36ecd0d68514ecab518dccfa80c274359d94c59cc43f78dd66a0e647954ee70f98506a9ddb199bf00bc431c75ff868edf36a1470407a04680d01498b9ca6874b549c0da6c029ea251f545c20d2fb39823423cb42ffa408400fc3f0ab83277e8cf4c4708111389b7f0ce3703f1451ff4d4b21e396c83530d72f0419755e127185d5a81a865d3c21c6b8b0d47922f9d35d6d4dd351639ecdbf01ccedac5a53400d47f9afd060726990b3aaf7efec17ffe3041f1883e74166637b17035456c947c15fcaabefd8569f32d819f04413e10b9064ce9daf6ce7cad5e50b2d79623ab76d767cf94276ee5b74744a1bb64c485ef56ec7d84e513bfe93f1f9754a003c75bf936ed5a3cff52c9d27be7c96115b706405fb1288d241687ba9a7ed1d231d997396c66763e47c3f0a6672492292be73be5a9794d7c0bc54aa0ed18c692d5d62e335b056eb59013e7fd774214ce14aa597197cf18fda961e80b9be1be84d871d2b5a2119c5f79cd54ba43a5cb364c741a755d76b5d3305a55fe19af4a5ad800b888b05a6fcb904a027dddaafc33f230021270102d2cd9fa10d994d38a54d3ae5b830bc326605a996faf41b52e940eb33f71b41b0abf94ed00beb58dc9588c052d85472056404470094c19520a67baa3e3ca937dd5b753b7353b2345a38167555868baa9ced3ad2f6094946d9dda0d1dfd2af81eca0a2cb99f554f57f6e3eb7a80eacea8985d0169024fa1c085846ffb2e507763d2ac6391153eb001113b59b0ef6c886a18bf9b7d30a3527979466db6d6d58377d0fe2582cb0f46e87e45e36cd627fc6baa848943e9ffa08cf4c9633690ac439c94081c3fba332009f681820aaeab9754caf10d9e2c3c44d8cd4b1653a04e8ae23fecec0727d1c1d9f4f94894857b2e44d95c391484012471a3dca192b7acd6cfcccb28d8dd46bdfb467c17f0ae343b72ba0a0195ae45c968e3b908b9b2adb9c313d2a05b00a0b414a195a24b945fb413e053e72804bb41b6fda35f4f2911bcfe8767f54a836b89aa39b1c1da76a705f1cca2b464febc49d36426e2a8478c84f7a97790fb5fbb1947cef32d7731f6ed3ff93ed76ae4bd64629fb5b05a6806aa59fa0d897a76ff1e874430af2d20b335dd29634a64a87e56f6bc23da2d62cee95e8a91ab0a3a77ad0962e6694fcca627abac6b182c4bf3834fab8535b3de36b7b59292eaf1812e593b380f57d896dbeff7737cfaf9d7c7d7f186450dac870d5fa6632afe5165841d88e5c41b27885ccf746d71e28f0fcaf64849e4a6fdf9033cdf32a93b7b6a9c77ec5a5533c74c7825465abbb24c26731084290f20f754ef163178bfdf8fd8c4eb56a192621613214ca9572bcfda876eaff02802582aacf87e0eb6a1ab41efeaff784c86a684604c343c9477afccbad2faeea1f74070fcc6f6d79aa777c6acc98007fd692c32ae3fc32d6ca8dc918b6a46a2f750476616195e76898904930046efeeaeabd6c2e9e7b656b865f1fe9e6eef1409c9839b28fba15f813f03c038637ea82db3ad41bc75ce41625d51c7b42a2ba19b3eecedc3ab3ce765681c91af53dd9455d7eeb57b4a5868e3393e9881957a76d929dfd6515d1d3c344da9fef37b5f63689819e0cfaa68668f6969951544be95efa856a3e80861d43323e2ddf8e7d70db43be1d1169036c270a086cd39e7a5b91c24b3d6f114bff1645c4cb321011e407ea26a139686cf9d84d7787ab4545ea41f6ded2d967a4817fb512020abcb7dba99f97bb4733a1696ca1e0dca1e284c370cc5f4f870ed6e4fa57bc6713cf1cf0ac4df164d1cf76b28c687010d8bd72b0082b5d259b7c5849cb5312bc89caaf2dee18409cd937ffc831936ba3167fa49fb8baefec9824d072d7ed4a381eb4a1547f0657260c866b165c8dc17763aba1bd9850e3464dbdf4dbb548248223515db9d21f80b3be3fe4373b899af54fc2bd0d4045ffe713f3c5c7dd5a4e7571cef4eb117739312dce414c1cf51279535423bc6b650723488dbdbc179aef6b1e3a52e52f9c800aeb6bf010cfa36ef463b683b66f1f43c1bba4ad680fc89819bf0a7a86486f394caa875ce4e23e09162aaa30d4f4e6d77bb2b98d07af216f501528a8dfd0f29744e0b404bd49256da4a7c2570158cea5f35111593c58da3fe1a67f9256820fbc33bb4e4696eb75758a0ea8b7b8e51dae3f37d6ede4a4417b241368215817f2df1e1f6917981292c6cee9aa90cfb428d36d9985c87ede21289b34a5d89d60c27897716019177ef27c02004b68755d56e5e0f66865be976331951700d0f5802b8d74533799e2ea9819f78bdc0237315e1fdbf93afe76cf555bd70bfb02c12cc76f4660f462360e48fb73a6d9f97e5e39f26f7d0c777f855e71d3f4e6a6d9f877d8d45b472ccb23a4a5b4424f7711480e942535f8511617c8fe531fc120d2fb8e650668ae6dd99e707f94523e5898052de92eefadd17d0ac3f5cfee327eb08f33bcd2a09677ee8119cd79614214a0d47783724b54cd9e1092e928f227818edd662df0df2537e74cb45fb1f49ff7e383947926bde9951ae67c3e29ebf109e22a91e5b29c8c9e48088797c8360f143784973252ded93aa05a636e45bae69a6954814167c1bd71e53959aa3c985b2e9c65b103031997f47850ba76c2d976c772a5104138374c41a7c35158d6d2b4a22b714dad9ab0414ba8c43789cd7c2dc77b9a88b078b5ce12e7542c5a05e263022b8d869d840bb8401162251e893ef3ca09f62799aed9d75eeaf8966776705a01c5eb9f1a2d04a884411fa8e6bd83c79997973bf92eeca18ee3d776f186f5d238caee06d47e3920f4518611e918a810e1272d12af3e7a02c4a27f44599722a9fe27d999b85612d178463eb08fca557a31bb28530b00d02fd5aa553a99d7f83c587ea477a492c5264aff56eaccce297cf7258ae6b66cc7731b8a63cf393e8471bf51d79c15627c747593a25bbef92db43e84960b6236fa2d8b503eca0635fe53958cb143b34569b320745eee3980c5de827543f2e22f860ae3e65d02d05bdb53b5807a6e7fe37f883daaa59d28723ca2456c9050b93f14ac312ca4d44d60822723b3e2db0b2bf84c6e0fb49539ffe3afcf3e42411d3da228b75e24d2985e3da55515f1700c3fe64012d15d9973a21c5fb59b53a560e99a3870635f1ef9c3d0913a1048b124f829a5468af499d5d2ecded4366dd6804081e842d4a3a75b0e24e2363fcc41ec6bcc7bcadd053f87388b5ed8e1e9c44868f38623070a7c902bfc44f053f37855865eea2fca51279e19434434ba4fc177230e4e50b644d0bd5b09c9cd8c827cfe8c88f963690f678f99d172d157f676a152f8ed2a3700e8ffaeba2f399408f43ff4da4b7a22148bb4a9cd62284b2493079cd76d105e9c9df553dada03e73942c9e769b83fac9900eb2af71ba8943cd77eda530c7be3ea78510cdd95e255c2dd6d6b496ec56d2753360aa9751e6de0b9d35bf10ab2d903649eb4413d48edd5e4ea99dda8d581995c4520ad98421a93e765a6a31bb51eb2efa74d424a5ed5a9ca55968415d781c094c6d5eaeb422236af90a6890e5af0349088af2bbc953539d7ad41e8c08807da81777f17b2c57d2579b563cec7c955013ab5e2da1a7c42e5c3f6f49fe648fb727fdddadd6dbf79df225e9181da382821a36c8f45445855e4d4830c0608f934769aba30b005f87dfa8fe5781111f48a628fa8169052951383427c82a0dca580462d25058c71b2b37a1ee3b92fabb2b3351ccf053b05b89a69195f2207b9886c37f14aef3861e9ae9a6166ce2f16cd54c72ad1ac72e472c2ad64281d93a741a3d0a21b011a3aac6358edeeeded12c41473cf8dd930fc0c9fc07f366ddb88b450d7ecbf77c4b7ff91f660ec01ba6c1528c42a1f28ce8b699cf46bb097bd2aadb0ce1db3870f2f19be4e6d092fb0799fc94a6fa8a063632a5eeafb1b26f8c3a64098b916df159501c67d965bc9dd381bc115dd8ae6e518d48e827358316b87ceedaefcc80f640ba293089ddb0a8b4524f8b509e8a545fa2b60ec91933b436837ffc5bd61687cde8f418ba638db887539e65d6194b085e9c3875143c7c81ffdbdbedafb53de23b710e1c20c29b452c463b351d4feac3b110400c2fc3892d3c3c24bb60f84925a7c356bd0ff142f916b129b524060e8759339451537d6f1d232aee5c1fcba1d84e50e93675ae5a835059ac979aa5f48d322b139e611c77455100c67cfd17ade3461224c48782c08db0a6aeafe40123fb7474a95c765e6248b4ece569fbaf55af9224b408ac09bb7434f9b2f6d92cd55b5a3182a7dc733f8816be65b1457da3bd7ca1ebe8ecbda53c960f69bd9030fd0264fb82d001673881e6f69b7e1fc6fa07764060a9bca8977c74c94d0fe732421f83f95d3019d4f850899be8d8549cb360b52af18561e0b30d04b4ce85374f17af43a3ce365ad604fb24aeffc16a4e891797b1caf1074eb3fe28584eaf636c1bdcccbc00136818e1e6cbd1a7a77f9cfc16faf5a6e546c0c6fb79bfb29123b846c4b9e934681d63c7d0a7dde2d01d0664d52400b4c36fa348cfead892f341120d8504a45326b7fdfffa11952796d4cdc4ee2c83638adf827ebb0dffc942fca91f0dd325cdf72171d69e3dc88dde9253789b7e70fac47ab8da1ba83e4c47610bb54c6fd9e8d0a86e4fd32ac06d5164a39bd49dbc04017d8bd751b5d57cae59580d094aa1893a227bdd717236649bdbd88d1110db005ecec25abe4a5313dca360a69bef5b4a4dcff92dc286e4779b49bae349f27c05ec028815d2fc619e3a6ff1045a1b0d227020121cce0717275a6adc68d069a033f80fa30abfc590f1d47cfceed3bf01f5e563b5831beaf1e1d08d35c26b4106a255c26658e224c37728b8e00ec1ac67210695af40cfb627bc6a90bcb107e0acb453918bea07395928014eac1cdbf423735773a21f77f8d148f3781286cffc77a1866ae59deccf6b5d7c7fa7ab3ddb7fc0812aee4584058184035236c5341acf1f613d3eb9b42bf18f52c41629f46dfbbc68759ddd457b379a8a1c02d2b783a2fc16c174b84131ece7e3bea34b5c489e72d57af2dcfdb666c6f05370e1f600132b13f1a6ac401f642eb633d7a41bd3db934dde0b99bc882fdc4b044e10cb0872ddebda170060975bb903f1a23e66562ad2f04625dffe99ce9d1f274265867ea62e1888c73a0fc8c17dfac078581e8d58e14f54380e9636780de0345babc3d73e03bcd965a3214530a71f90c35c604597bcfed195152e6fd37f05d5a4ce7f1dc8b1ad7505424b85f1245f347e33bf568f210ccc9f6c21cc5514a45e42b125822f756e4baf99287b82c47372adc40b4fa7be791fd2856cc53d48bc96c61bf167412d3f0ed342b3bd3f32d19ec37f0c1a30d971d481762cb9224ba757a536766e6991b08ef2d67d33bb380a8bad0204d73ecbab329aff156d3e53169146ef5e748839655aa605f592a2d5e86eb55ac46ead03d32185e3d7941ae9106aa85630016576e25052e9c17a5e6654d6a41cd67334cc7947a9c6d878dadb32f6b12d697c86b19211d6578d6e39ab3d884b67204a7f2b1fd31d70299487245152bcf65b023c9660ebaa14c69faa4bae821e56b2e036d076985f47ebc3e5454339926150ef0e459e74065adca5f54754012486b6176e81686a78be9513c2c70fe3792ebf44885c2090333e34eb1008979773b7f1b3af213091ac306781aa8fb9f885c964a2056139be3b4fed8ec26ae21b4428ae1944e3bd28a667a9a1eed8f222fcd301e7b45ee52509aba3af56fe3d3de816399a51eaef7cd54b5fc8f0fcb53bf57227cd664b9673cc0b0aa5449da7b94457fb215bd93c357b895df34c2e432681fdadfcd972417a486fc5498d5ae042cdb685a3c7b7265db33da050a8ef3cdf612cc4ade558452265e3c90c101084b87ea93846098e874e9a6bd8d58a71794c180f7983aefda8fb2fbd33b3a8f62f8d0298f9dc5992fd9663a1cfe3e9e00feacd74fd5b1e53fc9aa129d3189e050a55e46918560f7e24f1132bbd645b27424155df7698d4041ae74790e37a0b4942c398df9527bcd5b68f9ad290327e8344dee7ff19b9823c7a1c96e52cf57a99311ccbc1423e80d8316cbdd21ea76519d7832390ba2b692d91a70e1300ee26da15f596d21bb7b5ce32832026e8582acfa6bbf64db32b550d8eb8de27ef0fa3d172c283b9e1a2129dc9092c69adef3501b1b007e19cbf4638e0d94b28fc2ec72c446b8ffb92c9f2320c2aa5e3d94194fd45af18dac50ccf93cfb52c6fc91bca2b676103bc138b770e14a547fb9b5dfd04e02b474c3d4bf30dabceba029fb79ee856e413b5163ce62e526a90f672d5cc99be740abb512212c3505a4ac2291be2a8191c14cca5289081b987488c981186e60913e8a601fdd701562a7aee996db8e0a26218d6f57bc36a61d6c4071ddd8db22242efce83df64e427ee8150fe182c3ae90659d8ede039a0979c9124ab200fc07920339a5e34ebfc40f8986d8e0c28b48cea1f8cfe1882a6b255b4fbb4f5fb4afe0fd96b7f43e4a239edef572472fdc4bcfeacab823664485a65fcfb1d3dce37cfc7c4fc06d8183b2d4f5e49bd4f0cd23722463b868c091e2329b48df1765749af9c5f5dd6b976ea2587f3c5ad234e370ec549bbdd1cbbf48ba6a9be9176704270d9c5b1c189fce41bf84d82921ffacd279633ba9f08cb4a89ed21eb379ed3792d9b4c0b624972afc88579ba23a17c028e04410d9747845ee2ed052eacd4d6dcfb4cabf4d1be893c64fe98d5442f0556daaab28fbe54be2892a6a1eb491875c1e9f7def0b853b396a477f0a0d491407d9484b00f49e94ee0cefb71f59939a0f7aec018a65514acfd8e7506db85fa97075689139f0379876248d127dda9903ad0ff7c91e489572394a5e7f96151ace3f6d4a32200126e6aa0c9112ccb459f6c7f2f3cb5debc8cb22cc7c7a25508f69c3ea693eff8c4b77ec53bf3733b31217e82223eb57dbc24b963ba9fe4e8282b52f66f6096c884db7853875308dde41cfeafe1edcedf0286e4a6378d9d8fbc956ad28a7563c9d7f6be8352eed33445ddecc93002c0a25dba4244ab7a78b76065e08fb148c09b9f84e82e531fe8a2b7e1b00ba2d9ca388ed53d644dd774ff72d565ac3e742c2fd23ad0dc595a84624c2eb5d904a2349b7163fe90a91fa091c385632fd0ed1b6407aa9b2d1bf2a90b8c695b34a65f7e27395e0350eddb0ba68f633affb845282cd7397e3e488e7de68130aadbc0ac3278ea01b688a1764d085c616a68219979b0ea5218f0945d4a1aaa30408d9cc627340a97063a4dba217f7ed69d893e1928043ba38b0eca6eedf1f918d7a32e772f7c25da3327e09f2deb60d8295e39a0dcbd1ed65e3ebf4b11794c3856377e5c77d16616d2791c4e7f79e23214f8664ba694b5990391a8ea160a1be2328f5e0a13b432645da5f03177f907561cf56aeea3c944952ffe6e0570dda5913ebb7aaedb27f2a18a9f1c0bc50636147165675a218e3ee01a4fd9e4e1525ac7dd2b8b435ea8aa03c3f1d13528c508f15016bc9861e81f5aca9e6ba0ff8b433ee6b0c99f4b36d9b0e32b513a6e62e1924f9b37990dfaa0617593d9de9532c9b8316bc372c11466b85b63a9e34ad32581ad8b5f9bec742db384072e2682d298325810eb87d66ebfea409556c4ee36df3334d74cdd7a8bbbb7a748ba90e74c09ec35cc65d88ee768b9662b6ac947b24b9b8fe8a0878983eaca4b0549a67c08f409b5e50eb0254116d47330b689fc4aeda0be117104ffcee13a116c5a07d7cfe716380cdd2ca6dec709811147433670690f620c64866f4c19f054aeffc2aff84dc0b0fca95c309b849c2c3dfc7a0483b3c1674999fabb442c7da7dfb99538e96e0cb49a73da04af4cf9605849bd5f1d75efd86320fd8c9a7e09de65c3235701fa53192de79c40ef66846c6661d3d6310d25590dc49895054333098b9b7342631ff665862ba6a287dbb503476dce5c71d54a23e7e55dd7ca7319c165599a2759e17c04ebe6d56ba79404e25dd0252d259c05a595a34622afbaa68730505497e03a343f9d36e650b5a5611372365643547ea30da32faadb2923bcd81e391574e1976f38272cace98a1e5edb153e95b55a8bebf3f06092b0e2252355c3ce8173ce0d744d48448f76a9055a460207c2ed2b438d20ce50f714bcec082c2779d395219cfa4deb32a2c38aaa589a0084b1c1c7b3cb256567d5ef68a69de694699d67f3151080122e86077c546f65c44bee3612b0c2f34365cfa04ac54b898b7bd9072c6bd4358a009e8e457bb481e85af005f3a7b04477d7495d999c0265a8efb089861f944037c6bdaa18e812c76dffc702fa065d9652e4fccec643edb5f531e4ddba18e993f13f0e38ff83ae1162e9d37ea7cc8a6f1a9a792954a5b6ac7184ff74b36fd3d6d3eb257ecc63e9ffefabae206d61f454bd0e80cad52672eaaff8860e603eacbcca2e1f661e60120ef7bebde0cc10e8f3d4be24c151e0000f9ad344d3a0590c64a22ba9af7d8087cf83618bda7ed7fe823138230a6b09b4fdef1c5641812d2f774fcb38bb91dbca9eec23f41755693b4db3abaa8acd61bca1b864d2e1a61c0b62f7b31a3711cbe1d8e0e137e7c0da9d6122614fe9955c739bd560822b8c5a3e4a13f79a30bb6eb23c1d16ecfb3eb3009ca89016046818d42b3f0ccf81bf5aa0269a13f5659d6a934c94324dd9a128de287bbbef755dc0cc2a846d1ff8495e29d33ed415552347f93d12fdd51d19845be0093486f6e179b38cf10304423e9aefe5c47a4afd394a97f382ce049a6e5c11d324201c5aa758b79b85007189f5db00845ce5099eb11d3f62f22c741cc3273d462207242078b5ad0f0a708ddb364a57dae9d5a9b4e2b9eb237e49e687ef8a323aaa03764afd1a2a7ff73da0457edd175493a0b3162408cc8a1a4a72972b2a80b7223d993d994a0af302760e0ec95fc5b24f0e069bc8744b05a69a23cb15e5097ea204bf40fea4f4d8fa1423b6667bc3c60ebe6dc6118c73e6bd5d7715dd3f1f9d7f8c46fcb7cb7699c29c109bb3836f577456ce1913b8d95f52ba0199048e24ce301f9925039ead0e5f24c4714ded7c284e30b320334182f282a9f76c93bc9a3f127967318b5ce44434f07670de8f3b52e9e5fa85adb8a10617a3a5ce41b421bff2eea9ce093a11a78282397501a45cfe7306868d52d76e2e6254bdccf83a2dabfc7882dc832b08a9a10c15642b5078a45b035e95f7878e74b16b86509fbbe9f9710337af9d4cf6f2d2ac56647bb1c582d551ef35aff6dac4aee07069e130d560b25e7d68244f778cc477f3cd9f43b3c4c9a987e0a8f381c136111925aad89625f15e2bcf35b9bc81666cdd1e37bf4eb9eb56f91be5eed2359ae4bd78556c34fea1e8486a870295157c784ee6d35e370b8f266e587e42caa3471aa934e3aed35ea2835797d21c34cd6accd6a80e616fe22b10a27768ce720f044e65df01fb5ca9ac4bfb9885390b8d388d28b414bd97e9681986a0c2da08ac5974dfa1ca99bd0912dbdc97e67d74c8e6b4505f0a3020e95688088c42f2bfe9e4e4e2c9c9358f64060115a3b25b48af23d7ce1d0234ab8655e0675d35050b1a51101c0e4b890a2462f2a00a48957b766db0c8426a7702119c36a55ed3ea7519d62ba0feae8a3f636b3a71f22db23e4ebb55466e6029549838db1578a092fc61308ac1a0c1106f5dc0ce56b8d1e3917f3959dfcaba7854b2e9d1d28f61ec984caa271642773cc658384a51b3b57ab944ed21248fb18b17b686fb22020289b49e637781bfe0ddb334ad5c621449ef7c48eec039de211425e6bf05883e1f5ff1f3f19c5ac0b50a9acc3296859c7b77d5d7e6bdc1cd30bec2733592a94de72ab977a2cddbaa36d54aa8b600d1f050dca02be790cb4c04902ed493b09a13be0929328d02f3e8d5374405aa5a5d0633e02e45f610944daa4148c43c2019cc6715b55250a3675eb6a9e3a7991d2c3ff6742d72b96615cbcccb3486eacc30b6858e92c43ea0113d7fe42dad583dd64090e3ef7feccf0b218a7e6b2694f8941d65d4023696c83160029fab1a428fd62a04e7f61c64b1ed8561db4a4b80585e4f24b201f27bc4aaeb7b43a7a69b3b7e6a9c0b32b8b786dacbeb3a09ea691d7ef34d7b8408ceb1fd6d084453736240a573430d02e9a279caffdee3ec77670bd36f224c91591d41b13c56cc658bd7cb71aa270d8ddacfcec94801a7b37bd5d20d487696f0c60fdeae4f74c5a6fa3549985e5d1e808b37ebea744a40404c068f849ef73194072a98a2ce89be8374b4730f35d57152736db856c37b8922833c7f0115a8d1f66558df90ad234ac5b7fff38fd19e88470e54b9a399af59fde0d5114ef709d0f2b2605ec782dc1aa7d78167d8cc4d9725ba7914a36a0d77ed4e200fa79f7718760c130ab547ee555e572ec86b685d787c7f1daec39fdd48a714e1e30af96245c437b947379ea7c69bb3bb1fa4c7c8f739ea7d03ffdc268c1c13386c2d625050784076c6ef5c40bcce9511a66acfe77be1bb441035bec419e247a67c5d892d7e68ae04ec11dfc26f7ccf140fd3589c2a878cf9aa45bb2d153b7327b7e6a18d3f2432afd1a688217032f8eb576647a8f34218cc4e640afb7494ed061a8584e7a46b2a5c7156f8982d962a9c582190d635306e20855966005f88fb36b68f1b6274d8da1c0994b94d56f574aa2c88eb0d4373ecfa2374c7246783948c252cdd6ca932b626edc8217286634b7293dec02890fd967388c3730a7c8fdc8b18154d8363a5fd1a66d3b81a0d2d78bc00987b9b7af1558a5c6444d3b0ac97d66e009f621149fe9556ab6883985a5d5e215699ce512bbf6d306e4e5d82f3484f7ae14759624fc49947bc29bf328ecf67f028c5e887744688e6c53b53c2be16082f748f51a8a147ec2eb0cb6f4024c1642a1f141ece5e68337705f347414851a14f2ae54369126da968cf1231fb6a33970c010456095b4fa5f512dd751abc582637220b2981877e7d46c00ed02c196ad02f38c02a3b6dad786dc1a5881c3671e229bd82d2762f062eab3dccf93b6800424836ae6deca349cacbbdf38978520f030963135032711a3019d874db9765ef844bdf5d898eb9ff698521db425f39cc282a2fcadd2a6f4d4a62f908c4d8ea84dc3da3e9db1154f8617edd55010e2e8cda17c6c9157e2c6d53af331488d476ff797fbd5e4800977d88a36d7a1c10383dacc540b15fc4fe41ca2a4836f141b2dcebfe9b2f1260cb1b88d7de5e8cd80d787e89d7725b5554142d4a2ef8b96de2b9642b15d2f42fb77a669782fb94bdd26dbaf662fcc492f5a6c03ca8d388f5593b66efb007726766368e146be15aed0765f0d831375727984611c508ae4c849dc6ad6943a232a498839f13b419018e97b0a5471e97ea43d37e766003b0fd3bb8e446b7440b1f9197789775e223fc6261ba2d04d9a7df84c500796c3ba379cf10c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Dydは、パスワードを入力するように求められます</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">又是暴力场……</summary>
    
    
    
    <category term="test" scheme="https://dyd-true.github.io/categories/test/"/>
    
    
    <category term="数论,数学" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="根号分治" scheme="https://dyd-true.github.io/tags/%E6%A0%B9%E5%8F%B7%E5%88%86%E6%B2%BB/"/>
    
    <category term="test" scheme="https://dyd-true.github.io/tags/test/"/>
    
    <category term="SAM" scheme="https://dyd-true.github.io/tags/SAM/"/>
    
    <category term="平衡规划" scheme="https://dyd-true.github.io/tags/%E5%B9%B3%E8%A1%A1%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>test2022/6/13总结</title>
    <link href="https://dyd-true.github.io/2022/06/13/test2022-6-13%E6%80%BB%E7%BB%93/"/>
    <id>https://dyd-true.github.io/2022/06/13/test2022-6-13%E6%80%BB%E7%BB%93/</id>
    <published>2022-06-13T06:18:05.000Z</published>
    <updated>2022-06-15T03:42:41.087Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="d653e79477eb366c83256d3f0b061eb687501dd51e584fbc84c1205540e5e041">111e7d6409c611e6b63fd1363c3273c89f3a1c76fb83ca35f2018ff75825a9a2f5c359b3996036426d11c017efc8e36bf2aabaa769ace224315d1aed2200aa1858675be7b6a6f1f7019014b5bd7bb5f232d4852518eeab685d34d44e6b862f02ba386ae11328575396d9f3103d57106b394bff854122e60e15a955675ee124494add4e36c1e5628f8aa3b96feff5f4fc7dbaccfc5120d0dd059ada1363e73c4b38ad6564082fe77b6431b38402379ccf1b2b37fdbd276b18d8647b477c143fdb3419c0ed07b1051b5c902348478c4e9e43e6f2e1f0ddde2259aac53f87f53c7f51034e81d4334ff225d8ca62ee8189af23365e0949335e33be3e5f195902a2b927991a6bb4daa89479e89e2ef7f35849acb5264023a6abe7955408eaaa5338e1eb5555c6687e77694adf340bbe4a1545ad5c40ae96b1aba9a370cd42653441a1ca113ea2bf6fbd4455d38f2ad2b60be7cd37e8be0bbafe65f1ee66b6c5ca66906f518f7baf73afda114edf423dbcdf5194d85f86e3e5ae9131471c27a43f9f0b5a9b044b9f5c96f5d04cb1de2946860bcc23cafed545efbbf3d004203a12dea4e5b6b1e7eb78fd1deefbc278b650b74fdec15d97736b33c8e8860c01896b02c3bb82eda736700dc55653286902a335a2656cb154792cc7297ab5f073a4be1cb68b8736b51c01ecb412de8d42efc519a4cd9b35e5d52a1c0046338239f2af461af59aa5e2ae027bb75b742f1916b70c871133a60d56525b6977e5389b97ac733304c3a889dc5bd924e7e0c454db5272496b1581a770ea31865649d93a81730aa8a10a3c8c0f342b5cdcee9f22bb05dea20ce3f36af33ba5ab3e2ce66e5de1f26d0fe1d8ae63b82c37790f704ec64785f05b23a91485b2ef6d347766f16572d772b0a879ff23aaa0b7c1654a1fa0f4c995db0970aadb3bcbbe85d2ad1f6f8d12edaf7b2b81a068fd2950aa0c78200548735ba0d5494920a41c4c6c51137f0a8c467c2f42091ae4b1e4ff4a653a02e277e94179a302568c2e50229740c1ceae68ad47fcef858ac91f984e5a7d6d78334f8b1dfad0ab77ad35a8782e827d8804073fac238b1930dc47c97b10f78e1bd0a3c878dd8b857dc94230991580926b5a2485b9515df6de8bf7b67d2e19ca1e0c17d7225e7cccdc319f96db76b3c4edfe4e49dc47b886affb40243d3565d392381f9df9c1a49e0a9389ae8c49ab6bb4aa39a82becf71add22365444703aa859fd3c568ed5665735b575c190ce9d5a7cffd2dfd152a43fcca6a562ccb7eb493b844b6182df3ebdd7e8c1026fb7d5018488a08b2df1c69a38694b766ab40446e2092c98f7ccc6ba03c10f0d930adb0324c4154a3e3c3041e4384d297d93b8bbc45b64b96621511822e5e1e5357adca3774f465025e373847ea3bed13bfa1878e409a5f5cabd5d823dd4c074bc5673eb9255d2737c6ba7e0df522d9dd00822ed21911cc9702f4c67445f64c01785646ec094944fc5325fc767b770d9a6b9aa7b1d525336eae1b22bd93eacb1d36729b462e21b2b359cc675d23bd683a5eb6326be5b3392055d05a49e665833a78727f3babd33375a6a96999669ffafc1c0ccce039f65f54b4e3e17a676c64fea986d285946ec44522503222c2784273b98a2a8aa3fb9d745ab075c7a75afb64a61a04601ee44f63f20d47e99a08398a49c4e68e6121fb674b8a22a0bee20cfe5b49d9c86105a1f348b184b7521439e606b1fce3cfbdd46d45cefbf3b089fd38828aff225261db436da28b37ecf324ecbd3de2af6f9d3838ecf7592aed737a560d50733db24444b90db2fa366c5ff69ede849421a902f30fa5c06af61741b20ab9fddabc0eae0bc62f01423e1dd06a7701266b5370e6598f91221419a92bf58dac4d8fddb20459017440e4e5e8777ebc253ad8253789eadf4bbf283db24ba6a953fe906cb55cc9459687eca2aa78713b8af9333319b141256298fc20616d6765344ea6db72009fd93e553a63f1c1a7cee991de5f002001f69e8171adcbb962a0837a70836a90952e41750dcd371018e844503adb7e1b2c4d13f69482c83cb86c2de3074e655eb9c54f1292f297c2c75cc31dfe2d1416c784e80dcf4d3da0076fb9d0353b283ba39452ac3582615cfead6d1ee5498099d4d15baa518d9e1a6f0e78ca0545bc0fd1dd5ca34bc9fe794c398d0f632f396d99d3e4cb243b3ec6a590d5355c068e4abe9d4ecc1eabfed23d11908c4a9a5412c179b6a46d8fa9829caf51b80adcf7dbac179199b122f5ef839dbcc7a41601930400ae00e0e16bfab493d48d57cc71044787c40e910f8bd6a99e2b04ad0ec033a0f59626065a5be04674d27d728e43439cf46ff78d04b6619f81feb3b30ca4ee1b73f6ab283f27a3aaa3145997f8f525fa0d0fdd92c2fcdd1cdccb583212c08cbbb9a54b6ca49f6fb38dff41e6c6f4c859d0aa6dcee43fb8e56269f3b8d2d340cb8a99e7595bb44d3617530dc1b4b8e58878662ccbcbf36f6c07aa03094c6b10efaabe080b3739d6cbf166d63088026de99e77bf088b293edfc973f1645ee70c4a78508f1e5a468171a942241c696d70052f5c41db0d8218e183f50aad3b7ced7761862645c7baf966d2744c89d84108cfd35335127e3cc6a6250db2c4cf1d6855c09284ff936cd7a1f84f80a649d8401061dc40b4df77ace2f102a70b6296d7d663d64828fee256614d4f974191dbc1c3e573411b8601539c16c89cb6f671d00bcae65e0c5c4a38658d23967a83485c1ab3d22946ac56214659972b055cb3a0fa8f81759d6b83de15ef6d437c9fbdae689bde0f54d982332bedce5fb9c4a449ab5ace6e87a6093b79c7895a94c67aa255a4cfe1cc050f446082964184762810bcf32afc838892c155e2e7ebcdf93aa1b1797f7878f2a7865940cf1dbaa0736875875ffe3875222a62cdea988e69da5669df0ea35fc2b7fb9be51a1e14bf865689e7ddd438e80cb0750444fd3479afc10fbb3f6ef3e5854696f860ffafd6c98f6860ab77177445b5bcf50881ed733ac4e86fcc574013100120cbf76933cbf09545915c17caef21b4468a382061c575df6da3ac6b5821ca6fdcbc0913855c2a1e1ca01d01c987e0065b52f732e984a46b42326f67a2d492df8d13373b2fecf16d4e2ea5a79b070517a573ef548b08dcb2144ae9a5b1ca2a5458de1f7725e485279cf44aecab895bf6567a301bdf3b2981945a3d12e6698b952b77fd4fe6f773c768385b573bc2e7b36c6015cf6cf7e63a7748b1b27889776bd1cdb73801cb66e4e7f924ba89e8314586496396bde1d52811ebcc15f16fd45222aa39f080afb3144bc8d528e2ddf22a6b927d893e5c2fe7c05ee8c64d78e65425cc5a7ddc0b6d4eaa1933e74fcee0dcec2bd704ccc6fecd42171f0cc4ebe4808352baef8d5159cbec6035d5aa2da6dbbd45fd9829b3a6ef8f20101ba05ea75a00ee5d04f291fcc3eec4d4d3414d58513d54975e85bbc4fdb609ee03bddb0d3c385162057c23bc3741b20553d97e783ec2643942ae59feff2ec44ee74df8f28c9dc4a0fb9e0d2aadb9e15bcd69198fcf4cf01d37b42d141168056ebb89b8471f47521d976d1606b68fe289194fedda5e39dfa42d1e08b7e80cfa2bcec31ed35723f5f6d46eda9ca3424b7a5e5ee793ba9d660d1ad71f6bc6b05760f94a9fc093a67e0b603f21ef51e00d17b7a5b31e0b1ec19c7723ce1fd0bf13a3b10f05ab113961bd9d502c5b0ce576f7a9f97953ff9b62ae7d0dd87deea69fbdd62e2174fa356ef3de2169a39a072149b9840c994f8727856c472c0e028bb57e7dcd0153b042007402c430df3e9d198e3453c504beaf98c5fdc6467a1c23f6cd59fe6734c67eb671fae818c1a845b8314eccfff2d705e9b511ab0d8f4c275268a3ceafbd947709e3e9204b5314bdfed017c7dd482880b27f07bba0e4df82634b4b23b30edfc38d7221d0cd9f889003ec73a3df2963f03b74ba51630dd6e0d5fa83fd3947c8fbe999bb56157348a7f4c831e9a154c00934c1b23fd8fb9faa5bd0c4d8ddbf6f795349630a7e14fa856861763fa9c1485194c0b9ca2481870019b2e0cd544f24ccccfe6a8b090ce0ba6bba0b80116db6266c78dcb96ec2a4df9ac1a2b69df5e72906807c35afc6baf6d87ca3f907274cd2b56d16d43230cf034f540291c9c3ebc5eb7153901aacf629cd09910d7884d60dba18e576071d8eb2ea836d3ca6782cefb60efc401a1dbe147fd9ac5c9a4d4941fdaefef9957fb0eddee63573d7b82b7e181bd240359e9df0705a1ee3815481aba3f524e4c63d4675d4e4241bf2aea1fc44010ade1d60c7851f00766044468f29b7c60b66c258a1b2fd7fd3f05c3a454f660271c6dbf4b7a9e9cdc5d8f10fa8f147277585bcb4ad9f09b8d8f6853ef2dd775deeb6c41be70c9d4e507b2ae48f7e66f3b57667142655b1d589e2364b13fae9ec08b946333cdb569852a1e0321966e92e7be1f8820a072118bfa2eb7ad70de47985b5cfa9a8fff0444e47f2799836955bad9cae46b02232953c175764b1a3b98321b4d2bb753cf538bc4caf2e765865c7c317542566660049d9233419498e9f56f74b9b3ff3c32c194f66099758037353ba495b9183169b3034b358cc4db6e609fc757fd989e3e0f2c49f6172432892141c0aa09befc64691e734efae7b9e2e4d01a506133b1a5871b8208892073c43c645e00b5a94212a8e9b7956dfa0f294f77e3989f6976f69979f9ebdc22728115e4af996ed884826c4624d7fcc736a2e77a5f768607f6c28fea139bde2d9c6caf1357f03888892e33a75129bfef69b9eaf96efd56e49f00b75125109fea6b464df423babd7ba8fe0a894e036e4d67916ba00262a148f26e034fb44b44a8538af85352524ac03531f68ed2a51133d56b8bab2ae5b81b593d9d750b06236feb3630293a9d39e65879b746d32040d098b52e8384c4fc5097046b9464852645fe30d45042d6d9279f4d165d04823570da85d709aea099dc0eaa0aaf9711b8bf99438eef2315a2aa43468846b1f67426ff4202c630cefa03a82a4a9a0d03fb16338d4fb8838e0882273aefc07680f7634c70ac6ce2bb3ea24142731bfcb79f758e445ec1e8de074aa94a19557169765648ca4da9feba1c65cb8fa91f4e31de125e7b31569bdfe77d7bd2c8191875e8739434634e5a72bb18d9b93f5d481b98809fea62d03dede034f195952db5597063bc5aa49b1212eae64990177e18534bf2134f2d8bd25fe2c55f23c379c4592b214e45525ace8a6f981e21b00e448d9dfafca91ed86ecb6288ec21baccd460248fdcb6c837eae235375167782a38fd8bc0375d0444d6832b7a2ce65411ef88d6dea8180d470db91a84f44c3dd9f985ca2d959a96179949a916da14ec7888626c3a52cd5755b3feccb95d315b19027139016e0f689c10a93fa08e2479c2f007dccc02a544af9068dd2c723924b28d2a08b4ff52078ce8b2cede11a090a10e8a0df6cdb2372f1ee657a53c5be63938da6650fddd6e09af62fa41c8a93e3e0c4755331dec0a9b5515c981fc24421cd2febaa336ffd3e078480b7c805cc603e165e16a09b852e567dff8a824167956f88f7cfef6be7a9580832d5abf6d0e45c177d0c86e7c742090bef2981296418859ba1a71fa1de969c6d4fbbb12196766fc95c09cff0e0f1bcea64cb1110127be11a3d0c7897036dd8ac8f40b44ab3ce30d140ca87033127e50e3008ab81ac61580d16c1b4a82611a00572cb93d2c4a961bed8f73b144aa9ff14e716363e59058123862d8d5f52f35b356b091460b1d20af907921a928e788bca5aaeae96d5fbfeb833db2e1e7987b41964a75f15d9ff79d9fc1be67d8da24306a7d11d26752ac3a235bec1656ba01f715f4310ed20f2fecb6eca808d50333865037b81a1f7db9c94dc321ae6f8d5f63908c7d8812e60fe8bad4bd56240947938a63a59ed65464856155245881b6f129de384c1e8ac42c2ecb9d1c3afceddd2935392f8a987288a87f1f076ae0344d52eb5dd293cf9524e0a5b5291498af8bb6c786f5e72ccbe0b4aac0504e1141ffe0e1977e73d47d707d53bd63d2767d8fe3d8de996dd0108c419f844a709f92a3e3f4f037cb35603122a4bf30ee2237e398ed9b694adbfd76de3096702d62f664621d36c17835c97ba51ca057d6fc2051100b0f1170c93465649c94102a1eba22017de620d7824a13c76710e507e0e8e689c49c499e66ebe657beb1db9cf116e1ae178e7f3e8e85d25253d8a3ee43695c64605ce0a80923da9771e04d807890250c0e121f00e021c2a84935c0420278542171aed1e8e2ce5eacc2257de0201f035b2b08512a3a50ad5b9c7006f0c272b89c28589762fb3f3596d8e19672e21f07f2e4d5007291c063834d9c0c035ef4859c494ef4d41518c42fd38313ee3ca11d738d7de92ce3edab9d944e2bc649c3c2dc24eba911df5f80a0b847f2bb0c6f78e31439da7139729106d3d699c475f7498e74f184c62de9c35add72d15ec7560e1b11e0a488b7eb93e0474e44bd8a6d8f98926a287d61912475e4831985d21e46fcdd529613e03d3501a758a3c89ed43090ffab6ded77789a6deabf21d9cd924b9967b1fa40a9c5b4fb6c97255638ba334d9415f3b70a29b8afb1cc5388fb3bf325fd4f786d74263cf5a9bf35bd089c8829d6967501f98f42c25a62ed4769660b51583632a7ddc6b3d03dd8dce7efb2f2d92bc12a15891ae1e19c7e441c732c0461f55baed10de7d43a355d3723fa5fe097e2c11beafddb465aa5619ab6122aada7f1648486980d0e9d2970265007f3866c02ba9e5ad659b82376a1d35b0325001e408f80c268bd6294b9354cf4de96d3ebae0aa5adf9b0bcb70a11d43ff1f2289487f30d652aaed1ea4e4daf9efa83395447aab4bfbe7e3d6f1fdc679e0fe3907834987b2324c51ea2a2b5bd20cf2e71430b1e456bf6b686f959b7a43cf23ec174b3cab0e3e2efe2c3051cff68d1af95097748dae6fcaca80ed5556d90c34a966e33f0d5d296cd0eba6b327384d31d56a527381e8fc81431ba872b03917dfd6a6b788a366604925270f79a362e93af854ac74107fe7742e872ad4ea5ff4803c8e3c5f17cc7606b79739be5a81e0ab883b3c4d7691404e0260fcbe83b910ae84191ebcd1ab71a1048c3eb6f86628b232405b33f6362f396dfea5a8cf1813703eab468a7e4f9783ef75397214499bd3744d29dbb60a8bba2af0f45fde1a1c66d9be169affb31a22a741bb4dc69a8370810d19a11f907b31747ae0495de060d251852b23a7b7c90c9c357ab484e0e72ac91938cb1854accf1d761f5eb114a3be65aeaf7d92ec76621593e06403838438bc68e2a9e48e5852f5abd3ce21463d039ac977b0991882717b76a2b57c5f094c37ce4daab4822eccd7a823ac6c73a9b414a24ef51896fd0484e769d1af614a7ade67ca6cdd14de81845bed32baa51578667d8ee792d5fea7547575630f754547a202ef556fa29b6d3fb082f4e17bb558dc16a767dee96828f8ea18f74788cd07a25b48249871c21380c44668b57a24f91fb38f8a5b469581bce4418cd2e3fddd2ba77b138e9b585e3a1541c6c697fd524dc8350031b1183976507898c780c0d28b66192c0e99fc449c81be5d66d71e8ebba54da8ddff981229544b5ca63d9e28924f3487e3855c933e5bb6f327aeec266dc7f49a82513bee05b4ad1dd696593b75f3b107461d5dd49524af13f028023e1efdf4b72d4d8e42c0d504fe6117789da7918bf039e307bb564d08780c47cd119293b6f09a6fab66fd1ff5884a097a8a62e8698c61c77d671ddbca0a9650abdd00c682754b635c0138dda83fb9f2ad5676242ba62211237f7225d6806578e8424b74f2b0d7c0644b82c17a5edfe98fc7b9aa80357e3d6dd1fea1b9cd02124b9a04068655c1f05057b238008528f6728e67366368a20528bac0664c222eccc41657caf41a212b584b260a0c56aea105e24cf02bacd9016fbb41f50eb4c1559ebdd2bd72ca6296bf400fa0fa7976b117f4792d8a18511856c514085eafded711ab26b287d30aba3ceb889cac6c43048e80b147825ba50e07b999822562954df4f06cb51d1ebd1fbd235645e1b6fca535420705ea5a412dac3bd6b6a89d643172e84d0f7921ce25aab0f6b0cce6944daa7e27e36047f6031410b8ef85a79d856b9a5d09eee242bebb569aec795d8eb3928e613c279633f9cd3d2e522c961ba6db7b59d9c9b32b5c16345f9836f65a3bfb2e272ba461663ab42a83e7a5ecd015cbf4c7c0a1b561e85ab7274839554e47ad2fee525969a9fac5c379cfe10e764f5fb9667df2aae9473970550d347d04a96866ddf68b9fff89804dd80e0c228d00d6231c63ed459efdc987397b46844ecb894363daa54fa6335f033db63916719c44e1bdfe76a1d64ef8c3f5a7b2d75920c56ec1f7fa45e082c7861684003917027616005be56aff7ee46bab7149b76bbd24a6f9a4761f9dcdeac6a89c2ba330a8a9bc9d4dd418f271717ffda7ad26108dec30451005a341f52c79fc7d82fabd23a466013aa1036793bd1dc1da798246a714e3a26c49223a3136b812e5e608c4a745f47e19f52fd990d7960e8f9d3740dd231206001bee24090c709da19b0538dfb5cec2e7088e26c81464d70e0dd6c1eca1a55e46be3300d1b0087eba8467241611fcdc940b1622dffa3f1e0efa9d3e29f96db473b878c3c0f73c3063e25ed98b16da0080f9a17bb9919058b7588b8c13d4cbbaec90006eeedfb488f932e6f838a6f1b44e92359827d077771ca228d2b0c155a304ab18797bc56319789fc89c7a2242e59afe1c109269b9d2737bb68c8f0c1e1f00e7477aaf13286cd6d62247129f657aa49af53fd3d1d35de62cd005fa1c157b4f5264afa0823a3dc503ae6cb6eb4794aa5994f392a7358c229557a7981a598311dd67527d69b1a42b16d193573321fc18ccfcc17ff15f64efe473af718c365c9ce5ddce4e93ee8e28587cc9313cba88a9a749f5d66765753e35461b3ea91b0e7393207a6a6ee50c49a0a8a8766e72add3c53687b20bffa0c168b2f118a3ef061e0ecba29c1e2689a41a03422c6a1e3118c4c9cb2d8b4c98b10a4d12e9b52a797d7512ce65850949a159e7930a435b44214ae0744144ff32e8c36772923fb850ed6e5e50a4c890114c49459cf2d37f9742136a980ec2d9af948bd4e35c163e56dd6962013064d51d6f1641421ab1065c3cb70d0105a25ca9d1746c87a451b8a29d9282b0569a57594b3400d19ce737f57b3380664184bd4dfe8f4f5916b9d794f657b6f5ebaba2ff3701fb8a910988d31f87ccea5d2e966ef719497e4552f578f7e8e0759817beed28c91401c2ae613c655febf567d5544b797f93e932867f3772f96154d8f3a9626d303ee35ebacf853353c0c8cf048e2a8b17e57178a170bd8f6214d47df0a4b4a02c74c6585fc248b0633c90c2e6655a3ad687cff3e2ff30342af7d958711d5c94d591e9a34dad46fd79ece06a801ab9b78672c4f83ca919194e545d67ffe795681d27b1677491f7c1d18319c420c7f383839f42fcc0fbda57eff7ca3c7722fa3f6704de3e916b40c00a5f07b55944c093bdefc1b68dbc5e6436c82eea4b568cf07b815dc45a26db5bb7eb77d7b8f0e955507d2f9e6468a158b7bc3bebc616547ed7410f310cbce2743b9fd3ba79706e15ab1dd9fa764252b15e55fc3c012e733543747b093e34337f47b53b3389f54c594e42d075ca3130c9bf1773b6de377ae8a257bd2a98b96e9499b718cabc45a8b8f450c23e4158546ad750b4d3734e534e04451fc15296b7f02ac292582cd09110a1b5c3604dd6f36eaec372ef33f49aa9374c124cce7811e40b78b1bfe0483a2d171ff1341f5ebd9dd9c060e590fbf06c2c62773094095255ee3232c1fcb7e8f503c71cd36db22e143174b6cf1349ad78d367467c66caf59c97428a27d53b99df4384de6495c1a871b79ecbacaee4333da20a4ff247a92959770dab67c7eeb797b03a24ca8d558eabaa4b431ed462c09b41484d8489ccbb531e072dba9b79e696859ec57cc0e8d09eafa1a1b38f76ccfc6bf6ccdbdb3ef8b5a3bb8c7bfebf375707d699bc7dabb537a7c75ab369f05291cdd8617c31a2839f6038f35782fbbb5886527e97f2b506bc941e123862fc3c69eaaa377341b9da6d25dd551134df5037146a275ff2ff5111f8f84fce0dad67beed54630efad45d5ba4908638b680735a35d28f9bf31a28abf90820559103d7ff55f74c9206ee3d436170a7c37cdee588e130d916b483b71d004fb231e058f43118c162a307e9374827ef768d3f299a13b547bc68e0ebd33dee34b7710f51cdad00768edd80e13b93a2fe67689cdca60a81eff7d066432aa37ab88d9ffb0a57eefd669bb82d59f448f78597927ac6c08097011550da49d529ab5190ae48ad184b318f06c55f67afa00eee26cc981d74caeb236696aa0e963592b9d33690d05ac6d4d502dfa5c3310d5289f126484109fa706597eb18285bdcfc966d7a80e0c7d4822a96758bc3d28bc4f3d1a5464266ddce12536bad262494fb4cff0520e1fa911e2146a17b22490da8929dcdd1aeb120d352008b6298fd299a93138e4b4052a5ff73bf30c9497873eb4485fb1d29e6121b11ad97561a6c46b841f214bcd6278f86f71b02847e32e19eeaa7a41401e7ad7edb2fbe475019bc80af525dd3b2d2ab99a104b09f35213dc21d2867052b1c4576b8b97227228000ae45363553d47acf1d67f4e3ac06b05221e5ea1b61423a65bc095aeff100eef63b45c54e71d9b3020e33026789d5332b818bddc7c0235efd3734927a2ed58fb83edddb67859c1e14ab1908e6015923713df30ef9f46b3eda930900523a17813392dda22f38e819ddf37c16801b6b64a9430751818596d0affccaa983758b665561e6952d682d39af65dfd8e5189b020217d9edc8f7e53077abc3ede6091d01e9dc1dd0361b7b3904f48460067f1e02e5fad0c99200d5c768247c93c03f4c30087febfc0a3b54c4ec2cd5f4b0f98b2887476a25403c883262922d49f7e16a9d30bca16e2dfb7e815f17312ace835ed1fdbcd8d01c3131b6719543d059d485a21cc62406bd083fecf335b4c5580df7bfc469191071a4e834b7db740c2a1fae565115e9546bae16b11ffe0d9191a41b90ce2da7ae09c053378e6dfaf4b34cdd49f844abba7d1a28cba8aaa730265ac032b6de609eb1926aa45aff90f2037b9e19b3088c10d02c915ec7e9e8697c1be036d6a904fb8033ff9e8a9825ad1f1a39dcef7d3081fb125d9dde5ed7a98ad0c6e5d9f317390b0fe272983e05252b3e25742f8b2fbf988976afacb7d729289450a3ad5664cdf42babfd0f1d3a40adf40ff9066ef98b6bf3761d280e04864334eb22f8beefdd148ee9ccfa1e510f7a29bcc6a945e737d133b0f8d675e0671426ae645643a1109edf27193e3f9314dff480528b9bb28e3997e7d8669bcb165781809e7219f7f1980a19ce1de07d08af438ea83a87facd33b6bbce30a7d601e79b4a7412aaf37d58cda51f69a169c938468bfc873bf6c827860c07e1b8a755a3554d80fac8a20dade04f48c7d5c066297c9805713d7a6ab16d0aec8ba79479b84b710755d712a2ed4165264a1847e9b9341a557b2118dcf7c188295aed8f78a6ce847026111cbd88f73827aae50dc8409be3cf138638c96d18cbe16e3a2f7cf64a1b168e1ac3fc400e2e71fa18713e31d68c0da77a41d0d6a506f6e1634eca32a0c3791204ed9dfa6cc8884cb55a28df74237d7552c82edbf96ba8f0a72a21f0dcb57a34e6f1db5dcf4b74842347dbd5dc6a61529903eae25ce8a25b45da355cc20f924a88987457c9236674fea8ad99e33a172286721275881789c610e42fa17c6829f1e237b30f84996edc693d48fa703648328e5c9b4ef571f90ddcb28224313de1053afac38ee623aa2b6f7b5c29bb3e350499f3dd7df3a5277547929f87190d42473c5923c28f0b152dfdc44cd6fdabc63b1ae5f3b9d105af2cfface04fdd6badeec0780d82f90a0a0972f395161ff5e143e012169a3402b63dfc4326202416e0b8faac8aee8ac9f88b63dcc67435d27e5716311ac092d08c290088482986bc1eb6aa988c41f8c7e45006f7e043a163070fd211bffc233033bca9aeab1893ce32c600f2b0f64c8e908e2f88fc0789f33b10a94e853825feb4b20626f4c5a98e7748e5e68a23bc5065fb6352c6ea1280de8a90ee90a44e453c666c8176030d8dd06ab335d90aaae386a2f2c2e487b1b3460ce723cb54fde62748ee7e82bf9889756d38d0e0f6a7ba7b1dd450cca9b106e11c2617d07aff880fefc78326d331306bf7e5f7e0e09b2caf8a9fe03d722f6e0d93d0dae1e61cf84be94db07d95f9e71041908e1c2d403b235f806f46a22930614baad89e4b1a816c880c17eb09a2a6b66bbe1aa17a6dfb345e2ff9d5bc12edf828734b2d3b9ee11803142c64e9092552d951ab75d6b4641b5fb7e711d38980111df2b326acb68e48a7a81e32967ba005f986d5481430f8e314d8b91f7425ae4398559b612def18dcbd10987eb86e11fc510a17b3970e63497f80f2623747c21ce525c2b137e4f59027167f9c01acb915cfc4c106edf703bfa05abc3cbedab9ca1140b8122c4174e164e7069e0582b8c715f2d2fb3ce946244e16ac5581c9460b48450ad00504d6b37f042ca0ce4c41fe40f5c9c15043dfbb603cd451706ade7440fec71005f503377bca8e854d5da1f8fee7664cf46138321934cc0f921c663a6a5c1ab0242e201bdf26fad91a945bdb4756050e7f631b833bd92566691fea75ef4d55e2285ea9c20c8afda6560481221f853658d96d7f0fb5590800eada26fa4ac08d8f88f656479205439f7ae259f436289a3f906e722b4bb77768e8f78a5a66b318822733878d6c8beeb31a5067f75610441c75ebd26bff80aecf8e12e951c32d06a827d41919c79657accf32cc2332494f77f3a24a9303fb934b6a45b2cab43a931be4ea333550945b7fe1589e97d618275a851976d218fe9db8e9b777278effed1a15f3a3fee410ad78ec03bc9953b476cd7ac91451aa5a34ba82205c711429c0aa409ce38bf3c64e399c31a557cd224e4c2ddff652e9fc3ea667c158b8ae8c8cec324001bc51f29750a2aa0392acaf9da8eb0233f85c33514e260906c14356fd1d5a48f94169c2443d6171165ab7864c7cd2f4e430e15dc99ab72fac9400b1babe4681f43e62717c32780fc03fa27bc15e9a7097bac824bf34a55494b97c4429db9f32a36fb59b10162b3d23057e0f1de8c837cfbdd7bc397d089916539d31d2ca4a0b8e352ffb807071bc84fe729ab9ec495f04980a15daf40a0d6e328b7dc1a8fb336c5834a47db9032643bc1e1c096138952bf034ae8db9823186051f0dc11e4c4fe461cffc5b6351be304d8e95a6a97c0004d16386662218ea1113cb26d7c186a7942f5b4c6ae665b07fe94b51574dcdde8607fd2051ec250d8154e09728724f3c1e52df91cb5476cf6a92f78089961c704099609f4fce5be44a0e40005e541828e1f50c5ac09fd2d95bbd2bc4482878910260496197f82b9b01f64ab2b77b691bf0c88683439fa9ccd022ece4d34ecc629c2576a1a6d585fb7f77365e93565c110274a279855b21e0de686299881505817f27c0f94aa200c8f576b90969cb101e82ccdbe3f40d84228c0f4972e749dbdee495f4acfffc37e6346d45e8d45a82da9f9dc64615cfcaf399140210f3750eef15aa62d323bb96a13f68e125f00f6e8ce7d2e653f271f426832f66d04a2304e24bdb3c5b67aa99ec9f6415c469545bceca1e29f1e3a012ea7641f12c0348fb7768b91e235bdfa73288859c8007c30ea1ca92d5a87e9972da59fad06c3b3f0cd3ad83658285a0cfccb873b75aa081c4719bcd36e653edf6edb62f7bebcae50b33948f06deacceba95b7f674f3d80286644f1c201fed741e89e3431ccea99bfb482993535ee5ab0b1c23490f568c57633215a6e0b530238ed029af4dcb1b332818781cd482b8dedfe99f274109da7f193fc8dd6dbd370b0eb253eb3fd5800c6e1da66fac27eb4803aeb3d9f16c33e38d67b4d323c8cb83feb1fbdf8fd9f491b7af10cf6567318220672f580f4d9f2e3ce68174aa990adad796aea3f01a470f1646daef18182c270c19fac162253b5ff03b6da7b7f4e50d1f0b2ddf6b23cd98ffa33dddf213193cc357678aaf8f22616b5dfed74fa2ef886d4f003d9891f5a0456847abc5e9158051612a2754f880d4ac7effc6ff676c32db7b120ebf70b8bbdc347bfb325664aed858b3b41c6426d38992111cde91c6ee00d71d6d6ccbc0a231ccd649ec06c51df64d7147cd8a7410c8ec1cab95b3d0460de789bded4f17875933b83ab794dd15cdacc6b0e034fd2f0049fbdbba58618ad5435404160c47912bc3192557ef29bdc0e97cbf742909a5c8122d7ce90f0a9b6582d1edce29b582ed880bf0fe473bb15423750486b41a4dd74c53521d107077491c4386144256d471c73edba9259eb29fb8a3300fa5688bcc77d87685abfeed3010fe4c7d3764f40fe7b42dd657c28dc710b2818389f0637f73a59d54797093870422d703f7bcc4fac142fda194ef42c471d2209f1cd77d364c9765f64c7bdcabd9b728f202d7dd9b5b0f753f99b653ee0d7604e3b660d7562d8fde2103fd30f7a642d46c335e3cd5e01e8067fae974fa5225f0d25136be36a963b76546abc1e4adab3d4950bc1e8a41116cf07a54ea3f348f26f696fb78e26403aa74bdc176a44fbfdbbeb59bf6376e377846bd162327e94a310874b87efb0787f67d57cdb4a3e93df3ef13813e618cb450ca037978d436cbe499cd2d017b640dcbd519a998067463c718899e380e3976bc6c7e7a546da9337d55f5701609db660d822d5533aeb3ac42cdadc73fcba994f6a6679ea94997fe147daafa2d949bbcfaced0453704769ed47b59be3a453da91b82ba3812923ec9a6634ffcb9570cd3bdcd17b48b19c68f057dae72ec58714a256906ac5e47a6be443293efa93afe6568e857d2c2140540f39049d0922ed9d6a421bd485c5185a956f62d2584413e48dbcafe5747481bc1590a8c759d44d42baf311f1c41e82155a7003d771e0fd90d9c553fd7d2e16e3d674aac7aa64e3dd8b76b4ebfef087aefd575d6a4dffb5acbfc3825beb317e7a765a9364b29d7ca49759834b1214feec26b498bb6de8c7adfb4de3bdef8e3cab6d521042b0214e4c6ea1b5f75c386ad7a23185c906ed054d9c55e3d82a16e4783d699a1d5aa8cc33ecbf98c5ed768d64b2ec9ee35f61d1c1c1bbb92ae2b1ba754ab488e9f9bdd9eafecbdee42e05eedc342bc4547801db8c9ef35d16ff7889f509d76128154f20b3a120743fcc1863730065c8d8aaad27efb38c1fd27f612bc51285193390b90b87c64da9db9b1d497b3d05c99d0a389e2ba8fb271d8bd1c07f4580e787329dcb268c29bcc897ac7ca97879277e6916da44e459ae24356677e4de5cc22e2ffa6f7e2e8287b026c0c46406eb182379a4f814b7536a49889ffff52821998a7bc8a5c4c3f09435dfd6d135ffbaba77b43327fe3982b36f565957f7189c93245a34ecc61019a0256e28c737b4f9b2ad7740610d69347d273f2ef0ee0bc3d092567198fcd50463fff4ada1a959b4ce9ef063c9d62d9e4853bff9c2cfa6d464514efac2a0ec926306c000365d1f0696992d35b532177a0b4e79de45cef6f455ca64a101ade1daadf4426352be914f009e09d6a4ed8badec999e3606d52aa757b44258c78f645162445e6a49df5e72cf5a59c3c0ef80855d03a7beb5842fd938fcca04854b4ee176d8e1b08a41518be72a6836e259ae86426d03ff4ecdee174a953f05c96d7b2acc80d04e3caee990b95a67dd2c08d2df158bfe7535d1da9bc6129e02984a22a3973ff142106cddc198f11998e4db95f7283fdab5372da437cc1eb86fd9ec7bd2cc810de2fb59ae328356da4388b55021aee38d7c50542969e88ae13386a57008c7801c18c3df5d6e01998d902731378ec11ebc3adc88336091fc323fedb97a4b1ca9370f685bb7e6cf55b3fdd1982dc5e36cb7fc404b9bc5b766008aad0ae34d4dfd0dc61c8010df0ee9f3cce390d662f21164b3cc625cfaf1e5af1c32c2257ea67e9e24b6b378432f6536ac2ab9feb70194e8ae9e5bc8d6c9584e3e8008316e3628ec55ec7eb88f3fa54a3e692dcdadf4c72a6bcd80630156f95c1982ea17a73a84846cff6d5e48580de2f0a707c8811ca9ad1a0f6025b18637dc9cc92f688ad365bb4a60ae5491f65b276a780af23912c6c4ee2015114703980bbcc06758b3f923b155de3c83dcefc8e8cf4c0564fff2b75aac5bc2e81fece0b16cb0c93abca002b9db50019fa65055f801db680127119cd7031302d14d6c0a5002fc8cd2f632aeba773bbf2f943e58d9a4c2e3dd8367e48857ac383f08c88e15b2cc949119bc0faac0059d2eae5e2bfee3bf1d2447fdc13fe78683500b77005f2d16a6495b08bca7e5f9ecc8be7fd67378dc74daf3b7aa16b22cbdd92ff655d870de2051a46dddafea0c161a120f6d13785c68d426d566a8e98a02147f3f8d0c53ca88b964224dfe42ed23e913eccda961473a424948b46d67b37b283438d63c8232a80d6f1e3799c599a0f720b65b042108096e2c1b468b5acb6a9004140aa25d46a77413b74f5fdec9c490e1e0d7681625023d1e8c485529c039f70d841ef265d990bf6d1d46dd47c2e69a932bb1b398e2f22f042c00ef618ae4e0aaf29ae602be4d644eef116b49381aaffd2d486a4b94cd0c4d3a5c4266e956df0d3e7e66ba3177c95fce7046961c207f36ddc0070b4ac85312230abeeb9140727940c1c1bab16c72f176d52f5b3aac56965008c28a2bb36302530be426ee1e2fb462b0d3386b62206890a9e441ebab43ad920b306a422ad5e982e439d89c519d99b52617b1434ec2fc2085dc5e127e2d01deecacf80058e4280591c420b411ddea372ac4fe3467d5517ea6225961c63a05009bb9a5dff0be2f2e26c172f3d4a36dfb8786ff23169d461e385b8cf41577c1273ce9b7e0498f83888091ff0dcad870f85c7ec8b140f71c7beafee970e3532915f7cd7b50cce0f6a97a023bbe328c624e4f24fe41acdb0c7cd12b41100035759fe40ef81b63e9136f93d64152feceda5a302a786ded48b04aa33cdf62eb2eb1967ab6606e94478ed14bdd77e249f19bcf824d4974b717dc7e66fbc585f0056154bcfed2f98f040b028305cebecaee1b216f0cb7a794a9f84461b179c7c495f444d80c363eb4e3aaf2521e0b6f72576d0fe6755ff2b119781164fd2d309db7ea088b09b6a53e8c509064d717b302af36d88cfd054318ec698c7131e0cd5b10aabd1cde4e9d0d8ccb47d003139a3a84f7c7e12cfe4ff747739eadccbb29a0ce2487f29f1a39227cc8d73cfe324db77073db84985edcae4440b0f816aedb81c3411be4943e76904845cc90e1b16361431a78bf9329e32c2374033b5bb9c12584c39538f757832b398bce3cd181175b6929f0c6638ee71f57fa7a720a87ca5ed5b669bb45b5fd5250acaa1e01b8bec18e0d1e2783e6b94864d3e376f8f4965e714d0391b1a9c08a8ebc336081304cc130f829c0838c0d67f9bea36f77fae64226adf2cf512eaa204e065e3c3e5d3e4668cf75f304d3010ed2245ecc817af7b870d1ad74db5bbd14379fa04834a16224fe7a1ea997ed4b1152936d562771916fe68b86e9ba8d4fbd70c1fc3de4afd2deb77b5a28b9cde2614cb14b0d7692246056afc536ddf75a8a6632ae1f16d110bf93c707d7271112e79f0ca24216bde6e6aa781262981d5eb86fe7bab5dbca6229f9b4e1d3502353cbba6f7c15d62b9c15a7c93a3fe8d7a8a00eb45632ef5059dec10583ea61b7568650b467c8435f334cd7c6fe1d4db92fca733e90ba55952b1ad44c83d55dbce012907705763433ddf86863dd80b5177da13a3a099e8d6a996c0f56be282116bf57d09c6a253a143d4a959e33659d4a2432e294496a7c9868968b5dcd6978c6813b12aaea531733a7bacb890c879d42ac233d0553b0ff016ab64fc2e3b2dac37ca97d3a4bdee614d8fb6725629fe560128662ccd6c2f0b1956fb00b7e22715ac15344c170ad84177a538e47a55c4a688f97794f5c69a8b8d2b3e4ea3232c42dc8dd5b44f9e24648d959af9ec92ec3b839f46438fb51876e16f8ad3a27e53102b4e7894ae8b758d4545a1bb8cdd7cf026a924e43b3d634938087e72d962d1bad4875fa3169bcb46b8425928d49ede2d16d100cee54769378db8bad96c2cbc9a10f7c6d922300cd838c1bf1d9401def9f5ddea8a4b106318848fc8558be8b1fe350403dfad2a7ad754c3b4e53435cfaf77f3e9166fbb0ccb67469a43ac0fc81298a59c14550864480fe05e3435822f9092f6ad037b76d246724c15999eb640a48cc8ebb333a24f1ec73c9737c3d1e3d6e2d343eadfb0031f7e1b3c7960e5b9f39bffeca8a64a231555cdc94519cdc5c605ae115752a905fad5fa134053301db3ab6f21bc77592d3f4c37a7644f2191e48277648d901def3f62cbb3807156594db33db5968bbf544ecfd5ce361f066fcbff922b5ad90218aee8d56510a4f65961b8615953439c4436d539d06357ecb3608bfe602bbd0751321eaed27ab6180d265e70069c15b5c4fa0136e312e0c96855f0fcc47b7a2ded577a05c2fe5a6a26d7be9c09f847caf01d1059d96ae413a4bdf186efe026cc677ed68b944e2178a837f745b65a578793f6e9e28e1706abc99e9dc3edce7a2fa2baf015fee2374baec9d66a24be2ac61828591dee05308b44549771eaca018fd08a7bf9a16863b9558052bdb67eab99e88c032910d01edd2cf20f7407fc8ceb38e12f1ea3d38a7746833461ae003d75ec2e9b7b682c80c87374a29d59b2d52706d464bfa313c43bf5e65adf764a14bcd4386e6fdd42ff1779ba9dba9d72192a3d820c025f5ef77d485e27b5c608be4dc68f95c94e2bfdaa8f9cbd2da7175bf652ae9c8cb1cf6273fee2dcc510e69963be0986997564eb96e0f19f16a9a886e5be953b8cd8513650f03395f703e6ea5a3ca8158102a2008ad0dee832777ebb111c6e28ecef445ca457a3c42575771994c7d50e22058de42a14d792a634db6a9dda1469bd03b05183ee52d16a1480f86f18afc75d6917bd1789d2d117f77560aa1f0962515b167299bdb51ec670d428d64c3c64aa7220c687fc5dccb3432c5a0d91a497de67e9b178c66381e207671e09aa11f8b1686190490f521c80b3315ed9d5579df608ee137bc601a8ff3e431b86885809a691a66337e748cc27551e1f9e82a0fd2e07620bb16fd4a432b98071107b3e8baebabb2977296c794a5fbd6fc126db9492d63faf78bcc73f14cb879dce7c0ade907b2cc4f6511aa1d39eb6a8a239fe70ba3f191e06f119c1f85d709ae12ee9955be272b196505cb08e099e496c6d4ecb7a4435a5fbb1b5ecada98e55271dc2e48b871706792fe6bbae581d9b37cd338e54fa44a2d12de386e2e2bc0efba6df502e2efb5a72f03399fb5bd1ad46a3538aedd00a922e153010fd8a5dcefdb0a8fe4d138cbd7bc4cac0cda94e1b4d1f77bc17a84f967d8ad3d244f7c1fea377aabd60f2cdb1e156e921d309616d10a2fe61da843c20aa1483d85af0da174a413d2ff0e7a99a52fbafa3c649dcffcbf68d44abb6185edb84b096526b7af918048bd1a569465a3fabceb178158abcb29dcbb4e6881359e1bc0e50918ac796783fbaf17285aa460bfa9834939945f8cd3be8341f81c2fb23c2c562cc708eab3a0bee6735330e967d1aebf9f8129d8c20e1438122f9e1aaef78891fb430b2408de7051ec8d3c2f009404632ebf48ae97f0d8799e1241878a4ff0ec2e2ae039ad35181d70c0d94e186bc656fdefd33fd5733ff040dd442f76124f4c89c9756a9032e1adb1cd577a5745b6b495a40361045684ba2c5fcb98066a7f2ebf0b2d7fb4435a8b0e366efeaf1115e15140d6f47cc680de9076bbaed80de099fcd98ef743f8a8f3e6213565c9c8351255cd5086576ec6a2aad5a9b4e8a893b87cd11cd18f7c7a516e253a11b0cff45ed0147ec38adffb9346f0033491cb6900c9aed15b56fe6dad57f97ddc5d1b644d9cc47e247b70806236aff65cf0da3565a324008a66721536b7fbd09b3fcc397194ccfe9d0b84456d1524c8faf22b2bfef4d45b37f424882635c0fdd730099fc8fd4843921e1e61d19ee756ab634c6de6b121260672de0590e59abacb994702ae8fbea2773fa126e6bce1f1ae88e8d6486e5979aa08fd3445bdffc5e521cfb4569f9573bfca88cf282e49d25f10811e3ea1328dc40c825bf2d0caa61ce199623caad73e8d77254b601a10b449d6fb4769e3a1df59d4c8b308edd7ab8615866bdac7ce0933771d28e68a7adf62db60fe99345f129305dcdf67ddef407569f604d9ea16d85b49083c8876c6b9aaeaf236eded22ff71910d37758f5e197b7b9dcdcf062ef7b955ba511daf5999aaa260c4269f73b970589583ece8a2238349553d89d0562f34c67e74803ffa3092de940e40f7093f78c2aadddacd2bf6023a32b904010553974bcb00edc75372a63929c2c1d8669ce39686e94d11da67f74aec8106ee426a9a0abc5b26a6961a9be50f7a47dd4c77a6344961f40d20b1f448040583004f5552f64c36668d1dbf8bbd9fa94f8f349cf788c4c0cd89e89977d68c952be030e1bd00fcef5d9bb033cc3e6ece663fe3ea533f1f0c08b1a456e0d6b201f58c7f971b7f71734d47aa5eba792e154c938a0b2a9beb76422ea70e62d4f1bca3029afdfe82a86ff683e7c89bd23f548eeb589d2bf668d2ac131d3a81e4f342f371165506dfa73089f6ee27a9731d1efc92035c45714b27189446489fe039b5b7c8c41dc2323a0e901f63c489e32138bbb298d0db5678d2de2d6bdc0889096e424b3d08c986c6da2a1be50c32c9c68d0fea5e78e6531a99bafd8420327b199945b5c323f579121db8cc806a9e2a5a2413cd27f62a3d20b9cd11621c1f48a46ffe943806e0a3cd6feef0879bd98e7b2e66622c356fc40bfbf566d709fd7374176129c4e14b4bfa82534514a542db4a2333424c5ca904f696969d993624d318a3a108b84be9e45442aa0550e1259d12268285f68588a605d3c7802ad02c1459bb3af6c154730935c05dc9c808e9da539addc52ea1b01143f24bbc136d7765229ae9ace1248166817ecb776158ca46b59d3dbb16c5ff1a27b9c9d9900aa030da8f4fdf6fb403f38f35a50f9b2b9fd2f50a996b0d6eb22575e1b23eaff69198917dbec0cd3292fb408d67111ae6229ce176003225d0d6cd61e4efbb61a8d168fb1ba430b9f3db77668f31c2750f866dfb2b2ad8d58ef0afed6edb6088486cb0a790d7e3609fafbf85e937c340aed421148439cf35f7522de7df9be58316440cecf2a36c745702591a91c0cd4e42a8d295bf4ec4f76503b41e83b51962980450d871af679f5798f0694b65ac299ff187ba3e99165062bf0910f9fa8cd62ae94bc48749967c5ef5aef2af713c68957e5fba07eba768edca7d0c66010c004f44f4acd44b76253a8d24d1771a7e755d9b90a4c45b0aade5e247934ff2b95a27f48ebfcc5af159ea2315d7964a2d8f2c744ccd3d9e4571845670757b2eb14ce40443289f59daf7f42aa52a9f835fd4456203807e807c6e58b6d5910d383b0d27d40a9b6c40db37ec4211b55ba2035ec44d800b7b0436bfe3c3604aa39cc0f45fe9cc386097ae928fdd5ecf5022aa6bd2575b4b744da72f63e31a7ef7c6e7395eeb8b9d1c4dbf3f762f708b3f0fe36b1ecef716422f8327fd3eb76b1fd9171c67396f939e21124e0ce6b673257c1ee2e6f4928fbb03fd2cb894e606a08d9e844e92327553ece91845b026e8f3635137dc8adc070ccb7a8cfcd1505a4a0d5db381bdd07c1cad2656ca9609c6c14b2663e4be3944328de515e9ed2d4641cfdc468d7eedf0139fcc0621311ff347f61a48d7716b82ccc2845bc5d121e37a3eb0fb2490bc236e713318a587bd4f699c528f72a0ef122f5985c0cacad0d08531c0e62f388b077551f33f8a0eb95c4a5ca9b702a488c9dc0630e7d21f9dd731dbf91f722f9407b0d0d0d07aa18462cd21423f229b5cb79ad69187f1608aa1ca1719e1d8a7c776454e0642f5d1de3aa78740fe35e42a11dc94c78bfc03fbe5d52989adb46f672677d8222c50ceeb2a80a93aed5a23e1ee2ad2cd4f284326f78691773fe9ff4636381213fee483e9d13d271e57b10a2b82fea9570654f9d7ee017790755aaf49e5dc1f7a25bbfede32dfaf60ce2eecc584becf1f48e1102aa1ed22a51a96b6319da1c392949a0604710af21cbd397ed1e9569c607040dd815305dbd2af60a5ab3ed2afb59ba42828f6391c75f136646c58f1a59ecf49fd9f3bd71172be9b09353d0d991cc220e63b141a6cf9f599a5fdaf28fba4d4af1916e42b17d025fb5bb7e1d6d40814a1e57e6184b524b2a793b5fb8c59676834744dd04c467014d699d271a16827e424717e2a092f32f639fd4ce6eefa4b0def7abfacfac20dad8174aced4039e4f4d3ec63f95b1ffbd3587166717e7e52302f351dc1616ec33f944489bfb9bdcfdd6c24e315daa24e81f8729a861691229bfdb4b8a9a4794463da2631d4553c8da105f2e8e9010776f05c21f01b5dd864015a54a09f495935d9f1a77d79e3fa5fcf589002090ccd89a91ca5488021b3adb752528dda905f1bda2a44241bef44a4be8c6485383724808a40e05f8a3093d589215edbf6408650498afb48421f9e9fe3985d062f65cdf73dfa96b88ecc4530f07007b03263aec49c52bdb690252440a746bb4c80ce77037a96a5393d402335e5c7bf0e877ac3011b1f240da965f6c1397b43161b59d71d2396c9670f9d39664e2eceaa38abe393cd070c386d8fb59a50064c1064b5c84839df9b92ecadbbc3e634ec49ea6da631560753dd997ec5512a47203a33ca892ba1668a2956f4813a3204ca27ba647605d843be2facefbd61df9e71937caaa1793e196a1a1e267e69796c145e429f7a99d136db524ad144a75e68d3fdc5555ed874eec6eb929865c9473deab0d9ecfbf8c59cff90f4f6c18a03acb773e2a644a7480a1db1dcbfce7592e2085005eda2b507ba83c6fc115f5e09817f63ee67192515963dacae424a6daa2b9cb6379a12131c591bd7b3abc15b839e6bef06892c150c8326b8a7080c9083d3e86dea68230ae71f96813650bff723be38364aa61211bd450a5a02b516722c2af77a40af801404efc37cc15a5e44cef94b6165cbccb0c739ab65617380a5ecd08cab91dd8ebf4bcf795e5657c27c708caf0caf1faa51e5d0d32d05d452c06efc8e5a0e1430b6564c618d974dd4ff1085a699dc62135eef8cdabbb98fdca4734688f1fa30d775519a6f7de49afc74c0ace3d144724ce283405a2f023ee4adba56d052fb24842994953cc337c47ce17867d2fa29e28120632b09cdde5c5a7c2a01a3364b82a636407bc6bd6126425bb47c9309f2c4b1fb578208f2d3dc0d633aca0e250d3ab70ff920d6307c10a58a338144752efced4351f34d0e66da9587f2899889ea448d463f3a3b195849f594c579cffb38bba0f06e3236d8d6c5844adef86db394152503b72b629c95e0dd64960317d14995b19a650e21d94bfa2519c03266b65f47525ac72c2e9707bf0468ec02b3edefe57ce84d4e81c856f5568ba6a151d6b0266810853649b649d6a55c5ba11331d32cb69dbcf0d15647cf0281ac9056fd363c1c7bacaba205165cf64939f8628dbb607c75bacab0436d559c8db28248fdec42c1795c5e5e1b50523d8516d5e9f3d4af506ab2650b470e9589a635d3fb524958df0b6ce577397ef9614cf8798b3a43149fa23aff4444277efce9624f85299636c98d809ed91403db0cacbdda226f73c05d59a97bb4820525991795f93d5f0cd5855164fa03e2f96182340b543443b6fde231256f559e9f4a84f1b0fdf801abd45a8375eaa107354f8dcd9fbf4d664d7028662969c0168276d8c7a9863acf6b5109ceadce174ef628052e75bba73c2ae3475580852a6205b0f8e029f464d893d92bf1c131dc2dc6f48e1921c947816b7f4c5c689c3e11cc5c19ec55f5b926a64015f18dbaf7130eee064404ecef35a7264296b798d33000809c7b4a1a5c4b8bc095021d43d50746af1c71f07e4d13e458a2e835cdf6120084e533b4a184e872f231db56aa22b28fb53642dd1ddb5e4c227a2e657fdc945363755cb1944695946fcf9e51039877881945f5429ab49aa81a20085f759745243763a7d016f1da9ed56c7cb3cd0021da972d146b5e7803c4dc9dce88b72726eef56930744570328a71b44c9b4ae23f13ba4c156cdcfe24835a38a16fc7f8b642ca9f38cf96046ce6a1f7a7fbcf6223d25009794a35bac0219f376d93b56bfd42d0d764a1acd084403c757e2327bb2bb327d53f0b2c8e858b50f166f1ef38935419894cac5abd600d2901a14cbbeee2e39721b9745b08b416fa67964bd550ede58522f2842c3d28897c1c01c8a1ecb9622104c4fedc4a7f2f04e053f03f365af59fe5470fe0758abbc083a5bb030432c66c979fd2d888ccc60a12625a1002cf36762d4e6aef599e57d9213db1205ace92fb1364fd9a87f056ef20014239eebc5ac01c529bc86b00d3ca9cb90bba1570633dbf476e8818f5f6ab771793c40c3190812f34c0e1a2184073d20d1c56511a9d04cbcdbd76c9b60f980832fd35380cca9543400cc2ff2618e769e274db8007657c4079700e68241da2e404f044413cbf28bd089fb11aa2aa6b3181683fea776e66c07e7ffd6422adbb19336b3fa576941e61c09f42f2deac044e35f41092ef4077c6ecd8f86610cab563d185395d864ef8a662c1420a32a275a2504de096f395499af5970504de3606e802a03c80d8e767f87ab18f141140780fc05c1a5984872af1f9c439a64b4fcf950734ed7cf956cc2222b03685e64be31608c2ed864b1479eecb2205c8e33a831c768c5332f764bfa567ee18b9d9af5dd98f13e23f90d2d484cd6732eb12a3302f1bdb4ff1c629a67febcd133126120a3532159665d0864e4df65456be2f9ae2de97bd4730089aa6c33b1e9eaffb89de33a9738a6185d623029c2b74dfda213527dfe5525568ae795433f0bd7bce372c149d9240a7f8f05b7fda23aac91da75adfe6038d0a65d6764d96b04dccd222378c92404c2a9dac3f24ae7d43fce4368044e7f788a502938215cceb1c73c8673a6814d86ad94443783f8c95cfccb05be6c79c84f4daf8f100d1f8be7bfc62d9cbaff31bf0e8409ce66b5cf020b81aa00fc7a628832cb3aa37ef8e5d23fb583e7ecbb4c4e5b958050e16d3655bcdb9c28ed73dc9497b4161e0f59738369882a01143e93a92a3de3f62f2602c4b5d502b31b5900806518950c7942a27a50d6b9dca33badb81b2964f76023dcb8855f3b21a5fabf356c82beff99c15d267925930759c89f7d7aff664f3605a540df6c6d2f82d5a4ce97feb4c8445775a5e8f3bd9e1e32c830a32c9433ec24ae353df89adf0464f3417c903a1493b675d8cf568331cd5158d97655e47e6e14d55e4924394cb3ff885a8de092b6d2b43bedca14996e869343924c0249295a6ca08a185feb2a155acba45a66000a7d9ef9f49dafc8482022bbd66501dd701589178029ab5e18f5f8184a2cf14c5dc4d35794faa08ba09b2ab1c9a09f04ddc6b5f0bd0e5570e46e9ff6f19b3f5c1e028689f61ea2f1771b86b687e5ea9e7f9ae3f893b793ae4d1f52cd23cbf5d88e67232f1c852f27279101ba11f6c3e72fbaffead6c4b48a3f9ce18aae88a0e67f58535707c962ef7610286f3ec082bfc773f5d7d7f1d05e90aea7146115a6a02a65c85c0864e697a500d2992316dfa5fbd5a60508705a54a7f35c3fbf72decb1bce00581841c2caff23531f04918b13af1309a9ec9cecc4bd1ee796e96345aeed1fc244b220568b61ad2119c3faa64081402adfffc6ce82eef0438836bbad78342cfcea162057c23341b28ed9a20969cc82543196ef5dc7c12991fa7a83a1545d826d9b6c583f32636d4e52a472d1f01a26835d5d54a5ab03e351e915fecc72c07ebb2e92b37c7b76e5e8649f8734928ea5ae21d21f60fe7a5076551e22e7fa84204c475257589eb67370d222fa43e2ee2b2b38cdd38662268f8de1a06266b92453c2a2b731d3f1a4caa0c2693525b3d2a60214f2bf99afdd018c7847a7024d6497b75a54808f924ebf7361dd8e5881daa5f5149c789b02025faa222f1692d41acde6279d896a8550b82f015621908fb3f9d3698f3409cdf692a1b8358414648d15783576bb0d33cc2c04818abcd8e1a2852e0e350ca977fd956519d9e08e17084c3d7ab80c9b1f9efecb1a8c9bb5e9d7d9a5c262494ef9e21c1d46db5b08e93664f4efad5099a537077330a8920ec9ce3ec931173e9c3585bb16fe8ff896d92e391194dc4435125313e08c05d5728fc251f25065e9c7dc1cbca292813df70202a6b65cba8a2d8c304fa1b176d88d5473f1b5fe13524ad8dda4fe4b8cb67ad9ba7c16b0679e6d489a6ccde89f62f177b5cf78ada1b7b34462a8af3eb530be5ee9272361af8792dc12ea350a3308224b904727f9071ab8fd2b64a1bd6406dea3440b2931c9be77e1cee809fec72249b3196bf5917612e99cf49033c070c8b807480ce040e2988edc18a1c34c082e91299166a05d8556b2229b812a32f9d598cd419c4510f55909720c8d80d5c00a57ce493d07ab3a557e3abb014ca6f76d5ffb84eb82b4e1555d647b1f09abc00089bf05f468ca5be95cf0dec91299ecdde421bf0ce1ef167439f713251fe9e7135c249705ccabc8b3495d1801e57d24e4e257bc110e9cef2ebec8895e5c4e46bfb41ca9b62883f3a593da42855153838706fcc816e2bb7acecb98c97e8b043f6fbdd00842c73f3d6e6967322771f25b3da4d528d3ea7ab4eab629b09bfa62c6cc5c0ae956c90262b4da3e4e9c7a93db1770450b24b48c268622afcdc911c866df18d57ba095a28c9178e727fc56d2fed3974d858754e9b44fd4f29deb96602e26d1fd18545e8289066fdd34d27ef5cef22780de18d58582e2258cdcd2b746987093de3647c505d48e31793a427409721d2d71e803f68289452b142ce46527c681b5637c47abff3430753a485721d502b161325cc86653569ef26ffe075913a1bcf5ee0da933d69dba3bcf0d3037e3d6b73dd22a8498b59058f2af36c967786ec8351e13439b9614d81d0c2df463c14af8b8c12243331d8a30930b5c560987f0281629a40958a85746f3ef28fa6b878fe987da090b5bbce3bd7f2c60361a25a11473a09eaccf226d0d19e70b908e36852ed7083536c2c473eb88dfe8ec309bc3b6fca66917459ec35b262dd20d6119b7abb95f46d8af7ecf6e761e11a4c1f6eadea96642f001f79a5644db01abd68a1ad1a496879e78973665de6748bc4cf7376d2851e9ada2697b3791240796106210705bfff6153c2776ed9d8ec999ffe215e7c0ba55fd921619f6e01c93fa148c91777307a79c80409e833cadaa7643cde5122952f29a9137bcf1c4313deead516379c70c3ee6e90fa24c856256215d1839bee7d6347945df6e1afc7ccbbef63ac107641b603ea55c366591a131feb869ac40b78e2accf7bc586c620d735b28ac23f7ff3e242074b470e25fbc303ba0d79ac4f5373176cf7d832621f8aad49a6f17142a3d89ad8cbbbbc32d4af5f65910801febab89329891a1f102d30687e403cea3acf772fd08d23325bc12aa1723d74206227e49d19bc056c2da17108f73eb7b1e8bede0386942e6e423017eac779c94897ec2f80014c6b686dbaf530a3fe7408e22d3766c1e0850dc2d0538c17e7e89c03015902c45fa10eb0aeb5ee7e64884701c55fe5caf23c5ebe5e4b959cd69119de0d11a20f100d9478002288605aa91be9dd2cdfc4d7c415ba95d38cf170d7e4fcf0d94325bded85d73fa95733fd4d0b3377c67a768e5aa230e36b6505980b9f19ac5bb69853e139fa6115c7b97731c0f5a698e430de69bf43592b542510734412719664d087cb7d1ede2c78cd346ece4c35281c10d03006443c904898c93c5a6b2234a33369edf5cdf76241def0c8b321008ddf8c5d44080005cd5e3c4656af5648b816af3f37d831e1f1ead9df051f6efd6d3d04adc1861737d2ee9f17db6bbe2f42fa870eff4302e4e57d00d4193c3d482ff4eac858d9f62b9c4ce3091f9ad7308cd16e8bec92c68a3f24e3aa4f4a03c887fd3d07262caba9d644bb53321d80bce85abbf3061e5d83963d89bd340efcd72623d044463e2defbabbf7eab8e2b83fe8b4db8aa6705e2b736e1d8acfd8cc769e5061966cacb8663ba5aaaa0233efe2b6a4190a08bd74d564c10882e46a63b3381e6584b5f153902268f050ee98a69e77c0df24f33af923bd03bdea0f8865db0326c6dd5ef127e06589fcf4491c87d3892250b30fa0ca30ea20bed1ac3f0aa37a2d6a6b1aede8db44777390d4f4549f67ddb8b08f5f40531b4a6ef5c88c90dbef37713f69d4c13fc2f3b14763622629656c9065de935ad0eba392f041684a67318f9af15224b238dc983e2b6756f22e87d5ad7f3943382e6cf1f6a19166ea29e3b4d04ee47b18cc511b4c6c9021ee6787e959a7ab84f9aee30f35ee4cc2f0ddad48248eb565ca652106ca0a8e978a5a415bda04afbda3fa07a13fe914cd9124cd5bfddb12c0ddcd5434ab37bacd8fb6d4c68225dbe5d60baacfa2862801301858cd544adbc8cb915d75ea0b55fb1dd4fd592959b8f162fd8ee2902f81392fdb2674aa11acf9392d3efa6a65ec254dcce05eb9d681509bd403657b1d376e4c3ada9ec182ce246195485719c3126d9b29386df5107a9adfc499ce935e81f856b11860e49250d7dafb7a7dbbd9541698ddb2e02360fdf4b7148fe7841af3d0d9ca64b4b422459b3a621b4df30f9ffd6b34afd483609d0944f2a5c8e6a0afcaac28e0610e800924986038586d0aea1fdf935744a7fe315602041ac2aa8d16019ee690d48b281b243cf66a435e8a41711b78f09a5413b2e78d8709b68cc43b5200ed368ec3182b06798956c3be1bac82cec57283f68b1c5991f940439cb361a511ad58da827c7dc2600ba3225eea70f3d09551c5d06b6c5737f134d3c2eac2528a578a59a0861058365ad8d510d8e86775ca8674aa2772286ad96d47becec4c4daf733ccd8792a9476f9c01d48e97d6eb4e74f99fb947d2b93a42d28bfde091b366524d9f91a76288e6592a07318997f0cf181f25f5fcd6bdc70b2feefe3cc7ba456f1597624ae9c1c951f27f1899c406977bc14c3054436800dfd554e881e3f49ead1a17ebe0cf048d7912112ceeb760493b9795107f9a9a518379777b1126e8806cf6426edf429ad22e68df9f017155a85f49d964bc2df066f0174774851bb558fc3f234eba7fb8512f5effb8e6a79d77d8d2574a29240aa0ee60f5256ec6d317baaa49a97b965db3e8debe550820413f79c5b47d3f3553a7a6422e90831799ba3022b42436487df26f4b9c4f19a4cead891d30b19d1c49b9bf681eb3318ccc4eafdd71efac6a2ff25299d41d82206d19c893cace45100c7a00e140582d3b970b214d0821f830cc1362bfbc614e5246fac85e3e25dfaf83de4badb8b1d0f5f874ae36e652dac5ba4d03b77603844f5184afb651a28ec7263fb925a239ac64936d0f52786fdc811e6679d47c799459e84fca354dabc4e61bc998c0a3984c89138f6cf528f141134884b509568f1a85086bbc407464c0ad35c38baae623924fd8b27e3aea4165f1f9a4cb19dec907447e46f3af7954191f73cb1b15a15e75cc8d55712732bc78db6e768f5b5bd63f9c82d0ca0345565c20df380b5786682a365b9ec5296c6ec442e46724476b35adc5d2d2a97a424e07ea7f6031b346c62c9b1457d5e09bf71954d5369bd3276065a1f605aa5050a1b21566b17ce45f6a09b63b4d5447c87b25c0e43eeef9da33233d6c481944b0a832dfb07a7d4479fc6de4f2bf5b7e6185840c3e1398e823db36ed68f773c75d7fe2682301954c1f3d77720c12846c0e594be24db8c7732c490059fd6cfb24ec2a7fd35b8496a7d19970e35d3562c5c72f10efc18dd18918bfda891ca95609905925f44742244c899ab66c959d8ffb08630870460c4eba4b5d12577993d39d6e057f6f3c7503adab893b9d1c89f5bf29515eb9f7ec11c58f27968654af388326a9672a8618e2c967ffcb5a1b0e4a18e730d79ec216bbb3d8b8adc0a7c5f067b6334ebb70aa95d7ef618e0245796d9949fd4952785f857224c9186e2f22f401d973c61d4c71e8372dfd903a971ce7fd46ba9bc37476d7db9b5b18bcece4117b1018c6b18264a1de87101d4e9b5a5e669556b80081a99069eac476ffa5adf6269d74a68741c780abf090fd07427a538f88c1c146267b2ddce7b3730428cc9b508c666c4be2dffb2cbb86d8b0f7a631858b4bca0aa9dc6613e9be4b71306d660fd8c18a005fc6aec5c765c8209cda0969bb17f613ffac99d9b06c7d8d71f9db1c97fb9b58a5184069093f3354493849089577aaed1e0dc7f992af5bf517f6c20d40c27e2cd5961670f41680be5fcdd3b55335480b1ddb991bf396533ac395961b5f23657f6a569c7587f4377de4f6907ae87f347140b6f97681ce525b36d746ed5924337224e6db1f2188779a4f5ed7216f215e239681e3249b505cee0df259de12bc693829c8596d3e687cb7068d06eeb1a7ee23005e13df09a45831394b4e0ae90ef7ccf408f229d0f3c2dd3a443b0d0c077cf094a5ff621f40fc598cc4d3a9ba24861a6bb0e116ea7e8a4e777f3e9656228234eac1929d47fc46ae57faf0a54aa024f15c2d68d280aaa0be9efb300acbb02394782414eab47e47bfec0f7f4bd6ec2877167bee14ef51a6cd184ab85f61f90c6653e88199e54aa4877b8a61db5e4533fef44f4893231919e5086360236392abf82984aa8982f2537340ad94ec64c1b81bbc3daf1cec32ec33afe98d00b105f6f40cd22ceb97c2638cefde6c53a16748981adf75b6973743ead1eab395a72118e8d17aa06d37b5d7af1c1253c56123b75a578836eab5d26db12a23fce3d7f2b15a8686465e396107758553e4398f9f38056003b2de5905b091faa657251d59c21d12d713ffadf20b8b98d12af6f4ac733215711a121e2e6a16545fe4dc552a47b4192d549c9fcc189ed5f9aa52f7afa875c1228645742cf3f39128dc366a4c6b3d35c6855f3f02a83240c6b80e665068b192b4aaae0ef8a8767daef017f1af3fbca54dac400a1ef2d5fa5897b996fe4c60af17083acaf099c01eebaa315b105b661699fdcc08ffcb613587be2029f6cca1fbb38e33a835534618c6d95d7df59fb9637efba05b2638e1c05b3622ff1fb1c9d5a8125e3b288a06c77f0af45ed1aa83cc67ceb6285d27f033e2777d56c0ae9b9977ffe8b30755c7d075ecf32ac07b3080d55459e7961f2fd997a56159c9b9cb7b91374e25f9dd379bf8d9b0a17d63731d9038681da20e7e4584cd2c81230d4fdc0be529c143cfe9730d7b08bbce2a8b5128740f079971508b05f897f927f988b537055498ee541d3b953e17b0f38aa0caf6dd3b33f22e5dd16415d159df6807c6b3808ab16d0267f8a67e2da611dd2e3f21272931195a9539d91e9a4d06261822a6413c4ba19e377e36b1731f5be4ce4ec8802a0c01ab147355fe76ecdae09bc2332b13a4e2190033a7162a524fe2cdb17192cca1835092e10d023c40c8292366a6e291c7bed049624b9120ef350e61c76ed56870f9cac5fee9db7377b95b41ebcc5f0254da1f6600d7231f1175306714fc6863efe484df8049581105956bc501e4e32a01b2732e121c203c3aff4238ca905520176d00fb36a133209e2ab503545bf01b5dc9f489e328ea5f3b466bd6ebcb3685d6d92449997f9042f97a68b5c0a0da9148205beda2fe31fb3efd0df55a01832eac7974ca0bd84a2f334c31dd8d4549ffc107d17d95df27e461d91386b3ea017ecec5e45415cb8710308f9caf143f9d2bfd1488ac756059a825b8d85f12c37d508e6fc0435d980f1ce2966d57dd1578efc460e5851c9a7718daf2cbbfcbd95b8dc4a384c2609ec7fdbd8e99607fcf4dd5162b75a252ee442f466ce00e7f140359e7de1632c2f307304c6200c0a43eb4185aea77eaddc956f4021edabcda39f45431ae6de7907c2847717070c39349a96df14064a4fcda7af7f1672a6b4080eb8287bda965db027fd76891c08aca41cd06e037cf8711492f4f4ac2374c7d95ea32ded8f3bc1d54b000745dcbcf5ca07eee63c6ee8cac36c0d107fc47d964237486d353de64a688db76ffc7d5c4f07e5c719dec420cd6f1be2085dab4898accabbed6aa686ce4d2b7311b0522756b919f29085efa0b303f62a280c94a81a3850847fe86bd8931c39ef73bf583129963dc7e4890722632eecfc00cb36df2f9bdacd7ad9ae8b2b53b69eefb9d37207fc8cba5caa2bb2e507f1e0fe7df3a30f36f82362f907101da83622bac9e433290d8d73784190c275de8115b330c77cb6ac0d7d7acfa4ca0b48e117a6d42080ae2fefc5bd79f2cf8ab7a2e9fecffdee1d77b60e4f096f6e0dd164f2500b64f6115b56b9e9fd48bf5dc4189da04042c7b2d962d899633ec276264e761c11df869a4c17263e04a11e5feb91213a396a314918f5a9e78a70f928861a9c9e0eb286e2e43246546ce2ed5d6df9014f211fe00bd32e40ac32356997c39d0aba78ab371571e0c06cbf22f30c0f010f309beb55a6acfffc55213709af7214bb5385df722f026138212634d7213626ace466b156a95107bb326e0699601174f899f0004200783dac88fb5c4ae66d6d5151cdedffc7f15148cd361f441982fd41e0d1ed7272a0e49210ebd737be3444b8e90ad410f9bb02eeb0938dedc64226dcc65e5d1b4553089411adc3bca84c9180dcb75e93745757c5d66c52ef8c3dc8cd47c259c89e28864b035dc2d799ea4c616d372f8e0a1d17f5f79d3a57c9628c96c7adad2aa0cb5759e891c24581068fe200c042befa010a48c8628e1cb57a80654ca12288ea4b8c78ea2c7fcaffefd706a82478d997bf4c6557baaf8c14c1a647127dbcb2d0e90fbdd03078cbfdf95f7dede47a9636eff66bb60b2c74cbcc43a1cff4bf75e9084b258773ed9740cc3a3a30654e91a0000fed3765238bd449a8e85828bc7ebdc0934f6878b1b6e38bf561c36298781daa0d6511c41d4322e1fb4baf2132f8e441fc16c3c2334f3ca8a9f07d07980661f655963b089cd276cbc846e9676082b9c31256f5b91dd9e351276d68a157708e37af0fd4d0cbc01134001aaef4c34a5670e5081957ef72697376fb4591d3a095d9d66e58bca3468a6bcab7addc419eed063384bbe5184472355d7029a2c4177f1fcb31449c14942db408807fb568fe5a7fd5f579dfb28bb4d711e56f16ef12d736c1959bffefc3c58ed27dbc87d23fc926cbdf9306c8471d73781d0bb03701c1fde019a3b7e6271df272f67c60d6b0798ca502ab5a2cd7af6a5382adddddb9a2295fd66a9127ea2dde67da685fc51fb8dc210ea13bc31ec60b40629dee4a6150ae0c40a759af0c5e759020367a85398c29d67e2374d56c3925bf5e0eb61e2a7cf40df8304c4d6efed68febffb589c2cde1557af0a72ed6982795b6e037d62f93db141bf5700c097d439e4581c1435abd5d677889c48f9274fa846b47830eb0d62cdd296b668d673c941bb0668861e60ee762fccb469603dd1d12954342a1aba927f80c36f899c9624fdf220814386a2b7add3983be2a31bc9b2efd9c77bf3e8bdd56202df4a2c2e4cb46e2e815a5db68127e29918029dd08ce6c498d10476c708d47c1f2e0d7982346e68f32d47de0d3baa582976e956dad7c90de2c04d5e12eb67dd964e6c7d97eba50e0399f852b31974c56fa5f66dc387bd2d109c0f0bda48a0745ea6217a3bd4cc58bf7e03fff589d989d92de6c8971e23fa1cef4237fb976f77cedd5d68b091c1bc42d1d674d60a4fa1a7099ec5718786b8972ec9b3e7434bd6b43ab48e291a4583129e17e097b840b31c7dac3e461a298899ab3da3a688d1bb7663171b6a8d7f326cabf3644cbce38cdeda3e72e3e748bb28f081ef1010a55a81253c79e387c68fa89f734a39e7cf933cffaa48afebf93bbcfa60bfcc771afc658f6dc8608ba6cf0f6cd465ff29c14303f1c6974a219d515aefb8cd7860b7d9fd812dc4c37c87adcf01400d0b5966d72ae51b94fd98bdb6dece22a930f39364882f161eba0a0f5bae1a3cf9da780bc6e762f7201789911bfe37551772ed601dea1225592bb7e37a49be4c05c460d3a9f6b9b69544e53fdacca173a63845dbf21ccb6eb58b3d7cad85335c4031725496c735d54cc5ec0717ac76853e2263992cf55b033d91f676366c2ccfecf0e71b27df30762ed4495a4891af7ae18189043a1d56d160138677f67e77e8c2af3131170dddcf2dcb13cae8d988298b377f5390c5e9428ca47b753942f59f37c4891655140e4451482a07aa46357fe24515d519bdcb4f7c5b7d298a82f2f9a85ae0e4026804ece563b88259c5eb48374d36640bd51f7de36236c0a1c5f8aeda2c310fb660fec1dfb609e4ed9b14513d1bc03021dfaf72033e55d04e4f65bd3034ec9093dc1c2aeccb2123cc4a783aa29b8b9555ed513153a2addb5393267609b349c4894f53828d4d8a7d2b9312c0f4b55ad928e729d802355fb7860e96c5b1df8361d6a2011084881dfbae8d4218c5f8b3cd488b9837919ae1d403d96365eb8e6c2fd3b0d65f4253c41b996edcd9e9f8328c9758fd72060bc3cf0ac2cdb514edaf3509e02922d709e3f416948e16f8eb1fba2f50526834ee5c40d2ce0704a1f8764cafbcb719f3b3b4d6abd27ef2bc015758cfb79ad4d6a754868e6bd1bf7bd03ed94ef321ce0cffbc54ede4fd3aa2f564d71cc91d8faa5c64b57e5463c1a8726286908076d0a62ac6bb70981b3ceef001885bf88e030b57611ccd3970ce55ad70a04f44c25e1adcab09e93a2066887aa6687fa16e7aa8f9fa3e3b603155fe8704e56bb4e34d0f7b38c6ac362233059adbcf3e2847e56ee779454d30b8be0129e59c20b1db28d16965dd26e0176ccf1d89dda8fbc67ae22097cd5101a2a6cd3667c1322af287ffa758734fb1aae809df8aad4084c56b68f7e8b997f51bf01e821d99953d38357466b4d43751aa495a2b63ba127bfc606686943029afe03254ab0647e65bfb872ffe6e86e0077fcb49371725c60a8f9980a28c28deebd4a595fa29870e8f567b628c69adc413a7f3814271f78a2270f30c8eba57a2a1269cf5394b5dce57c0d22596d7fe933c7d616f196fb275472668effb9732e5a3497016622f235a563ac466c5174d9f9660773bb429c574734d949562c938f9aba1bd2181745d76b51b38670b48395c78eaf31d0282c07184e5f77d3a8e8a5409d43c493934ba08541e529cde29c2f5253cf7de6f24a6bce7a09599d1198769bdb1a6d58c701abf1ba2a6054fad96c71ed4a6ae3ba0687ab9659750a3f46069f3edacc61a659815f6bad3ae013eb5c54800606dae26284221fb72806f46018b73792a20f73b8e95f4c3cf0f26346695185a491fa0ed860bb1f34ab041cb0615ebe6fcfcf8f9b646b720843f0950670046bc44ab0e67210fa0c4cd1c47f0374d1d2312e4e9f76704ffb474e2f93843097e4403b31af3a75df7867afae25857ed1789c0b186b75a4bac69ce8b79ffed717a24a0646c51da6c2e7a5704cbaecd9a97bc7d51685a1daf2c3ed83f68150b189b4f720c36f2e8908fc0637cbdbbad574845278f2499bb0b6b10579022b44ce3ff8439fc8432ec1f740c05e868eef16ba5849f4e27f9d5436ec65e87228e76f6aa043e2830a2185ec8e9edb02bc7a04c64b3dd20cab77095e7a4b3d05ddd4d2d55c42d93f4600c3e7bdce13e015533419da84b22d7c8e76b74f403a8bb0c24f3c2fda1beaa7eefea834468996688f856db3edb330b98813d3d8323eb68907024ca338a3373cd1b5e7c7534341fc28630e920d210fcdb693d5ee925473810ca4d6022099063da196d42d02d208ab2a36e5b7ef11dab9178bf2ecb8f6054acfd6b7621efa1e9e528de3cd7776e095da6f4cd8194b161146013a796157a8ebab128b4382ac8a7e08fd8d7143aa41611b21efefcdb1429724bee89c36eb5de8e19d0864eb86222b34e9f3a4dbae0d1e383fa317f6c0948df47ddaf546c97b74cd89a07dbcfeb5b3b21d973494752bf191772366b0c09b41c47b4742692e2526d248f6bd396de7635ad859b202332ba89fffe65fab1237fdb66ae1bbb3d2e0d41cdf11148e653c6cdce3ea9ace8070a5ee045fc9c5e0a786a7459b2c0b32180403210bc5cf61482749320172d40b6ed45fa51df08ea20bd1118ba369faff74b103dc948ef013d95a40adc78f7032b6f0a77da7c0bfb8596c0a134751115acf20b593c797b18c0c596f466be8b0be2f0f6caf75831aff1de5ba11394932b2868f9f9e39d28bfa96d73b8542a31934f6f2132390158b0d493ec66eb900788926902e8a179e68ec7a75e1933e15b7611aaf1fc69f8951caa6551c458f61e4210352cbdc8e20c9717770107a0027a78b1a11632e0487c9e7036e45cf187fc46d88d6c7e88d412e2e0e59371fb1df9d7588351c40bc84b1801228860c96be5a3643b78bb4dadd5cdecb2e8a4721369729b94e9a342490727b12c969d262eb946706dc3f1b940eeed13de48971e5db7e88fd2c0c45b3610cc37e3661d3d6ff673fce01333209770ae1a36840bab5a047f97cb40844910481f425bf4c87fea8faf9cbb9ce399aede606a88ed782690829b7a3880da6b40d5465c183ce121151fc8738a2d87955ce615655155b3fff88b3c9b48ef4f30a797619fa2c08eb1c2e08ce97335adbd072fb3580735164e9be51f2b94f8c501ae528493197f1242124a65fc23a8a7920f3aed6e7a1b533d1fe05f0fce084139805b4dc236a634cdfc45e834b597092ea20e4a4824a3f8d8859c65f0e6b12ba5bf5196af2af462a7114551d57cb5fdb0cdeab86d0003dbf38ced9bcf52f1871eba811694ba0f8e92db7b0d01f430c066d60a2cbae894b02ceb698a064bab5c3ab3cec8e662411a4d99febf4c61bf9f9b50ed1597617bf6c6269081a2e12f06673b4812b79251fb9aa8ece4c3dddb4316ea86dc9d58a90aca9f1ae6c1773848d6d127030ee93b186c6647c926d9e65ec5742960d3ee037314aeb50153cef7024c8ea44cb133bb3f71a1201c554c1e3e8ffb5508de0b3a541d6fe91338c2dc4dd0d9b157e83915e3d323804413ec5684ca3d9d5b98a357c5e8a80ea53b39244bb64bcc112450e53c136264e09bff6cde0b4e12bec83a7e96157f300f371d46b8b0efcff428a433729307b4df4ae469961985961d7156e7035d53384ca5f36adda99cbf2806f2306c9c357045cf1c44c89baf23619a31a09cde57b69242696c2d69f53bb92de6d903073681f30466e7e13f4b33de7dacd97f00c7ea7f816323300afd87434b4a329c76d1a061e2b6e2fd1ed7b49b65fc49a6e33401da44229173e9225eedadff6191bb6d04b5c2c3fa20085353991be14c35c6a3ca4a6b2d6f623bf5babe2175ff7447c9fe4366bed0923361d0b2156a13953fd2cee1c32ae0bb1be108e19bf484e81d73d1b0b3ae678f6de320f71d6253d9cd832c5b2a3e3025130add38f129d615669a5cba1cd810fa37fefcad400bb7f2b7a5f29463974a55a63a00899cfde8ddc5165f88567e98edcd09009026ab9dde4036b1e4b709d648c8ec3e4991b5b3a05ad3dc63b5f8070197b09e44b039652b477a2b095bb00cabf693222a6cedb199c2e59c8eaaf8f7541b7b1dc7c7103664c56bd2f7ab630563de50fd0875a3d38ff108358b4525ac0f483269009e3e8846b99344bcaf47294ae64a514522d78e2781ec7840b7816627c1e2d24738f16cd8b1033bd5a5c576695e20e2c1d4fb3b80cec5691429ae6072982a0adf9aa86f8176a85ade62724652a65c3baae417f3c587c40b67d2fa21f3f930a49050a3fc9f45dfdc2bcb8ba0c11c50507a6284ecfb528fe43cd9e36227395ed5ddcca90d6acc5db7e8f2c117b02e5da3b741c855509fb9136ec355f42586dbfbdd726a725dfa94e1d60383602527fd879828c10ae7954fb732d190c91a8e6fb75ea15453be9c8289b03ef1c9d82f1aab9b916902020729cf6b96e228c7114ef6f6bfa30192808469e0d55b208cc5dad64256b51c990b6087e14db4d2b82d7bc62a2be5ca6fc0d81b05e0bb7a5dbfba269fd87a25fd51c2f04cd83a19770deff14ac444bae75ab1f20684581239a28e3d8fe0af5876e073a6111233835325d6eb10b7cd48f61849b0f2bd6d049f342aa1ae4d7f3bbba6c69a062e74d44bbfa5e4a02a84692fe3013532180086c6c88ab7ae3c1cf58219b9b581abf8c03d755904d35ac91ed92eaaf332f6e5a2be507c832e8d69981ca27f630e5f85a9181022d38c1bd0f3d2b855a92116da7428ce4a9b7c41c26a6dbef74a5f947b95613fee1cf4cfefc377416a3cf97e90381abddd0f0d13205f3ac80f7592ef1f638dbb846fd0521d7189eae31467ea492520f71e91d86a9e856cdd16eacdd40125f67e70aee0c59dcc9c9b2802e4149ef0be05c0bd6b34a0cbcce9607b5cd447cfccf90da57e4c3a3e13f68fd0eeb0cef49776fc22d3c1dfcd038779ffb3c5f21d445f583727e803b4c87bde18439d15d5dd1e7f009c586aefd5ab3424b8c786b08f94b5d3e63cf4cea9fb3ef506a2c6e39a16ca9a7414aab2b692cdf41bba2f3858a7962fd75683cc088ea9202ab1b75f9993a31462b63fbb6ca6ac8905019916ed13071a5f26cc73612e219d7968edbe8ea0d69c8334b7a0e905b20d152ad3710d2608d43566548a94502a2d93d49c180d1779c45cbde0b4809e05faacd7e0b4acd80f0071b21fc460e16ac78efbd0b7d274efaa12fdcde6dbc57617cc1dd17a1602753d277072746b0d7c5ebacd73f21da0338d0f4ef32061638cf9af11def584f6968cbbd19bf53f617ad89c13adea5061fc74629f58c7b18ee45cba7e3f5870b1e5a7a0b5b652eaf3f783aa867b86fcf5e291f3e4b9c56e4ed1a437c6165477f3dca8974d2a1f5bef15563c6339aa3815a769904ec18febe13c487fecd783d5de87f894766ed2f2d765286ad4fbbd883c1764f065a4302fa0a4c3579cc3d1d91d2c693fb07c4f35dcd65ad9854365ef5d521b9e35d0d646ebf4ec8ef59900ee778ea344294cf2799684bd97959399f537c33f8cbc43c26af68ea805bfc4cb02d8981ade91b1b9c778971967e757d1aefb7ac0e6e9e46ec485dbed3148f17d2cce9f9830744a45e83f696efc6b5ea55fad8a372bb8fc573e2684c04d4bd65968cffd15f70ae7e9c5c704564af10ec40a262c8eb12ab35d6d820395ffecedf96bcef25d8743b87405be1e332daa8c9ebc982c1940febf00b5b5287565902887bf951cccad728435ba7daaae11ee6757c146a17e85f32f6d5f4685b7bb089e6638f2ad5939cd14966d782968ce93cf2ae84b4c15f1d587d96d642e76fd4d5bc0b455cbfcbcd77233d10c392bcc4d5658e8bddcca49c1011f76a315900ec9d67e9b5d2b9a970499d644d642cc8aa03846d550b81f97dc823321b80d54d94d7ece836116abae42de83c1d649fa58e56514fa0c07208ed7845f31dc3a25adc8403d9718d442a1c162a459e3588b3097c4deb19b20baad95d695ed72bf09d1e020e65d3f929b52073ab38b853c6c6f78c2fb52fbd1e6dcda6168e6bfe7054f7b5cbe990179bc293459643f9d61eed3b9e32074a9d876f8d4f8ef1ec04802bbbf2ab34f54aec5eff9ee394edb083388f653df7f4d5984843d079253dd022acb4fe742ecab8dfdb21193d595057389b4316c7ced990108327468a00a0ec8f97a62cf834cb8b9b1b2de3ccff6b4262dafa00f159f16ec9501520c37a02b90f40884e8ab81c86f3832b2861c63c599926aecd4db8fd3b5173e8c9f878e2642368d8a00d5784b759887d912cf7ac4993d70696950ab2b9d87a94179efb113031286571fff28dee4113a0b07058a3992b393a80d4efffd3e653a0e34c829ce8286618a9254864ab22e6310a68cdfadceae18a934e318ef0ebddd493695d0bc631ba28858048fb1ddf227c70e2b88b0440d9dd22d8fc7c9f46c3aad628581931726927852e12db1abd66170890ea9b6fbc1224d70043bb2804eeafaf7a18ae13842a40afcc1e187ae73ee11590f3ceebdc8725554e0bf959dcb1c7b62309545817176dc173db897dde28104d41a55d65012f9184edd038baf38f5afa36f19c9c2c6c56a84f176be5e4e36fe637227b4c897836b932c3a9abcbacb351a66bdbece69752d23ebc06f1c6d12aa0ef50ea035a40359407f97efeebc9ae7c3dc6c9442fff8239f16e5a3a1c29a73e6650ead1b1d64d4ca89bfc93817475f43b746a151a089fb5437ca9533bf3f66511fced816db5afe1722ea4e07de356b01e8691049bb7fbace43549089a57b6f039088bdd6818b619f90820968730af85f319f7c9c510be15a1fe0ff30931aed9d6b186e9a9a02822d2969133297916354ca6a4f5e06fbc04da83d1f65b90e0960f013de3cbd8a0b6b16e684d0dacc4677a4981a1eb86fc33a89d127272d15e4a93ba47dbdff2b1ee39b42ffc388c8d0845bf768bd2bbde0d400d0b0b225e06ebfc8396b249f382c1cef11197e42d9faf6708e32afe6119cbf547c301881707a3facfea8a2808d9307cf4edf14d3d97c4d00276aed957805af4d8e042684afa6b253d1edd8f28093ac4fe1f3e01cc553a16e2494b6c6aa4e958b34836cdc6522f0aa2595dda2feb2908af0c16a8fc5a99feb0963640d29ff5f6afd767497e490320ae612b8a357510176d25d2796327ca5e164318a39e8c84fc90d28316e2bec86465eb2087ed6e95a99785d755a806ea3b16ec7d9c588bcd8c94e1570f8351c195aadb84d70a02781bfb9f0aeecae98aec27a4316c2e31ff9926975768f8ebf63699d35807c59e0f82f51b4f47e27e31d7bef16a8de9df5c61259231f07127728956ad692f093eb77e482463a54c5c7149526c47cf60d8204fa9caf4a1a64a2fd169cb3fe4938ae81ab465a3aafaf6cdf80878f02eae176d34610af7678cc263e2b0754dce44472fa9b75979c2cbef81847a678345d5238c859e8b99c2db50c64b9e796a003bec6e5e350bad86509c34cc1da8a9e0bc1c646950fa90b0b0204bdc62a8ba198f35db4559193a3e6b7e252a9623c7fca2a2438103559d43a7df9e0dd6995713765497864426d8980a85075c0fd0b36d468ea7bd7c6d3fa8f09fbeeda6f7cb1d54341eb0c68478d83339427e3d1ecfa4b5c2e19d1c5381bff9c54488673f997a2a9a3eb2dcb13f64d6e9477b6c256b013815f1cd6f6878c79a581854ef8edc6178125fa35d1380ac01cab213465c225ddc831a1683e6a6a373f946fbf568136b1c4160ecd5f81d1446587ab01c2dbee6e9afc557082458d2de737b6e8476abf7913f8513af96135fec001164f82d48bc84747f33f54df7528d71f278c50d18de3d03248c61ef4940f4a91825795fc761b516ddb8bc62f403e97940b211b065a1b16384439dcfd6124dcd1203d90d142e953492cf3b6eca90ee43f674adae87fbc6982975603754d87d35061c9f8a9334c5265800ed3678de213db4f12c57bb5ef6243300716cba6c4bf80232fd605f70ff8f878b8983ef73d948f7a7f225221a4cb3bd6d8201ebca7345b195700cf5df67a53d64865e861042dfded3755ccd4b6a7bb0e1229f26dddabd4670cd9e44f73a59f581bd57bf684f9ef7a91bdd257dd1fc27c60e95fd0739dd0571d50f69b34ac632bc9d18f8b625b918ef32e5d39b89b63ac1bb8ce7b629a3b36dbf68198c69aca190cd37b3432d9df40f3c18893fae22e13c4681584255b570cb4d4557224106fa2ac6737a63e477d835803d36d092b8c6b94ae6d9c7f3543cdca97c032a390b1aad54efe846cb96f6e6ae4eb3095ccac16df96814503d936a490329295189878413f5bbdf6b23564f78a3d295b8c5e630f274e8fb8531ba61dd1341a9df9bd0a25e89f01f1fe1628e5503edd117ac10b8a352213dab4a3dd6ba51426335c3671cde96ba2247af5e0134222e486a0c481879da71169114d9879a89f407d3d4bd78037ac4dfec9cd7fc88d657e2f5d579cc2d53b77397632dbea7ba24958785701392a7939a01234a5e6d65cb6252b514ff7b0574e17db24a8ef2119fe2ff2a6106803383f521bbc98342183106eee24538fa722161e1d3254eb05b186067624524fc18279ae340d4a946bd48a0b4f587d1a7b76ec556bf65108548701cf3f8b5366e6d72a4bb831dbd59b2b0c3c95e2492436dabd58053143d4633c2d0f673df8b02fba9a8eb673cbc48ffa29d76e2e4e8da218c5babcea871a2e635379d3dd9bab117b9734658bfe9552109f7fd141c20a25a2430a3ba2bf5350a46db1a6ea5822f766bd02cb1d260299923c09c28d6b37c111dccee9412f6dfba263efad11a4f9d053a0f81be3deba302f5a1a3fcf869136dda039ab16e912447d463a41cb2458fe505d637d44fcec2843dec8d86587518b180a0d0c86894a4921ea9adff268578a2f15e84871df336f7783406ce69333fbd33f616ea7a3ab315de619434d4c87ae9b49c7c79a9c7b105461e1aaf228a363b1038a880dfa0f88d36e37102f797c5aa6c2689600c72a9673a17ee2b4433cdc398d1c60b16c67d71d67edcc11e97d600f0c64f3b17bd8080d867cb8233ca14d82cd8312bc8175bb1c518925b5c6c4fc6eaf59418b2bbf4f9019e3453499c75cd748d7c52970f273a1651a54c88d31d7a2ef4f08fbc38c6b2a1bf574ed9f497181836eba3db3ef9540ac167be8fadbcd97571c8fa26865706b82a3b4b00e6fad2bb050d9ce1ab06c4b6743ab36ab2b594cbffbb94df684fe448cedd67cffd29e40cbda3d81ec55b527d1f93976d8f73b82ce242e37713990b9f24e5092d24562ebb2b2d2d6eb64a757bb45dd597a50d4a5ae3fd889234caff24e475069900146be6006a34bec3e66b5ccee951dfecb00e4f4d2272ac9c3e10f54bdf4d4db50f9fa5be54c8f85f2c70a73c22264467f3ca35c55f8949b30fe11b1766d5f2f55cdb38ee6ad33972de6421afe2279e6faa6158c13f810c7c4fd81d612220ed2f2bc89a9e9ca76654b229f994e34083f2274160bf92bdee3aafb8fe5a26620d98411dcf0de88f85f82bd75c79a7e7be15a956c86cc70996effe81212b052c63b64f4debfb9c918044bf6ce43f499ebfba8ae6468f8587f45dd71098bee13d32a52f20cfad55aa4d1a8ac80be53f097a67a2fa21452102adc0107a0322c8480354eb508bcda60f410cc021e1f6ea15286a95eee1e552dddea3347c6cbb5696145fe6502203377fec5540eddccfce0f7a2fefe052214f0bb975eaea846b837c5f0f56caa11d5ca3309c6a25cbde8a1f3f3799ddf26e650134a7f5c2a99fc0e0b6b50c5906e125dc773aefff0dbe6618ee6c94f913e004b8bc4689cfe26af3f4abfb156b8c8c583469631c45e27327b1c8c574a98765296fa8cf1f3b86301f75dff3c267572a29a97756a7d0766f4d630eabaef46ef6f7c5007d93ad72f44786233f4f3eeab2cf801ebc05363449b429f8fd9ca4efc9c2a541c7494cec5c02a20a652503f615fcbee97d6518f907aca719c4fb7b2f7188d21e0f24ed0b57a0f5d5de9ebba4195e5cf3f4db56b708c8e5a1e03c7b028719b2fa5cf07be3c5ceea3e9d5098edfd970f36115ae227f9dcaee1432d8f57ed3ea4000a79e9887fb71b1016eb7d96f0d967d34b6ea7e0cfbfb626d5802ccf66d0ed8641a9b378ca0ec247c0f8886aaceb3488264059f46013f24147e4b4896846e5e1069539176f38314ccd79219d3434b1c3fcaa15d5ef1ad97f1d2df2096e5b69a667cadd87a0cc0305835c001cb25763130efd1e25a99d6292340ea1b7ee62f51f4e74c8d1104b699214f5622dc71316e416059e69a80940662c449ea84fc1a1230663ac093ab199c83a37450500d6a31a0a29addc2feab348593321b12b2076e07b252fa103f86d1b895530251cc4700887eebb803089e67988d921bdcf9e6e4c06922202aa64e4e435ad67417879f243d036756f26adf74223c2cb6cae6ced0f760ec006ec5a6395da0ede453318b1416ada9375460e6293ead1b4e18b55bf31998fa0a2f10d004ad9275b94ef7a9b60f8ed9ba17f6af4cc07018e4cb09334fefe62ad27d38fe314ebbd9fe89edd61cf1d8c82f13a4cb76eaf87fc9eadbb75bc8b519c72d74ddebe6023c6a8f598fcfb2432fec700b58ef74b088a446dc7b714b521d1d91e5d71764ad19d98867c5edb66577a8f48ef95641a0ebd1629284e4340266f23b158dfb192b762777d7d3a0988ef9f2a4bacc49dee7942896850b181f586c5c5e3d16446c4d61bac8975aac226df720d5561b248ee1b82d3ad38d67ee3b120c24c785dec3fa324d1278cc8ff58d947d96e7ce7ee2825b7af8bcfebecbd8344bc8d926e8d3b34ece1dc8d8b6e0f54e30a0ecffa24f734a577793d371a3aa166e5ae449ad66cf59d9c0ef97b928147bce091b7393bb2f298e1c1622aa41d550a23bc26bb1ddc0b3eda375fce154dac03007a87690d67876b5555c405113a92f1c24ef747ecd370b1c6e623c3ef94999908e8afb33a8322b9f3f748be87546742de6edbb60ba605aee2866d10ea8ebf819ab74d93edf3e20e059f8f774dbcfc82c72d36a7d9768cf23271ac78adc2f39e0cdac7286abb19e49fdce5f6aad733dd8a3d5d11c6f060697f463d59e3cf2039ac62f5052a86fe35daaab1b8ed3ad78c5e1a88bb07aa94f475fcbbe550528f5c9dc5db446b0dc7bc206c7223c43b98b8b2d17e6ba637e89d74f6d2bdefe102e45d4e0d2d9b58e4589a06cf5026ad99285abe432d6cc6d3c19a94081a0ae62ac3efe006816943f97271c376fa8f0b029def5f5328b3da09c9a8fac506948ea122f26b8dacc706a0d4cd6e3350945bce8477c0a7c3f53b00d131274fb27be7dd59c0d3204176cb0143ab720f85cea3b97df049819dc9cb59e74c2764feb0de27dffc8da6ac8edcda192d695eddf633df77f8eec519513f1cbd297729d700a150526446f2ee220433fbb9d3d0f81b22ce3accab873bb2f5bfa85800b2d4775fb3cd2d4ea5d81c0da4162c4329e7d5fd87d68804fe21ebadad1de455e55ceaf295acb6d78dcb530c66f2086b06b2fa2bb70c3a1609eb8e9cd88fb29a004689771a3dbaaf060aeecf93ba6e0cb45e85439a5f50d4a1f4bbdd04250692d366f26a08bc2b07deb67da7ff66edf49a5330c1123d301dd9095debc287033a50cb2d8f97c87711e807baa2c70cca33e8c13bb8417cbc16e8c10a3e74228fdfe234e048406a7a607e169d0f1a10263b9cfc165a9d3be7005a537400f8026fb08a155f60d41b04a3082c04c546c2b9d3e8bd7573e4f42c6338fecf2dca64f9da5beba0cc56a8e57cb167b0d523a81250adf9a5d2bd4e4b3bd12130830996cf53c6b4798cb639bf6da71a97f7e586ecc5d72c74d142e183d28b7e227f6e26e6895485abfebbdced13603b57ef8bb49236be8f77540d08e2e7e60c48b6f61db7c8989656b1215aa1a0f665f42e2cfbb1f8f1a93acb292ff5f6a4160eba36f5bee3de0636fde0fcd1f5a9b61d204d8b91a2db674e54b16d3423569f77d600b2f8eea64db2fd95753079a514ac0c1cc54e20d2c977012c79951b281d0857537b31d599d9c480955cd448e3a6fe3c7b8d92a90a043978288217ee4c32585e403815fee7939ede6ff7993a53ba97276304725549a2bb9422b4f4dff15477e3b02f0bea7b51e788633c39205f5b1612697ea9b15315760be7671bdef8290199f9ad62cab8cc554fddcb1c990edb530b81d0bd8414d86579f26f7fe0d7b493b07110dbe7bccfefca233a7bd365659c823843ed789735c87f662bb7a3052fc66911dc08b10446bd012d24d3aec31c014351454e3f9a3eaf7073007d355a789919aa9d46d47a092dfe5912ab7b3801d6f6228c185192343fbd79cc02bfbb03764d35c4c20e89307c8fbd324ff8ecfaff9827a60207adbbd3737b52923fb9bc3ca36f3609efd90c746d54482ee0655ebd5ded976a7e0616f651621635860ba44afd016d43f36acb355ea0ce4f60c66caac5a89e7dc00fa67bafba454a225336111e4f9ebb6155a824d5a1d891b5cc59de43adda97e35c9301c4b003571e9e87068e8c9a864feceedbe6a2db1aabf715167d374d71353780ecd5a8ca361e66c5ef2c84e01927ff2c6b688cee40177681f54492a5b40860a7e151d5efb6773e5212c6c0e63ecf5dd6c74e002f4a0118874525af34e3c4e140b759996f984b4917054fc0a88a43f2fe76f3b2d989c26645b56ffdadb3d9b1ef7e0f6f351d8ea50bb8912c80c11455472bf33477466efd6deaab48c84aa1fcf7851b6db12a1c5ffb34cd3e26c91e04d63561c86ed3ed2e1719880a2aad1abdd280cb920458f02ae29bcbcf0bce818a9454780054dbf15a72cc44972f421e6f01fff3f4c6177d3eae292aa3c2029ad5b784664b7add686d68fbee0818e0b21a5fc657bb19dc930aedac6baae628ace88a33e1c2da27b94bcaef5cefdddd2e26b1e03ab12312ae1fb7d2ecfcad0a12eca20c5afdced97477afa5cb8f7b4b36d8d93d701791bcba10c285ad0b8081c1928fbb43ebd6a43b7af1537e295f0906f5a9e9bc40817c622f6c762e865a49f56d8bebdc1309ecb6eb01114265494dde27be740d845a4e8a9af0a269c543730722b1304e7ff88f03c754cd1eb9fa3e4e2fe2baabe4a062071b4e1647ea37f07dbdfe2c451f728531842270a7e368f37f1e2448dcb16de7c324f23f1ccda31a25db96e52b88735bd626df7dfd8e341d46c44054deee26632a2f16143924bae45494a86a0af8da20c0625e67a999d6d3018d71a54d8895d583feee2f53130aa7ed470bbd3076e2d30ebb1526976c545df7361c799d8e769c0ffd952564249e685f6afef3f02d28e92a1e597edcae85fb378f65be6c5714413cc0481ff07c7cf0c634c3210a86a39990f56411c979e41dae00a3af42cd1f1c9292c8e92d3f3ba6bee69c183bade45a4da3eeea35fcf4063f6884af62a1d66d6088f7f8dfbafe1574bbf1b9eae58a4d61466b96e03e310ffd08ec53d9125d53f000704182f2f0f096b4c6c2436194abf43071fbcf6925ee3ef3cbb0bee1d6bc17c4106a5069fb651aba00e85bbba3ccd3edb5a7535d4c2268ac334a2f49e3258f543340c68a14c55d24d305f0feae3a72940560929dbb159352acd84d468df10e881715fa9e1270f4fc7238d19fc99d5883c7411ef5a7cf8d41371fac733304a9a8a142c1d2c9d14e1249c8d0765be542924d814283b4a71d9a7b7f72a4bed72f7fbb006294cf5589cf861009bc568ac84fd13314e34403676d14ecd51c9a225f965cf01e1615cedca044295afc66a3fd9c8eb2fba1bc7ae40c40c9b9bdb380dcd9f171a413c1c7250b788a58a31a49cec92ecbd00c2f5fbc55785c989089756d8ececa42a2e79479683021cd1004841ec0edec122b1e0eb505a40d9c7066db678e77e0ed2f63018201379265c2aa015c19df7a7e76440fb493d8ba5c34125291b1564a1637569a2f8f642265454a0a73cf8f3c6ed35d284ad604bcc339caf4c3f1b1affd724f5cb179a76aa7b011a0b9fd9aa14e0506b766ee6703b48e60203d5e2831a1b3c8fb936e3376432f44abf795b94c73121d6ebc7eadbbd0d944fc065aa9515e60922eb137c7926659654f93c5edcb079ead3529cb356ecddb6fe7a4a6c1bcb1310593ef0eff6e21dbb974477d92f4fa4b871728d716d18433cdb178ece3e2bf13fc46100dd2fa8b6d2d71d56438d6a6cfec1fae1a6591525b98e6c2fe38cd89bf2563fecd2c404dc5a615b65342ff1a4fe7dce4b8b992b2597f520dab06b94ee8e144bb9adbece9a8e5ea7638df70f5d49f35bbfdf7cd86800979c855e80abeba359abf0e60afb9d9ae2b476ecf190c6f4d992f2637f6aa35b060e15583afb9aa11316b32967c2d9f994b899e1e8cca481ff7440048736ce99ab0f20c12f4942fe61ba146ff320cb2463b3bee6714b420b4755f9818333a965f0ee1d13286921aa4d3934f91e03ae690890832c1076810352db422b8489bb3d545ff76b106e3d620fc3d469d45940d58e5eb7793c3ac678e7c6d29fa72866450bdcd89b49028764d4d34f56f43c145f73d8f0615458ddbe513ea754f828ab3dc0aa1e9e9245b376b9dc3a5782309867348170325dad2a8a54342d9070c957d82494c9f99979177c5e93400b11555dd72d5594d8908359ff87a32560b383689cf89eddfd64466b1a08b68ee27c10a51b5a1ff173ff73b97eb1f0558d24d646b59c2b905bd4a9675728100cb369c27bb9f26b560b3719f17ca1f45cf862275fce2c807a71ab4126895a0da86ac2993c93872a33186bc3a6e56434229df2b43ce27144d85b175cf6ade9588350665712f94cad027b2b769850268faff90a720e61f0ae7d70678bf7a12c753a608021a98da69029543c74af8b76e1b025960538a57656800f8a2737a452d0eee9e01890d076ea716756294496ff115fc67837ff52adf00a0dcaf7cbc59289ec5bfda081557b2d0fb6b06a76a46b7da2ea964e96a45ceba9eb244d7d4ac322c91e15d08722a751187d7f6d874d74e2ab521f77dba9a0251e47bc5eb57c9d5fe2cef1a89ef7e7e48f04ad8c2608e237478050a0ba581fa31c4707e36a9e9bc8a19806dec3affae9b28c4726c956ca408486d5f3ae7b77d1465b16b75f557ce0dc6c95ecc8e0161debb16b473bfd70f43bf2863e2a0cf035a35ac3820252e935bc5e9d5e9cd603c43423602763fe9662fa3090b2660840eb6b0e8d14fe051bfed2b84fc58b9dbf929b655950ee64aff7e3ae2a892259cc23074d06f255811bb9d982b80734a5035fe90a798c7f3851dfd94abcf2a6e801f70654d27e855db5364ff40e5672131e1dee30303ac5a32aa1b748c65ab18a3f93599f77d40577490a7b196cc3675e13b71505683064835285d0f878937ee0702545d8a5d8dfdf862d8829a13e1a2fc7d341f259b8c79e5366d68a61eea7e4d812d5851d1b4d67d532bd91d6d5e6b5ee2a3633e5945d937676c43d3f295679528f09a803a1d13cca191b3f14a67844d6bb579ec2e3c2a263fe1ff56e8ae309f737c3249b2bdb228b6b52c38f8d36fb196302559017278f223949222b490ea48d802f6bb0704249a40af2b0bff4c033f7f9fab11f9bb63f811f1e1a42d1f5dfbe6ad04874a45c295020dbaf8da42994e470f69d02e02be23e0f66268fa0698e3e815734492e105c9d184d4cc6ab7740485bd5266111204ce8ee53215ebc48a64f8ed80053fb5d9fb4e3ab28996e4d02d4455648da87080e22ed8fd09d4c6f0a8c71a56f49c713780323110f73348137b9802e74c5c8de10f7342bb31199eab26e0ecbb41e6cd375a1df7a83b63f2f55a91710e45f5910973bdfc3ada46398703068d7095a1636037d57544458083ca12f0cbc2e19c3eda481f6099b723d061a559720f1115d0f46c9351212614fae50f5f7cd2344b7509da65ace8659163ba37761c7d412e43bccb42d81aca54dd0acbbeeb5d464e050e13398b5039d0c1a45deb862b629976e24cff52923896f165cb6531bde88537e24d897b67174b54f6994c96e5834f8907337f718bdfb04fd8a11d95ebc80839c157e50a73e00f9cbf36b0127422eec08257ad0717a9a48cf4a6d514ddb659af1a81e8e2e17930c6864d72cca3d92259f377f1d89e1626714290d6ba9f6cacb12fda15ca1e815376349e5f23836eb2d1fce11a6925c558c651880ee073b0d4af76843b5f892028e155862b5bb0722e5b43bb79abfd20dea8743c47168ed44ccaa140c845cbeda36027e2104d42b19b2efa5345569f606b0d0345af37af05ef377f7c169676224782119dfc02864491b2585c4740d539fcefa90e38553668e5a4561eb6cb4a157d1a994c1b4034aec07175b89b7f58ca7f49dd9008c0d8fe52d89f93df8d50c5207e21ec02b33c5c17feb4780ad9f6eea4c9fbf426150dbcaf366289bf7e06e5604cbe75f23f8ecdf8f853dab53da821d76d5d4e216ff57721d618957013ebb082422a0c02845f9d73d2980d29fe09f62ced62847895d5a6f408c322084a022f020458942a1ef28ac1152bd0a2164c37b2c1ded0b648f494ef54988e7a89e78157ae4a5cd86072cf00fde90a609bccb88b8e265390a9cfaf69c2f8c3fa5ff403ee8b206e81c7f58534993208ec53fd83a12d3fa71d3ea7dc02b38aa93cdbd873b87efde485cce9ad38da0798787c67233149931ceba6df25d05a37847e4f118b9b1b54baeef018175f80a24f0578bc1243117ef338995dd5d98d44f0b58d6c8154d097fec10cc03df95876998ce115e268dfb1eb63ed0cd2c46184a9c47265058ff6acb4ccc9df9ed8624c4365fb17bdf6add95ecc9b96c902c36152e241daf1727585833e3dfdda2f7a9a829954ded4d62cbcc6b6fde4750c924f172f9989b516215e854628eaadb869bc117967f033686c35435d594f67ce15321564c72a3c77fee5b5a7ffb3877a52efa1e0cde171e0fc5d73d5c2113948fcaafaa9398cb34e535a78bc4aa70babf5ff226d772f3f5369ac08b2a722b175764b62016b2b530ee2c3b223aa0000dea16d7ccd9639f014f72af8e141e55ab4182c41c52f4f8405f3f576f8ede0f1c9e301d75d1e77f877d662984dabdb8cd2b3617d0df9dd451cc84c8702ff61ce28984751f059e9487a4233adcbb1368ae38f1ee9408b4e3f78c56562a0195c9a9f65046c5035c0e52f201a33239987c032e99b3ee49bf8f73763a5bdb91666daf62fa139b3a20df92d979803c6f73625c0c4c857a5654a4e9d6d6a220f0869a5e113fbb36ac081abecc7edb4704ab53738a54ca3a06d5c0c8feb0dac138e531be23f96b1a651391fc704c052d51fd2030cecdf72659203d86e906c0bf9b691aeac93859b1ef70e8ead7ca2a20e035ca1fa420f2865f84361937de3c3048225b991679e7daa2274d15472daeeefbc498c6fad79d0d2637276884e81eb00bda464bf5af64c2424f794cd8bae5f7f08d5a0d30c0dfb428f414369574a6a11d82cd5b1bd64e85906035464b60585542cf651e9b17a24bcb8f9d9bd592730429a772ee3e075e925725a502ec21af7a8d1d826cbafc843e1f666e60ab33ab4029de941940b983341c6028429315001029793c8b8ddf206d8f3e554a28f5926f14689e6150020042a38aac382addcd9f6a6ea368ce368dea93f81e31ae9c4eba26b1333453fb3654e6cc87be1f070a50821df6dff7039e6bae9fcc1eedfeb002a80297e2d6ed65fba10b14cd7dc17bc29b1b6188f38ef27077adfde3f4488287531429ad4826385e38704996321b0a7867200a6328b2348f37c00e683b260f7b8248379e49c31049cdbb9fdc9667ac41224e2b255023927df50db78649c1c874f9585eed831a99ba3955e0c1272c9303e40675d906f776139bd2897d7db39cbfbf69aa1f337e80bb9c05e3a1d7120053c0c76c705fcdd11d60a9ffd110e27826c2d99a7614667f1ec0ca8fe6c35bc19d42731e111c43821b2ed04977aab93c69227c4caedb3c3c46a3e66e0cc5e3cc4dcf91d762d43bc933de2d82e0fef7762898b6fa6d2c1f73f65d02fc7cc2f574b15175e5b527995643f17378f1bb56861e899b698d3ad9c96efab24cd3323ced9d3f6d164a36984d1882a48136a7f9965a6bcc06952eae8af276051c80d2a7dd8f562d5b0bf96a244684b264530322e8e5070d937a2dc9201d924b16ed4bceea5fa113c891a364f08334196f4b3bbe8294d74b0571fa818cd288967efa7241fe3e0bfbfaa6bbef49b9589a8ef50a83d1c838b5fbbda42d19f451d338f32450d44f35197367e96dced76aa5c2a89e442622f87c7272ca9ae68493f09b5ab21bd8bc0412975b8c3eccc1d6543243942a84324ac3adc7eb5e8236949e5e01299c5b0f113b1fc42a2b4ec0f527d439ac5611398644e0fa844d60d78d0ca4a931ae57a542c3c1498f6ec3da4c8b63cd22877272ee97391e43bec2cba2821fb529f7932a9e8491d91bd41938cdd0d75b52d29eaf921bc2cbeecccae78e48bb305e7b0d10605cd69f4563188d4caedad3246cddff1cb9da08421b50699bd91dd1aaf54b4b8ba6f0f8ae85b4586a5b5df180fb27a86a20593762ff61bac49b670edd3ec410afd1e26960f273f8e7385a92e85a8601f902a4ae89839bfb382e2952d094970899f7dd115d98f89022a2965c93aaa75e1300aee5d4a17c78aaddc9881dec1f108174d201b726f8c3c3a916538771cc16fcee5e3eb4bea141858da9fb7b179d90ea670ea422c6731202a5273d2477f08ac050fc5c672c033abf5f9515712bd0bf761dc0ea72673c7048e4b228ed4184f1edacb82ef5be7d9eb7be011fc57e41a0369b8613e6888d87b935f51b77b00db0f75368d17f1116dd1affeb93268027d091ee984367f6c2c4a30e68032ce3eb205a185c823e6a60a68774363c99170800c147edcf0405a46cf328bb0a83d536a5f6ba07738d350a43f13899452e8fd1dd1f222bb8e5d3aefd1b0e9d72c3d2b0da14b3b98ea94f2e535c2ffa65a0e825d764816c9af2d26441afc193c216e21e725afedfa553e8066c22827ae6d051a22947202f4721eb25a66a01d7dec8c6f756039c46d256e502d4786d30ac4986b1037ab82906f096a611f0d1c0eca3bbcfae32765d54dfa5c8f8000c9b67da63f80080d6a82144adc2ba961a5d0e41e69ce73bb6d31b48ad1110d46ea9379b855d171b87f36904bf4f53e948b7e6c5c4ebec79ea9446994f526d872d8ba56fdfe7997c23f570de12bc257752a7f5aae47d72ab94f2a3fbfb86b3cb82b8188408d4bb0cc11b93fcf8c0fd8602996fbe9202486387885b93a58a2d25ddf3bed1773d91fe812710dbee515a239c6e1b8300e0d919f62c3952e5c4048f6c2bb1c41597c8f4bc9965fc29ef5f3d11200c6bfac603a85429d117301d261b1399ae4932a56ddb1a8097dcacc78006c6c21b2c894206bcdb610e7b8f6f9a4bdd35374bbdb83e9110313143276c8ec338840ab557c14a6045476855ca932c8340c9f87a31696b89a431c93f5a3cc2e08650ad467cd8b6539123b079ae013992a13ca565eac3d62b252251556faadec71d6117358bf39872dbe876fbcff127e5391eaf90320367f0bdf731ccf718fcb1131ac44ccce342c86c0d6dde646679149d71d6e6137a457db29c44c7e740f6c8b167d9b54175f3ea49118e42f37967affe2ab65d2a56d7db422680d9de58329e8736b5cea253da92fd76dae5f499cddc796ed890a8919d7559a1a11dabe749e0773b27796f3d0b82cf290c383ecfe7b83f180770d47a315de16631c1a3642f0895510a925ddcb077b029c3a13fc7fb9a1281857cc57da590f167221306b7f33580d22f499889afc9d68cadd7a2b77b7f966cb2bc6615787af787de9e7c621152d875937685499a70d77c1eee6498469d51ca769008066446d9ecf8c9e1a0045e613f525006b3892475a47cdff648fe0f851e94e1297ea19f8cbdbd5b8e25482e011f55d302d32b13c520ed575e45fee21bed5ac1951cefbffd0e97a6757d1f7b907f05696d5cee6e2acbefc6b51b23b30f5532c10700766de2c31f86bc60cd5fcbef9a7f3e19b91317b44a33b725103470368181f80204d0ae02899c4aa4628e34443d6d1adf3224c00e54d86f287c2a370655333ddd5e2347f650ff49e90c26a959735cc8fbd8f7fdc60f0c578e4902137eabf9aae37fce39e5cfdb5c4cd312c6c6ceaa0e967d373bbdb0318b12cdbd77b66056d2fdcc1286cd609a77cd1a215738253cba95cf8993922a944a1dec327fe6475f111952b0bb7c3815667de28c9988afc52742b15ce50a728d318997f926eb617d55e7adeae7870aa0df787b207d077e3e01e320c92bb4918e1ba5301bf7b718613d8fef84f961cf29ceee906138a30cb66ddc796d64456dfb3c9929e8997e5265a737e0a411048a801933c0886cbe32a022986ae376b246d416ccee5d0aa11078f267e94c726a00d71da03253ad6031c808bbabcb4a03c17edc7b3d83702cb9109edeea65d50c4481c9f7b4443eb1552f981861b903e748628b909f45d8423822764d69728267879bd813a9b5338eccb2d4c479f28fdcd48ca99050fac303bd402724615fc7ebc34a0dbb77920d66d2502b8b568f182a1959df4a2bc312af62d2d791225fae08852d341c3a7c3f1659ba846a5528cb84135387edabd4b80c4fbea848ba25cb60ec642860f863db11055d7cc0f18e6b6951a9cd1babe21a85bd6397fdc3a08784fe191f88ba5043d41ebf466d667f87fe5b88e00e599b4f322939c5df487587b9b7f0e991dd23869a960dd660e4e9f3d4d60c91853e9f50189c25947b29840689f29189a131e38776a6c2d7f134b3c376c7efa155103bea268e7ebecc32f787ced5ee4ed5fae8117fe25ae2d0316582127c75cfdfe8be63868b4f62f5b977b9c2b4732043ac160a1fbafd8f6b2caad05fc23452131b89bdd0b8d737ab0bcd8d21c25da6e5ac7b72861d2e75db4082330d86cb38c1e470980f237637780827bc7ac8cd6d9c71613a98c00a584e60827c2fcc37a9e2fbef62d179374c2939ec6a5c227fe385c8bbc28f973598a8d7d4a531543d84a91333795ba61f2d31f756af006be01a8922c58a119310b66e6cf8b6a5ae40d4d6e34c71d0f8fe4aada8164c79922fb211353936837c28a59a591f130e6a1d872dbcdfe7aed4527403e1d6b891cc871f1a97e2c65cf4ccafb1320911a891bf9cc8d4a7ff1aa01be7fee6091150031b7ccce1c91c75ba45b6a1dce26be30983bc6e08413d876a2e4b85432a2fb3c38b556201b61fce425b36288f45e77b8190c67e517b1e5613f21b2224bdffdfd8ef1c8d296242a6a7d80f73b0a4473e4b680bac9ab2067b55463eb7949008aafacb3a6bd974a11fd08cccb9c82f80cf850648f397e5f55c5952942f747752311bf226ea9b287ee95e692a768752624d4683ae5ece80c35fab9e129cd80e6b60e7919d27f886c5917fe5abf08e7b1421fadd395b9df976cbae8c44324cff572301395ca59c95aa06a73964606334eb3d5f6e467c31157d077338b6e746e6421c77c21e0a151e26f893e76c544d036ad0ef47a8b75b1281f3903867a20b4aed1004b6a89e2629250d433ab1301b2078f2b42786b660076d58a62f8f6c1fe80d9e983b5f1bd79c64a9393a1eec4c4c67cbd55ae27d5aa7e26681f14719db459fa95aff25183a60ee05020085436dae3b8624866141fd19ec5bba960db0fa2f0581a1ab4ddee65d7ef96f84d62935e22e02d3a895e1635041593240eba6c26c28947132a540bfd49b2c41c0767e3e17c6f56872e74e738f10112796690443b540b27693ba3dc592722e6ee48e27b33856c9ee928497878a416506876301965f14e3975243498b8b82daca19108bb4d17d87cde46c06d1a5079e859919e3cc354ab31697c8a47c0e24428c270e3976a67cdf9caf3dbc2f31da14b1e8da6f37118518f7e3d699c3d1ba066c694825f77cfcecdbc10cd95f663e4c5346cd08cb3f4bfa2d97d6a8d024542548e0b8453469791f7022194cd57646e47a7a6ee425ca2b2aabc2ea12785a3985e8c449964a39c3b7efd033c232f0d9958516d37f229d32360b5feba937574841d354954b348f30569aa4d2538d896c614fb581e0fea1e64b62725ca75d30c3396e8b6473d0422e799cf61981cb4e6f3be5452884b55448ec2025bde78822af521f5e5e39306bded2713532e16788fe60fe442f5ee9e9186775b5166be6873b09fc9f994f4f571a1a9de4cc039006c0361616c5c46befe84e3a1f915e3811dddce069d8af52ff91b3c83d7a139ddaaa2a5a8d1a67f23209995bb63d9fd466afb0ffeb25db6f7133c66f44e88f0921637bb196ac4250e1c377cd2b4546f1dc0a2f8323187acc19549962752e7e619293e1637f877c969196bcfdf13f210fa04673944810cb167e9a7b55a4e2ed2bcd15e0d500cd2fb8768797748eda70e32443586a4a5624daf609a1f27cc41c084bc4f6b8f005f13c7b74746dc97e119f09aab82e62d989aa7e60f0fac7b43f599580cf5dbb79c9dee9b72b3f19fb78ec0c94f81a2f0171691a307992f8c90d7f95cb9ee1fa2a51139cb104ce9467740920b8248ef05ec7538936108cae69dada88f0e88a042dba6a3c5fc4035d38ebc5e7b4fb874219c9e01f9685c42bfd21c1f11c5fa023852825ec7354470453b7fa0724b0c170cd461db0da9120799185b99c07e02c35623408832bce23c64c768f27a14089e05b81a640ab61e39f59e940846f759578682c469bc9b45fff9506403f2b5048262c37f2e290362308cbc9b07027ee3a5b67651455cbb3be00e596013c92dc11158034be4bbcbbfb975979fd892a7e64302841b122abcc7bac1ae0a379cb245be598554725bfe70e6be2a55eef51bfb4c32adb76b1d18fc0005d334667638ebebf0f4f849dbfb2cdc2bd0d356000b0cd9686e324b95090aa0cb891e2e4044c846247a8fb2519e9969b3b67ea660c2e8b5376df4864f1d456ca5170e48127d839838115a7627e23bd90fa70573065cba935e2399a027eec2de6313dfd5134931f5c67470db89f090d405dd14b1b560a81a170b5af37c949c7c5a193854f1773e5d141bddd80da5d317b20b742baaf2f7fb34d15b55e3d81f5f65324969780b8f9e103d9d6166a9f78f0934548bbd0a9a347a36fc3d331c44ca7b229f2a37e0cc8cd31baa8a7bff732bbb43a4b585e52b90a4203dd2c24dc5a55f3c03d8d806b8b3f4c3deed6ee4bdf65ed3f5dcfdf358c6edfb95ce980dc56819c77a9edc3be55e6b4740ed1c2fc4a40d4c33f90b3ab1ab5e6a1c83ec95a779a5430fc119667693076597dd92d7b5b9d6e259de73ffe5b347a1bea12b3f29aaa09a514b3ef4485331f3916db7e2eb2361313658e9ed35e398b20ac87a3acc3ac6c6776fc0226273b802540e31b9769819347eaca5b38aa18456669e3e83b12874f32fce0f83107dc481a7ee62f33242f4d419cb9b6da1dd40d11ba1cc50a75e88ad54ce73f982eca06b2451b2def1ff4b8b9c9a75333a8578eae0a3061bc350a850f2956b23106c5266731959ac3ddd6e59acc0624906a21f9d8fd333730915bec0e71e4f973a1c866d58782c46d4f597da99cc967f822bceb73ceeada9822131355a1f8878826e103170e2cb0084e3ffd746d37ae5a7337ba4c76a598cb0afa25ae20650912789d9d7650fee252619dd918493601a4288e64fa7d73cf6ef1179311b13d67e02d105c4b304bb4f879376d4ac3f63e4a9b31a92196adae9fc89cd54d7325637da60219391380a0c780e183078e95449d6fcfc521761d0ee89b2b981638789f79e49ee467c84bd1a366b45b3f69010b4db2af97dae6581f98532d45db653f9c40383673a843e2fc31bb6529c650db3c7a20106f4fccb731a2835d24f329cae22c315b809f2ebd3954ef871ec3ae71383544be371f03a39ac53011dda26525368db0bbf0263507e2e374cfdd5ebae68bebabbda5d6c2bd8644cb85e46c864d560e1764492c701b7dfc9e848303134771058b2dff46c8adcdbed47f48d6ff7b38a9122eec99039e8a1f7d532b3128ccbe4a2a9e5fa96361a7675d21e70e609b2bb6956f63f600765d4f586e05109dfd160efe974d3ea89b498143f1248b6ec9afddde9f305b9d35cb120ddf1df9d720a74294ce821d1fddaed51b0fd1af10f482bf707b65fb34672c64d2b36f6502741fbf404b595ba94ace91aad10478e4589c41bfb5a48a29546c1e99b6383dbc95a56859bc33175fd0cb454c97c5ed0d18ee4f5b5d71e7f745441e3772d0c224c1f8031b7f35759f380429db211060b05b71096fd8511fd3c360ae0ccdb04daf1a8a9bcf3a9a394bfa70550da9fa80b2b28b052ae53c03398b762c90e8f1c8373a94dd97562b4278df7f55b58465e738ff743ee85bb4298af13fbd8526522106916249541ef20aafbbbb3151954235876d20ed938fcd588128365698743c3e534f575239187c8be88670b8242b75dc1e99fb6084b62f9d20f2d4fe9f42b21d05ffe48cae2680583e94041661a5b1ed69c0ffaf62e08a9258940da175a18f06a93cf59e7edeebbd38b40978b133f9142915fe302e446eaf83d82671271f60e0c5451d8c5374a3e4fcc2835c62a920796d34ca7e9520dc38a1e20f10cfe6416016e3fc15ad65cad4a04f317e938cab77e37013f5b51e085090a287369685a5ad91e7858a4514e159f18f16b53c3d62564f093c03125acf5a75b36431a891b44c25d4048b507e2be9bd745173a6fc564f6feb4baf10e032ac614e7fc32a6170def76d19209291e9f24b74a1beecd3671d8df4f1935ee2059c109b6a51ccb655dff71c1d6f209f1d238729bd86ff9ceac5f691a1e1a64a42dc6b7daa00d6790983b1ad9f253887ef8ee2bd7774b70bbf6b02330f97cec4cbc8b70be92c04a0e5b682d22839660cba7c479c49ebde4b626db9963dad3a6b5b0147bc3efd17e52e78787e105ab3f854809ea25fa87267249e2fa0c39b9d6fa7e4ff9e948f8019724d961e1f9e932e6132457f48609dee5133c3d7a7fe5a79f14f3d99d4cf8a6087e035006d51890a26503727c440abebc1bb8f5bfc23ca964967dae3f7251773a2450c017d0895619d153a45b03dcd44b39c379d1ae41233eb509dc64534b47aea50cf0b40ebe688a98466420330f6637fd7ae682a5940f6a0accacf92b035ecbaa7f69eb2c29b6f2bfb8cafddbed811f490b7cdc4f97c4922865d3148c5d8ce9ea6e8db95242a6e49a4f76d7063dc8cdc4428c496afba7a11060ab732fde727db9bb1ba8cbb62a3705bd070b359359baf3de2975a9b41d8f9e0456721fa0258c1916b7e7ca7b925843af9e680e30347f22beb09b0385bd4e670b545baf9221fe89389663f5da9baba5fc8231d68058f9b6f98aa44a22a5760b2e9efa80a45136422a28f8676ff9a8dabf1bfe86f867536a53e6732298765f6c873b7dd93217925bd5064bd87a7d62b57e8821c4d0bbb8416b03a9c6dae3cfc814527c90934468be09ab9a13722262df0de235cbb925c4fe3b650a0d915cfb439c9e664f21cdb4e9e8c89e7d058b63e2a361de9e7aa6a647678ac100ae0276e60cd7cd3389acadd27fe9d72a55c35f7f0f4a05485e23268d0c77f579b06184356bedc1e9c01ccc56c13988cb0a0bc71bba75fcda2a8b49c367f05d537a99287aa4615b2523ff97d95a892196f4514347d27b4a45ae24fa932c4b5afab9a21d90222aff777783f3550652ece82f738ed5bd1262601e75158a1b7d9e0cbce8e7d64cefaf6c9972da06fdccb8084fca93a0c10865395ecbb6cc224452c238a5f9267a40fc224f97d3ef53bf702923b31fcce683c7072840785891f9a1e731726201abd7cda94f406bc449a636b9d92b4b31ee43d133a137019fa8fa22acf86df46c64114671f5585e8f3432858cde3c834453c901523b8ce01cb9024f4d32ee00bd4cdef6651c545aa64d129194cb0f91f85e0b7ac5cc6351b3cf6dc5f4cd8a9cc5254ea06f99266b51e2ca628c9d66dd2473e5de3e83586cb70b023fea8fcd41b6cad485d1e527488bcc2ca5873ccad15f14887e0d602bff8c55887704febccca51f27c92ff2551536850edb1448a4d5e2680d4dfdea56aeed6edcb0fa0588d56c7e194364136c08d05497f012bd07d0b53dd0cdc06fe57a39e7ef343e8a8942711c25b35620daf660525a6c8e478e886207caa783547501b98eacc245ca64a4662aa01dc18536e24254b04e2cda88b3c1d912214f8823565c109e3bd403ed255700d44fe54f8cd3e91978dad111a8f25db9a45162af0550a2cd99c3ba5a1880741f8c2fa2049147035cc7c9d14cee68dcf519a933d9644b7bdba6730b387130b9377007f413995beecc0161b1bb22342b6402865a43e456b664c035643b179465bfabb95bc6986b7b8fd103f2ecce89cec5198ba27a608b123c6c423293971d73e2100b5894a56da07d08c439adcb434257331154ab4c0e0b69ba9c003db636814663222631bb1c78cf5c33e8c71969b639481eb30940c1efa20409ae52ad9ec7f1d3536db657c2d8c094fb909cee792919e180e8a4adf965eaece57d5cd58405bbbc0f9e432b50a8123bc874953cd079745614b49d4cb37c639c5fbc1236d960b867a81c73b883f4326dfa311ffd800e058af198a658a5540dc6c33bd7b782ea887b863b5b6c9781960d66ad1d08c7181ba1480e68dcd7d85ff3c0c94b5fc1a069caa79804218bbad9dc636a92245848c80989b4efbab1abf31cee8453b8819a6a7bc87654dd9a6f6c37d36c51291736b52b8d5031da4796f29d18a4a6453778314ef09c6f6f9d72a6b9cc25ee93bc0f9e69fa7dbd4fe313bd38b75e97c3b7c628781e09b2c2b84f3351979ba3f952543eb137b6f542bf5ac03200b62a432900d513210ce35554a1634be80002422057eda721e3fd6577313e2e7cc1a4354a6a6f9963472c69e88ec82b6b4ce0c3e3e43637d10b57892f864773652f8e4d486d88976eff458264df9a1a53866e92fdfc82009a82a0eed1329623662aaec64600856be83fa7e226b03328865c2ad73fa9d3a66a31be0464b16dc67eafd05fe2c1f20bc8e057ed47e23fd8952557dbfde8acc9d01a3a1df3a53025d835ee74b1f91a8fafee9e3b753c1b3c97c3c5a6a936ed237a5c587a55e039fdf5bac5e8d471179397cacb1eacceff7ec2c3ad99475ba6a0e118c37dbf4dd554e66e73fca81230d492b923cc79f55bf9f3c3a5a28c3e941954625e88b1df7628d44fcab8f837701696cb29b0f32bb0b1905667e6bb3ef628e5afc5dfb1b94eb144778beed2b0d89404b9c6de0d5f85de373274c99da66c45163cf9326a8ed80710cffdbce00a2bbb78856d9e6d314a63ff495d5c8f6068e25b04771d09a0b005c712c1557ae3d6c9afdc8d0cc2587c79c3ba8f66be8e3686b2b938d049b17bd6a98ac0f9d58fb51f8e18f7e71d29cb97690d24c6d0bce4b290ba249d4c207600ed10d7edb09a7cc825fc2b917d2d418030455f56600927e36acd498eb4c940947ce35b2a10610c282685e3e7bb57b963b5fea89078dc78e3cfc0756e54b0e53011683858ffb3c2061d4b7e3a44aa608009eb32978782f55f73fe511ad6920b339a76ed60216ddae86980e19c44f21017518202fe0d2a564e09944790645304ee93fcdb7a10fdf5f24ce2fa5b340511dc6cee4b36e8e9fc52a2066c8311d9e29b3efb5c093d823c0bcfda338db59b56440bf69981bfeccbad5a363794dd8e9d58ad8f5e57db4f66f3ed0a2b8e2a63c83b66127e5038300a2fe11e898dc74198a9aed4cb7478ec1dd4338c6adeaa03c6afc51feb197e1eb7f860048211b1b4a768f40fe420dd3f00965493146f82dba287ce347e53417f50a3f51faaadb21eb9a383b1c96d274017be0d9d71258a496b5c09915660811c1525699474036ccaf32efa1fa521d7f54c6a3d426abc752d063b281301a61240ebeb9b8c7b8708d82dc4f2f4cda35090a318a804e4315dc2426e58ea308cfd32ca3dd0ad5d291f41a407aedb87d8078ca163be5a754112b5ef8a4dcebac0d5ceef3c6b4a67b081925a9b89251706fa0d1719a31aa8752308aee6df2d5b62e23ece4195f60c155c970f3ad0de552aa59253ade7c894039eedfbd5778442e588df3ea24bf15e2c9b21a489bf731b9c9e5aa049ac711859b8cef908705fccf28d77b69ba11411fff0fd5444f504cfb4d3da8ee62afd74f73507d2883420a86a1523421dfd54de72fed5c19974b2ea5e253749f711d5c3313bc59c1278c3daa568a4d186d565f1746e0610915f0880ad86dd7dba5211c0d9c1d4b82811194a0435ccae8afbb4d6b18a1c254dc616944c1be52e59b6e35309f58cb6686943deebfdc835f523464def1b86f62486cb2a51e6e4e7c65dc38d01199360475c896c3653ef1d826feca6eef146c6d69f3f905cc0510b04c4655e4a51defa6dcf9aaf863e477b84ff728b2d195470b78eb16ac0d4e20b41484db15a827a316091d6ed8f8e57f329a5c54f1d504c8e423a00e6b76e8f91e311c33962835d8c24386f91b61deb74f2c7be201bcdc2b4ffd82785b40f9869cdbc6fbb67a335f1be4843ca48a95e91927819881fe90cc4e71365dedbacbe3bbf13bcd6931c23e9017587a2c7f773965c18531b66eaa2c0f147e10d50a4780d25aa7a63aea019f16eca48e5cd1533f5ad8eaa2ced13376103e78ae47c0b251aca6a3aa1a993a9f7f9c4203a15f0cbc095cd808715be5645ab165a8038c6e3bbfb10c8e2ace1b9a9b8ed12bbc6a50ad3b709e0f514292971c2cc135256b11fc1959314705662bc9f8a3f41bcb44feb0504b643df926dbe995c7110c3c770c26a9339ed08416428a5c5f73457a5ea83683e5193f4f010d043907a4f013283905c94df4ccdd438dcac86be76da5adf21391e15b210d13af5ca96c11c7baee1c74a42f4f3af01f2e7c8a59c5ea0442c87abc987d62107f186de852d809d614cfbb26d88966c3facaf95b0dfd7851a82019626d766b80b2c0541992ced84a018284c4f7696442e844e14e7a76d087f0c6dba3aa5d6c3f9f89f20aa81d0a017b2825961fe7034757b9bc8fa901dcffab30e30af8b47d41b5514d0f06b5522ef7870b2d4d8bbc1c9465b938c2c9763fb174ce3d68f7ddce2d0dcb23c38b9bc8094bc9d8c9dbd0baacb3d3acd332b09ee3358184f74ad5c8302508b14e87cd94c5e6a39d8cf212ec41520e6273e02748bc30c1d0cec2e9b5a0043b800a70475c66051b5b9ddc438e039e7ee5a4545d9be63a1c24d793be7bfdaa641c50b16f07f1cf59f1dda327cf4cbf3f3d30840451e94f28d9bb7d44e9cb75a8d916c48ca41719b7aaacebb8fa58ff5a804f8bf3728bc9d3b63ba403790a600c06de9135b2e3c04e85c347e6ab983247132ac2d81c3d4b1ecb06ef288e758be77f81f45cb484665e5a9a460d38dba5ae778466b56c011c0e566ad6180cc794dcb638c55c3f1bcea7d98f58529e8e70e92360d20ebb32ca3d7431fcbdeae770a39a1b629cd49a62826bfea32f5e735d8e9caad6c4601919795afb8bbdc18b3c363d720e7ca7df6b8debaa7a3085a32afb415699571df8d8ca482c789049a32931a4c0ff385fcdcfe1759aa2d145379f4d54b451ffb3fbe9313af26b79d5908ce3bd2ee52e46d9dbf88a542b874f3c9981a21020f05f95fc947a24b328063d33f6034543f5cd2c0c30c6a0968cc5b83d7c611d98429eefcb0264214493a4e3241823fe6e7150ddee6e8c07eed1aba0255f8b68c694fe7bb87f872de485a9851f983f2218c963f076613d8fe481cfe8c92311b024772032fa47ea7f5f8fd77c4c31b70de6e14ff984e61a4a04a8337ed54f759aab8a866d97d0dc674206ac7ed513dabc0a10f93e2e0b436cafd9254c42a937ca91f574e1d82eca18706637a795448f6069228d41ea73fe9db4298d4cc9a67d8327ebec11ad5a19374fabbaeb31d4001e7701e03c19268ff5b912e1db0a721e66b272cd307756ff5dc32a3867bf5204592e1d0da7b2d90a2b4c8824453d0dcee8b46d10c29e5bca458f63487ef4bce99acc5de7484005cdbead3d07f2201848fbe9f17b6f0b67e252a881944fd9f2b60c9fbd938278ddf55d3a0b336a6345720b165ddac6037119467c19d0d5dddf7b130676634768f0c939e39ea85e3850a55c34440acee2513755e54182a7ee99ef27ae054fbc8e12a2cf41fdd537206d15a347f89ae735cb2589a3c608cd589bf405d319594c977439a990805c210773e393261914a58f70c9a1f20787d2619836c521e81a3de9a8a3140106ca5955448215bbd5eac1c6894d48d4d239e588a6e08b837ceb9470b166705fafdf900c534543a8eda645b6d2f93d08046e63b3f083dcd1e4e571aa8ac89f3836d3dbf9ac02cc780bf2a94181947f6a3efa863ba95c36e384fae514332a05cbadd93251d66ec761932dd8d6db4925acdb9b74abe0759ef453185da9051c8d522094aa0e3f786563f65e4d7fb285c4549ba92799229d7554123e62fe72da10bd7c11cf88cace4987375b98431add174b46375200006dc3d8ed75a6e75734c6d67c216a6fb1b8e29911b836cb0863de596872b9cb4d71c82ecadc4cd07c5535ab782785d6f8307fa65fdbc871247ee7253f13e238b5f04a4266a1e95bd573e7c95f51a54e326fe4cb483ea092a8a6a3b708e98cd96f9f90b36d486435d280033d1d8376be714c5037f60231e33c3442ccb7d034a65373eae56cd47a0416c8448ae51f6841201b3d08b3457085d6623a9a9ecac82aba1c892007dcee19e3b8a64a7404855f0e4e662437059483b9acf2cb9b0f5be2556bc6e86120e9665e1dfeee7eaf16f9dd4b197e839ba44f02af24dd4e966ec473f42abd0b291021107c276ddb69aeb48fc4f4a641bc41c9735a0e12a70d9be476d6374ea7eda2dbd778057762a41bd6fae5628656d401496033c001a3318c915fff018da65c2c93b902f6fee7c6737acff28782fde3a085cae6dd87eff9b8036de00d082c54cb74005c09ac2d70fb7aed8231be287109cc4d33a091d01e0945eaf77ec8a7c8df4ad4f5ca42c3a6de70cd261e6fd72bd4cb7e045ff8d0cd128fbd975f53ef4c018b3a351d9833de72e32e8c59d6a6163c89c627413e193e989563382d6f343e20bdc51fc3002b9ba198947da85623af2b9fce4431a6b080f40c5d468eb28b5fc56f8ad7e38940c5b0f7f1c37aeb48065b2036813ff748622e96ff931c1ac0f0fb8bfbde4db7ce5ff7e2c9341919e0a1833120e5bf38b720289c63d82003d01a4b0990e8267ed7d2812e0848e33eb9b9689d930d9795002df1bd3e427caa4d691d832b6906a0a0a928a5bb602b340977997d9df05eb8d55f01787114811867e2b8900caf3619e8e485d4f7d99d885f1c3b37768342730d40b361915defc20f530c4a31abc007863bd625507216e41aca00598ee387808f170bca501ec205b5572e42345e4736cef8d18a80ae46bbf6da06098a70396c10cf67f46ea9136ccc4aa8458279b54b78297ce220da748a4130ba95abeb719f3c84c90994896b99bdf40d6106343d95fa3969a338d6fae5249c64d27c093b9e2535e2a5f48fb6ebba1378f41902cea2f95294f0d6241f74990fad8a284e73c0cc3f930ad33a480e7b46c5ccce6f256d28b7dba4bbd8ccda7c0d250a80ea2f2fa854342daf8afc1d7d13bc23151c04e0b705dc17b00d8768b3b1fa243e3dec1218880345cf4332173b4b8b7789493f495e4065e24b3a696569600e0ea21b83e761b855031ec8b0d407c14bb7d5753202f4d692ef147fc0fce14912672e67226b6c6fb701779969dbd47b55a302d3e1a9a073cfd0e078cfc96a360d23bf10dcbe6df063edafe4ed7394aeaee958b517bf53130ab0be50cd99a1ad9df45658990abc411a1397eb29c962f23d8aa42fa81bed82e5367daee4daedaf7eb70f5a88d03cb145dccf1829092ad25cd6daa1c6083f4d6f1688ed63a6e4503fd6c173ff573385a1aa8db9d882c3db42dd25c4add53acc65442f50749a08a54856140ebf0f5663414d6f48ac47807437a56d1db335c13d4940da327a287347fb2439bd26b9dd629c146716417c1a0a8af6fa5939ee4c641cc7388c6420783a3f087c95800f4b62934bca072c3fe3ba9fbb9a20548dead392dd91da849db82bb9eccdd489d3ea89b098418481abb9d9725a408ef6b613162fb384d05bcb2821281a157eee2ab9168736e4ad9621abb62346ce562a126f98b67cef6ee52e0be062a1bda63ea07d86bd11229646310d369988155a81d02b6f98b7556464c59005367a6c2ec4c12f8c2c04e89c29b428ab37f57287236be1701dbd561046ea05f4430a4c17a945ed9c891f69eb748661d2811ea90a36b8809bdcb11e893ed8df633168e57aca693b85c4ddccc6753c6165ee548c78b27c162931ae12bfc4a76485a5f9b5992d4cf3db48645eb1d895858d3b1158b7451738fb4d5b7400c5e1b79b7a80dd668d90d892c17542e4685dc4c8981816a3dd7ac9c2d6eafca798256d819cba1683d74fed31a2803785b276fac347c25e71dc0cad7148613b52f3ecb9a1537642b88806fb2596d1afb4ee5ca14577fa7bb8abf1745e62b07a1e17ea0901d32d13c272d1623b1bbbe27a76acda403f2cb25a31faae65944cb841f8a6f0acc3b7573ab66117c0d9ac81b497db41b029c50f42e64c46e9d6ff3e0594229c68161a4d377a4a31827d14743b67ed69c38cfd159a28612ff16a61d8dba9d5efc74410cd2898edc43d6987b31a7288676c1f852b7cc616ee0f80a3fc06b51e38811d909a135978d23a067c9266c05e2ba9a4dc0ca8f14b4463b6656b805113530acca167820322ceb8787defa228eb81021b61cf5fcf52ab1a18df9dfd0ae55a3df490ac13e8a517608e68d2c8e6309fca9ec1b69cc900d3b4040170f78b6c2a9cb9d68bb008b29deff4903dcd824a7f6bd2d6f34ccad6f83cc5682070a71bd8fd8a3473712d7c757ca0e0507d7b88d056ca487a425ff7e2ced0228ddff00bed9946e327bc54f4249b3234ade4557dd982b6672ca467c40948efd076d96153ff217ad2d8cb83a377a774a2d3ec178eb599b86700efe07aee882eb1b1a766551b91543df84ee59e4b7426f9d0afc42817b519b9cf3f7e981ad858b790bc14f86f8d92829563b42738d39f858abab4c7e4635bee3283bf970c439e1024e71af963ce1251a7120b9d7e304f5b980464a3fef90d6d57a4dede310464a2cce145087b54c4d6bce9a3d008dddfd6efb236a2afe91382edc1e87709c1b6a9ac7afad6d26a4d85aaad7dc46a8dafc0687ae1db5884a126253f35d78866b5bb0737583498bbb7a6bfcd16f068774739c0b43fb6a4f2fc369dfa620b8895e86e4079ab117e7377e9d9bbe552fce5ef682986b5d58891fe5392db00e4acc9921ec8f6e5fdd8baf1128983fd07f5820a8eadaae40fc315f44aa22933de6254f34e90f5f4396c0e0ff505cb3694b3f4bc838510d142d93b936c698609c2cfa56adb3c87e4a820b4342a46c6a8078160ec46543824c41205cd9980ce6650bceeaa964e27ea671ced25f565a5f5915be7a9ca578f7619ec5f5cad2cbdbbec678e9235ac989195d2b113d57a393f9932088a8baebe6932263b8a9b464c18981938c69aaa8f6200c7f0f70fbce143fac433c29062ff9e272598208b78248a0155a0b53426c0908f4bbbee935588e76330b32a5557121e0d967aecfeed63d5e7aafaeb296f31e782c98db9e597030b0ae789685ce9b8d92ba055ef33c1eabf1b426b04c2bf275e03e41feace8b2c9f0c2bcb5316f9a59d1a05642d15c806838f31b5cc1457319878434069ff7e23ed0ab162bf0b62401063f4905008354e3009d35b7eef52a12e29398458bdebe1e141944671700156931b5e4cd1229fde1632db92116f80a9507f0af019f6330e7cd5d274681a4e46b719e5d9cc36a906e1d0f053cadbb1aaa0df604337095a9d56663a5472faff0abc62b0806c929e4e422463e562915f4c0f3cecaee3ba3e338dda8ca1006567105a0e6f36e01f568c9589a985e28d0925fedadea07a9f52b17e96ebbcff4b60cbc2ae97f600d048df2c132d792b699f3f81fe409f48d5ca7717869965d490e31374aa152343b6956d2d81994d5029d0a6e204201e2d6627e3ae4a6055d2ed0addc250c5e6dc3da41fff4f98068a554650a5054e93ba48ef18461e8ef45d1854e14b68f5f8d963c81369c73c0c6e673a1fcf925559ec13fb02995c0a49e01fa1bf59efe18a0a3fe4cae33c4169d30b6f8dad0490cd476e500251fa35c74a241cc1fa10304778185ea0fb255c86b5aefa9b6438a74fe02f701afbb08dfa0322098b8dfcdda93e31c518d00ee3bf5b59f1e2dbaa65f4b44ed5f2eeeba7d03208fc8f248de14174790f72d5a6dc4349f3e0d3f00b7e97542790af464f931f3bfa371c892fc5ce8a5c35c325901919bfa0c4190ed70cda19b0c92937009f401f1731d0ace1fa6e92392f097098c522bfeeb8947f6dbf2aabcdc268f02ef6c8ce94385dc71dca9a5a6347ccd405972dbf0f865a550274837dc54614d5ba5ec096619a00be86e2ecae9233ed4e63e901da87d94dc649a3dbb1e657a7482243d6b245e02352666304a707811f8a13f357ebde19fb4c994dc3fe6a160e66cd013b9dd989c5c4a1558ed56d85664b2da23f0f8707790fb06336f35</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Dydは、パスワードを入力するように求められます</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">暴力场</summary>
    
    
    
    <category term="test" scheme="https://dyd-true.github.io/categories/test/"/>
    
    
    <category term="字符串" scheme="https://dyd-true.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="贪心" scheme="https://dyd-true.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="数论,数学" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="暴力" scheme="https://dyd-true.github.io/tags/%E6%9A%B4%E5%8A%9B/"/>
    
    <category term="组合" scheme="https://dyd-true.github.io/tags/%E7%BB%84%E5%90%88/"/>
    
    <category term="test" scheme="https://dyd-true.github.io/tags/test/"/>
    
    <category term="SAM" scheme="https://dyd-true.github.io/tags/SAM/"/>
    
  </entry>
  
  <entry>
    <title>一通乱讲</title>
    <link href="https://dyd-true.github.io/2022/06/13/%E4%B8%80%E9%80%9A%E4%B9%B1%E8%AE%B2/"/>
    <id>https://dyd-true.github.io/2022/06/13/%E4%B8%80%E9%80%9A%E4%B9%B1%E8%AE%B2/</id>
    <published>2022-06-13T03:49:32.000Z</published>
    <updated>2022-06-17T03:33:07.706Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="b6718580d5d57eb73ccee3d3ad31e04ac5266382187d5adab04d26e3710610f8">00ecddb57144a23e5ecd6181707bef537a91ae3b484a011bb573e3f31c373353abee08fed08890efdc3c879e11bf7672f2d945ba439e66a01ad2b52e71f809479260b59e69e5a6fdf9b98aba26478ba0bfc10a44313695b8dee6229d795f2aa861d7d7e679b1519bec5ead37b6f161cc34f9f277f0b0480cd9152ffd1e46643f0a53623a7d80c921496daefc1cec67a1833d83e7e8032bc4f0b9504a8ed7421190df90aca82392b6f2343898c5bfe983f7d3693da80fe4400c26e673e3371400b4ebb97955ffc4984db0a9cf0fc44ccef856d84951d9eaf75a22c87a97b0b602fc57a0785b59f3ac161bdc82887f438c9dba38e6835efd9ddcd816798c338e84575244673724f2c14f608db139bfc9e5d788f1eba5ffe32cbb836b8ecef1cdf5af64cbbdd18873e53df3e0f100fbe84bf7d08516784a9292757fb0ade659eead4e2cf45924f75333ad27f068cb7ddb304aad756e9894b88d2e3f579a21c9b850139f6481ecfeea074d7d7de671e88ed9c97b5587a0f9244dac43cb7f88a02799dd13187605a8a2a052f342a7dd4a4a37d889ca5add25c5c856e692f6a5440bf62e41cfd05d6a3ff9f34cbbc6c91849882cf5e6bf5b5d7ce2a6f0b5b6742279b5999acd9157f98b08aa200c3f0c0fffed2c7147791086a9a41b835aa8b7793f01aee75d885c4942ae66c4331efaa545ee81ba34636ee7286919f67cc9368f69d051894c2a4dbf6b203534a12158a3f11549cb31784b455b293e33aa0a5d7b23cc62ef7729dd5d8423292fd5c7ba0a506e1c238fb2faaec63fb1aab23012edda0e92b86e7bf3377de2f45367c03c422dfef6e3270a9ca89df98bdf11cf76339f29adf680559b20263dcef78ed68c07a11fa0c302b9cb45c2652f3d297303cee6f736b8266f3a18b2ef88df899a99ffaebf57adda04035d284f77d245b3d9fefb6b44832029f9ea38eb403f6345891be0a0e5a7944f85a3702dafa5d0d9701e2dabc1a49dc2c2ba228031d025bc8fcf44051e5b607052991f642b3e179601136381b5f40f51c7edbdf84fa303eaa385c1354ed76361f5716335ffb6eb852ec726df40447a435ba9758471366dc270b1ec8e4981a84bff6b5d68e41741ea23f84bc6c3fc5630ea5f23e244219b40787279a8c5ceea4788a735dea9b9e967f197a55dec0f57999fced776d37e93c9c1dba1ddb5ac34fd4521c8ddeb01cbce00da09b25199e243dccb948d7b2779df9d0d4e2855692eabc90a0fb85ff8f4f8c94aceeef742447a6a982a8dcbdb55cecacc2ef2640cf71fecb03a78099cc4b10704083bb33b4e1e7abeb4183f744b8d4dab45ecd4f4bd6fe55ed9111aa7bd76d945a4b243d754f3aa13df3e137995c86920fe2ca66b0893f4f54317ad4baec4d2a5b7ffae78ef040e42f49670ffa1c3c2dc9db5a4c63811796c0b2152e4c4a0891ac7d9ee8f09b1fa24eab0c7fcf952b7bd8a572ba723300d0c777a18a4b65728307f614f6d8aa8cd8c3f109fcea65b4e221ed7a2fcf0e55efda69a5ebc082e896d64fedcf66af271322435ac8f75791c9e564d156cbad348952e351b2aff52418db409235a64c5071eea18bcb8be3da421dd9103ffa3003d9ea8a0d8f4bdbd84e67f61f227f49c0f606a0c3f6572cba43c1e6744f6d063a53ec0e948a47c4a8112a4fbf561765b6f22850652498be442e80253a679877afc88ca5e057ff343a222771ce5410ebf62941b40d0b38e6dfa39a67a36f77f6746f6348775b6404327c08b21cb2fd8a91d1c247ed97f7317656601958f24a4d84ff0bc9531a23f40cfcdf711edb730eb1fb36a944e2c45dcdb068fbf7f08a640b72055f9b72a8288c33e328af30cc3f2c4b6385ae7ef3e19254b56ad559a32909d0529ff27698d2a72c3c977b1a95f991444a75cd2d132a50ec937bba6a10b82216075171314076a7d8f59258e3c50e5139bad19400985572ea557c72c77346d8ccc3dc09d0fc3f137180a3ea4f557c693050813bb7c4a8ba4ffa69ce1fd1ce7ee2be0a25192bba1635aaf0cf068a2b97f622ea83c5a1edcd64b7cdd41053698638fb6ce9a9077b0b46c8c44f869abb8c4983f82ed00bbc33daf435bd454b77c27bd4b735006e2ae6e10ca37863315a3a237ae4e1b924f925af87c9b97f85489ddd50b9ae898f6822a20076470563bd87ffadb5280ddea9ed39dce18cd78a0c1b1945336829a3dc6ad80b7ed3a8bad9573d961040a69eb77b010bf583b1fc939e6a6a17101dc2d391b39bdc759de006b45b5177773d4b8909dab502b0d1e36fab2e32c183eeffbc28295f5471a473714b98bf3b4dc678665b4fe4e35d93e5a5f9b530c2393eafe57d2f9bb460a3fbbbc8e6127d8dfceeb7243a0ae139592bef76dc7f3695327088148bf47fcec2470a0564f34a2eabf33cc53096ada155f5e2c024b33b946ff0086d6607020be3d7b74e3a90fb6d9179189bf1abb6ffbe0a59d8b57695e834ec4ac94f9ff38343286565061bb567896a16b59a233fa04f2e84e648d4657719c5338341d80b4766386d397dc47314e37819c80c0f734553bdd9f817e08a62df1d4e4ae937464a6c297dc87ed29d878ddc54459585643021706e0c2f6374a93d0d6ee43f9314653dd0047d531fbb9c78c499453aa31ad68737f15edd1fc3d8af35d1dc3ebe99c7a9ea1709bf8a1877c227f1efa26229245253c880ed29f89318f844d0e9091a85eea5c5597d7989294b41e4937277e66764c9ef670723d666980349cb4925e6edf5e2e9436d30e706e0cbd0997a746a68f2a9e80d5b780f46ab067d0259cec645fc940ef8258488960b8b0375a29c13cb02320a390ff67b759f2e89ca28c05499ff34ab0e3c801b8fc15d9dbc0318e3054a93ec5e2839546e17ecc5353d341adba23cd7d17dc825d31aec1931bc015da33116dd82417e4b161ab4f08e754d1ffa937ec0c12f90fb2897cad01260ca12e9af8d3892af390c1cb5945925c1e3b84a5bc22ab73ac6811568cf00b87523b9df5c91dc9692055dc2bc2c5633df36f68b019f3fdfb47873c7a89a1c986b282276831efd308f2dfdc1bf1ef2d7724324ab4eb3c6bfc62a10e948d878390206a63caf554a66650947926f09b1e769879b055e5970c31c92bd924535bd02c92745e2719a4e84b11bcfe65d0101b5ef41ad90f289d07584d1a2a9c9978751f6a58337d2f8f8df9f4f7b5c39dca84b13640d986e5f4e796d1ef7718b5f713bd226da3468cdc9150605797be5ffd7c4aedf8e4e95bbeb650e51c8b8b81aed26ac4b158eca0edc53c69fb059bc9cb9b84f35679e9b6d6688885ffab439cf44aac56a04c21076b1c9d64064c62f4d4107b8dcb2bc99f5ca67a9dd43626a966fdaeb3d1e740b4cea55d25dcae7d6b2fb1011ea4ffd7b39e5615e84cdbc164590a639b429b5598427212126c4ebf3992fc26c3431c87c6830f2ae6d235b591b8d85c1254ffd67f2999ec0c0b5b3c71f658807e000a15c7899896d4a20e2d7c6303fdb5aac8ffc08a906adff946b7f28b6083e765535996a05aca9b01b8de11e2fda07cf39cc1e0f9efe903a4adc3914e38d0ab1e5f72dd7793d311424202c029940ed62f65eb2b3de406d777186538d31bb9cda5a4ea99255b5e2ee361c34ec2e91a1183dd471f6aacb9d737cc708e068028827bd7c0746f2bca3c175901e85c14ea1b6ea33a1100786ab0bbcccb21161962e71754f837e2722c52c991778dcaaf89da73065e5cba9ec2df42400079da2e1f462245bfb426f7cfdd70f44b44f1eb86965246f37d80151b18eb9cd41afb22a94f14260eb63d549b36b019fc34a6fab4250007bac4e3093fdf8cbc349d3005fa6657b141479454e783ed4c78929dd4e1eb45005be3292376eb9cd4b76a033e129ddf1fc4668d6e4ea4747bfa760390967c5ca21142dc274e8c2fb496b2a9310bf866a9b50bd7d8889c1214359dfa7cf4a1f1cab0424a81fd1ecebaf0380eef70d5cdac06d9ecddcfe4e2f61c8d8658ddccb8aa229f30e8fde94a565deeb97bcdf02b09b3bbcae129247afb2ee94fbde69d86ec93e123cb21e2cc25c1f5112d8af19ac2d0a378db5935868534f1edbd2e865c77cfc0bd46f78a75c47c964f47359c55708a0fe257f94e126c15c6cd8123165e687f56be8760a8a009e72ea3ee71534ba8dfde99947b483975decca5e18380f67cc25a6cbaae6e119536a97f9c364fd33752ed75b1258314c62f90b1fc1ebeeb3835ec77557f9ed303b86d2717216aa06265c88b5db3e84046a32a3831d4c62ba3829d08388fa90cf0c62d25368c0d15823ca8d1c9f142f99ad5493302522d59ff2ad196d9df20eada1592532e6294b6e9aaf24bb5f4e68ffdb74bca5ce6040eb77953a473dd40a60a14c346824594d2d5e341117539b2c533102b587de798560f843529eb6657286eb0106639072ce66c3f91c99fb54a3d12211bfd8e5d25ca25af7eb22d17e75d98422b3cbf01f169789cc04b119ef0ecfdaf5cd98f5025604d047e26c0d7b668e258689e859ee2b0ea01842720b1218ab8929b259f1f012df2b671abd8ad052f462c1c65330c9d4a77aa58221f8d88afd74287ea320d7591bca7b38deabe7db48a192c55528c9648b62bd4afab1ca001efda6a6638dd9f038d21402ad4f2f3063e9d0d5e4aa8d531710947397719648ea4aaccf33164775dc6cb83de7a7324e5d2cc9d43c02c18e7e8b7866e33e557ab50f3fcc9bfdcb6f3fc5b64cace02ade4cb10e1eaf1260ec6c7c215e7716cda1fac543c2ccce19021955f92cb2f721a8c1337810576e5fb1b558d29ba6eab31eeee812c22754234b396a8dc8b1f5780d4dcf7ca91fdb0b2e15cfae14b17beea96b5a4ecb5daa75ffdc9867fe07cd8ec544bf9e9a86560da6b5bb4b10eca3104c0bbf0737427195991ab794c012e3b56f632ecbc57099ff4c66dd44c83c0e115e7e3390f41f8eedf84d34dad52bec86e6897887f8e7ad0b415be4c879dbd54a1aa7e91daac8cb2c6edb6c448a0de6e0bbc263aaf9c86274f112c647b7a917f304c9c6aad6ec56b5950db2acf790c6b3666fdd1faf8671a437e5b0ebe423085273392024a9a0b07221d93b4f7d59f2fde2524c64a31e4ac8f3dd2fd04bba85c68740c1efda84c88866f7afabdfa9e0c15403455194d20de5f160794e77eed5be03c3d95d1eafde483ceda6912f1b757ee95cee2ca00b884fe56f3aea8dbd9d3e07d78307b578ee1e08aa117e65fae0e95d826697d977baac048fcd03720843ae6d3bf52003212f57e8df0064c1dcee8d9b323b9890eeb2558c977e7f4525aa88e86e26f27af898ba6d028433ed628796dedfbb65fa197ab3d19d08ba1a74c80cf48015601bcbd1f151c93aff8ccab1e0c0eac1d28c870e075a5792af1f4d875bf414f30dc88c598d9453abc0d5af81a02217a876710b85a4700810da1ad168a1fa353c0517fe7358a75e8d941cddbb55cb31025aac150fc6525d476c0d24fe298a032f38c775a19e266b16b14f763e80dd09ae41c2deb2a711d62d5592410feabd0184e681936260e849a44a4003d8e734926f24c98b690d9bd2249671450bbe1a96e5c1abbe762c9e617af07ce2dca193220d87773a7002e8e8432a5427f339d61c77e10154e89f99c5c119d68e6fcc267ca9de8475a2cdb9277b44f37ad0e4453dbb4c103b671ca7cf415bf29255569d1f4798f5093b28e6ad058a623cb3581db57f25751820a033f58d75375e3c26c1465cdef8f48642cb5f45d541866732790266380534e0619f57810fa010ee69679d60311d3e2692f925d5e022d9067a58ff86f431107dd95be2bb905345120b55dfb45ccdf2cfd545f0df5ff6bb15eca2b4932896713009d71174343d3cb64de2642b7a19573297f995de5ea5c6d158a97f68c5a562c06c1bfa982d9f62e80abb6b0068d263792abe2e982e0bf2429c05629a654e00d1ed97d9bc195ed143bc242e9d39cca8fd896e5d60476809b4b0288b4261684e1febf9c8d00b9f89a1fcc9cafde07b788209c26f5736005721a8a73dc7bee66dfb3809d5f16e3535611ede8945c21fec0ea3a40be61b28c5062d032814ea9867afa2cb0da5f396ce242b474f2fefee95e8cf483b0399b8dd1f91245406e0e7a15fb9805ea951ea9b892d2c852b7629df33fefd0c6dc769a20c7bbbe8bff390056b04c5afbd657940415b3f50e1140277ca21ee872a0447fb7153c85aeacf14168d2b4b25ae9ee59b5c45dfd67d03c5f8d44d635cdce0c646e5f42d254705f776754152967dbecda7126f300c14c664251cd38b05b0753ac435d5666dd052592f21705581ab03b1cdd7622367358458c4b7fcc790bb6c300bca0f20294f28ca45d3ef5eed474a26ecfbdab1fb1745394194db2c547ad1d9caf0dd418451efa11be5d7ac4b0430e3a5f1168bf5b330142561bf8d160e57629bc46c86ff73698caea527e39c07b47c7e8c34ee8070e9448dd02c3f765e570adb29ab8ae213e4e60049849fdcfab476c5a4df6d97903dde8a133ef5d940141b32960148e6501f6301bef9d3ac5425e7980cf0257986bca245869c5adf6bccea59b776eba9b51f5aa4fa75c7990b7c4ba5114af48372fe598a95c56c4271dad4ee4529f8797d0b410894fdcb229fa92d71dfbae6cdb15c9e99b081d62e721a42c88a3631e872ca283c90f3ec1e1bceca1949da0636c81de901d813a50f767661910e7cfc49288092dbf02f3fe10e8b9ca56083947856bcbaf558c16c0e44c1737737de901d649936990aee587693346817211eb0e8500756dd4c8e9a10d65f6563582699a87f43f08d24f3f9d0de0ad2b0a28d682f2470b95784ffc01b2c38dff79f6f944a328ededf4faf2ee6544e563ffeb3a938dac929e3d0bbf5cd81869c7f11a1a58793f3548d433f8ca84358d9efb031a95d28cbb83aaa56d1f3b85a0b079ed06efbe799fd99864e10a96b0539ae17154e5b5048ca404e31409159be02bf7afc5556d0a3b93acf5e47c136c179a1a62932b6d49535c7aefca055624cc947dbd4fd04f0c00b6690def1205a96a6a5c0a97d022994d13708dc9ea87e5b79754a2bb5053a2629286fa35729ddd3eb3e5ec0c678f247f5b7f14ba6b2b41df9a10ca45c95a4940854caff0bfb63318b30e86ed227c4939528daa593d3f8695d4b73f6ec95288294f7c566f6b6013619e0799bfa2dc3e9353ae6231a7582ca478d335c5fa54071535ecc9ea9b151e2be24a75ca91b91c6775db5cd55c758d74af40667039a8c44cd4715505a0769016b10a5c072518d3353ed832ee2b697d9ac6dcbbdf0cd551988fdad2529bee6b15b8b74e3c427cab18c35e8fddcbe8f1545abf4bed887008b62327151d57aa4c22f6e3f14a82a73a208f9395ab18e89b23b8154adc8b947714f5ed9a8e598ddf3332ce3aac64bc8025e2c13074ec01ac1966c5b927eb7ea25ef40fadc98c6a6f7d03700ece1cbc5fc56dc4a76a4d1a57eca430991465d6ee7da938576a013e3f355ce41ad7a4c9887947561e8831a7744579f4abe2ea66174893f26420340888c85cc92c90187b955576900a71b7960a18672642a262ea31c4ae20441de0fec965feeeddd47703c1bdc689231030b115f28a8e3c611302e61a749180daa034b858fadc25eb62cc038ca7545b455a00125b236dba6fc12f4d8cce0067e2f15ad7d2b25ca365815b629f5a350ac68f8d4c4f697278db27e4e70cc4f1014321cbf4e353fdff92713f9ede13175d50281e65fb0b5142facc7cc5eda6203b52bfa7456e86b90dd7c6c0a4b8d45835165157f8519b729fdb58f4bd93ffc14550f4cd3b101bd4fbe731762a519ca340499c7164c6d8d05e7795e4df985f6ca5ac96d96d748ffe9d95ff763b174f53e078276d407d8a826d7a64494f9723d3d81ca85a512ab16ef2d05d9e473cd2bc40a9ac3532b5247208808e054a93c77ffb996426075793de8bdfc4ffac6fb5cfcd83ed2fad00c4122d3e303d395fcbd690a9e8ee44c7b2795ffdb082173f342c3b40aa56c03843eea08c996f94ff8c5b8acfdd4869adf785e4d9c7329f94ce991dd782cb222789ed8b1d6b5318f13aa90ad1f6cbeae2286be29b1ba0ae12ae33334b351e59838f592fff5269f877de944a647709f03c2477713ec56d92378ecbf6c5dfaa0cac35b62fb373b9571da09155e4f23ff4c7db27a2b209cdfb4b0362e210b514a53c165d55d40754487b1852a45aa6875c52b08473044902d9b63ba0c70f9ca99147cff05c182831d1257d571bcefa85ba0062609059761f594227152be3f2cb39c3deb9a24a1e9619e6d45437c127492211ea48b6d07fd825c4657812311ea56ea0d01c751441ebe7fbe93ae8b0d741e283af4dd7d18e3891fe59aa805ee4a9a8813d2b9a591a9a94e8942768281223e276243220735c44e552929c5c04255dd1c17c8cef88738231e09c4641b5ed4b724c9fd06997d5f51665eeff6d59adac79bfe3e9217bf803bebf306c14efdf1c8591ffba5b246c4843bc7e93cda1dbe88cef7ff548669252bdddc9e939a46b4262cc526207adba46d832aeaca2681e0ac8fe92964dc25c547c18475dd963924aac4be5567000ad20f57f4e1f8dc3a3a2e4ff0edcf70509006f78e0fbdd327aea5f03edc86b0b324d9391c6c1eb07a4af5520e2a1f0da0125efca5ce573868eda341b3429e1f8ed5042683da6c8fd685b23b602403a16aede0a6db365e91b2944c85d2fc9034505fd765c87f6bd246bf0054a44480c2e68dda2cb1a454190764cd776cfef8e41ce51114a6618709cfc1161aa25287b1041acbf13cdef24911b2ae6d92d6e0e4f37279ceef48a65400b9ba511ad9b86166bcaf84e81c48f5f09912d8d5bbb3543d03841ccc4892b61ace07f712c5c1df5975930a48aed0137a913b1f9e89cf9a246cf10d71a87f8557f9d691760e285abf9b951134f997f68bb168dc635c1f979ffcb422953798ae68ec3b30f619eddde557186a1555a28f0934686c053d35a21ff7e9c7d7f12b36cfba8b7ff1c2acd8ad6fe74b6fb72851b74ed794ed1c0b930c9f810e73ef2ebccd12a0b162d5684ef421700cc6bafe51f7fd240846ed0b648276ce32c90d413ace4912fb2ef85d9f5d7656d0ded881b72f72421d649134dfa24b9f872fc4a226e70e4e8b40cf3deb1ac488e3774a7f2b1441d60c867ce4d872a3b0e1188901a1bb74ae8105787e23b1657bef45587ce4f0db9d55b6d099806946c9a9a3ac52dff87b88bf6bce57291881daa30d89be54b90c3b62c648f90e8d762da930de87aa81d3dcd2c11ae00ab1c50d9cc081d51ae2012a1038190ffe8b8e116971940e3b5fcd51ece52ba88fabffd053dc88fad8cddea7cc4fe431a8989c7fce03c12d5ebecc7019dea643b3310a216fba4318ef751d2e7895f54f3b0166861120ec7e299a4015c5e477c5dc1940bc64a3cac7332e0494af2c06286dfca0931ded01a16e9bf04fef470ca0d17cab9f9f25d74c8b9476636f71b55f317a672c45f629dfc30f814e9d38abd9338a62e2422bdf51f46461aeb97ba3ae897fd6f8cd94a89524b94c5054cbb190cd7552b025eeddb53c9d8681a3fbf8daadeecb2c4f4812b4d8bcbd54334498209d51ac97e09319931e6492cc5a2bc410555c0112e1d0380ce6a0e911f4886545324ae3515ffadf4f541ac4ca295a543fd2ae6bb0c9b8c31a87f9b7e94ab4ffbd48fe2593125c28cf72a6babf7f2b30122e9d77d7f7326d9530a825d0179131686a51855e1e32ff42a0977d7f706c6ba002185880614071413bdde164a912a4a2895c7c40d97afcb1971192114d49b3d0ec5496f918c338720a22d300b93346acd6f5778d2ae95ddb050ebe06d370154c4e6795a1ffbe0fc3af176adf1622eee72d32f1b1cf56d7c903c628ad1c889956edfae5a07ea8ef643b64cc446bfaef4619aed7bcf6caf19d9c920ee9a79f3501d51053afdf492437eb8f947e978f2ca3376e80cee8c068421705013034196909f7280b3de08619aeaaaf4d7a5cb50128c6996f1ea304d685809dcaf69d38b2a87b3406f2291083869981459cd402c3f14b005fbb78b87de4af004efc44ab4d5b4d05fdc10063acf8ab8c4da5281553b9d8ea859aca7d44960852812c12b1a46d0ad455c4e905d83f493982001f61453d15518cf3cc2d07e178625ba1ea58b3479cf629dd32316081cf8d7b7a9e6fbfe0b1ea5fe58b851e4ec5aa09b5b3741d0631a233e4f992ceca91c676443e29546c8d660dec14de97ca346b0a76e71309e37c41a251a9a9ba1b7e9678885dafae44518b8ffc2f4d89f27a0c69fac0a10949d64b81efcda721edb921dac123252adf50e415e33c858fb7569532b5549a7e9906f45665812fbaf8a536ddb062c0a03dec3e38c1f47c4568bca59cb6eaaeace4e7a4dd265662884cd5bb6b1bfd26bf5f856a7dcc89c9c774aa52ccc2bba20bd514af4528efd625f9c5fa0e09eb7aea2e5a3f2f451dcdede4d06326bede9bff4891d85f564d6c9a314faecaa191ff48e5d6fb1272bc433454566180b79ff94078bdca5806a02d5e0071cc29b92ee0d0bc04f51fe4bd1cfca1c8e956b2c2b4cbfa043ff7a319e07391527908ccd0db07baf53390b6c5200233244a86aa6d9d0a13321f51a9ababa32173200330f9bc030db0cf8e743486e500aa488e4f7b4e114e6caa59f3998201335b738ccf03bc8ab7f7d646a99840f51257b688ed8e4b40fce892df02a6e76fac6a78b9f9358cf6a29a94a854c9542970b1bb97fc2f49c272c013b7eb51038b51d2ff3c00b0e087319b0b8843307025f319fc5bb18f6cc3fa000b7e7ccf393d41c4d1b7723912af63a2d61911de915b09f1222467e61c3d642412063044bef570b358da19b80e30831e616c3a478dcbf2c3feccc5ddddf9b1b13d04944c25e2f3166463dbec4d880c69925ca98863c724607c847ba840cf608af52bf85604316b4b93575772060cd4e3dab1e7002a4ab0680f16f2907fd392a9c8b86c8b7c7f0a0f68a5e65a49307366b85efff8fbfef3a8d8dda0ceb237a10997ffe7e635f2b78178b94e629f3b8186bc8fdc246b4a653c77763abd54e5a14aecc39218771922c4504c33ab16846539e0a703909cb73d76f9b386def201b9671dbf38027a98e82dcff43185895eecf0f1a95aee5112f1befee2b6059f8a281dfb3327b56059479fe0d750d45dd1572934339a17abb46051aac8804975476e9b595cb23c676aada8db3b7e77949703b05446491d3e643282d3039a5d754112eef3bba4e75638b2edf680fd7c6f474ce29f7502da24cd1fc8aa6d54d8bd0920dea7272dd3a762e7f903e45da08f681adead4f67a32e3388456e36701d6d6ee5a80649bf40924bc2d498ffc27e4751d85e34895a30de590bc155b02a24b999f627ed26e532e94405710cf0417039b97726a01f0ebbf120542262e10882b991378102325a535e23d2d116336fd921343c4495b9f71f79cbcc0d089ba8223d220d0f9caff2d64c8575519f4fa346903371fb9ddf13aa19bd58dd3ba2e10a6b2f4ef267ecc184b8aec91c515ca42f62d29e217e36a7f983cc8063c2b78a38f053a331305389989c0ea046627b504804eea3f7d147b6367e8d32825fa32d58eb9827b7a6ef27824ec9676e7f6c7987d9246c3f45e99e0e05314cb0f600ca6b257b0b1d4f227779b6ded19120f434c01e74a20a2a26ae8553f91ffb9aaec9ebdd28115b03d6120c5ef26cfac50559439671997c4b99f10ef0495baeb8f71426e867e5ba141ed9afadf9cb515847ce1e8edb83d1a1a5a825961cca887a0cdf09c37827dd091edd123301f0e7cc607abb60e5203e28be2666ab3997ab250653197af74a355e9bd41beccf93bd251883d8f56078276cad1ed1b60b91de6fe60ea4ec5e8bd34388fb30f6b733114f97e9c744c197640abea169fb1a8ec779f2d8a0aee6ba660c5dc5cdfa64e0c127bb4376689d09871698248781ef56f982f25afb17958a2c6646f1c26d1f3021b52d6b02ba3ee3deb507907795531a02a10e4009939a7f19f0919768ec1bfb1ae75e4f6ab5f263bd89e94822e56d82d42981571fd6f21ccb98ebb251abee118f519379781feadd1f3f97b37270b3503148165bdefb3f12503f966b036ddf52042d4cb3ddab1a30dcd85280725a436e6caa36bb75d67810781ee600aee203490f629ba051cb91b31ad14e35ef9d04fbc0c36a692927ca399560f435b8af06aceca1f493754435a6547102dbc458f0fd996d566c5a3bef2bb491871c2cdc9b9277c4fbb7f56649ed8aece21ecde234057eb1a13ac5b2342c24455de924cbf415ce1add4219f8696f22ff26b48e4605d483867f1b2dcab45734bcccfbf5532d59283ac29fce36d6ce6d765a5a636d1ac5a988c106d85619d4c668566a7ecebea8c5ee04128bb74b29979413502593ab9ec579f15615114d56b1eb0fe3d103ee314459a32c68ec6bde821e8c45283db18aab50b96ade5726a16d499b37ad222ccd55ec9958f68e69013165557ca55a1e4023aeeba5550a144e1fdedea93ddec08218f01a7418999173d3be92ffd023d9a9f1c607dd1abace5601972e990ace949f1a94e1ee9ea63f46696115a93768899b0cb4a46588038300f0edf6de6e3afd9c223788c8d1b9af5d40038a4026b75ba9008ebc232a1bf73ccef610c8826acbf55271cae3eaa00dbda0ac1b6998a73c68f673b55931c0cafeec348554b8d4342ff077a97c17263f719bf7c8d2268bad00435aa216445bfec2bcc622bbf76c98408f357b55e1576e75007d8d7c903599aad5a7a48ad3948dbb7215bea116ee8e76785fb5ac204f5263b7d9605dcec7a66316d48513059b89d620dcf11c89fcec9ae6dbd158886a565e0adcb1dd854b3c43fe0e92cf0e09adebe018ccb72a737977116c7a7e022d77266dd660b1072d5ba5f7a7348511c0428cf492c79d8efe27b74690b235605b21872d36af67fd3ed27d4def041c18ba41dc275820bbc2532d4457190d8cfc212d08c91939b11d25a9667e72292f6bc20110649099946ae15d0963f37272e4598345b99697c1c043e08a3f44eab7611ccbc29719a1071d29ab7e8fae89d269a63009af5c278973170c4699ecfd48d90cb89fba91fca40f59091f0cbe9ddf0485bdd21ce4a5fc16c8c25fff8c7b558a08e551d0227584553eae04fa6659510c551923c368b7971d69d3ed8445a831d8d73730a021d275c8938840677bf4ee8a130597cfd80c2f791bfe696665daea22d7e85c5e07b56b1bbd6f641ff968b0a7f76528b8a8089faf431691201d53c491c5969dd3a442235fc9bb0745d2a5d5f1ed2c6d18d1c14875a926a32b2c798051af5622d22707a0d2143b8cea679b75f3701b661027c41dea41d7af37b0e89a96710d6b5399ed498729bf82e454a6224da6452efb3d3cd05c7fb2f8a85214f8a2ea795eeca20bac3e252eedd09cef5d4cf149c23d4470674f9b49932b0529e1f48f77480ad2a12dcf836a98df7f759b876cd0c3bb6e9668127e3c6d8633f3120b69d7fa96bb3bbace0307c6bb07e6cd355b019ae1edee3194c37e04a4451e583cf9db40825b6de2ddf6ba9db763ae143b6aaced0e750aff6be398d0f281b7c1fb6a8c5f9e26e99d501a25246f6f2058024adf35e2ff357ef0ea8a86318463962f08993f4312c1b4c6e703f0c20430907532c8cfe9712f3d37d5fe8497ba9a4f8d83099b0b63594db8be57d14718c33dbca3968bb97b9dc09dfda3d92ae246f3d604095158f6a37e522c541588a2324c39807c97bbbffdbdc05fcb0dfd9b191cdeaa1fe13896a392e4e366d6edb859cdb02a1de6b75d9ed4b124d9f11dbea6bc3e2266d1214781b29fe5db4ed9076da684bacdaa128e8f6c3a0119fb6c17b684a2d0733f7334484a9a5955927c910c87a0725a6af83bfba83607ed54c9134f664b1caf3b739aed112c039895900a425e8a288d97ee21b7c171ee9e044685bc1e4672d139edab9b4088777f65b18c02086849640765588155bff2df8961c1ad33359a90c2a1077c34b1815e8a4ae1abab12abb85276827f43ae1a4b6ed4a44f212888bb66b0e6839e37ada6c70e9e6c59c2dbaa154b5d37055bf7285d5718568e75547eed8d4a4265e5185196c7a9c9f9a47446309714e3f568175e85c85187698241505676a50dd93c6bec8fcc1e26e10ad9f5b768326b03b3df4160d37d0b116c33bdabeee30daa598bc8913e191c6bb31059aa2cbc575dfb1d40864ed91b29554d6790d10e5276b07ceb81b0851bb661df67a2417af51a2fc4d50a4ba1b212b3201a166abd29a136cbc5d617df5ff214f062a79711dd7ba6fea41610bb105c330eb8c2d119d34f6d74f5e8ce75508f9bb6980b0a20104748698795880b188c6521697c3fba107f59087ac9175a0efb9b7d82ae53fcdd3f618214ceee48a8b7146da7ab5fd0abf77c80d091e76aeef9f00cd39731108968c48de6eb9dc6f61d80be385ec569c759cf44a625024cc2dcdcf74bf72e8a5924d5c58cb125446431701d4899cf234e6c0b1d80f2d4026ee146fab54c8f4b1de2e9de3bcee3c03d746598048ccaf3921b6de44e4b81460e7fd8da47119b1f97040d765eea0ce4da50a7ffbc2fa53e1193a0985ad961211ba2dfb6bb97aa5809fe33b51f20ecd7927e154fc8823991aedfbd49dee37167e645b12eda9befaa548818a384cc37a38c3c0e702fa12f7cf8c74f3263c214676b32b64ae806305d5ab96a58aee15601793b137ce470d504150a20d8e00a5f214d7d3bb803230daaeb5034c6c07949c6fdb6c811da573a2f0d39784f0a0d9b0654b3b5ba7e5b88c30368993795ff1cada41a4d2d7f26f5a1ed4c2931db3948a932f82f3b908be2eee905ed37b6aaa3347b756d80afa0f40fc335f2793b600b0087308e1ebc0191babeceacb4d38a7a02729beb153c3996dff6ee7f88c044e6c07f977c36bc83c244c391b5c1c557b241c6b152d0b601c234805277a5d236543953e3d4d9f5f119e92c3a9a8761aac1a3457a68eaebbe3b036f4a4598044e06ee559cee7f3c7126ae840e07e9c4473eebfcf29d447e41c099c1e63f01d8c9c0ad0adaf74985022be9211b1d96d505151ed0613ab1adeeb7aa151608098dad1abcb4b01cfeeaf41290091df72b214076fcf1f836199f0cdc890836d62db8fc289e92c5f5c45f47dddae4657b3321fa978d2a6ecc3519f625cbaa2ab069d3dae24e17f8359966dc19d4fa3047248ef08723c535398990e018380d354918448a4c6d957ebaf317ffa235260db23562c3da2ea82a06d2cf84cb4c060f7f21deaed937cb961e4a9deaf49d5caa33909db29a2d2fcbd4da01ff4f2cb563b9712a9c643fc2611b54469b56a6ead0d867cc77dc26b4cfabdeec9c23b72f4e62a4291d930d9efba4345e4fbc0a984724d558283b9102d1881a3aed652a61195f3c1c4e5a9c348126bf975a6a22ce6212b5cbf13fbb030d7bc0ca6a170fb4cae95cff3c923bfe12dea3be5d72ea76ec1454e5690f207590151bdeb01a2fdaca459b6af13d2c81f6d7f39fb6b4b2b1de7543cb119cd6fce13085e6a90872c2aa54851218ccd5a8eee39b6b4157ea0f323c7b97c7e81e79f8504b1c6eb829f12e6e6998b7e6caf77fe6543112b4935d6f9de546f39e567ca06462eb90477acc704e0667200e429d70de6eee54aaf1c68bd99029e65e22efbec8b8ba49a2520e46eca89245f57e02c5278629bac3664a967048518cf4aeede3351db2b01449f248cecb93ae0f5034bd228e8f350befd615b34aeeaa0bd83991e53a8af7926f6cf0a2ac5f106ab1dc88009baa16de7f99739cb02329a66ab742208206212addce90b9a097b32af8fbe123a6a6d8ed68f0d7a9298fdd264746f34744149f96a6dd5c55379043a3eea633492748a6a58bd19d2ac12777e71822511e793d901b12813c4ea12090bed1a124cf7e252d234fa58479ebbb49d4f368b760b2d309e3a68c365455df91e07f294bd892749a34ce71f5f6019190dd3af05d54e29ad4ba7c9c8dc0e9b3be4a015e1e181159cd96b960c46e4b78120640bcdc8a458d6ccec4b76059659a2a36a5237fedf788f1704d758ddd1f3eb8a9973d0c275af0ae6216cb925d8fb9c144d52c7b5898b5c16b8993e286f4a2bb42ecd6df54dfafb42940d347a711dc16aecd1b0eccc5095167199985d7841a0aeeb15f5f4af45492e89f7e0480f16623663d15c779be5860e555fb7a9758128da3ef7c436b082bdf5c7f772f0b7a024187dab3a46e7fead45e1aca56128e47149655b1c40b9e3cc0474e2c08ed5cff103341dfdc81a6b06e433beb84c9134a79e81b8db21b5691d9ff1e9794ebbd42115ae1e3e90ae9005cf98a385545810c5ba3cfdde5d439a074634504b0a670503be2cfc3b6e50cfe65207fdd841e009c20c5f3b09873d8c9a8676ca77a151cc5602670e2ac699754494007d5314ec14729439f1a47d4919c41fc62017e07ca094f6924ac43c5eaaca4f93128a3a774d2edd9b58acdb1f17e8e9c816b015e903e3dce19a7c27b39c4f5be4e26ed97488746ad6b818943f600bc59e5c8524d590a46c779fa42b9c5d7e689c415e35842c0dfed4506ad5d1f3b91b8ab360ce88f4abd0cc4c32e64cc252e77248976eddf6a96812453f2927f7bbfccbcb72df231261ee57a8c6dc52ad265c2f6274cf2eb473001a1dc31641307fcaf8627b541da3c811bb084d9973b9507b206e3a5e736133a0e91c3f54dc3743a36dfde5436b27d102f1f7a3f8b92bec64189636730df356ff9304f59d12c9bd9c317e2057d5d2d3dd832f37a04913ddacdf9f704bb9a542054f5ee13db590c90c45fda077b65b74b66eeb75e3a6bd305cf19c0beb4468f457436b72a793030b33d42b5aea051f2d97df4a9fe08cb9e5a629fab77546dea737182fb12a2d90f763ccd00196db9ebb20d70b4fcd06028df5452c72ea0ba8d96a31a16666485fe327a799b46bf456643451b5a3f615a8a20553d9332b1d4470a20af16d3698943cf48f18ac34383db298fffbc291e7839bc38f2c8a63b9e4dbfb3598a5b23c0afeb67ea6cbc1efdf56c84080af24506f469a0fb37b13694074b2a17d036c47164fef205504f24be6981a329675b33645ede9fd13213ed8d80f76892c05183618b4eb07cee89223b20bf43a1f906fdf87a9bb0d68ef9054070eefe67d6188a1c88a9e2e092c786ba50aba9a8007f24b25b3023bc210d7691020b3a7e4f3aa526d1d9021f1c76462a8cb437005b7b5d2ff78685ff13103dd15f43223fda91c7a60d1e18289d88876aa85ec7efea205400b86074d7287109f729ae13103ded93adde6fe5f8776649b62ec042602bf12fe41960aee95a687db8faf4cc024326e3f190c5e3fb7d98797be6009d155a2ee380804b4bc56bd6dc11fd8678eb6ee9a793e7c86d6448faa2b8494075c6bef20169c2a2f0129b402ef4f583cc44470adde0ea98f56ffe2bed6239babc5bfd7d00767f85d5d1eebebce2a3e842cf78bf0b20a5ce5504f5370d2314bd12d4dfe32c54db45acd13aab007a8ae27631417dc9408716d2fb13883e22705e14309ec42052176fb3d66c2a34fa436490c9186a11f11dc26374cdfcf924bc4b4606033020289cd673b694f11a8b0ea0d1dac473461e1d2e09e19aba52e9807d971d0dcaf750911bc1c291e9a2a37f43649d8cf463bad724603eb2121e342fc70dd84228e6280059b15a365ee7e0c4e607ba81f85fc3edd8c774a9b8a35a5e8feda7cac4125f150d701a520411e10d3845c22d6b1dc8a07a2b828fc2d6b15df1a5de1c8865c2d7c8a9edf4db72d93a3183f8964eda676eaa5d7d058b7514e14a7909bf1b6cf460ac1bf91ea64d4021f77295116f7861a3f644e9347f0336f836e313801d6474ef9a11c4827ff9605866eec0d500fa98ca304d1dba240ed4c04014c4ad69eff00d8d3c583db556fbd77f911fd4a6c388fd9f6aeb3edb972dff59422891844d8b2cf73d375691403d443b7bc2a8a06e69a43e388246ffa3723b28cd8a254ac3cc41b0b27cf6d1a80b69c2afaff6d46411f89394c40534b88761c60a4ae832e980e96f4a343df286ca057f3c93bcd1128022583224fbf4e4e08bb9eefa79ad66f41e89abe18da0df2479f71adcad268a22e331b6c1581b3fe00c8ff6ab116cfca3ac6d2f2f735855738cbaa64d02b88afb0bec49b5028b8eee9ddb3fd92cac378d3cde29f5a712cca1df3a747be7771d9f685f7b1c2efc9b371a5f8cfd5e0a0ac343f40e432714485e93e505318841ea423a02a12003d2c18633c6cebde8e06479e515e8747c899378b471c10cfd2819adf170aab6e9bb05edba0671739b27a0284a26cab90f80716c0fa7987407d5f8bcf2545893610d25f59b543a10fda28377eb5100ffab4f812b6723f35f9adc95d49fe167e025bae606377e2432a56dae012c22160d750c8f5cc5b82c8cffc10204b5742a816bae3dba33d0adfc8369977904e7d354825c13eff817ccd9e836d3913698c0bdc4363fddb44758d57c5517c14e69b82540dc5d4328fc9c08b6351c4a7f04e9e00fe6061f4b27bf0335db2324169c595348b66686f1ec36e5ad4e684ad313d5d9c9ad1aeb61c5dca70bb1283718c09a14e96abb4456459270f27763797ed2194492406a32e5089d2c066daa1674107d2cad70b1f5fc84fd9191522643dcb14595430275c2268568e643fc3ff5eb313384f5ddd4ec61c73079da71973d467bac77cf237bb1a2b828e7938ed3ceae6bdddab9d807c4277cb751bbe36cc70e38e6026655f1a23252140c6534574931d716a7116fa2adabb78c24eb23d0efe59a5ffa2696c8b2822d1ce19a62e9047972a299995d7c10fef1a625b43fbcdc6d8ac72036dd6a3b3634828c7106bcc8a7f290f9a1cec721cbe38dd2f2d5e578ddb98c960c650263e1829d8885870f312939f8169d35517b6a9321692471e247ccab8118143782433dc249efceec502361688861e8461d2af6644d6d73c06b86c943440439c05e5ef22097757366705ebd9430507ce4d3ce2b906b49cdd09324d1439e190294fcabcd71213e9e2efe062a84bab9855348e1cdddd5e128e8654acf7d16ab7adf594eec84985e996b3c0e99d0fd55c6b8966ba0ae6682eb240a3660f69d985ec01cb211c4760c9514d36f702b0ab3b5f72f92c8021aaf87ff8f0a53e021b4aabf97219ccba1ad4b0e44538633dd1896fd0cfa4a18e9300c6e39eddae7a7b59cd52ede9d9c416eac44d1765af8914c675eda8da96afe349328d9a729df5bdd2777b67af551750a871fedc64c9933262e67881f658c1798cd14b80cf7b4cecf6a20ebb872c3b39203f45bb3937b7b8c664ccc5f85f70380e6315460bf4c157426c9389e4e93cbc2d6d71d86bb9001ed0cb3f227e9b7c75e4143a3e8dc237ea10aa0a4f2db4cc2a6d508c98efdd242bfadcb09a1b97e997b280bdea33d8e7ed7776d45ac90e0e1b4700e0100717b4d57e389318c30177b49dccbfea9015d9d040d72c469468d5036e73b107c9f82da034a117479396995acc429cd083996dc891d094dfde9a84b751e65c23ef889ef61ff0489ebd8698bb0a606a70a8bf1a0417c6092575da1cbaf2bc13265055409d0ba5e599d0087a1952832f269f0749c9f00bb35d05dd8c44945037a41498a65a5e81762f2a40096653fdefe9d6080808145b92de334e48e302a4de7dd47871c4f55563d23268dbc445672487b0c50494fe2b1162e902d1f1ca22497e68057e565446f8ad48430276fa6c734056989c8061723178f65fa68a2b397ab6b4dadca1d46b31deb3181f7750a2ada7410960da1ca76d0a4e6f7bc5d6708d4f4128ba906421e42d672e472749acbfeda109c945d7af03db7f7a6ea3ba21b6a0b3f5350ad02f182d7b3c2ff358baf94702ade336aac171b5662e2252d043bfef7076cf540af4a81fb9003b8bee216f6697179c2a3cdb0896e886703e499fd25209c558d79f51d201aff3e2b0b980ddd831a5a8a2874af78f33815061bef41c9aaa7515d2845b7384600ace5552d7904915e31202d9e8524377f206640368b2555aca834476ddc491cac3706d9a3a7d63ff088efbef1f9103c9bc3327f78fe85f69fbaa007a289cc87e63836b1fb880f65b3d10af1909f2852d8dd0b6ba7a827a193ae5bfd54f0fd260cfd8c0f5f63b0c0b7e3612e379a3f3cd324993270945b6c7af47d7b6f227ebde424dc27ab4167fd7b42ff65b41b442ca8001c15ed9c1b822feb25d1df6e8e9ae426394d527fd1d12af77e96bd3ebbb71aa37f9a7ad7dfa292e18c51c97530aa04c05b2036135251107a4d1a8b64eeae8963c7af90d7e778614bc61854caa772f83fc61d188586a84acbbee365b6a9edddd209da93817336a21f0330921e147a504cf696dadc060dcc768df2768e45a9dffd31a2f5f13996ffeed78ac53d29ef601b32a9cdc36b1e49f44ffbf92d20a1a52f349c6c4d90a83edac61977dfbdadb1fc66cd40c225ecc0d5e5d1df2cd75cb0fae041c7141afdaf26d4eea05104eac46b2c1e4c45673972a165a151ba700d4190a6d5a1957ac95ecc703696335384ebea967aea7c846c9c5ca3ec6e7f240943edc91c1750c3903e44a64b8db4ec385816637286b4304f4e30015436649356887436838a1b3d1b0ca6dfa18c958e275edd3bd0c073080ab7ba20a43ad6fef1d90fead8c6946a90f79d43d25c681b2b822c7af5144cacedc8c8b710701753bb25e09a412cf359f7e5f14dd3780a2fc7b1aeede08d04f236a3ac964c831cc090e468f1a5b1073410fedbba415e293f4719bdaa3303100e1cc5a6ce66065fcd59e0d6064be94e8b98873d715158418e84bb901953d79e0e6b21fef5ae1019498edc3e16251d692c249eda74af2ad1da2489dcaba1df2624a61f50f27b9bcc8fa1665658c33a4b84412d7ff3d41faab6b831193972b530132cfce1cea549ef3059e29db2bd44aa8921e29d1595a4b0f9df69ec7905d19bc519bd75bfe6bfb34800cd2961794367e2d4a6b26dcd20a4b53ce2252cdffb66e110ebdfe1d22af53592b6a8999e0dca5b6e1c9c5e1e540b1d67d5aba56378eceb2b16d1b18d6f66f137cb99eaed179be35369bf07cd3932246f9832eba9e8430005ab01352ebed933a4f7a2da13851925c2067c32669aea0125cbc769749cce1eee3991781ae1af1c6cf65f0ca475050cb634ee143014769e0d9f8e181a22da48b29ef3a8b90b51f410f62b8f573fb3f99091b1ac67a5932ffc9ae801e1621473fdd1eb86e20eb4a48ea3c818101c21f1c202d1fc12de81c67dd84e7c142c5ece46a17d635fa4c1a24a20d58a4788ab8db23cc2802732367eefff564343f5919aa23748712d7920932d5bf46bd6ea076be7717317e9bdad211cbcdabac99a1fc88af88fb02fdb2ae4d385136699d103f39ab6bc16ff0f132802c589a69cbfd15b521742cf67c7212123b95df0a1fe47b94991a232620bdfbff7e3268a4c5875030f5129c4a510aa5319b2928b879e3b6f106824bd806e9fd133339a2f20d4ffa59f7a040d0023410c87569afce7adc72b4307f9546dcfa710fa999a44ebaff497e9d6f32be7ec42aea327a081471960764d8d3d09b806a313fd85689296643680e9b75a9239256b0525ac28acb207e11ef6523aaa36df1e1002da4c43c86cc4f4e650fcf91c2d2f88f7586b6977229e3c0bd0cbfb8f653b8487706e67caeba9d0a32f26ff4f1e6d34055416c49a956e48c8d9a898c5128ffbbe097149f4bf43279924981626c9e1243c36465576b282657155be6b2e3c5e0234895f388980260c356b8ede952168506466558f97165d94e4063216d607ac581d9cdfe5b84f87b00a845b72899be14f16c0b9ce94292f65e950341bc3624db1359cb751d7b0239f4d3bb28218041f85a3703d25999ce2c077b866201895c0a0553b7948f4f7814c0fd6f327563cc06b13657dc54e7a7f2ea59b0e2ab1248a5913d4842ba2592ed8bb00b3bab361d66bef92f00f1b2688a88293699b3d3bd4b93e681642809d585038b85f8ca1c62cb6651adbb3b6d83d742547f23ed520f4c6e79f2ba6ee21431f7ec9835eee480369c037f09e7c0cad86ea0f9bab4853d8b672e8b249767e6a178cd5dd92fadc1c54d2b999d4c4463597e9f829cdc059eaec05a483071c009a6afa4341da534729b3e4e1512b975f839a29e186a196f398fad4b24d5b3864223d330673e541cd7096323caa46a9f7897c5559a2ae5ffa96de1cd12a354d94bbaf1d0994b7c0730c544642e2c73730d3bb4a69cf0ba13fc4aaf774faa5bdf496f5e9ad256cdd3171dd3875ec283864cfe5be2a35e738eb64ffffb25e0b8ff5b0fb0849719bb2e2bf7e991f9a233ed958ef7d92c8af08e9f4f2b80c8d54b7cf7e9bd79f0f1733b5a3f70b97d76f6aa84aeadc336bd0b7e5c7c5c0679ebc6ff0f9457c99943db5bbcd45c41fdd21f8fcae1549c99b63552cbc5b66e03cca2eb4f63665f61824b94ef2e9d2dd070fd54f7e8f0c912b892a8f77dbd3983ddd92b48cd2bd4ad0dc25968e9b5e86e022952925109799aeb47ddd3319d389d697b72ebebde0d450434469e03ac580df1a6b95d95c8fa67c3698040987be415f1f3f516bd43b4abe426a6c980284fc27fbe00cfdef156820fc5e8704a2d66d2f4ece540544b126174b938d8cbf96929fa2b1c5727515852d15b7a67a2c84a9de166917c7ff138bcda0f7ac9abc5a7624086eafa38e1c10aaea154cdc26293892650844f50a494ec827c7888fd93244e8ec6a94e45e55c234a97d323a8ed610db7bbd7a78bf668c953b81edbd6a8611f0da6aaed6b76bd235e468b7d3bc4ec1cb4a92361d322f3a0f0c94e2e39fce30ef44cb6c5716d8cc9b1398c47caf2050196fdba85609f10a15e8ed60e63df020a3894325c8afd347d878691ca9a810c32c783367a309c7731a0edd78c68a138497584a30ca821adbf32dd79c1016436f598094a844b3add699a227cf5771c3b8ddfe5d4f1f84e5890109811a258e642c3498ceee39c396683bc3b12f0a097c3057c1b17b3765ca8ab95d6c99d74d4eb7201f0b761928f3ca60eaaea151ead476b5a32b2aabe7323eb6c44de9a2f94af2e7a6313575280c77c6ae4db410ca061d3ed6b7fcd0f980cdfca5cfc61bb77dc604a183c5ea0f4b9d497bd079d16df0aa71db1a0ab2fcbee435c0d51f734d592e8c7b102db2f5c0c63332d7934e1bc954b54932bfd47d157a04f56abd79eaf317d0c3b3665bbd3e4f934da7ef4746d8339ff6fe68a5264357481ddc7edea1d9ebc38cf2d362e1af68863fa67d667195e45d1114da8cb6063133e2e5d3276c298f88c192a6dc01805e55fda22dfd70a59cecbcc6bccd0de8071e36d38387b79d7ec3dd4871c32fc0f4b190ecba8b8e9fbe2a2be59f70b8fb9d5cad1019dcc15a51be53fa43296c0eb894f7afc755608f95e6028b377f93e2c9e4ab12b06eede4adbb58e0395c9c6e2d5fe55bb7f760d9435759237a09980f3dbaf59f9c0513f62cf12d1ccbf8a943e4acfd722abd652bce9881120e68cb045e1c31e4b5916c3bf0c8115716b7366f714c1cf43677866df212406bdff9eadbe93c588f0550ff08253ba6c5bb1bdff98f81b676d515da80b72c74d0c8beb0814d96a41fe6a95f2accf9c1bf35e0c90a94432dffe83ab7afa4f08dffa69a2819f370bbbd260d7f1e170f16f78f36c85ba54cb9bdefc10e3315d21810661159aef344809147eeb2bebe33f7d877fe2f2b684169c4a0cb3647a78178e8343bda9da1b18ea904860f0e54f70906f98540a61aa8842053f3362281902dbbb9b8d2d22f37de28acf6f822de6204d0b72454f7af901d16c80592d54eeaf5a84db5b58c89ddd3bf94aae5f237245a3c862959be407ec84673d081d74512b77a7ad9c26f87e09f99b7ffc9b9810f8b3cf97d275cf0a32758d5649e47fca49a153b78d2229fde1f55e1d3f711b1c71d7653cbf423ade257dd7b3f792d7f0676e8fd2a6e967a2d98e9b0837116f58180258a97bd7454d16c7028325daa91e04d01faca03d081dbdb1925415b91dbec370341b47d98092863df81a75887a79b2bff3ec213605555e7c8d022d2ee2928cd03b1268040c37428afbb49f4db90864a26aba15aec6006977ecd3727b342293b04cb5b4457f99d0a952902f4113f0eaa52088b3dec64b5788c450103a4155d8624ca994c4468753d12163c4f6a5935b5d84c71fa528eb8a5dd6306f1c9be1eb18aac94d54593475e65ac84dc208fdbf2cafde1d8ea09246776a65cb4f8e5dd820072354938fa28c3a263dc26925b4914faedd9f0b565a99d99a1c741dbda22e1ade13f2ddba8e5a2e9554c553e7f3cdada61390c21cdbeeb3baaa3bc555468be0e50df4591686249b33a29bd1a9a93bcbe598289e5b2d5cae93c52827de70b7dc4f5ecc55c8b719e4ba44e9a9d62f5cea1ee2b08c4d26b547a1cbd75223ce274cf6cf61b2801e63c6a580adfd0b96ab73fb610705ac39991ce8026e0924b82787763a73bf3858484b0f498c4b5197a13b78d8b80a0c4b804aab057beb9f1e1c98bc7be42ca29f45fe6f5fe00ed90000d422d82de5e61e56f35e47fd8188d5eeffcdb9f0a262bee9e2eb362d4639f1b5899c2ffeb706b85c732d97da562074bcafb2f2f28bb9408df35004c5dcc3e757af5539853ca6fb6de8dcd1d3ea955d9af2d373217e3293500ce03c587a77cbf09bfa09b5c98958a9b28892471d07f4edf5a1f0ca9013b4c6b30f11f90f7aee5e879e19c223f97c2b8d7cda7643922c69b621101ae5d926c6b1b8668e44310c52cf6bb1044699f7c53f78b460a316521ef55fbb6d8ac586e288f1bc73ac55bc6ee4710d094001a29e9f6fa5d593720cc67083fff52e2a17db43911b082ffc639a9626265e9f6abfda85a3ac437bb125997cc05ead811a5fc1bcc9292a32e4e01b2ebb0bceb7cb8c93d491457a3a0657c637eb06dfb20f72af325a5cb283742b9a0bea05d7fca46488be2e2830203979a5f2a6d29f4b0a5ef7dd272ff66359802bf62aa779686af1d594a63e652d43a20e1027336c765a2035c5d14c1f40fef76a41a9653abacc072a0dea0395bfe7a5796703e4fd973b6bd5ef1978ea4150658ce96b33735af41f2a0e14384e4f110a5b2f5633b1bbe1a1a4b1515ef9ba3c6815cac14a3004a4feddac9b2f41437143b9d20c5458ed2b6df21892c7e02e1006a13deedeaa24407ed3b21bf092024986b0200972f6e17b0de43cd33711d91a6cb6f28c4e54ab487eca9a3f19c9198e8803dd4bee4b60347d6b7aef73291bb26b4e9f67ad5d7708c7d8573ff2752a9bac732fc405d27d613a1231c7973f2e357d629c33a1367b0c1692976aea4aa00417c70ea9c502f4ea7c002039881607283546485df0d900922b4760c5018ebad5483a0e35bcd043d3242b953e94267e14cb0559a0a19317c4baeec3cfdb5f825589444d73492a39ab378f8d942fac877e911c6d2f9949c8c60c79d326c5c642052a5e6bd950ea9b5ac88a0a723434931b93b31077d6244a49e6ee62aaa216fd6d5d80314aabefb855cb40efae8dcf872deeb2c7e3f13a3d3e1af00822627c0a9bd74d03913c7ae3253f30699a02f4e9e8f3ab9ac0c60ff234871acb29a54c22b9fc7e1b086fc7a734146e2e6240d4d9d53fb75d4dbb45eeed5f6bb08aec38b6b71556a90e1c9739524182088225159e0617f5b02f19fd92023674004f7c22c94e11ce97b0743c8a1917a82943ac730b286c324fa57377b915f727d0e20057bada7b12d16ee33314df03ec79b9280ca9a25dbc9a17ded80d6a541b54da87739fbad7b45023e3ab12e65a0e991d82142f4f5016dac5a7659a9f2539c8408d9144fea11aaee3ddf4ce9c372c557cc1c89964491fc41ba720085ae30a4dea7c93ba4eb87336f4e70930aade3c05b56a65f704d8c9c2d58744a76302497f72382a785d328cf54cf7576c7c255490c958083adcaee7727bee6f775e8962effed28ad7e841d993864f1053fcc1fcff7913811b7292cfb11d9420a783adcc45c393a315e0308168fae86f78ba21f1e7d78e2ae1ec11a7c1c46848655d0d6e6ff8c1a65945091064570ed9726bb95d85dc109266f27b9d89efc28eed0b670cd1b335c6cd9b2f20d969c41a297d74393bbac2ecce8bb70bc80c5da3d878d9830f7518cd1faa90983b5dee55cc759b8eb5ebdb224a40f74608d6c7964ab1bd3a884333ca03a5e1a21ce45dc812923309850a653cf528bffe907255430849653bea59b768edcd78ad1fd6656a691c576859af9c4e3ac417b2cb3ef25d83a41660f19ff358224e9c33572e0db7d3473ea639c29b9dbf1d2794bc64e980027eaff755de55b7f81385b0b3426daaa043132e70881cdcd2c06a1698dbdc2c341d26f3a736009b5cc43e55702aeca9193b2448e987c3ca7604eef4cd4c79364da92fc04848af0be30f33b5ac23c52dba72128a3851f763d994ec0455626a8cbbbf265b85d1538d7fe42d63bd27c2a526b75af2e7e6207851a625af5cc187a7f99452c911185a2a5c122f6fa564b85c81b54bc517d12376f8a5a8794239aea9ad0ea6fde1eefefcfe951111c27f39decc7cd3d1fd857a3dabab81f46e8cd25464d4a23cc4c7da0565d7481d60e9b79e615b062cc85ca3148b5b1b4b0f9282dac906a75cfaef941f12b492b889d8ce8b1ee84f4c65bacb885aa2066a61ceb4f64ce63611ea4ad3842edd410c1a0b09ebfe1aa0bf5e4866847e2a4318ade96d25a9bf13531f238ae2fe0ebb036be0adddf261dc6786b6f5f5b38afff8f608fa1bf3154327049132c7fee2b93456b10d3d11ac5d0e19d3662e9d5eee1d12a8b1a2ee43454d79657c4077bda9735f9d156558e5611f0509f212750af05e2a7a051334ddfc251b1176849ac410309796690ec823a167094eb889280d5fa537ed6bc86d797b201172f4f22a3d2c53f1047f8c7e12d9365faea2118fef9e622372aa46d9a7361f7354b5d135d56c5e35e97e5128abbd6aacbffd3a00eaacdc5bd3a1d4df87da7aefc13379637764151c4fab4cd4e049cddc7394a0e6aedb91f00b430601f15aca91651295a75746ef00d4855c5b6a6c79ed11ddd80568178867a24731961dbc87c40d43a1c5b7d3f7d8b09cb1185bb66c4c9680edbe23255a55ea86f130f2e60befa9c9fb339a0a5022111ba5795ba9d97491351b15d940744bb9095088eb665672cd42435d31a1f1734539d9042770df43074ef908791beb3a09a07c51506b1b27c7811f79f8875365f692d47f1196fed9fbc91c428fb8d8b7c6dcd51987accf7aceec74803f7bed100e75acf3145150a0e930039a4b0456c749fffd51243cee8d9585235d18c6d4060f97328dd87ee2d863d4a71f0d61d10279a539ea9fa87fc01f46c5b50b68963d1405bbc20882c51857925b414a0a5ec96975dc730c5472ab020d759db057d9fa8ef6bf7d0e5591732507cef95cd733d2e3d8045ae2ecb57bd776e43c061393a5c196e7a9640cce967d0f73adc2dc1210ff9b53e798ec9cabf708069b934d234b70bb298d8d14e0a81b1fef4855a5a175b364b4e09ecdf110e2cc2b290a6e23ac09e487736916e7eb69a6e7b4bc182b12d5d78e4e1fe649743b88c0cfff34a66d610abefc29dbc6e46019d410c02a44861e59dec25c8996cddf58fe7415f3cdd5e6d2847a6d33c190132f9d2f80aa4d01bea6929ab7eaff662532441d746bfcc0fec1e218fb38188cba4939b3f3a8badc5656e196abc6240da439b4ac1d76077b1a184127513d72c9efefe6a9fc9d9cc8711abdd502f1791a09a580e510f5365893748d623cdc61f97d0936994f8645e852c9f284d4f779c83811c8d1c843325e0b0c533a9315e67660427dcf8761a0a29e7116fb3d390e1b5d9dcadca882457b5ab2eac112df179eec97dd77606bd64c0daa8cd6ffbe443e669c5ba4421dd72492beb40bba6ac409b4566059a1df241e19e1bb72eee243fc6fef88b7012e348752bcf4e49c2575c9daa8139d9d732060361cb75124d0b6d2234ad7ac573a363922a52624d35eb54198ad615a8094ecfa1da0c05fb2c6aac3a528d33b0830ddaf56744e603c694d4554993da44f9472b2f68e0d5536fea0124295b09afc6ab00de73f2647f9039e17169bcb6c847507edc6a1f817168506cf210345cef14bfb3862bb91ec938f6d00e2e2949ca14e07ee5b4bc6f0af2cddeb33140a98c4987cc65b2a8d66e39f282ad37fd0e0f550673519d7d7982cecfe49023ca180275087baa5d1b52c6c945dcf79d885fa1e517238911e282d8b523f93dbdb26fb0091f3accfb0f0284a99100ba15c31e124c8f6c0002af9f225d7d25c0749d8cc1de57f116a42fa81865323504771de65e3962afbc7448bf13600c0b77769b62adb2a0da16372594610a3861d7e164674e606a70c9820e68fd1306cb126ef7f44b91fbf532113e717ffd7183feb6f30c1929f18df612b288e6dcd866c8e40f3aa4d0e2defd250c5a8dc40ee50aa46d7bab866ef566ad3f3bf0911ec2acd0b254147d2638e420a59147acb448da9cfbda7e187c5f5f3a59d3abea0f751bb5a90b1c934dfaac08c990c87b596a1db54f537172b78b6a0fb2d5fe9c0f4f87e1b5c9aa798c36f2fca17a05b72b0a79e9a1ef47b234be1ae1465d759cc9e17458488079434389b931c83cac89363d0ffc94a240f7d809bd4b2eff3301b90e1ef81024183be36a4c9cc2531f964d1b227999b9c39e5465322990913ba93f18110252593b0edd84c7bf07123f76972d9e99cba51e8d64d9b1d40ff1ca3031e559001cca0432ccc5d06c78afe414390b2b2ba80c3e3136ec1eb4034638179939caeaf3cf19b1333fdc061f21159bb61b8c44bf8e12504481abb7af1bdc2ebe33b8cbf777ce400913b40ef56d24e24d012d4304d8094dce03f3f8004f638d3c89da59816860a65fcfd46645119e2ef5aa76a744ad43e0c6b3f83de89b2a1affafa4d4b15b3f465c970d12516329b0cb075e0686c87979f0c13d17d6e4a1e6753cbe9c4f5059b7981cd34fdc697b8d31648a6be06dfc67832e87b6f452d3f82373297c69a8049d921abe0a192e5ddbaeb6c85bcd69eb8cdf2cc9a9efa667fa8c6001cb2ea7f1537639185d80e772a9afef06ce168eac5e34a1e6f6c764c1cdde5d056e1ab61c5c4ad10fe0e33acdfdffb9b28ed7b5915099e305ee21029c32a936c4284849c79e1e2b3aeb48a27948c9fe7792c8bab6e2a8eefdb91cbee29767c631908075e187459c80f4eea552fda0a7b66fb548583e116f7cfdb15372ef87da783a844faeb81c1a256af7bbfd195921cde720043e26b1d5b92ab21bdb6fdb64f9d5597342b046e4e06c023660b0800840fc7d089e35d5f5f6cdeae4be9b8e2465985009a782e318b83ae3d9435936b07374118dba9a62ba468bce7a280830be82265fc8c3d58bb8254aa0709faa1960e8dd75a8524e74d5a78f26104226871e489ac54af8a557864965a15af05148785cbe5736f9a27b064b32610464c6dcbd9926cc3e23cf7313b46b95950fc960e9b0f7cbb6241606f72d5cada0f5696019623057faa8d6ef5ab69ba1dabf6d81ee5c1b49f1ead64a248fc79243ba56dabb472d5f73e80cf399edb3d36657245d176f4367c5c55ba0789b3a28bf3cf119e4fc5da30e9ccd7a243f73aa43a915db2106a6879f2d62e5061343257ce5eee643ccba8152d0e6f5105da6e080acb76852534f1ec3d9c8936ecf73a9246f790aea9b0eb4fe39dc70bbe58650a44ef8e6b193386c2bed9322ce15d7d9dc3ea73348995ce5e824f909bd1f224e85b1661dd2b2308bb5b7d87d8661ab9774da79358f089068fc96d07c2fe7eaf7c07b3700cdf3737bc5a36194d1777cfb3bc8dd51dce1459d83aacaead4ef52c8dc47d1fbc9a5af081cc0cac8ea34f4ce76cbbba6ae7642cb4fd37d97c39b93d99b3fdbd9a01f3ee57116b94e9b73b50a93dc9d1b8e4337657728808547a18e717a262c9c80ccbb9c490ced2a1cf190160b8d94408ea38ec6fdf3cf522f8442071269da6dbafaa4974f9edc4c0052754e50896e49617e7a7dee349a9cb9851809340417b5eea789439fab2379442a0a0b7130d86429acfb4e3e0c3047abc53a73825c6a169a6ea8ad125b0e6c4838c9bf74377e398ddd0f5f395dd5737c75d5a27b3e172fa003615cfd25b7974b01da1d26e489030c3364088ddfbb99a73bf37eb8bf81068b5f6ff4f5c04954fa5b12ccf13aa44bb4e1d62657fe353723c7cb4c9c85aa8e4888c270d4465b40905d327e9002140d2d3a51e7698640d49df8fafef16269fed7633c1560ada9b1ffd132cb6818b9eb3df40c704d153ecfb985d751fc036efaee17536ed2d6b08a08da5d6c5ed3dc3af4a294674bbb8728fae3bd58414e8447abad532210010bc27c15513629bf920217946bced11f43b2094cb85796c06d805039091620078869a7e18e88dcc9040d14d7aede41fe7bd567160ea7bfc152ffc4bbdbc27d67f250d5fb5128925cc5ba92d79e966cafab0470551917452109a8b4447f0b2caa1abc43ad2ab9f5483949844532770c22df7e41d1f4f7d5f20f50c10eecb2bd369f82e89f66ff04d4ca3d0f8fbbb5614bb990b8d72e4417845c7d1f3913e6add7d63b376c7d73f887a06074ef2131edc2f869135f9709c5dddcd4a4ca72fcde3f9cdb2dc65a2e664f87c78417a2f2ad18e56d866b242a4d08a1153b1060e1dc2b05d15418241a124a1e6eaafb2c0fe60330e3df6fa3c52ea85e6ad6e5b9fa25f6f15ce343e9b91bedf9ae5c8d8948ac32d86a3a3a1173832912e7e3cd981fe323a45aef1249dae8ae8a3f641c42cd10b0efa9cfbd5751bddadaa8dbfb0168675fe116fe2e4084d538a80c60d13046d3df7d7e8555171eeb4780a3ec72050c7a55c7afb2a15f2203f02283780828616f66f72970694f47ff998106b368379857dcd67da1ba375eeeae028917663dbe661bca720a127da22558e0d0a8a9e792d17f5202e5c61bd1562e4ab567aebf999ec4ccda2c168829a7722eddb1c004b2ce5e76ce92d36f4123ebbb3c09c5301a744194d3f9be6809ea3ee3fed1f56bd493f7037158c0f5a9c8a4a792df5cf0319235f850eacbadb8d42b5d3d773f0f0b121b493e18c28dac1e9f0282076d968f8a0cd58dc0bef5c9f924cc63a1f08803d898863f16d3eac48b811864863533809675be6127dddef652a6a1972b3cc9bd0b4a6aabce610ea6b9f30d68333ea4d85b7ad046530b376ff0551b5b5fac7388d935f3a704032175730607460e6af6598fb16742d1646e64f4281b110197ff9b1cfcdd87a5774423ed0497ea5893422e9daad9711a59edb2fe1e5a502089c241ddb87ccec5332244c936e8919355e6c47c258f47654cf2224fba9570ab58fe39665b2c3975d9c528a7e653f1a4b94876da3432557d211abba40589171b562737d0a9e8e9054c95a1dd7e100ea8e89315b52a6c89425ad78f548f121cf6ab5a07eed7732d467e7851fcb7aae98dc57d709a35af34656cf98ace8313ab1a9ffd4564af1ac44bf3c06a31f9cad14230a182772294b3f2a419f2e81b7270c1ea8ba0952b25205377921a1b8d936839e03131fc92224bd4ff9a51c596b5a4a9597ebc93628689101b18768c15ee07cf0a199e69ec2e341942070e67db9608857826af7f9a11519cd5161cc74a6fb5132684a3ce513163548458f38b1369f01fbb67c75f53e7a58b3e620aea6919f559dece7d0808d893e868ce25b9c0d38438f51c1b4f45934a7d51d6ff1bb0a592eebe4e47a8fd2a1644b6618c6faca17305dbbcfc7cc2e1d841c7e64dcd0c6b258cbddc0e41adc33edf12bd23de3b3945ab76d40655788b3ea953e4ad7bdda1512d47b5349bc41beec8f231a660652d90ca23b6f594e780dbf0e73961c62975a180737afaf16cee4c89c01c94b89da45a01caf9f0ac405c66f384762797c4f071b170a328bab479fd79a274f09c58f38ff3bb68d1f03ca2f0de2746d787f234457dee304bbbda9a4401b48cba49a2fad7f672360995a36f164a484ac80c56ff05353527d563ec461ca911826395e7680fd31c2a5d57f180221658ba6a061fc8e80dc9f64c54bcdec148aff83d7d06322b24ef53d276f2e8f47c11f3286340b49f11339af8c4071b5cb6e494c54ae89748e83fbf61d9c8034d483714bb285e5ef6b01b243bd8c3f66358006d3fa571dd6c9a2c540452ee2f601a137151fdff053fe49041738209ae39e6ce677189723150d136e6597aeb2c5fff396f41dddf2fe6b3ca6f23e2ce9cb86aafabf25e03544d7b41c5413c4f6ef1160734a01ce46bef5dd18401f0b0e4a6d7913233fe35eb02f5d10a42b6913f25acd4caad19611ff2213a16b00f3dfd4d2568dab8ae3e4f2cbace78468bb9241619aa949716607ab79209a42b8bf2227ea1a3214a106ba487cd8c9ac65137c5d84b87fc3909d172af2dac390ca28072578da8bf0ab68ec6b7863c3aa990c42dc294f8c2ca99bbaf9a1bf0421667a71d31e7970b96221475af99d764e24e667574588437df0760dd63ea6a03164f8ad7ae6c913f75c6cc9346a466d84985bdccb9691a22f3bb90c7cfa1511333463d6e672c6f82df782b2da08f9a3bf7385ca741ba7591051e359c3c4ec1e520215787a2f6db8203155a2e7164d18a19ef1a1071be8f56c1109aa48494261f0269c0fd6279c7c95dec26da8b192ceeb742036759f6d98c2abbfb5ecc74c185470354f55af133a50a8ea5b3743536d742a9f543521238591df6712f22f4f0869668f22dc7d1178e15b38fa929ee4f218a55babd77981a33988521afb5591452d878174804d7408ae322557d0ac09053749f75a25a2b746da0c127149e2373b712998e8ab9db0e239192748be08eec0ad24558f1ac3a27532283578087e97f1426dc9e02eca14b3fad3f2e371741b435b37c9d5a6f2ade174e4ab2365e278184a473704ae0a27aa76c499732162a3c45d4032a81cc513407fa7ad57c62669284966c222ded61be5a8206054f58bd8671877edf144b964e678003a82430f9e3cc72bed4f1d6f95279bb58d202b37520becbe9d53b5df8669cd917f623542b78655185b67078408481756cc29a0c0080f7b6b0ca7428c06b90117f9978f4f0a14b4b0a1549ff1d4d4169e2214c3db1b7e23de7601af19fc13dc5393b2185949a61fcc2304a6b49bfb690e255ce6e6c4d327fbc32d064587ced747dc8ff1191bac86a6e9bfb03dce1ac0bc12d5315abbe3bd18a1e7b8e84d0f9c4ab14821aa3340b378a0a0fd9362c23a63186558c5976f8261b998b6be1baf56cfbf7db358e28067e0637de7a6fc31d1f1d8dbaf1f5f96a3e886f74192375da550a334e642e4254e3e48927739106dbea7520bd6bc581d83295825ba4e542be5b3c1f8f66210b9b188fcaf119d9b2d662e7884cf000ba2558ba0e4bbcc7d49f7d5a419bfe58f58b4fcdcc1d992f339bef21890f1c837ebc4e378b3e1b7e51c64e59dfc24ac59764eabf2af4f5534e11eac143aba8c0e877f8ab1f733da627ce015eec9eb8ec043ce6698c705ded4075c988012a1d642d7e08208e24468a818e4cae4ae6d3b4e8d9525bbfad57f30a40c6250a749fac793f370ac89a1a9c9ae154bfc64d38c84781d0b86d3361abce1f8afae5d6f18e8399ba7fbabc7fa45908ec9d39c3df11d980c05805abc35343eb5a76633dd28a86eb8a219163062facd9dc3403fc25c33cbf847017b69f0ff7dd275a338ea9f366c72cfdb2ad2180c236ef6092d800f2aa5d0ee212894a9c892d4ae4d259b67a2ed35a46a51b05361ede39b3d5ae960b6b9c69ea7176c54e295660fa6858c956a2c4d308c837db888d9a99dc40c1519d034fbed652d6fa1e8ef62ec8ee2ce420a60e0f4c4bfecb082a794428ace9d73c1fc969149418cbc6cb0374ee00f567056cd2b2d858126c11ee02635fc59cb0f6f720f50fb10ebdce920bb7e90555ec3702c8f5ce229898fcd161a18a0c2b9de725167de41c9f3013d56e1de5f0965404b2fd2344be5cdb5b1605966d976d2c671b3747e5fbd2c631b4a802ea313706a6399f97daa3c551af74939543bdf3d9b5b8af7c10cf8bd07548ad0468733c30d4051180c4c70b5e336cac4c26df3255ffd0e6621eca5b0f73c608ab7a45369cb66e7402336005c2ee4e0cab3f956c9962c5f16f20ffb281fc7cf9b0ac91ad570a0091ed85de15969ee1c01c6807102aed360e54fa7e9e9cabdbe532de76de1479d22a631ffa0cb2635af45a0f0fd5fc16126e3e93d58a77f203fd87d1cd914814ea0ef53eb9a5d2ba303074009fb3b9b6122442d62feefacc97b56eb861ed35a6541e1dc3f628ec07d0835f5da74e0c11af5329cecfc48d653e475c316c42f6c019dea2442e3fce8dd38f164c1cc633102341572dab481cc727a8a7ebb460e7a9d5bf0109ad307c40e053ace49ce116bb47ed6376123bab41269ea77f16956dfe037132e05da0cc13f82839d98c592f34a7086321803666fc6cacaf1a0a6528f82ce5771da2715e776db546ecd355d1cfa8edf388c0715f358eb14147cc86ae6d0a49fe3bb9a5cfeb40b74da234ff26be2eed19974f4adcf466bd99ebe2ad1fdce71459b1d8a35b746514c319408cb5d28a85fb50e6fe487b55d9ddb7de2b18b8c265485c33616dea9c41950b1fd6c72ac7ba98cc976f883a37cf93a50c4c123f3a339f007c298390570a8da29314583b3842572bc9765ff4f4622a09d81706c1b1bd9f71a9438a11f885a225ba04d9d897d31601925b72ed4d8cb89573dba20a51a70903179c5fedaa1aa5f302ba9fc3eb16fbd6f8c7d8f9a64adf426bb429e9b4e5e61eff2ecce6a3a5917b545e3c07418f96e61b33b2b424c1b5cf23231f6f50546039d9dd66630965ac2a0b25407e3883ec058713888a14c53ce5462075ea6356f99325db71d692cb14cd44f4dcce51043079722be33f6f513c8019a2dd9d0c447a3535302a15e9c11a826370986926a69c91c1dd2b330461293e830cda1917f3a92cee0360fca1601ca6faa4cfe85fda52cf75610d3b3bacb1c2d9233e4460d3710e5f2ab7dc45ed8682bea7e70ba08fc81c1c2e8876d3f64</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Dydは、パスワードを入力するように求められます</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">又来……</summary>
    
    
    
    <category term="others" scheme="https://dyd-true.github.io/categories/others/"/>
    
    
    <category term="字符串" scheme="https://dyd-true.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="数据结构" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="数论,数学" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
    <category term="分治" scheme="https://dyd-true.github.io/tags/%E5%88%86%E6%B2%BB/"/>
    
    <category term="备讲" scheme="https://dyd-true.github.io/tags/%E5%A4%87%E8%AE%B2/"/>
    
    <category term="SA" scheme="https://dyd-true.github.io/tags/SA/"/>
    
  </entry>
  
  <entry>
    <title>luoguP2605 [ZJOI2010]基站选址</title>
    <link href="https://dyd-true.github.io/2022/06/12/luoguP2605-ZJOI2010-%E5%9F%BA%E7%AB%99%E9%80%89%E5%9D%80/"/>
    <id>https://dyd-true.github.io/2022/06/12/luoguP2605-ZJOI2010-%E5%9F%BA%E7%AB%99%E9%80%89%E5%9D%80/</id>
    <published>2022-06-12T12:00:54.000Z</published>
    <updated>2022-06-12T12:23:30.695Z</updated>
    
    <content type="html"><![CDATA[<p> 线段树优化转移</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P2605">基站选址</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>考虑 dp ，设 $d[i, j, k]$ 表示“前 $i$ 个村子选了 $j$ 个，最后一个为 $k$ ”的最小代价，转移方程很好写，设 $v(x, y)$ 表示“当 $x, y$ 上面都有基站时 $x \sim y$ 的点的代价”：<br>$$<br>d[i, j, k] \gets<br>\begin{cases}<br>d[i - 1, j, k] + v(k, i) \\<br>d[i - 1, j - 1, i] + c[i]<br>\end{cases}<br>$$<br>然后，发现寄了，因为状态数就是 $O(n^2m)$ 的（这里 $m$ 就是题目的 $k$ ），必须优化状态，发现我们之所以要记录最后一个是 $k$ ，是因为我们还要考虑 $k$ 以后的点的代价，不妨新加一个点 $n + 1$ ，它的距离为 $\infty$ （无法被前面覆盖），不被覆盖的代价为 $\infty$ （必须被覆盖），在它这里建基站的代价为 $0$ （不影响答案），然后让 $m += 1$ ，这样就保证最后一个基站一定建在 $n + 1$ 上，那么我们就只考虑前面的代价即可</p><p>设 $d[i, j]$ 表示“前 $i$ 个村子选了 $j$ 个，且最后一个就在 $i$ 时前 $i$ 个村子的代价”，那么转移为：<br>$$<br>d[i, j] \gets d[k, j - 1] + v(k, i) + c[i]<br>$$<br>状态数是 $O(nm)$ ，直接转移是 $O(n)$ ，又爆炸了，考虑优化，发现 $c[i]$ 是定值，对于每个 $i$ 如果可以快速查出 $\min(d[k, j - 1] + v(k, i))$ 就好了，那么最直接的思路就是用线段树维护 $d[k, j - 1] + v(k, i)$ （对于每个 $j$ 重新建一次树）</p><p> $d[k, j - 1]$ 是不随 $i$ 变化的，考虑 $v(k, i)$ 的变化：</p><p><img src="https://s2.loli.net/2022/06/12/qupR6WVErygTto1.png" alt="cg"></p><p>如图，对于点 $k$ ，设包含它的范围为 $lp \sim rp$ ，那么在如图 $i \to i + 1$ 跨 $rp$ 时，自然会使得 $0 \sim lp - 1$ 的位置代价加 $w[k]$ ，对于每个点二分出 $lp, rp$ ，线段树维护即可</p><p>时间 $O(mn \log n + n \log n)$ </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e4</span> + <span class="number">100</span>, K = <span class="number">100</span> + <span class="number">100</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, num;</span><br><span class="line"><span class="keyword">int</span> d[K][N], ans = INF;</span><br><span class="line"><span class="keyword">int</span> c[N], dis[N], s[N], w[N], lp[N];</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; cg[N];</span><br><span class="line"><span class="keyword">namespace</span> LT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc (u &lt;&lt; 1)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc ((u &lt;&lt; 1) | 1)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line">    <span class="keyword">int</span> v[N &lt;&lt; <span class="number">2</span>], tg[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123; v[u] = std::<span class="built_in">min</span>(v[lc], v[rc]); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adt</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> d)</span></span>&#123; tg[u] += d, v[u] += d; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dw</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tg[u])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">adt</span>(lc, tg[u]), <span class="built_in">adt</span>(rc, tg[u]);</span><br><span class="line">            tg[u] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> u = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        v[u] = INF, tg[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(v[u] = x[l]);</span><br><span class="line">        <span class="built_in">bd</span>(x, lc, l, mid), <span class="built_in">bd</span>(x, rc, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">up</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mdf</span><span class="params">(<span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> d, <span class="keyword">int</span> u = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) <span class="keyword">return</span> <span class="built_in">adt</span>(u, d);</span><br><span class="line">        <span class="built_in">dw</span>(u);</span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= mid) <span class="built_in">mdf</span>(ql, qr, d, lc, l, mid);</span><br><span class="line">        <span class="keyword">if</span> (qr &gt; mid) <span class="built_in">mdf</span>(ql, qr, d, rc, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">up</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> u = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) <span class="keyword">return</span> v[u];</span><br><span class="line">        <span class="built_in">dw</span>(u);</span><br><span class="line">        <span class="keyword">int</span> res = INF;</span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= mid) res = <span class="built_in">qry</span>(ql, qr, lc, l, mid);</span><br><span class="line">        <span class="keyword">if</span> (qr &gt; mid) res = std::<span class="built_in">min</span>(<span class="built_in">qry</span>(ql, qr, rc, mid + <span class="number">1</span>, r), res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> mid</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findr</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = st, r = n, mid, res = n;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (dis[mid] &lt;= x) res = mid, l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findl</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = st, mid, res = st;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (dis[mid] &gt;= x) res = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;dis[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i]);</span><br><span class="line">        cg[<span class="built_in">findr</span>(dis[i] + s[i], i)].<span class="built_in">pb</span>(i);</span><br><span class="line">        lp[i] = <span class="built_in">findl</span>(dis[i] - s[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    ++n, ++num;</span><br><span class="line">    dis[n] = w[n] = INF, c[n] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= num; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        LT::<span class="built_in">bd</span>(d[j - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            d[j][i] = LT::<span class="built_in">qry</span>(<span class="number">0</span>, i - <span class="number">1</span>) + c[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> t : cg[i]) LT::<span class="built_in">mdf</span>(<span class="number">0</span>, lp[t] - <span class="number">1</span>, w[t]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= num; ++i) ans = std::<span class="built_in">min</span>(ans, d[i][n]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 线段树优化转移&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="线段树" scheme="https://dyd-true.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>长链剖分</title>
    <link href="https://dyd-true.github.io/2022/06/06/%E9%95%BF%E9%93%BE%E5%89%96%E5%88%86/"/>
    <id>https://dyd-true.github.io/2022/06/06/%E9%95%BF%E9%93%BE%E5%89%96%E5%88%86/</id>
    <published>2022-06-06T07:03:53.000Z</published>
    <updated>2022-06-12T08:33:12.137Z</updated>
    
    <content type="html"><![CDATA[<p> 与深度相关的时候较常用</p><span id="more"></span><h1 id="长链剖分"><a href="#长链剖分" class="headerlink" title="长链剖分"></a>长链剖分</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>在树上，我们很多时候都是父节点的信息由所有子节点计算得到，此时启发式合并/重链剖分大部分情况下可以做到很不错的复杂度，但是，当维护的信息与深度相关，甚至是每一个深度都要计算，我们会考虑长链剖分来做的更好</p><p>长链剖分的思想类似于 dus on tree ，我们在计算父节点时直接把最长（最深）的儿子的信息继承了（实现时常用指针维护深度的变化），然后把其它儿子的信息暴力合并上去</p><p>关于空间，由于一共就 $n$ 个点，所以所有长链的长度和是 $n$ ，那么一共就只要 $O(n)$ 的空间；关于时间，每个长链自身只算一次（自下而上被继承），也只会被合并一次（合并到其它长链中），所以时间为 $O(2n) = O(n)$ </p><p>另外，从任何一共点向上跳长链，次数不会超过 $\sqrt{n}$ 次，这虽然劣于重链剖分，但有时候有点用</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://codeforces.com/problemset/problem/1009/F">Dominant Indices</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一棵 $n \le 10^6$ 个节点以 $1$ 为根的树，定义 $d(x, k)$ 表示 $x$ 的子树中到 $x$ 距离为 $k$ 的点的个数，对于每个节点，求一个最小的 $k$ 使得 $d(x, k)$ 最大</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>比较板子，用一个 <code>pair</code> 记录一下答案就好，主要是看看如何实现</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> PII = std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n, h[N], idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> son[N], len[N];</span><br><span class="line">PII ans[N];</span><br><span class="line"><span class="keyword">int</span> dd[N], *d[N], *cur = dd + <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span> <span class="keyword">int</span> ne, ver; &#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; e[idx] = &#123;h[x], y&#125;, h[x] = idx++; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne) <span class="keyword">if</span> ((y = e[i].ver) != fa)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">dfs1</span>(y, x);</span><br><span class="line"><span class="keyword">if</span> (len[y] &gt; len[son[x]]) son[x] = y;</span><br><span class="line">&#125;</span><br><span class="line">len[x] = len[son[x]] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">d[x][<span class="number">0</span>] = <span class="number">1</span>, ans[x] = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> (!son[x]) <span class="keyword">return</span> ;</span><br><span class="line">d[son[x]] = d[x] + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(son[x], x);</span><br><span class="line">ans[x] = std::<span class="built_in">max</span>(ans[x], &#123;ans[son[x]].fi, ans[son[x]].se - <span class="number">1</span>&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne) <span class="keyword">if</span> ((y = e[i].ver) != fa &amp;&amp; y != son[x])</span><br><span class="line">&#123;</span><br><span class="line">d[y] = cur, cur += len[y];</span><br><span class="line"><span class="built_in">dfs2</span>(y, x);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len[y]; ++j)</span><br><span class="line">&#123;</span><br><span class="line">d[x][j] += d[y][j - <span class="number">1</span>];</span><br><span class="line">ans[x] = std::<span class="built_in">max</span>(ans[x], &#123;d[x][j], -j&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="built_in">memset</span>(h + <span class="number">1</span>, <span class="number">-1</span>, n &lt;&lt; <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line"><span class="built_in">add</span>(u, v), <span class="built_in">add</span>(v, u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">d[<span class="number">1</span>] = cur, cur += len[<span class="number">1</span>];</span><br><span class="line"><span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, -ans[i].se);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题二"><a href="#例题二" class="headerlink" title="例题二"></a>例题二</h2><p><a href="https://www.luogu.com.cn/problem/P5904">HOT-Hotels 加强版</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>考虑树形 dp ，满足条件的情况如图：</p><p><img src="https://s2.loli.net/2022/06/12/w4NRVjPu2FrBlhD.png" alt="tu"></p><p>设橙色的三个点为 $u, v, w$ ，记 $x = lca(u, v), y = lca(x, w)$ 有 $dis(u, x) = dis(v, x) = dis(x, y) + dis(y, w)$ ，我们搞那么多 lca 是因为树形 dp 只能在最高点统计答案</p><p>记 $d[x, j]$ 表示“到点 $x$ 的距离为 $j$ 的点的个数”，记 $g[x, j]$ 表示“满足 $dis(u, w) = dis(v, w) = dis(w, x) + j$ 的点对 $u, v$ 的个数，其中 $w = lca(u, v)$ ）”，那么对于 $x$ 的一个儿子 $y$ ：<br>$$<br>\begin{aligned}<br>&amp; //这里还没有转移, d[x, j], g[x, j]的意义都还是只包括y以前的子树的 \\<br>&amp; ans += d[y, j] * g[x][j + 1] \\<br>&amp; ans += g[y, j] * d[x][j - 1] \\<br>&amp; //这里进行g的转移 \\<br>&amp; g[x][j + 1] += d[x][j + 1] * d[y][j] \\<br>&amp; g[x][j - 1] += g[y][j] \\<br>&amp; //这里进行d的转移 \\<br>&amp; d[x][j + 1] += d[y][j] \\<br>\end{aligned}<br>$$<br>显然直接做是 $O(n^2)$ 的，考虑长剖优化，每次把长儿子的答案直接继承，可以优化到 $O(n)$ ，但要注意， $g[x][j - 1] \gets g[x][j]$ ，这意味着长儿子应该填到 $x$ 之前的空间里，所以 $x$ 的前、后都要预留 $len$ 的空间（相应的池子里应该开 $2n$ 的空间）</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>注意 <code>dfs2</code> 的第二个 <code>for</code> 只能是 <code>j &lt; len[y]</code> 不能是 <code>j &lt;= len[y]</code> ，因为 $y$ 的子树里到 $y$ 的距离最长为 $len[y] - 1$ ，调用 $len[y]$ 会到奇怪的地方，上一个例题没有这个问题是因为上一次空间是递增向后分配的，后面都是 $0$ 调用了也每关系，但本题 $g$ 是向前向后都分配了的</p><p>更具体的，如图：</p><p><img src="https://s2.loli.net/2022/06/12/Qjh26EmtTYacOpo.png" alt="空间"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n, h[N], idx = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span> <span class="keyword">int</span> ne, ver; &#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> len[N], son[N];</span><br><span class="line">LL dd[N], gg[N &lt;&lt; <span class="number">1</span>], *d[N], *g[N], *cd = dd + <span class="number">1</span>, *cg = gg + <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; e[idx] = &#123;h[x], y&#125;, h[x] = idx++; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne) <span class="keyword">if</span> ((y = e[i].ver) != fa)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs1</span>(y, x);</span><br><span class="line">        <span class="keyword">if</span> (len[y] &gt; len[son[x]]) son[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">    len[x] = len[son[x]] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d[x][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!son[x]) <span class="keyword">return</span> ;</span><br><span class="line">    d[son[x]] = d[x] + <span class="number">1</span>, g[son[x]] = g[x] - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[x], x);</span><br><span class="line">    ans += g[x][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne) <span class="keyword">if</span> ((y = e[i].ver) != fa &amp;&amp; y != son[x])</span><br><span class="line">    &#123;</span><br><span class="line">        cg += len[y];</span><br><span class="line">        d[y] = cd, g[y] = cg;</span><br><span class="line">        cd += len[y], cg += len[y];</span><br><span class="line">        <span class="built_in">dfs2</span>(y, x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len[y]; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += d[y][j] * g[x][j + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (j) ans += g[y][j] * d[x][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len[y]; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            g[x][j + <span class="number">1</span>] += d[x][j + <span class="number">1</span>] * d[y][j];</span><br><span class="line">            <span class="keyword">if</span> (j) g[x][j - <span class="number">1</span>] += g[y][j];</span><br><span class="line">            d[x][j + <span class="number">1</span>] += d[y][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u, v), <span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    cg += len[<span class="number">1</span>];</span><br><span class="line">    d[<span class="number">1</span>] = cd, g[<span class="number">1</span>] = cg;</span><br><span class="line">    cd += len[<span class="number">1</span>], cg += len[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 与深度相关的时候较常用&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="笔记" scheme="https://dyd-true.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="长链剖分" scheme="https://dyd-true.github.io/tags/%E9%95%BF%E9%93%BE%E5%89%96%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>SOS dp</title>
    <link href="https://dyd-true.github.io/2022/06/06/SOS-dp/"/>
    <id>https://dyd-true.github.io/2022/06/06/SOS-dp/</id>
    <published>2022-06-06T00:46:14.000Z</published>
    <updated>2022-06-06T06:50:44.981Z</updated>
    
    <content type="html"><![CDATA[<p> 和 FWT 有点像，用在子集和超集</p><span id="more"></span><h1 id="SOS-dp"><a href="#SOS-dp" class="headerlink" title="SOS dp"></a>SOS dp</h1><p>全称为 Sum over Subsets dynamic programming ，即“子集和动态规划”</p><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>考虑如下问题，求：<br>$$<br>f[i] = \sum_{j \subseteq i} a_j<br>$$<br>这里的 $a_j$ 可以是任何信息，点像 FWT ，因为 $j  \subseteq i$ 就是按位与等于 $j$ ，但我们其实可以 dp 搞</p><p>考虑定义 $d[x][i]$ 表示“只考虑 $x$ 二进制下前 $i$ 位的 $f[x]$ （但 $a_j$ 是所有位都考虑的）”，转移就讨论一下：</p><ol><li> $x$ 第 $i$ 位为 $0$ ，那其实 $x$ 不变，有 $d[x][i] \gets d[x][i - 1]$ </li><li> $x$ 第 $i$ 位为 $1$ ，设从 $y$ 转移，发现 $y$ 第 $i$ 位是什么都可以，所以有 $d[x][i] \gets d[x][i - 1]$ 和 $d[x][i] \gets d[x \oplus (1 &lt;&lt; i)][i - 1]$ </li></ol><p>发现 $i$ 可以压掉，所以最后的代码是（两个循环的顺序是从大到小还是从小到大没有关系）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>; ~j; --j) <span class="keyword">if</span> ((j &gt;&gt; i) &amp; <span class="number">1</span>) d[j] += d[j ^ (<span class="number">1</span> &lt;&lt; i)];</span><br></pre></td></tr></table></figure><p>初始化为 $\forall a_j, d[a[j]] = a[j]$ </p><p>上面的代码从集合角度也很好理解：就是枚举每一个元素，然后如果 $j$  有这个元素，$j \oplus (1 &lt;&lt; i)$ 就是它的一个子集</p><p>也可以从高维前缀和的角度理解，类似集合</p><h2 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h2><p>先给出超集和子集的定义：</p><p>对于集合 $A \subset B$ ，我们称 $A$ 为 $B$ 的子集， $B$ 为 $A$ 的超集</p><p>而 SOS dp 就是用来解决有关它们的问题的</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://codeforces.com/problemset/problem/449/D">Jzzhu and Numbers</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定 $n \le 10^6$ 个非负整数 $a_i \le 10^6$ ，定义一个集合的权值为其中元素按位与的值，求权值为 $0$ 的子集个数</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>考虑与在集合意义下的定义， $a \&amp; b = a$ 意味着 $b$ 是 $a$ 的子集， $a$ 是 $b$ 的超集，考虑定义 $d[x]$ 表示“ $x$ 的原数列中超集个数”，显然转移的时候是 <code>if (!(j &gt;&gt; i) &amp; 1) d[j] += d[j ^ (1 &lt;&lt; i)]</code> ，最后 $2^{d[x]} - 1$ 就是“权值为 $x$ 的超集（包括 $x$ ）的集合个数”（两个集合是不一样的），我们要想办法去掉超集（不包括 $x$ ）的答案，就反着（加变减）做一次超集的 SOS 即可</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>要注意的地方就是 <code>NN</code> 的大小是 $\log a$ </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">100</span>, NN = <span class="number">21</span>, P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N], d[(<span class="number">1</span> &lt;&lt; NN) + <span class="number">100</span>], pw2[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adj</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123; x += (x &gt;&gt; <span class="number">31</span>) &amp; P; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">pw2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">adj</span>(pw2[i] = pw2[i - <span class="number">1</span>] + pw2[i - <span class="number">1</span>] - P);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]), <span class="built_in">adj</span>(d[a[i]] += <span class="number">1</span> - P);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NN; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = (<span class="number">1</span> &lt;&lt; NN) - <span class="number">1</span>; ~j; --j) <span class="keyword">if</span> (!((j &gt;&gt; i) &amp; <span class="number">1</span>)) <span class="built_in">adj</span>(d[j] += d[j ^ (<span class="number">1</span> &lt;&lt; i)] - P);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="number">1</span> &lt;&lt; NN) - <span class="number">1</span>; ~i; --i) <span class="built_in">adj</span>(d[i] = pw2[d[i]] - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NN; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = (<span class="number">1</span> &lt;&lt; NN) - <span class="number">1</span>; ~j; --j) <span class="keyword">if</span> (!((j &gt;&gt; i) &amp; <span class="number">1</span>)) <span class="built_in">adj</span>(d[j] -= d[j ^ (<span class="number">1</span> &lt;&lt; i)]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, d[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题二"><a href="#例题二" class="headerlink" title="例题二"></a>例题二</h2><p><a href="https://atcoder.jp/contests/arc137/tasks/arc137_d">Prefix XORs</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定长度为 $n \le 10^6$ 个非负整数序列 $a_i \le 10^6$ ，要对其进行 $m \le 10^6$ 次前缀异或和，对于每一次，输出 $a_n$ 的值</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>考虑每一个数被算了几次，写出如下矩阵（设 $n = 5$ ）：<br>$$<br>\begin{bmatrix}<br>1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\<br>5 &amp; 4 &amp; 3 &amp; 2 &amp; 1 \\<br>15 &amp; 10 &amp; 6 &amp; 3 &amp; 1 \\<br>35 &amp; 20 &amp; 10 &amp; 4 &amp; 1 \\<br>70 &amp; 35 &amp; 15 &amp; 5 &amp; 1<br>\end{bmatrix}<br>$$<br>发现是杨辉三角（斜着的），可得第 $k$ 次前缀和，第 $i$ 个位置的计算次数就是 $\binom{n - i + k - 1}{k - 1}$ ，这个东西也就等于 $\binom{n - i + k - 1}{n - i}$ </p><p>当然不能直接算，在异或意义下我们只关心其奇偶性，即 $\binom{n - i + k - 1}{n - i} \mod 2$ ，考虑 Lucass 定理，我们只关心上下两个数二进制下每一个组合数的积，发现 $\binom{1}{0} = 1, \binom{1}{1} = 1, \binom{0}{0} = 1, \binom{0}{1} = 0$ ，显然只要有一个 $0$ 积就是 $0$ 了，所以要 $\binom{n - i + k - 1}{n - i} \equiv 1 \pmod  2$ ，二进制下每一位组合数都要是 $1$ ，则有 $(n - i) \subseteq (n - i + k - 1)$ ，即 $(n - i) \cap (k - 1) = \varnothing$ ，又即 $\overline{(n - i)} \subseteq (k - 1)$ </p><p>考虑对每个 $\overline{(n - i)}$ 求出其超集的异或值即可</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">100</span>, NN = <span class="number">21</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[N], d[(<span class="number">1</span> &lt;&lt; NN) + <span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">d[(<span class="number">1</span> &lt;&lt; NN) - <span class="number">1</span> - n + i] = a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NN; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = (<span class="number">1</span> &lt;&lt; NN) - <span class="number">1</span>; ~j; --j) <span class="keyword">if</span> (!((j &gt;&gt; i) &amp; <span class="number">1</span>)) d[j] ^= d[j ^ (<span class="number">1</span> &lt;&lt; i)];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, d[i - <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 和 FWT 有点像，用在子集和超集&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="笔记" scheme="https://dyd-true.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="SOS" scheme="https://dyd-true.github.io/tags/SOS/"/>
    
  </entry>
  
  <entry>
    <title>luoguP2155 [SDOI2008] 沙拉公主的困惑</title>
    <link href="https://dyd-true.github.io/2022/06/05/luoguP2155-SDOI2008-%E6%B2%99%E6%8B%89%E5%85%AC%E4%B8%BB%E7%9A%84%E5%9B%B0%E6%83%91/"/>
    <id>https://dyd-true.github.io/2022/06/05/luoguP2155-SDOI2008-%E6%B2%99%E6%8B%89%E5%85%AC%E4%B8%BB%E7%9A%84%E5%9B%B0%E6%83%91/</id>
    <published>2022-06-05T08:28:42.000Z</published>
    <updated>2022-06-05T08:41:56.135Z</updated>
    
    <content type="html"><![CDATA[<p> 感觉式子很有用</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P2155">沙拉公主的困惑</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先给式子： $Ans = \frac{n!}{m!} * \varphi(m!)$ ，打开就是 $n!\frac{\prod(p - 1)}{\prod p},其中p是m!的约数$ </p><p>直接预处理即可，注意当 $n!$ 里包含模数而且分母没有约掉的话直接输出 $0$ </p><p>看起来很简单，但式子不好推，比较简单的推法是写成 $\gcd(x, y) == 1$ 然后上欧拉反演即得</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, P, ans;</span><br><span class="line"><span class="keyword">int</span> fac[N], pr[N], cnt, imp[N], mp[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = <span class="built_in">LL</span>(x) * x % P) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = <span class="built_in">LL</span>(res) * x % P;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prev</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fac[<span class="number">0</span>] = fac[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i) fac[i] = <span class="built_in">LL</span>(fac[i - <span class="number">1</span>]) * i % P;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[i]) pr[++cnt] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; <span class="built_in">LL</span>(pr[j]) * i &lt; N; ++j)</span><br><span class="line">&#123;</span><br><span class="line">vis[pr[j] * i] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i % pr[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>, sum = <span class="number">1</span>, is = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pr[j] == P) ++j;</span><br><span class="line"><span class="keyword">if</span> (j &lt;= cnt &amp;&amp; pr[j] &lt;= i) sum = <span class="built_in">LL</span>(pr[j++]) * sum % P, is = <span class="built_in">qpow</span>(sum, P - <span class="number">2</span>);</span><br><span class="line">imp[i] = is;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>, sum = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j &lt;= cnt &amp;&amp; pr[j] &lt;= i) sum = <span class="built_in">LL</span>(pr[j++] - <span class="number">1</span>) * sum % P;</span><br><span class="line">mp[i] = sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;T, &amp;P);</span><br><span class="line"><span class="built_in">prev</span>();</span><br><span class="line"><span class="keyword">while</span> (T--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">if</span> (n &gt;= P &amp;&amp; m &lt; P) <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ans = <span class="built_in">LL</span>(fac[n]) * imp[m] % P * mp[m] % P;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 感觉式子很有用&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="数论,数学" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
    <category term="欧拉函数" scheme="https://dyd-true.github.io/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>优化dp4</title>
    <link href="https://dyd-true.github.io/2022/06/04/%E4%BC%98%E5%8C%96dp4/"/>
    <id>https://dyd-true.github.io/2022/06/04/%E4%BC%98%E5%8C%96dp4/</id>
    <published>2022-06-04T06:54:52.000Z</published>
    <updated>2022-06-06T00:42:03.434Z</updated>
    
    <content type="html"><![CDATA[<p> 然而我 dp 废的一比</p><span id="more"></span><h1 id="优化dp4"><a href="#优化dp4" class="headerlink" title="优化dp4"></a>优化dp4</h1><p>才发现这个还没写……</p><p>上一篇：<a href="https://dyd-true.github.io/2022/02/12/%E4%BC%98%E5%8C%96dp3/">优化dp3</a></p><h1 id="wqs-二分"><a href="#wqs-二分" class="headerlink" title="wqs 二分"></a>wqs 二分</h1><h2 id="（并不保证真确性的）定义"><a href="#（并不保证真确性的）定义" class="headerlink" title="（并不保证真确性的）定义"></a>（并不保证真确性的）定义</h2><p>以下全是自己的理解：感觉就是用来求一个“选 $m$ 个，最优化”的问题，更具体的，设选 $x$ 个的最大权值为 $f(x)$ ，wqs 二分要求 $f(x)-x$ 图像是这样（就是先随着可选个数增多变优，后来因为必须要选 $x$ 个导致变坏），形式化的，其实是要求它是个凸函数：<img src="https://s2.loli.net/2022/06/04/1LgZziuFHh7BPTb.png" alt="f(x)-x"></p><p>如图，设绿色直线为 $y = kx + b$ ，由切点 $D(x_D, f(x_D))$ 得 $b = f(x_D) - kx_D$ ，考虑到这是切线，显然对于一个确定的 $k$ ， $x_D$ 是使 $b$ 最大的点，那么可以二分一个 $k$ ，把每个物品的价值 $-k$ （如果是代价就 $+k$ ），然后做<strong>没有个数限制</strong>的 dp 求出最大的价值和就是 $b$ ，此时对应的 $x$ （如绿线对应的 $x_D$ ）若比 $m$ 大，说明 $k$ 应继续变大；若比 $m$ 小，$k$ 应该变小；若相等，则用 $k, x/m$ 计算得到 $f(m)$ </p><p>值得一提的是，很多时候如果 $x, f(x)$ 都是整数，那么 $k$ 也可以只在整数范围二分：考虑求导，有 $f’(x) = k$ ，大部分情况下 $f(x)$ 的导函数 $f’(x)$ 都是“比较好看的”，加上 $x$ 是整数，那么 $k$  一半也是整数</p><p>但是，整数又会遇到一个问题：如果一条切线过了几个点（包括 $m$ ）怎么办（更具体的，当斜率为 $k$ 时 $x = m - 1$ ，斜率变化 $1$ 时 $x = m + 1$ ）？其实此时我们不也是算出了 $m$ 的斜率吗，直接就用此时的 $k$ 就好了（优先用小的那个算，即 $x = m - 1$ 那个）</p><p>带权二分的好处在于，对于要求“选则恰好 $k$ 个“，我们 dp 时几乎不可避免的要给 $k$ 一维，这让状态数（和时间复杂度）直接乘了个 $n$ （个数），而 wqs 二分可以避免加一维，把 $n$ 优化至 $\log v$ （权值）</p><p>另外，一个细节是，向下取整（ <code>l + r &gt;&gt; 1</code> ）和向 $0$ 取整（ $(l + r) / 2$ ）是不一样的；且 $l, r$ 的初始值是斜率最大值和最小值啊，如果 $f(x)$ 是上凸的，然后 $x$ 的范围是 $[0,n]$ ，那么 $r$ 应该等于 $f(1)−f(0)$ 的最大可能值，$l$ 同理等于 $f(n)−f(n−1)$ 的最小可能值</p><h2 id="例题十二"><a href="#例题十二" class="headerlink" title="例题十二"></a>例题十二</h2><p>经典题：<a href="https://www.luogu.com.cn/problem/P2619">Tree I</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二分一个 $k$ ，对于每条白边，把权值改为 $c - k$ ，直接做最小生成树即可，时间 $O(m \log m \log k \alpha(n))$ （ $k$ 是边权），可以黑白边分开排序，每次合并，时间 $O(m \alpha(n) \log k + m \log m)$ </p><p>细节是一条切线过几个点的情况，此时明显白边权值与黑边权值相等，我们优先选白边，还有 $k$ 可以为负数</p><p>（所以这和 dp 有啥关系啊）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> PII = std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span>+ <span class="number">100</span>, M = <span class="number">1e5</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, num, ans, cta = <span class="number">0</span>, ctb = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span> <span class="keyword">int</span> u, v, w, c; &#125; e[M], a[M], b[M];</span><br><span class="line"><span class="keyword">int</span> fa[N], rk[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">get</span>(fa[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (rk[x] &gt; rk[y]) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">fa[x] = y, rk[y] += rk[x] == rk[y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">PII <span class="title">chk</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>, ct = <span class="number">0</span>, x, y;</span><br><span class="line">PII res = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= cta &amp;&amp; j &lt;= ctb)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i].w - k &lt; b[j].w) e[++ct] = a[i++], e[ct].w -= k;</span><br><span class="line"><span class="keyword">else</span> e[++ct] = b[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= cta) e[++ct] = a[i++], e[ct].w -= k;</span><br><span class="line"><span class="keyword">while</span> (j &lt;= ctb) e[++ct] = b[j++];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) fa[i] = i, rk[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= ct; ++i)</span><br><span class="line">&#123;</span><br><span class="line">x = <span class="built_in">get</span>(e[i].u), y = <span class="built_in">get</span>(e[i].v);</span><br><span class="line"><span class="keyword">if</span> (x == y) <span class="keyword">continue</span>;</span><br><span class="line">res.fi += e[i].w;</span><br><span class="line">res.se += e[i].c == <span class="number">0</span>;</span><br><span class="line"><span class="built_in">merge</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;num);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;e[i].u, &amp;e[i].v, &amp;e[i].w, &amp;e[i].c);</span><br><span class="line">++e[i].u, ++e[i].v;</span><br><span class="line"><span class="keyword">if</span> (e[i].c == <span class="number">0</span>) a[++cta] = e[i];</span><br><span class="line"><span class="keyword">else</span> b[++ctb] = e[i];</span><br><span class="line">&#125;</span><br><span class="line">std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + cta + <span class="number">1</span>, [&amp;](Edge x, Edge y)&#123; <span class="keyword">return</span> x.w &lt; y.w; &#125;);</span><br><span class="line">std::<span class="built_in">sort</span>(b + <span class="number">1</span>, b + ctb + <span class="number">1</span>, [&amp;](Edge x, Edge y)&#123; <span class="keyword">return</span> x.w &lt; y.w; &#125;);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">-101</span>, r = <span class="number">101</span>, mid;</span><br><span class="line">PII t;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line">mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">t = <span class="built_in">chk</span>(mid);</span><br><span class="line"><span class="keyword">if</span> (t.se &lt;= num)</span><br><span class="line">&#123;</span><br><span class="line">ans = t.fi + mid * num;</span><br><span class="line">l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题十三"><a href="#例题十三" class="headerlink" title="例题十三"></a>例题十三</h2><p>看看真正的 dp 题（不难发现大部分时候 dp 都是套在 wqs 二分内部的）：<a href="https://www.luogu.com.cn/problem/P4383">林克卡特树</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>为了方便记题目中的 $k$ 为 $num$ 显然切断 $num$ 条边后原树变成 $num + 1$ 个联通块（更进一步，它们都是树），我们求出每棵树的直径（最长链，可以是点），用 $num$ 条权为 $0$ 的边连起来就是最优解</p><p>考虑树形 dp ，套路的设 $d[i, j]$ 表示”点 $i$ 的子树中有 $j$ 条链的最大值”，然后发现没法转移，没法转移的关键问题是，当考虑合并 $u, v$ 两个点代表的联通块集合时，会出现两个链合并成一条链/链数不变/链数加 $1$ 三个情况，我们当前信息无法指导我们如何转移</p><p>考虑加一维，不难发现在最后选的链中每个点的度数只有 $0/1/2$ ，于是令 $d[i, j, k](k = 0/1/2)$ 表示”点 $i$ 的子树中有 $j$ 条链，且 $i$ 的度数为 $k$ 的最大值“，那么转移就分讨设 $v$  为 $u$ 的儿子：</p><ol><li>不选 $(u, v)$ ： $d[u, j_1, k_1] + d[v, j_2, k_2] \to d[u, j_1 + j_2, k_1]$ </li><li>选则 $(u, v)$ ： $d[u, j_1, k_1] + d[v, j_2, k_2] \to d[u, j_1 + j_2 + dt, k_1 + 1]$ ，其中 $k_1, k_2 \ne 2$ ， $dt = [k_1 == 0 \wedge k_2 == 0] - [k_1 == 1 \wedge k_2 == 1]$ </li></ol><p>那么边界显然就是 $d[i, 0, 0] = 0$ 其它都是 $-\infty$ ，吗？发现如果是以一个点作为链，那就是 $d[i, 1, ?] = 0$ ，但 $?$ （也就是这个点的度）该是多少呢？显然我们不能让这个点与其它任何点相连，所以是 $2$ ，即 $d[i, 1, 2] = d[i, 0, 0] = 0$ 其它都是 $-\infty$ ，于是 dp ，答案就是 $\max(d[root, num, 0/1/2])$ ，直接 dp 时间为 $O(n * num * 3)$ ，我们发现很难优化，因为转移已经是 $O(1)$ 了，时间瓶颈在状态数，现在我们要么减少计算的状态数（即只计算一部分状态），要么减少状态数（即修改状态的定义）</p><p>此时不难发现 <del>这篇 blog 讲的是 wqs 二分</del> 此题也是”选 $num$ 个“的形式，我们把 $num = 0 \sim 100$ 的答案依次求一下，发现这是一个凸函数（不会证，具体做题时靠感觉 + 打表 + 猜想），上 wqs 二分，把第二维直接去掉，转移时发现边数减少就加一个 $k$ ，否则减一个 $k$ （这个 $k$ 是二分的）</p><p>最后是 wqs 二分的经典问题：凸包上多点共线怎么解决；我们打个结构体 dp 时优先转移边数少的即可，注意去掉第二维后出现自己转移到自己的情况，用临时数组避免多次转移</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p> $l, r$ 初始值一定要够大，注意是 $num + 1$ 个联通块</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">100</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">int</span> n, num, l, r, mid, h[N], idx = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span> <span class="keyword">int</span> ne, ver, w; &#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DP</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">LL v; <span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (DP x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> v == x.v ? num &gt; x.num : v &lt; x.v; &#125;</span><br><span class="line">DP <span class="keyword">operator</span> + (DP x)&#123; <span class="keyword">return</span> &#123;v + x.v, num + x.num&#125;; &#125;</span><br><span class="line">&#125; d[N][<span class="number">3</span>], as, td[<span class="number">3</span>];</span><br><span class="line">LL ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>&#123; e[idx] = &#123;h[x], y, z&#125;, h[x] = idx++; &#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmx</span><span class="params">(T &amp;x, T y)</span></span>&#123; <span class="keyword">return</span> x &lt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne) <span class="keyword">if</span> ((y = e[i].ver) != fa)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">dp</span>(y, x);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; ++j) td[j] = &#123;-INF, inf&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; ++j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span>; ++k) <span class="built_in">cmx</span>(td[j], d[x][j] + d[y][k]);</span><br><span class="line"><span class="built_in">cmx</span>(td[<span class="number">1</span>], d[x][<span class="number">0</span>] + d[y][<span class="number">0</span>] + DP&#123;e[i].w - mid, <span class="number">1</span>&#125;);</span><br><span class="line"><span class="built_in">cmx</span>(td[<span class="number">1</span>], d[x][<span class="number">0</span>] + d[y][<span class="number">1</span>] + DP&#123;e[i].w, <span class="number">0</span>&#125;);</span><br><span class="line"><span class="built_in">cmx</span>(td[<span class="number">2</span>], d[x][<span class="number">1</span>] + d[y][<span class="number">0</span>] + DP&#123;e[i].w, <span class="number">0</span>&#125;);</span><br><span class="line"><span class="built_in">cmx</span>(td[<span class="number">2</span>], d[x][<span class="number">1</span>] + d[y][<span class="number">1</span>] + DP&#123;e[i].w + mid, <span class="number">-1</span>&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; ++j) d[x][j] = td[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;num);</span><br><span class="line"><span class="built_in">memset</span>(h + <span class="number">1</span>, <span class="number">-1</span>, n &lt;&lt; <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, w; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line"><span class="built_in">add</span>(u, v, w), <span class="built_in">add</span>(v, u, w);</span><br><span class="line">&#125;</span><br><span class="line">l = <span class="number">-1e12</span>, r = <span class="number">1e12</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line">mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">d[i][<span class="number">0</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">d[i][<span class="number">1</span>] = &#123;-INF, inf&#125;;</span><br><span class="line">d[i][<span class="number">2</span>] = &#123;-mid, <span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dp</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">as = d[<span class="number">1</span>][<span class="number">0</span>], <span class="built_in">cmx</span>(as, d[<span class="number">1</span>][<span class="number">1</span>]), <span class="built_in">cmx</span>(as, d[<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">if</span> (as.num &lt;= num + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">ans = as.v + <span class="built_in">LL</span>(mid) * (num + <span class="number">1</span>);</span><br><span class="line">r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="未完待续？"><a href="#未完待续？" class="headerlink" title="未完待续？"></a>未完待续？</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt; 然而我 dp 废的一比&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="笔记" scheme="https://dyd-true.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="优化" scheme="https://dyd-true.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
    <category term="wqs二分" scheme="https://dyd-true.github.io/tags/wqs%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>模板汇总</title>
    <link href="https://dyd-true.github.io/2022/05/29/%E6%A8%A1%E6%9D%BF%E6%B1%87%E6%80%BB/"/>
    <id>https://dyd-true.github.io/2022/05/29/%E6%A8%A1%E6%9D%BF%E6%B1%87%E6%80%BB/</id>
    <published>2022-05-29T02:56:18.000Z</published>
    <updated>2022-06-14T06:47:53.254Z</updated>
    
    <content type="html"><![CDATA[<p> rt</p><span id="more"></span><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>总结一下板子；顺序没有意义；尽量不会压行（但有时候略微压）；限于本人水平，有概率会错；有些东西的运用要视情况而定，会给出类似伪代码的东西，还有些之间用文字给出流程</p><p>关于编译选项，默认是 <code>-O2 -std=c++11 -Wl,--stack=1145141919</code></p><p>关于头文件，默认是万能头 <code>#include &lt;bits/stdc++.h&gt;</code> </p><p>关于宏（包括 <code>using</code> ），默认包含以下宏</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STC static</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> DB = <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> LDB = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="keyword">using</span> PR = std::pair&lt;T1, T2&gt;;</span><br><span class="line"><span class="keyword">using</span> PII = std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">std</span>:</span>:<span class="keyword">size_t</span> num&gt;</span><br><span class="line"><span class="keyword">using</span> AR = std::array&lt;T, num&gt;;</span><br></pre></td></tr></table></figure><p>大部分情况默认数据范围是 <code>int</code> </p><p>大部分情况默认 $P$ 为模数， $INF$ 为正无穷</p><p>如未特殊说明，那些写在外面的语句就是主函数里的</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span> <span class="keyword">int</span> ne, ver, w; &#125; e[M];</span><br><span class="line"><span class="keyword">int</span> h[N], idx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="built_in">memset</span>(h, <span class="number">-1</span>, (n + <span class="number">1</span>) * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)), idx = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>&#123; e[idx] = &#123;h[x], y, z&#125;, h[x] = idx++; &#125;</span><br></pre></td></tr></table></figure><p>使用前要初始化（如何使用： <code>for (int i = h[x]; ~i; i = e[i].ne)</code> ）</p><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">get</span>(fa[x]); &#125; <span class="comment">//路径压缩</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = <span class="built_in">get</span>(x), y = <span class="built_in">get</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (rk[x] &gt; rk[y]) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">    fa[x] = y, rk[y] += rk[x] == rk[y]; <span class="comment">//按秩合并</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>STL （大根堆）： <code>std::priority_queue&lt;int&gt; q;</code> </p><p>手打（小根堆）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Hp <span class="comment">//Heap</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> hp[N], tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">for</span> (; x &gt; <span class="number">1</span> &amp;&amp; hp[x] &lt; hp[x &gt;&gt; <span class="number">1</span>]; x &gt;&gt;= <span class="number">1</span>) std::<span class="built_in">swap</span>(hp[x], hp[x &gt;&gt; <span class="number">1</span>]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dw</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = x &lt;&lt; <span class="number">1</span>; y &lt;= tot; y = x &lt;&lt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (y &lt; tot &amp;&amp; hp[y + <span class="number">1</span>] &lt; hp[y]) ++y;</span><br><span class="line"><span class="keyword">if</span> (hp[y] &lt; hp[x])</span><br><span class="line">&#123;</span><br><span class="line">std::<span class="built_in">swap</span>(hp[y], hp[x]);</span><br><span class="line">x = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; hp[++tot] = x, <span class="built_in">up</span>(tot); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x = <span class="number">1</span>)</span></span>&#123; hp[x] = hp[tot--], <span class="built_in">up</span>(x), <span class="built_in">dw</span>(x); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>左偏树（小根堆）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> LH <span class="comment">//Left Heap</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> fa[N], tot; <span class="comment">//并查集维护根</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> <span class="keyword">int</span> lc, rc, v, dis; &#125; lh[N];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc lh[x].lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc lh[x].rc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> v(x) lh[(x)].v</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ds(x) lh[(x)].dis</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//新建一个只有值x的堆</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">lh[++tot] = &#123;<span class="number">0</span>, <span class="number">0</span>, x, <span class="number">0</span>&#125;;</span><br><span class="line">fa[tot] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> _merge(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">v</span>(x) &gt; <span class="built_in">v</span>(y)) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">rc = _merge(rc, y);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ds</span>(rc) &gt; <span class="built_in">ds</span>(lc)) std::<span class="built_in">swap</span>(rc, lc);</span><br><span class="line"><span class="built_in">ds</span>(x) = <span class="built_in">ds</span>(rc) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">get</span>(fa[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">v</span>(x) == <span class="number">-1</span> || <span class="built_in">v</span>(y) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">x = <span class="built_in">get</span>(x), y = <span class="built_in">get</span>(y);</span><br><span class="line"><span class="keyword">if</span> (x != y) <span class="keyword">return</span> fa[x] = fa[y] = _merge(x, y);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="built_in">v</span>(x) = <span class="number">-1</span>, fa[lc] = lc, fa[rc] = rc, fa[x] = <span class="built_in">merge</span>(lc, rc); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">v</span>(x) == <span class="number">-1</span> ? <span class="number">-1</span> : <span class="built_in">v</span>(<span class="built_in">get</span>(x)); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> v</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> ds</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树状树组"><a href="#树状树组" class="headerlink" title="树状树组"></a>树状树组</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> BIT</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(x) ((x) &amp; (-(x)))</span></span><br><span class="line"><span class="keyword">int</span> c[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span></span>&#123; <span class="keyword">for</span> (; x &lt;= n; x += <span class="built_in">lb</span>(x)) c[x] += d; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; x; x ^= <span class="built_in">lb</span>(x)) res += c[x];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> lb</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意下标必须从 $1$ 开始，否则会死循环</p><h2 id="ST-表"><a href="#ST-表" class="headerlink" title="ST 表"></a>ST 表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> ST</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mx[N][D], lg2[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prev</span><span class="params">(<span class="keyword">int</span> x[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) mx[i][<span class="number">0</span>] = x[i];</span><br><span class="line">lg2[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) lg2[i] = lg2[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> t = lg2[n] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; t; ++j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - (<span class="number">1</span> &lt;&lt; j) + <span class="number">1</span>; ++i) mx[i][j] = std::<span class="built_in">max</span>(mx[i][j - <span class="number">1</span>], mx[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = lg2[r - l + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">max</span>(mx[l][t], mx[r - (<span class="number">1</span> &lt;&lt; t) + <span class="number">1</span>][t]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四毛子"><a href="#四毛子" class="headerlink" title="四毛子"></a>四毛子</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> FR <span class="comment">//Four Russians</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> L = N &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span> <span class="keyword">int</span> lc, rc, dat; &#125; tr[N];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Block</span>&#123;</span> <span class="keyword">int</span> l, r, tp; &#125; b[N];</span><br><span class="line">    <span class="keyword">int</span> dfn[N], bid[L], cnt = <span class="number">0</span>, rt, num = <span class="number">0</span>, B, bk[L];</span><br><span class="line">    PII dat[L];</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">bool</span> <span class="title">cmn</span><span class="params">(T &amp;x, T y)</span></span>&#123; <span class="keyword">return</span> y &lt; x ? x = y, <span class="literal">true</span> : <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="keyword">namespace</span> ST</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> D = <span class="number">18</span>;</span><br><span class="line">        <span class="keyword">int</span> lg2[L];</span><br><span class="line">        PII mn[L][D];</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            lg2[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= num; ++i) lg2[i] = lg2[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++i) mn[i][<span class="number">0</span>] = dat[b[i].l + bk[b[i].tp] - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, t = lg2[num]; j &lt;= t; ++j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num - (<span class="number">1</span> &lt;&lt; j) + <span class="number">1</span>; ++i) mn[i][j] = std::<span class="built_in">min</span>(mn[i][j - <span class="number">1</span>], mn[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">PII <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> &#123;INF, INF&#125;;</span><br><span class="line">            <span class="keyword">int</span> t = lg2[r - l + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">min</span>(mn[l][t], mn[r - (<span class="number">1</span> &lt;&lt; t) + <span class="number">1</span>][t]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> x[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        FF&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>[])&gt; bct = [&amp;](<span class="keyword">int</span> len, <span class="keyword">int</span> x[])</span><br><span class="line">        &#123;</span><br><span class="line">            STC <span class="keyword">int</span> stk[N];</span><br><span class="line">            <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) tr[i].dat = x[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, k; i &lt;= len; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (k = top; k &amp;&amp; tr[stk[k]].dat &lt; tr[i].dat; --k);</span><br><span class="line">                <span class="keyword">if</span> (k) tr[stk[k]].rc = i;</span><br><span class="line">                <span class="keyword">if</span> (k &lt; top) tr[i].lc = stk[k + <span class="number">1</span>];</span><br><span class="line">                stk[top = k + <span class="number">1</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            rt = stk[<span class="number">1</span>];</span><br><span class="line">        &#125; ; </span><br><span class="line">        <span class="built_in">bct</span>(len, x);</span><br><span class="line">        FF&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> dep)</span><br><span class="line">        &#123;</span><br><span class="line">            dfn[x] = ++cnt, dat[cnt] = &#123;dep, x&#125;;</span><br><span class="line">            <span class="keyword">if</span> (tr[x].lc) <span class="built_in">dfs</span>(tr[x].lc, dep + <span class="number">1</span>), dat[++cnt] = &#123;dep, x&#125;;</span><br><span class="line">            <span class="keyword">if</span> (tr[x].rc) <span class="built_in">dfs</span>(tr[x].rc, dep + <span class="number">1</span>), dat[++cnt] = &#123;dep, x&#125;;</span><br><span class="line">        &#125; ;</span><br><span class="line">        <span class="built_in">dfs</span>(rt, <span class="number">1</span>);</span><br><span class="line">        B = <span class="built_in">log2</span>(cnt) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i += B) b[++num].l = i, b[num].r = i + B - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = cnt + <span class="number">1</span>; i &lt;= b[num].r; ++i) dat[i] = &#123;INF, INF&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = b[i].l; j &lt;= b[i].r; ++j) bid[j] = i;</span><br><span class="line">        FF&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>)&gt; calc = [&amp;](<span class="keyword">int</span> x)</span><br><span class="line">        &#123;</span><br><span class="line">            bk[x] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, mn = <span class="number">0</span>, sum = <span class="number">0</span>; i &lt;= B; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ((x &gt;&gt; (i - <span class="number">1</span>)) &amp; <span class="number">1</span>) ++sum;</span><br><span class="line">                <span class="keyword">else</span> --sum;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">cmn</span>(mn, sum)) bk[x] = i; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; ;</span><br><span class="line">        FF&lt;<span class="built_in"><span class="keyword">int</span></span>(Block)&gt; get_tp = [&amp;](Block x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = x.l + <span class="number">1</span>; i &lt;= x.r; ++i) res |= (dat[i].fi - dat[i - <span class="number">1</span>].fi &gt;= <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>) &lt;&lt; (i - x.l);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; ; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="number">1</span> &lt;&lt; B) - <span class="number">1</span>; ~i; --i) <span class="built_in">calc</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++i) b[i].tp = <span class="built_in">get_tp</span>(b[i]);</span><br><span class="line">        ST::<span class="built_in">init</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">PII <span class="title">to_ask</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="built_in">to_ask</span>(r, l);</span><br><span class="line">        FF&lt;<span class="built_in">PII</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; bask = [&amp;](<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span><br><span class="line">        &#123;</span><br><span class="line">            Block &amp;x = b[bid[l]];</span><br><span class="line">            <span class="keyword">int</span> t = x.tp, ll = l - x.l + <span class="number">1</span>, rr = r - x.l + <span class="number">1</span>;</span><br><span class="line">            t &gt;&gt;= ll - <span class="number">1</span>;</span><br><span class="line">            t |= ((<span class="number">1</span> &lt;&lt; (rr - ll + <span class="number">1</span>)) - <span class="number">1</span>) ^ ((<span class="number">1</span> &lt;&lt; B) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> dat[l + bk[t] - <span class="number">1</span>];</span><br><span class="line">        &#125; ;</span><br><span class="line">        <span class="keyword">if</span> (bid[l] == bid[r]) <span class="keyword">return</span> <span class="built_in">bask</span>(l, r); </span><br><span class="line">        PII res = std::<span class="built_in">min</span>(<span class="built_in">bask</span>(l, b[bid[l]].r), <span class="built_in">bask</span>(b[bid[r]].l, r));</span><br><span class="line">        <span class="keyword">if</span> (bid[r] - bid[l] &gt; <span class="number">1</span>) <span class="built_in">cmn</span>(res, ST::<span class="built_in">ask</span>(bid[l] + <span class="number">1</span>, bid[r] - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123; <span class="keyword">return</span> tr[<span class="built_in">to_ask</span>(dfn[l], dfn[r]).se].dat; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> LT</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> ... &#125; tr[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc (u &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc ((u &lt;&lt; 1) | 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adt</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> d)</span></span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dw</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">tg</span>(u))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">adt</span>(lc, <span class="built_in">tg</span>(u)), <span class="built_in">adt</span>(rc, <span class="built_in">tg</span>(u));</span><br><span class="line"><span class="built_in">tg</span>(u) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">(<span class="keyword">int</span> u = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tr[u] = &#123;<span class="number">0</span>, ...&#125;;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line"><span class="built_in">bd</span>(lc, l, mid), <span class="built_in">bd</span>(rc, mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="built_in">up</span>(u); <span class="comment">//有时候可以不要</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cg</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> d, <span class="keyword">int</span> u = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="built_in">adt</span>(u, d);</span><br><span class="line"><span class="built_in">dw</span>(u);</span><br><span class="line">pos &lt;= mid ? <span class="built_in">cg</span>(pos, d, lc, l, mid) : <span class="built_in">cg</span>(pos, d, rc, mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="built_in">up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mdf</span><span class="params">(<span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> d, <span class="keyword">int</span> u = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) <span class="built_in">adt</span>(u, d);</span><br><span class="line"><span class="built_in">dw</span>(u);</span><br><span class="line"><span class="keyword">if</span> (ql &lt;= mid) <span class="built_in">mdf</span>(ql, qr, d, lc, l, mid);</span><br><span class="line"><span class="keyword">if</span> (qr &gt; mid) <span class="built_in">mdf</span>(ql, qr, d, rc, mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="built_in">up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> u = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> ...;</span><br><span class="line"><span class="built_in">dw</span>(u);</span><br><span class="line"><span class="keyword">return</span> pos &lt;= mid ? <span class="built_in">ask</span>(pos, lc, l, mid) : <span class="built_in">ask</span>(pos, rc, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> u = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) <span class="keyword">return</span> ...;</span><br><span class="line"><span class="built_in">dw</span>(u);</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (ql &lt;= mid) res ? <span class="built_in">qry</span>(ql, qr, lc, l, mid); <span class="comment">//?表示某种运算</span></span><br><span class="line"><span class="keyword">if</span> (qr &gt; mid) res ? <span class="built_in">qry</span>(ql, qr, rc, mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> mid</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意空间开 $4$ 倍</p><h2 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">读入</span><br><span class="line">将询问按照(l所在块号，r)双关键字排序</span><br><span class="line">依次处理每一个询问:</span><br><span class="line">移动指针</span><br><span class="line">    维护答案</span><br><span class="line">输出</span><br></pre></td></tr></table></figure><h2 id="莫队二次离线"><a href="#莫队二次离线" class="headerlink" title="莫队二次离线"></a>莫队二次离线</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> TOF <span class="comment">//Twice Offline</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">320</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Tag</span>&#123;</span> <span class="keyword">int</span> l, r, id, pos; &#125; tg1[N], tg2[N]; <span class="comment">//用vector可以不必排序,但慢一些,且有时候不好优化</span></span><br><span class="line">    <span class="keyword">int</span> tp1 = <span class="number">0</span>, tp2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> bid[N], f[<span class="number">2</span>][N]; <span class="comment">//f[0/1][i]:f(i,[1,i-1/i+1])</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prev</span><span class="params">()</span> <span class="comment">//处理块号并排序询问</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) bid[i] = (i - <span class="number">1</span>) / B + <span class="number">1</span>;</span><br><span class="line">        std::<span class="built_in">sort</span>(q + <span class="number">1</span>, q + m + <span class="number">1</span>, [&amp;](Q x, Q y)&#123; <span class="keyword">return</span> bid[x.l] == bid[y.l] ? x.r &lt; y.r : x.l &lt; y.l; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_tag</span><span class="params">()</span> <span class="comment">//打上离线标记</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, il = q[<span class="number">1</span>].r + <span class="number">1</span>, ir = q[<span class="number">1</span>].r; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (il &gt; q[i].l) tg1[++tp1] = &#123;q[i].l, il - <span class="number">1</span>, -i, ir&#125;;</span><br><span class="line">            <span class="keyword">else</span>  <span class="keyword">if</span> (il &lt; q[i].l) tg1[++tp1] = &#123;il, q[i].l - <span class="number">1</span>, i, ir&#125;; </span><br><span class="line">            il = q[i].l; <span class="comment">//一定要记得移动指针</span></span><br><span class="line">            <span class="keyword">if</span> (ir &lt; q[i].r) tg2[++tp2] = &#123;ir + <span class="number">1</span>, q[i].r, -i, il - <span class="number">1</span>&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ir &gt; q[i].r) tg2[++tp2] = &#123;q[i].r + <span class="number">1</span>, ir, i, il - <span class="number">1</span>&#125;;</span><br><span class="line">            ir = q[i].r;</span><br><span class="line">        &#125;</span><br><span class="line">        std::<span class="built_in">sort</span>(tg1 + <span class="number">1</span>, tg1 + tp1 + <span class="number">1</span>, [&amp;](Tag x, Tag y)&#123; <span class="keyword">return</span> x.pos &lt; y.pos; &#125;); <span class="comment">//标记排序</span></span><br><span class="line">        std::<span class="built_in">sort</span>(tg2 + <span class="number">1</span>, tg2 + tp2 + <span class="number">1</span>, [&amp;](Tag x, Tag y)&#123; <span class="keyword">return</span> x.pos &lt; y.pos; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">offline</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tp2; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (p &lt; tg2[i].pos &amp;&amp; ++p)</span><br><span class="line">            &#123;</span><br><span class="line">计算f[<span class="number">0</span>][p]</span><br><span class="line">完成a[p]的修改</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = tg2[i].l, r = tg2[i].r, k = (tg2[i].id &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>), id = tg2[i].id * k; l &lt;= r; ++l) q[id].ans += (计算贡献) * k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p &lt; n &amp;&amp; ++p)</span><br><span class="line">        &#123;</span><br><span class="line">            计算f[<span class="number">0</span>][p]</span><br><span class="line">完成a[p]的修改</span><br><span class="line">        &#125;</span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tp1; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (p &lt; tg1[i].pos &amp;&amp; ++p)</span><br><span class="line">            &#123;</span><br><span class="line">完成a[p]的修改</span><br><span class="line">                计算f[<span class="number">1</span>][p]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = tg1[i].l, r = tg1[i].r, k = (tg1[i].id &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>), id = tg1[i].id * k; l &lt;= r; ++l) q[id].ans += (计算贡献) * k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p &lt; n &amp;&amp; ++p)</span><br><span class="line">        &#123;</span><br><span class="line">            完成a[p]的修改</span><br><span class="line">            计算f[<span class="number">1</span>][p]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modui</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, il = q[<span class="number">1</span>].r + <span class="number">1</span>, ir = q[<span class="number">1</span>].r; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (il != q[i].l) q[i].ans += f[<span class="number">1</span>][il - <span class="number">1</span>] - f[<span class="number">1</span>][q[i].l - <span class="number">1</span>];</span><br><span class="line">            il = q[i].l;</span><br><span class="line">            <span class="keyword">if</span> (ir != q[i].r) q[i].ans += f[<span class="number">0</span>][q[i].r] - f[<span class="number">0</span>][ir];</span><br><span class="line">            ir = q[i].r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) q[i].ans += q[i - <span class="number">1</span>].ans; <span class="comment">//前缀和后才是答案</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) ans[q[i].id] = q[i].ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123; <span class="built_in">prev</span>(), <span class="built_in">add_tag</span>(), <span class="built_in">offline</span>(), <span class="built_in">modui</span>(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h2><p>额……，略</p><h2 id="点分治"><a href="#点分治" class="headerlink" title="点分治"></a>点分治</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_si</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = e[i].ne) <span class="keyword">if</span> (e[i].ver != fa) res += <span class="built_in">get_si</span>(e[i].ver, x);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_wc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> si, <span class="keyword">int</span> &amp;wc)</span> <span class="comment">//求重心(其实是一个保证删去后子树大小小于n/2的点,不一定是重心)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">1</span>, mx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y, t; ~i; i = e[i].ne) <span class="keyword">if</span> ((y = e[i].ver) != fa)</span><br><span class="line">&#123;</span><br><span class="line">t = <span class="built_in">get_wc</span>(y, x, si, wc);</span><br><span class="line">mx = <span class="built_in">max</span>(mx, t);</span><br><span class="line">sum += t;</span><br><span class="line">&#125;</span><br><span class="line">mx = <span class="built_in">max</span>(mx, si - sum);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">LL</span>(mx &lt;&lt; <span class="number">1</span>) &lt;= si) wc = x;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//cp,cq是p[],q[]的计数器</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">get_wc</span>(x, <span class="number">-1</span>, <span class="built_in">get_si</span>(x, <span class="number">-1</span>), x);</span><br><span class="line">del[x] = <span class="literal">true</span>;</span><br><span class="line">cp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line">cq = <span class="number">0</span>;</span><br><span class="line">得到y子树的,记录在q[]中</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cq; ++j)</span><br><span class="line">&#123;</span><br><span class="line">利用q[j]计算答案</span><br><span class="line">将q[j]的信息记录在p[]中</span><br><span class="line">&#125;</span><br><span class="line">可能需要修正一些偏差量(比如多算的减掉)</span><br><span class="line">&#125;</span><br><span class="line">用p[]还原q[]计算时的修改</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = e[i].ne) res += <span class="built_in">calc</span>(e[i].ver);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h2><p>STL1 ： <code>std::set&lt;int&gt; s;</code> </p><p>STL2  ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ext/pb_ds/assoc_container.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ext/pb_ds/tree_policy.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_pbds;</span><br><span class="line">tree&lt;LL, null_type, less&lt;LL&gt;, rb_tree_tag,tree_order_statistics_node_update&gt; tr;</span><br><span class="line">函数为:</span><br><span class="line">tr.<span class="built_in">insert</span>(val);</span><br><span class="line">tr.<span class="built_in">erase</span>(tr.<span class="built_in">lower_bound</span>(val));</span><br><span class="line">tr.<span class="built_in">order_of_key</span>(val);</span><br><span class="line">tr.<span class="built_in">find_by_order</span>(rank);</span><br><span class="line">tr.<span class="built_in">lower_bound</span>(val)</span><br><span class="line">tr.<span class="built_in">upper_bound</span>(val)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Splay ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Splay</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> rt, tot;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> <span class="keyword">int</span> ch[<span class="number">2</span>], fa, val, size, tag, cnt; &#125; tr[N];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ch(x, y) tr[(x)].ch[(y)]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fa(x) tr[(x)].fa</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> v(x) tr[(x)].val</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> si(x) tr[(x)].size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> tg(x) tr[(x)].tag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> c(x) tr[(x)].cnt</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="built_in">si</span>(x) = <span class="built_in">si</span>(<span class="built_in">ch</span>(x, <span class="number">0</span>)) + <span class="built_in">si</span>(<span class="built_in">ch</span>(x, <span class="number">1</span>)) + <span class="built_in">c</span>(x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dw</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//文艺平衡树的交换</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">tg</span>(x))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">tg</span>(<span class="built_in">ch</span>(x, <span class="number">0</span>)) ^= <span class="number">1</span>, <span class="built_in">tg</span>(<span class="built_in">ch</span>(x, <span class="number">1</span>)) ^= <span class="number">1</span>;</span><br><span class="line"><span class="built_in">tg</span>(x) = <span class="number">0</span>;</span><br><span class="line">std::<span class="built_in">swap</span>(<span class="built_in">ch</span>(x, <span class="number">0</span>), <span class="built_in">ch</span>(x, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rot</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> y = <span class="built_in">fa</span>(x), z = <span class="built_in">fa</span>(y);</span><br><span class="line"><span class="keyword">int</span> k = <span class="built_in">ch</span>(y, <span class="number">1</span>) == x;</span><br><span class="line"><span class="built_in">ch</span>(z, <span class="built_in">ch</span>(z, <span class="number">1</span>) == y) = x, <span class="built_in">fa</span>(x) = z;</span><br><span class="line"><span class="built_in">ch</span>(y, k) = <span class="built_in">ch</span>(x, k ^ <span class="number">1</span>), <span class="built_in">fa</span>(<span class="built_in">ch</span>(x, k ^ <span class="number">1</span>)) = y;</span><br><span class="line"><span class="built_in">ch</span>(x, k ^ <span class="number">1</span>) = y, <span class="built_in">fa</span>(y) = x;</span><br><span class="line"><span class="built_in">up</span>(y), <span class="built_in">up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">fa</span>(x) != f)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> y = <span class="built_in">fa</span>(x), z = <span class="built_in">fa</span>(y);</span><br><span class="line"><span class="keyword">if</span> (z != f) (<span class="built_in">ch</span>(y, <span class="number">1</span>) == x) ^ (<span class="built_in">ch</span>(z, <span class="number">1</span>) == y) ? <span class="built_in">rot</span>(x) : <span class="built_in">rot</span>(y);</span><br><span class="line"><span class="built_in">rot</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!f) rt = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> u = rt;</span><br><span class="line"><span class="keyword">if</span> (!u) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">while</span> (x != <span class="built_in">v</span>(u) &amp;&amp; <span class="built_in">ch</span>(u, x &gt; <span class="built_in">v</span>(u)) ) u = <span class="built_in">ch</span>(u, x &gt; <span class="built_in">v</span>(u));</span><br><span class="line"><span class="built_in">splay</span>(u, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">near</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> dir)</span> <span class="comment">//查询前驱(0)后继(1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">find</span>(x);</span><br><span class="line"><span class="keyword">int</span> u = rt;</span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">v</span>(u) &gt; x &amp;&amp; dir) || (<span class="built_in">v</span>(u) &lt; x &amp;&amp; !dir)) <span class="keyword">return</span> u;</span><br><span class="line">u = <span class="built_in">ch</span>(u, dir);</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">ch</span>(u, dir ^ <span class="number">1</span>)) u = <span class="built_in">ch</span>(u, dir ^ <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> last = <span class="built_in">near</span>(x, <span class="number">0</span>), next = <span class="built_in">near</span>(x, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">splay</span>(last, <span class="number">0</span>), <span class="built_in">splay</span>(next, last);</span><br><span class="line"><span class="keyword">int</span> t = <span class="built_in">ch</span>(next, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">c</span>(t) &gt; <span class="number">1</span>) --<span class="built_in">c</span>(t), <span class="built_in">splay</span>(t, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">ch</span>(next, <span class="number">0</span>) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> u = rt, f = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (u &amp;&amp; <span class="built_in">v</span>(u) != x) f = u, u = <span class="built_in">ch</span>(u, x &gt; <span class="built_in">v</span>(u));</span><br><span class="line"><span class="keyword">if</span> (u) ++<span class="built_in">c</span>(u);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">u = ++tot;</span><br><span class="line"><span class="keyword">if</span> (f) <span class="built_in">ch</span>(f, x &gt; <span class="built_in">v</span>(f)) = u;</span><br><span class="line">tr[u] = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, f, x, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">splay</span>(u, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_k</span><span class="params">(<span class="keyword">int</span> k)</span> <span class="comment">//查询排名为k的数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> u = rt;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">si</span>(u) &lt; k) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">dw</span>(u);</span><br><span class="line"><span class="keyword">int</span> y = <span class="built_in">ch</span>(u, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (k &gt; <span class="built_in">si</span>(y) + <span class="built_in">c</span>(u)) k -= <span class="built_in">si</span>(y) + <span class="built_in">c</span>(u), u = <span class="built_in">ch</span>(u, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">si</span>(y) &gt;= k) u = y;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">v</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> ch</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> fa</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> v</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> si</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> tg</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点是可拓展性强，缺点是慢（被卡的化可以试试多转几下）</p><p>FHQ Treap ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> FHQ</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> <span class="keyword">int</span> priority, size, val, left_child, right_child; &#125; tr[N];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> p(x) tr[(x)].priority</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> si(x) tr[(x)].size</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> v(x) tr[(x)].val</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc(x) tr[(x)].left_child</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc(x) tr[(x)].right_child</span></span><br><span class="line">    <span class="keyword">int</span> rub[N], top = <span class="number">0</span>, num = <span class="number">0</span>, rt;</span><br><span class="line">    <span class="function">std::mt19937 <span class="title">rud</span><span class="params">(<span class="number">114514</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="built_in">si</span>(x) = <span class="built_in">si</span>(<span class="built_in">lc</span>(x)) + <span class="built_in">si</span>(<span class="built_in">rc</span>(x)) + <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnd</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = (top ? rub[top--] : ++num);</span><br><span class="line">        tr[res] = &#123;(<span class="keyword">int</span>)<span class="built_in">rud</span>(), <span class="number">1</span>, val, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">//合并以x,y为根的树,返回合并后的根(要保证x的val都小于y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">p</span>(x) &gt; <span class="built_in">p</span>(y))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">rc</span>(x) = <span class="built_in">merge</span>(<span class="built_in">rc</span>(x), y);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">up</span>(x), x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">lc</span>(y) = <span class="built_in">merge</span>(x, <span class="built_in">lc</span>(y));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">up</span>(y), y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> val, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span> <span class="comment">//把以u为根的树分裂为x,y</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!u) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(x = y = <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">v</span>(u) &lt;= val) <span class="built_in">split</span>(<span class="built_in">rc</span>(x = u), val, <span class="built_in">rc</span>(u), y);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">split</span>(<span class="built_in">lc</span>(y = u), val, x, <span class="built_in">lc</span>(u));</span><br><span class="line">        <span class="built_in">up</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tx, ty;</span><br><span class="line">        <span class="built_in">split</span>(rt, val, tx, ty), rt = <span class="built_in">merge</span>(<span class="built_in">merge</span>(tx, <span class="built_in">newnd</span>(val)), ty);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tx, ty, tz;</span><br><span class="line">        <span class="built_in">split</span>(rt, val, tx, ty);</span><br><span class="line">        <span class="built_in">split</span>(tx, val - <span class="number">1</span>, tx, tz);</span><br><span class="line">        rub[++top] = tz;</span><br><span class="line">        tz = <span class="built_in">merge</span>(<span class="built_in">lc</span>(tz), <span class="built_in">rc</span>(tz));</span><br><span class="line">        rt = <span class="built_in">merge</span>(<span class="built_in">merge</span>(tx, tz), ty);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rank</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tx, ty, res;</span><br><span class="line">        <span class="built_in">split</span>(rt, val - <span class="number">1</span>, tx, ty);</span><br><span class="line">        res = <span class="built_in">si</span>(tx) + <span class="number">1</span>;</span><br><span class="line">        rt = <span class="built_in">merge</span>(tx, ty);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getk</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t; u; )</span><br><span class="line">            <span class="keyword">if</span> ((t = <span class="built_in">si</span>(<span class="built_in">lc</span>(u)) + <span class="number">1</span>) == k) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t &gt; k) u = <span class="built_in">lc</span>(u);</span><br><span class="line">            <span class="keyword">else</span> k -= t, u = <span class="built_in">rc</span>(u);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">v</span>(u); <span class="comment">//可视题目改</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getk</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">getk</span>(rt, k); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tx, ty, res;</span><br><span class="line">        <span class="built_in">split</span>(rt, val - <span class="number">1</span>, tx, ty);</span><br><span class="line">        res = <span class="built_in">getk</span>(tx, <span class="built_in">si</span>(tx));</span><br><span class="line">        rt = <span class="built_in">merge</span>(tx, ty);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">suc</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tx, ty, res;</span><br><span class="line">        <span class="built_in">split</span>(rt, val, tx, ty);</span><br><span class="line">        res = <span class="built_in">getk</span>(ty, <span class="number">1</span>);</span><br><span class="line">        rt = <span class="built_in">merge</span>(tx, ty);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> p</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> si</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> v</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点是好打且较快</p><p>SBT ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> SBT</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SBT</span>&#123;</span> <span class="keyword">int</span> size, lc, rc, val; &#125; tr[N];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> si(x) tr[(x)].size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc(x) tr[(x)].rc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc(x) tr[(x)].lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> v(x) tr[(x)].val</span></span><br><span class="line"><span class="keyword">int</span> rt, tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r_r</span><span class="params">(<span class="keyword">int</span> &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = <span class="built_in">lc</span>(t);</span><br><span class="line"><span class="built_in">lc</span>(t) = <span class="built_in">rc</span>(k), <span class="built_in">rc</span>(k) = t;</span><br><span class="line"><span class="built_in">si</span>(k) = <span class="built_in">si</span>(t), <span class="built_in">si</span>(t) = <span class="built_in">si</span>(<span class="built_in">rc</span>(t)) + <span class="built_in">si</span>(<span class="built_in">lc</span>(t)) + <span class="number">1</span>;</span><br><span class="line">t = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">l_r</span><span class="params">(<span class="keyword">int</span> &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = <span class="built_in">rc</span>(t);</span><br><span class="line"><span class="built_in">rc</span>(t) = <span class="built_in">lc</span>(k), <span class="built_in">lc</span>(k) = t;</span><br><span class="line"><span class="built_in">si</span>(k) = <span class="built_in">si</span>(t), <span class="built_in">si</span>(t) = <span class="built_in">si</span>(<span class="built_in">rc</span>(t)) + <span class="built_in">si</span>(<span class="built_in">lc</span>(t)) + <span class="number">1</span>;</span><br><span class="line">t = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mt</span><span class="params">(<span class="keyword">int</span> &amp;t, <span class="keyword">bool</span> f)</span> <span class="comment">//maintain</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!f)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">si</span>(<span class="built_in">lc</span>(<span class="built_in">lc</span>(t))) &gt; <span class="built_in">si</span>(<span class="built_in">rc</span>(t))) <span class="built_in">r_r</span>(t);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">si</span>(<span class="built_in">rc</span>(<span class="built_in">lc</span>(t))) &gt; <span class="built_in">si</span>(<span class="built_in">rc</span>(t))) <span class="built_in">l_r</span>(<span class="built_in">lc</span>(t)), <span class="built_in">r_r</span>(t);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">si</span>(<span class="built_in">rc</span>(<span class="built_in">rc</span>(t))) &gt; <span class="built_in">si</span>(<span class="built_in">lc</span>(t))) <span class="built_in">l_r</span>(t);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">si</span>(<span class="built_in">lc</span>(<span class="built_in">rc</span>(t))) &gt; <span class="built_in">si</span>(<span class="built_in">lc</span>(t))) <span class="built_in">r_r</span>(<span class="built_in">rc</span>(t)), <span class="built_in">l_r</span>(t);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">mt</span>(<span class="built_in">lc</span>(t), <span class="literal">false</span>), <span class="built_in">mt</span>(<span class="built_in">rc</span>(t), <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">mt</span>(t, <span class="literal">false</span>), <span class="built_in">mt</span>(t, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> &amp;t, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!t) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(tr[t = ++tot] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, x&#125;);</span><br><span class="line">++<span class="built_in">si</span>(t);</span><br><span class="line">x &lt;= <span class="built_in">v</span>(t) ? <span class="built_in">ins</span>(<span class="built_in">lc</span>(t), x) : <span class="built_in">ins</span>(<span class="built_in">rc</span>(t), x);</span><br><span class="line"><span class="built_in">mt</span>(t, x &gt; <span class="built_in">v</span>(t));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> &amp;t, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">--<span class="built_in">si</span>(t);</span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">v</span>(t) == x) || (<span class="built_in">v</span>(t) &gt; x &amp;&amp; !<span class="built_in">lc</span>(t)) || (<span class="built_in">v</span>(t) &lt; x &amp;&amp; !<span class="built_in">rc</span>(t)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="built_in">v</span>(t);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">lc</span>(t) || !<span class="built_in">rc</span>(t)) t = <span class="built_in">lc</span>(t) + <span class="built_in">rc</span>(t);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">v</span>(t) = <span class="built_in">del</span>(<span class="built_in">lc</span>(t), <span class="built_in">v</span>(t) + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">v</span>(t) &gt; x ? <span class="built_in">del</span>(<span class="built_in">lc</span>(t), x) : <span class="built_in">del</span>(<span class="built_in">rc</span>(t), x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rk</span><span class="params">(<span class="keyword">int</span> &amp;t, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">v</span>(t) &gt;= x ? <span class="built_in">rk</span>(<span class="built_in">lc</span>(t), x) : <span class="built_in">si</span>(<span class="built_in">lc</span>(t)) + <span class="number">1</span> + <span class="built_in">rk</span>(<span class="built_in">rc</span>(t), x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_k</span><span class="params">(<span class="keyword">int</span> &amp;t, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="built_in">si</span>(<span class="built_in">lc</span>(t)) + <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">v</span>(t);</span><br><span class="line"><span class="keyword">return</span> x &lt;= <span class="built_in">si</span>(<span class="built_in">lc</span>(t)) ? <span class="built_in">get_k</span>(<span class="built_in">lc</span>(t), x) : <span class="built_in">get_k</span>(<span class="built_in">rc</span>(t), x - <span class="number">1</span> - <span class="built_in">si</span>(<span class="built_in">lc</span>(t)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pred</span><span class="params">(<span class="keyword">int</span> &amp;t, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!t) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">if</span> (x &lt;= <span class="built_in">v</span>(t)) <span class="keyword">return</span> <span class="built_in">pred</span>(<span class="built_in">lc</span>(t), x);</span><br><span class="line"><span class="keyword">int</span> res = <span class="built_in">pred</span>(<span class="built_in">rc</span>(t), x);</span><br><span class="line"><span class="keyword">if</span> (res == x) res = <span class="built_in">v</span>(t);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">succ</span><span class="params">(<span class="keyword">int</span> &amp;t, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!t) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= <span class="built_in">v</span>(t)) <span class="keyword">return</span> <span class="built_in">succ</span>(<span class="built_in">rc</span>(t), x);</span><br><span class="line"><span class="keyword">int</span> res = <span class="built_in">succ</span>(<span class="built_in">lc</span>(t), x);</span><br><span class="line"><span class="keyword">if</span> (res == x) res = <span class="built_in">v</span>(t);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> si</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> v</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点是快</p><h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> SL <span class="comment">//Skip List</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> D = <span class="number">15</span>;</span><br><span class="line">    <span class="function">std::mt19937 <span class="title">rud</span><span class="params">(<span class="number">114514</span>)</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        Node *nx = <span class="literal">nullptr</span>, *dw = <span class="literal">nullptr</span>; <span class="comment">//后继,下层</span></span><br><span class="line">        <span class="keyword">int</span> v = <span class="number">0</span>, si = <span class="number">0</span>, lvl = <span class="number">0</span>; <span class="comment">//权值,对应范围的大小,层数</span></span><br><span class="line">    &#125; pool[N &lt;&lt; <span class="number">2</span>], *upd[D + <span class="number">1</span>], *rt; <span class="comment">//池,待跟新,根</span></span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="function">Node* <span class="title">newnd</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> &amp;pool[++tot]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(Node *u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;dw == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(u-&gt;si = (u-&gt;v != -INF));</span><br><span class="line">        Node *end = u-&gt;nx == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : u-&gt;nx-&gt;dw;</span><br><span class="line">        u-&gt;si = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node *it = u-&gt;dw; it != end; it = it-&gt;nx) u-&gt;si += it-&gt;si;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> val, Node *u = rt)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        upd[u-&gt;lvl] = u;</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;nx != <span class="literal">nullptr</span> &amp;&amp; u-&gt;nx-&gt;v &lt;= val) <span class="keyword">return</span> <span class="built_in">find</span>(val, u-&gt;nx);</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;dw != <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="built_in">find</span>(val, u-&gt;dw);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        rt = <span class="built_in">newnd</span>();</span><br><span class="line">        rt-&gt;lvl = <span class="number">1</span>, rt-&gt;v = -INF, upd[<span class="number">1</span>] = rt;</span><br><span class="line">        Node *t = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (rt-&gt;lvl &lt; D)</span><br><span class="line">        &#123;</span><br><span class="line">            t = rt, rt = <span class="built_in">newnd</span>();</span><br><span class="line">            upd[rt-&gt;lvl = t-&gt;lvl + <span class="number">1</span>] = rt;</span><br><span class="line">            rt-&gt;dw = t, rt-&gt;v = -INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">find</span>(val - <span class="number">1</span>);</span><br><span class="line">        Node *p = <span class="built_in">newnd</span>(), *t = <span class="literal">nullptr</span>;</span><br><span class="line">        p-&gt;v = val, p-&gt;nx = upd[<span class="number">1</span>]-&gt;nx, upd[<span class="number">1</span>]-&gt;nx = p;</span><br><span class="line">        <span class="built_in">up</span>(upd[<span class="number">1</span>]);</span><br><span class="line">        upd[p-&gt;lvl = <span class="number">1</span>] = p;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;lvl &lt; D &amp;&amp; !(<span class="built_in">rud</span>() &amp; <span class="number">2</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            t = p, p = <span class="built_in">newnd</span>();</span><br><span class="line">            p-&gt;lvl = t-&gt;lvl + <span class="number">1</span>, p-&gt;v = val, p-&gt;dw = t;</span><br><span class="line">            p-&gt;nx = upd[p-&gt;lvl]-&gt;nx, upd[p-&gt;lvl]-&gt;nx = p;</span><br><span class="line">            <span class="built_in">up</span>(upd[p-&gt;lvl]);</span><br><span class="line">            upd[p-&gt;lvl] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= D; ++i) <span class="built_in">up</span>(upd[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">find</span>(val - <span class="number">1</span>);</span><br><span class="line">        Node *t = <span class="literal">nullptr</span>; <span class="keyword">bool</span> f = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= D; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (f &amp;&amp; upd[i]-&gt;nx != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">1</span> &amp;&amp; upd[i]-&gt;nx-&gt;dw != t) f = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> t = upd[i]-&gt;nx, upd[i]-&gt;nx = t-&gt;nx;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">up</span>(upd[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rk</span><span class="params">(<span class="keyword">int</span> val, Node *u = rt)</span> <span class="comment">//查小于val的数的个数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;nx != <span class="literal">nullptr</span> &amp;&amp; u-&gt;nx-&gt;v &lt; val) <span class="keyword">return</span> u-&gt;si + <span class="built_in">rk</span>(val, u-&gt;nx);</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;dw != <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="built_in">rk</span>(val, u-&gt;dw);</span><br><span class="line">        <span class="keyword">return</span> u-&gt;si;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> k, Node *u = rt)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;si &lt; k) <span class="keyword">return</span> <span class="built_in">kth</span>(k - u-&gt;si, u-&gt;nx);</span><br><span class="line">        <span class="keyword">return</span> u-&gt;dw == <span class="literal">nullptr</span> ? u-&gt;v : <span class="built_in">kth</span>(k, u-&gt;dw);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">find</span>(val - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> upd[<span class="number">1</span>]-&gt;v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">suc</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">find</span>(val);</span><br><span class="line">        <span class="keyword">return</span> upd[<span class="number">1</span>]-&gt;nx-&gt;v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CDQ-分治"><a href="#CDQ-分治" class="headerlink" title="CDQ 分治"></a>CDQ 分治</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdq</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cdq</span>(l, mid);</span><br><span class="line">    计算[l, mid]对[mid + <span class="number">1</span>, r]的影响/计算跨过mid的贡献</span><br><span class="line">    <span class="built_in">cdq</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个顺序不是严格的，可以先左右都递归了再计算中间</p><h2 id="李超线段树"><a href="#李超线段树" class="headerlink" title="李超线段树"></a>李超线段树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> k; LL b;</span><br><span class="line">    <span class="function">LL <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> dis[bid[x]] * k + b; &#125;</span><br><span class="line">&#125; li[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">namespace</span> LC</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> std::max;</span><br><span class="line">    <span class="keyword">using</span> std::min;</span><br><span class="line">    <span class="keyword">int</span> id[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    LL mn[N &lt;&lt; <span class="number">4</span>];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mid (l + r &gt;&gt; 1)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc (u &lt;&lt; 1)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc (u &lt;&lt; 1 | 1)</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> li[a].<span class="built_in">calc</span>(x) &gt; li[b].<span class="built_in">calc</span>(x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mn[u] = <span class="built_in">min</span>(mn[u], <span class="built_in">min</span>(li[id[u]].<span class="built_in">calc</span>(l), li[id[u]].<span class="built_in">calc</span>(r)));</span><br><span class="line">mn[u] = <span class="built_in">min</span>(mn[u], <span class="built_in">min</span>(mn[lc], mn[rc])); </span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">judge</span>(id[u], d, mid)) std::<span class="built_in">swap</span>(id[u], d);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">judge</span>(id[u], d, l)) <span class="built_in">upd</span>(lc, l, mid, ql, qr, d);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">judge</span>(id[u], d, r)) <span class="built_in">upd</span>(rc, mid + <span class="number">1</span>, r, ql, qr, d);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">up</span>(u, l, r); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= mid) <span class="built_in">upd</span>(lc, l, mid, ql, qr, d);</span><br><span class="line">        <span class="keyword">if</span> (qr &gt; mid) <span class="built_in">upd</span>(rc, mid + <span class="number">1</span>, r, ql, qr, d);</span><br><span class="line">        <span class="built_in">up</span>(u, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">LL <span class="title">ask</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) <span class="keyword">return</span> mn[u];</span><br><span class="line">        LL res = <span class="built_in">min</span>(li[id[u]].<span class="built_in">calc</span>(<span class="built_in">max</span>(l, ql)), li[id[u]].<span class="built_in">calc</span>(<span class="built_in">min</span>(r, qr)));</span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= mid) res = <span class="built_in">min</span>(res, <span class="built_in">ask</span>(lc, l, mid, ql, qr));</span><br><span class="line">        <span class="keyword">if</span> (qr &gt; mid) res = <span class="built_in">min</span>(res, <span class="built_in">ask</span>(rc, mid + <span class="number">1</span>, r, ql, qr));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> mid</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主席树"><a href="#主席树" class="headerlink" title="主席树"></a>主席树</h2><p>普通：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> CT <span class="comment">//Chairman Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> NN = <span class="number">5e6</span> + <span class="number">100</span>; <span class="comment">//点一定要开够</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> <span class="keyword">int</span> lc, rc, dat; &#125; tr[NN];</span><br><span class="line">    <span class="keyword">int</span> rt[N], tot = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc(x) tr[(x)].lc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc(x) tr[(x)].rc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> dat(x) tr[(x)].dat</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">(<span class="keyword">int</span> &amp;u, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        u = ++tot;</span><br><span class="line">        tr[u] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) <span class="built_in">bd</span>(<span class="built_in">lc</span>(u), l, mid), <span class="built_in">bd</span>(<span class="built_in">rc</span>(u), mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cg</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> d, <span class="keyword">int</span> &amp;u, <span class="keyword">int</span> la, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        u = ++tot;</span><br><span class="line">        tr[u] = tr[la];</span><br><span class="line">        <span class="built_in">dat</span>(u) += d;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line">        (pos &lt;= mid) ? <span class="built_in">cg</span>(pos, d, <span class="built_in">lc</span>(u), <span class="built_in">lc</span>(la), l, mid) : <span class="built_in">cg</span>(pos, d, <span class="built_in">rc</span>(u), <span class="built_in">rc</span>(la), mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> ul, <span class="keyword">int</span> ur, <span class="keyword">int</span> k, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="built_in">dat</span>(<span class="built_in">lc</span>(ur)) - <span class="built_in">dat</span>(<span class="built_in">lc</span>(ul));</span><br><span class="line">        <span class="keyword">return</span> (t &gt;= k) ? <span class="built_in">ask</span>(<span class="built_in">lc</span>(ul), <span class="built_in">lc</span>(ur), k, l, mid) : <span class="built_in">ask</span>(<span class="built_in">rc</span>(ul), <span class="built_in">rc</span>(ur), k - t, mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> dat</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> mid </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>带修：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> BIT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> NN = <span class="number">6e7</span> + <span class="number">100</span>, D = <span class="number">20</span>; <span class="comment">//任然是空间要开够</span></span><br><span class="line">    <span class="keyword">int</span> rts[<span class="number">2</span>][D];</span><br><span class="line">    <span class="keyword">namespace</span> CT</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> <span class="keyword">int</span> lc, rc, cnt; &#125; tr[NN];</span><br><span class="line">        <span class="keyword">int</span> rt[N], tot = <span class="number">0</span>;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> lc(x) tr[(x)].lc</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> rc(x) tr[(x)].rc</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> ct(x) tr[(x)].cnt</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">cg</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> d, <span class="keyword">int</span> &amp;u, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = num)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!u) u = ++tot;</span><br><span class="line">            <span class="built_in">ct</span>(u) += d;</span><br><span class="line">            <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line">            (pos &lt;= mid) ? <span class="built_in">cg</span>(pos, d, <span class="built_in">lc</span>(u), l, mid) : <span class="built_in">cg</span>(pos, d, <span class="built_in">rc</span>(u), mid + <span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = num)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = rts[<span class="number">1</span>][<span class="number">0</span>]; i; --i) sum += <span class="built_in">ct</span>(<span class="built_in">lc</span>(rts[<span class="number">1</span>][i]));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = rts[<span class="number">0</span>][<span class="number">0</span>]; i; --i) sum -= <span class="built_in">ct</span>(<span class="built_in">lc</span>(rts[<span class="number">0</span>][i]));</span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = rts[<span class="number">1</span>][<span class="number">0</span>]; i; --i) rts[<span class="number">1</span>][i] = <span class="built_in">lc</span>(rts[<span class="number">1</span>][i]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = rts[<span class="number">0</span>][<span class="number">0</span>]; i; --i) rts[<span class="number">0</span>][i] = <span class="built_in">lc</span>(rts[<span class="number">0</span>][i]);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">ask</span>(k, l, mid);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = rts[<span class="number">1</span>][<span class="number">0</span>]; i; --i) rts[<span class="number">1</span>][i] = <span class="built_in">rc</span>(rts[<span class="number">1</span>][i]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = rts[<span class="number">0</span>][<span class="number">0</span>]; i; --i) rts[<span class="number">0</span>][i] = <span class="built_in">rc</span>(rts[<span class="number">0</span>][i]);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">ask</span>(k - sum, mid + <span class="number">1</span>, r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">undef</span> ct</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">undef</span> mid</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">using</span> CT::rt;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lb(x) ((x) &amp; (-(x)))</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cg</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span></span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += <span class="built_in">lb</span>(i)) CT::<span class="built_in">cg</span>(a[x], d, rt[i]); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        rts[<span class="number">0</span>][<span class="number">0</span>] = rts[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i; i ^= <span class="built_in">lb</span>(i)) rts[<span class="number">1</span>][++rts[<span class="number">1</span>][<span class="number">0</span>]] = rt[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l - <span class="number">1</span>; i; i ^= <span class="built_in">lb</span>(i)) rts[<span class="number">0</span>][++rts[<span class="number">0</span>][<span class="number">0</span>]] = rt[i];</span><br><span class="line">        <span class="keyword">return</span> CT::<span class="built_in">ask</span>(k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> lb</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="K-D-Tree"><a href="#K-D-Tree" class="headerlink" title="K-D Tree"></a>K-D Tree</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span> <span class="keyword">int</span> x[D], w; &#125;;</span><br><span class="line"><span class="keyword">namespace</span> KDT <span class="comment">//K-D Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> DB a = <span class="number">0.725</span>;</span><br><span class="line">    <span class="keyword">int</span> rt, top, rub[M], cur, tot; <span class="comment">//rub:回收空间</span></span><br><span class="line">    Point p[M];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> mn[D], mx[D], sum, lc, rc, si, k;</span><br><span class="line">        Point p;</span><br><span class="line">    &#125; tr[M];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mn(x) tr[(x)].mn</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mx(x) tr[(x)].mx</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sum(x) tr[(x)].sum</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc(x) tr[(x)].lc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc(x) tr[(x)].rc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> si(x) tr[(x)].si</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> k(x) tr[(x)].k</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> p(x) tr[(x)].p</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> top ? rub[top--] : ++cur; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ls = <span class="built_in">lc</span>(u), rs = <span class="built_in">rc</span>(u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; D; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">mn</span>(u)[i] = <span class="built_in">mx</span>(u)[i] = <span class="built_in">p</span>(u).x[i];</span><br><span class="line">            <span class="keyword">if</span> (ls) <span class="built_in">mn</span>(u)[i] = <span class="built_in">min</span>(<span class="built_in">mn</span>(u)[i], <span class="built_in">mn</span>(ls)[i]), <span class="built_in">mx</span>(u)[i] = <span class="built_in">max</span>(<span class="built_in">mx</span>(u)[i], <span class="built_in">mx</span>(ls)[i]);</span><br><span class="line">            <span class="keyword">if</span> (rs) <span class="built_in">mn</span>(u)[i] = <span class="built_in">min</span>(<span class="built_in">mn</span>(u)[i], <span class="built_in">mn</span>(rs)[i]), <span class="built_in">mx</span>(u)[i] = <span class="built_in">max</span>(<span class="built_in">mx</span>(u)[i], <span class="built_in">mx</span>(rs)[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sum</span>(u) = <span class="built_in">sum</span>(ls) + <span class="built_in">sum</span>(rs) + <span class="built_in">p</span>(u).w, <span class="built_in">si</span>(u) = <span class="built_in">si</span>(ls) + <span class="built_in">si</span>(rs) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>, u = <span class="built_in">newnode</span>();</span><br><span class="line">        <span class="built_in">nth_element</span>(p + l, p + mid, p + r + <span class="number">1</span>, [&amp;](Point a, Point b)&#123; <span class="keyword">return</span> a.x[k] &lt; b.x[k]; &#125;);</span><br><span class="line">        <span class="built_in">k</span>(u) = k, <span class="built_in">p</span>(u) = p[mid], <span class="built_in">lc</span>(u) = <span class="built_in">build</span>(l, mid - <span class="number">1</span>, k ^ <span class="number">1</span>), <span class="built_in">rc</span>(u) = <span class="built_in">build</span>(mid + <span class="number">1</span>, r, k ^ <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">up</span>(u), u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get_p</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123; <span class="keyword">if</span> (u) <span class="built_in">get_p</span>(<span class="built_in">lc</span>(u)), p[++tot] = <span class="built_in">p</span>(u), rub[++top] = u, <span class="built_in">get_p</span>(<span class="built_in">rc</span>(u)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> &amp;u)</span></span>&#123; <span class="keyword">if</span> (<span class="built_in">si</span>(u) * a &lt; <span class="built_in">max</span>(<span class="built_in">si</span>(<span class="built_in">lc</span>(u)), <span class="built_in">si</span>(<span class="built_in">rc</span>(u)))) tot = <span class="number">0</span>, <span class="built_in">get_p</span>(u), u = <span class="built_in">build</span>(<span class="number">1</span>, tot, <span class="built_in">k</span>(u)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> &amp;u, Point x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!u)</span><br><span class="line">        &#123;</span><br><span class="line">            u = <span class="built_in">newnode</span>();</span><br><span class="line">            <span class="built_in">lc</span>(u) = <span class="built_in">rc</span>(u) = <span class="built_in">k</span>(u) = <span class="number">0</span>, <span class="built_in">p</span>(u) = x;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">up</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x.x[<span class="built_in">k</span>(u)] &lt;= <span class="built_in">p</span>(u).x[<span class="built_in">k</span>(u)]) <span class="built_in">ins</span>(<span class="built_in">lc</span>(u), x);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">ins</span>(<span class="built_in">rc</span>(u), x);</span><br><span class="line">        <span class="built_in">up</span>(u), <span class="built_in">chk</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> mx[D], <span class="keyword">int</span> mn[D], <span class="keyword">int</span> l[D], <span class="keyword">int</span> r[D])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; D; ++i) <span class="keyword">if</span> (r[i] &lt; mx[i] || l[i] &gt; mn[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">out</span><span class="params">(<span class="keyword">int</span> mx[D], <span class="keyword">int</span> mn[D], <span class="keyword">int</span> l[D], <span class="keyword">int</span> r[D])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; D; ++i) <span class="keyword">if</span> (l[i] &gt; mx[i] || r[i] &lt; mn[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l[D], <span class="keyword">int</span> r[D])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!u || <span class="built_in">out</span>(<span class="built_in">mx</span>(u), <span class="built_in">mn</span>(u), l, r)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">in</span>(<span class="built_in">mx</span>(u), <span class="built_in">mn</span>(u), l, r)) <span class="keyword">return</span> <span class="built_in">sum</span>(u);</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">in</span>(<span class="built_in">p</span>(u).x, <span class="built_in">p</span>(u).x, l, r) ? <span class="built_in">p</span>(u).w : <span class="number">0</span>) + <span class="built_in">ask</span>(<span class="built_in">lc</span>(u), l, r) + <span class="built_in">ask</span>(<span class="built_in">rc</span>(u), l, r);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> mn</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> mx</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> si</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> k</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> p</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="笛卡尔树"><a href="#笛卡尔树" class="headerlink" title="笛卡尔树"></a>笛卡尔树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) tr[i].dat = a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, k; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">k = top;</span><br><span class="line"><span class="comment">//找到最下面的一个比当前小的,满足小根堆</span></span><br><span class="line"><span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; tr[stk[k]].dat &gt; tr[i].dat) --k;</span><br><span class="line"><span class="keyword">if</span> (k) tr[stk[k]].rc = i;</span><br><span class="line"><span class="keyword">if</span> (k &lt; top) tr[i].lc = stk[k + <span class="number">1</span>];</span><br><span class="line">top = k;</span><br><span class="line">stk[++top] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>二叉：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">建立小根堆q,把所有点放入</span><br><span class="line"><span class="keyword">while</span> (堆中元素个数 &gt;= <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">int</span> y = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">    ans += x + y;</span><br><span class="line">    q.<span class="built_in">push</span>(x + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多叉：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">用权值为<span class="number">0</span>的点补足点数,使(n - <span class="number">1</span>) % (k - <span class="number">1</span>) == <span class="number">0</span></span><br><span class="line">建立小根堆q,把所有点放入</span><br><span class="line"><span class="keyword">while</span> (堆中元素个数 &gt;= k)</span><br><span class="line">&#123;</span><br><span class="line">    取出前k个元素</span><br><span class="line">    ans += 前k个元素和;</span><br><span class="line">    q.<span class="built_in">push</span>(前k个元素和);</span><br><span class="line">&#125;</span><br><span class="line">把堆中剩下元素取出,计算贡献</span><br></pre></td></tr></table></figure><h2 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h2><p>重链剖分：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> father, <span class="keyword">int</span> depth)</span> <span class="comment">//求每个的重儿子</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dep[x] = depth, fa[x] = father, si[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne) <span class="keyword">if</span> ((y = e[i].ver) != father)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">dfs1</span>(y, x, depth + <span class="number">1</span>);</span><br><span class="line">si[x] += si[y];</span><br><span class="line"><span class="keyword">if</span> (si[son[x]] &lt; si[y]) son[x] = y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> t)</span> <span class="comment">//求dfs序,t:当前节点所在重链的顶点</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">id[x] = ++cnt, nw[cnt] = w[x], top[x] = t;</span><br><span class="line"><span class="keyword">if</span> (!son[x]) <span class="keyword">return</span>; <span class="comment">//若是叶节点,直接返回</span></span><br><span class="line"><span class="built_in">dfs2</span>(son[x], t);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (y == fa[x] || y == son[x]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(y, y); <span class="comment">//轻儿子一定是其所在重链的顶点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">path</span><span class="params">(<span class="keyword">int</span> )</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> <span class="comment">//路径操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (top[u] != top[v]) <span class="comment">//当这两个点不在同一重链</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">if</span> (dep[top[u]] &lt; dep[top[v]]) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line"><span class="built_in">work</span>(id[top[u]], id[u]); <span class="comment">//注意在dfs序中top[u]在u前面</span></span><br><span class="line">u = fa[top[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dep[u] &lt; dep[v]) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line"><span class="built_in">work</span>(id[v], id[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123; <span class="built_in">work</span>(id[u], id[u] + si[u] - <span class="number">1</span>); &#125; <span class="comment">//子树操作</span></span><br></pre></td></tr></table></figure><p>长链剖分：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[x] = dep[fa] + <span class="number">1</span>, fa[x] = fa;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne) <span class="keyword">if</span> ((y = e[i].ver) != fa)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">dfs1</span>(y, x);</span><br><span class="line"><span class="keyword">if</span> (len[y] &gt; len[son[x]]) son[x] = y;</span><br><span class="line">&#125;</span><br><span class="line">len[x] = len[son[x]] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> tp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    top[x] = tp;</span><br><span class="line"><span class="keyword">if</span> (!son[x]) <span class="keyword">return</span> ;</span><br><span class="line"><span class="built_in">dfs2</span>(son[x], tp);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne) <span class="keyword">if</span> ((y = e[i].ver) != fa[x] &amp;&amp; y != son[x]) <span class="built_in">dfs2</span>(y, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//常套在dp上:</span></span><br><span class="line"><span class="keyword">int</span> dd[N], *d[N], *cur = dd + <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    初始化d[x]和答案</span><br><span class="line"><span class="keyword">if</span> (!son[x]) <span class="keyword">return</span> ;</span><br><span class="line">d[son[x]] = d[x] + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(son[x], x);</span><br><span class="line">用长儿子的答案跟新x的答案</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne) <span class="keyword">if</span> ((y = e[i].ver) != fa[x] &amp;&amp; y != son[x])</span><br><span class="line">&#123;</span><br><span class="line">d[y] = cur, cur += len[y];</span><br><span class="line"><span class="built_in">dfs2</span>(y, x);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len[y]; ++j)</span><br><span class="line">&#123;</span><br><span class="line">d[x][j] += d[y][j - <span class="number">1</span>]; <span class="comment">//合并链</span></span><br><span class="line">跟新答案</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态树"><a href="#动态树" class="headerlink" title="动态树"></a>动态树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> LCT</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> stk[N]; <span class="comment">//中间要用的栈</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node_of_Slpay</span>&#123;</span> <span class="keyword">int</span> ch[<span class="number">2</span>], fa, v, sum, rev; &#125; tr[N];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ch(x, y) tr[(x)].ch[(y)]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fa(x) tr[(x)].fa</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> v(x) tr[(x)].v</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) tr[(x)].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rev(x) tr[(x)].rev</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adt</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="built_in">swap</span>(<span class="built_in">ch</span>(x, <span class="number">0</span>),<span class="built_in">ch</span>(x, <span class="number">1</span>)), <span class="built_in">rev</span>(x) ^= <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="built_in">sum</span>(x) = <span class="built_in">sum</span>(<span class="built_in">ch</span>(x, <span class="number">0</span>)) ^ <span class="built_in">sum</span>(<span class="built_in">ch</span>(x, <span class="number">1</span>)) ^ <span class="built_in">v</span>(x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dw</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">rev</span>(x))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">adt</span>(<span class="built_in">ch</span>(x, <span class="number">0</span>)), <span class="built_in">adt</span>(<span class="built_in">ch</span>(x, <span class="number">1</span>));</span><br><span class="line"><span class="built_in">rev</span>(x) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_rt</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">ch</span>(<span class="built_in">fa</span>(x), <span class="number">0</span>) != x &amp;&amp; <span class="built_in">ch</span>(<span class="built_in">fa</span>(x), <span class="number">1</span>) != x; &#125; <span class="comment">//判断x是否是所在splay的根</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rot</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> y = <span class="built_in">fa</span>(x), z = <span class="built_in">fa</span>(y);</span><br><span class="line"><span class="keyword">int</span> k = <span class="built_in">ch</span>(y, <span class="number">1</span>) == x;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">is_rt</span>(y)) <span class="built_in">ch</span>(z, <span class="built_in">ch</span>(z, <span class="number">1</span>) == y) = x;</span><br><span class="line"><span class="built_in">fa</span>(x) = z;</span><br><span class="line"><span class="built_in">ch</span>(y, k) = <span class="built_in">ch</span>(x, k ^ <span class="number">1</span>), <span class="built_in">fa</span>(<span class="built_in">ch</span>(x, k ^ <span class="number">1</span>)) = y;</span><br><span class="line"><span class="built_in">ch</span>(x, k ^ <span class="number">1</span>) = y, <span class="built_in">fa</span>(y) = x;</span><br><span class="line"><span class="built_in">up</span>(y), <span class="built_in">up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>, t = x, y, z;</span><br><span class="line">stk[++top] = t;</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">is_rt</span>(t)) stk[++top] = t = <span class="built_in">fa</span>(t);</span><br><span class="line"><span class="keyword">while</span> (top) <span class="built_in">dw</span>(stk[top--]);</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">is_rt</span>(x))</span><br><span class="line">&#123;</span><br><span class="line">y = <span class="built_in">fa</span>(x), z = <span class="built_in">fa</span>(y);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">is_rt</span>(y)) (<span class="built_in">ch</span>(y, <span class="number">1</span>) == x) ^ (<span class="built_in">ch</span>(z, <span class="number">1</span>) == y) ? <span class="built_in">rot</span>(x) : <span class="built_in">rot</span>(y);</span><br><span class="line"><span class="built_in">rot</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//将根到x之间的路径变成实边</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> z = x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; x; y = x, x = <span class="built_in">fa</span>(x))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">splay</span>(x);</span><br><span class="line"><span class="built_in">ch</span>(x, <span class="number">1</span>) = y;</span><br><span class="line"><span class="built_in">up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">splay</span>(z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_rt</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="built_in">access</span>(x), <span class="built_in">adt</span>(x); &#125; <span class="comment">//将x变成树根</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_rt</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//找到x所在树的根并将其转到splay的根节点上</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">access</span>(x);</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">ch</span>(x, <span class="number">0</span>)) <span class="built_in">dw</span>(x), x = <span class="built_in">ch</span>(x, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">splay</span>(x);</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="built_in">make_rt</span>(x), <span class="built_in">access</span>(y); &#125; <span class="comment">//将x到y的路径变成实边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">//加边(x, y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">make_rt</span>(x);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">find_rt</span>(y) != x) <span class="built_in">fa</span>(x) = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">//断边(x, y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">make_rt</span>(x);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">find_rt</span>(y) == x &amp;&amp; <span class="built_in">fa</span>(y) == x &amp;&amp; !<span class="built_in">ch</span>(y, <span class="number">0</span>)) <span class="built_in">ch</span>(x, <span class="number">1</span>) = <span class="built_in">fa</span>(y) = <span class="number">0</span>, <span class="built_in">up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ne[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= s_len; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; s[i] != s[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (s[i] == s[j + <span class="number">1</span>]) ++j;</span><br><span class="line">    ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= t_len; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; (t[i] != s[j + <span class="number">1</span>] || j == s_len)) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (t[i] == s[j + <span class="number">1</span>]) ++j;</span><br><span class="line">    <span class="keyword">if</span> (j == s_len); <span class="comment">// 此时t[i - s_len + 1, i] = s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下标均从 $1$ 开始</p><h2 id="Z函数"><a href="#Z函数" class="headerlink" title="Z函数"></a>Z函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Z[<span class="number">1</span>] = s_len;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, l = <span class="number">0</span>, r = <span class="number">0</span>; i &lt;= s_len; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= r) Z[i] = std::<span class="built_in">min</span>(Z[i - l + <span class="number">1</span>], r - i + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (Z[i] + i &lt;= s_len &amp;&amp; s[Z[i] + i] == s[Z[i] + <span class="number">1</span>]) ++Z[i];</span><br><span class="line">    <span class="keyword">if</span> (i + Z[i] - <span class="number">1</span> &gt; r) r = i + Z[i] - <span class="number">1</span>, l = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l = <span class="number">0</span>, r = <span class="number">0</span>, as; i &lt;= t_len; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    as = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= r) as = std::<span class="built_in">min</span>(Z[i - l + <span class="number">1</span>], r - i + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (as + i &lt;= t_len &amp;&amp; s[as + <span class="number">1</span>] == t[as + i]) ++as;</span><br><span class="line">    <span class="keyword">if</span> (i + as - <span class="number">1</span> &gt; r) r = i + as - <span class="number">1</span>, l = i;</span><br><span class="line">    <span class="comment">//此时的as就是t[i, s_len]与s的LCP长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下标从 $1$ 开始</p><h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><p>普通：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Trie</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ch[N][<span class="number">26</span>], ed[N], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; *s != <span class="string">&#x27;\0&#x27;</span>; ++s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!ch[p][*s - <span class="string">&#x27;a&#x27;</span>]) ch[p][*s - <span class="string">&#x27;a&#x27;</span>] = ++tot;</span><br><span class="line">p = ch[p][*s - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line">++ed[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; *s != <span class="string">&#x27;\0&#x27;</span>; ++s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!ch[p][*s - <span class="string">&#x27;a&#x27;</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">p = ch[p][*s - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ed[p]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Trie 的根是 $1$ ；注意空间要开够</p><p>可持久化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Trie</span><br><span class="line">&#123;</span><br><span class="line">AR&lt;<span class="keyword">int</span>, <span class="number">26</span>&gt; ch[N];</span><br><span class="line"><span class="keyword">int</span> rt[M], cid, tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = rt[cid], q = rt[++cid] = ++tot;</span><br><span class="line"><span class="keyword">for</span> (; *s != <span class="string">&#x27;\0&#x27;</span>; ++s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p) ch[q] = ch[p];</span><br><span class="line">ch[q][*s - <span class="string">&#x27;a&#x27;</span>] = ++tot;</span><br><span class="line">p = ch[p][*s - <span class="string">&#x27;a&#x27;</span>], q = ch[q][*s - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = rt[id];</span><br><span class="line"><span class="keyword">for</span> (; *s != <span class="string">&#x27;\0&#x27;</span>; ++s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!ch[p][*s - <span class="string">&#x27;a&#x27;</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">p = ch[p][*s - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任然是要注意空间</p><h2 id="最小表示法"><a href="#最小表示法" class="headerlink" title="最小表示法"></a>最小表示法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_min</span><span class="params">(<span class="keyword">char</span> *s)</span> <span class="comment">//求串s的最小表示,完成后答案存在s[k...k + len - 1]中</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) s[i + len] = s[i];</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">2</span>, k;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= len &amp;&amp; j &lt;= len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt;= len &amp;&amp; s[i + k] == s[j + k]; ++k);</span><br><span class="line"><span class="keyword">if</span> (k &gt; len) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (s[i + k] &gt; s[j + k]) i += k + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> j += k + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i == j) ++j;</span><br><span class="line">&#125;</span><br><span class="line">k = std::<span class="built_in">min</span>(i, j);</span><br><span class="line">s[k + len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意空间要开两倍</p><h2 id="Manacher"><a href="#Manacher" class="headerlink" title="Manacher"></a>Manacher</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">manacher</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">STC <span class="keyword">char</span> t[N &lt;&lt; <span class="number">1</span>]; <span class="comment">//临时字符串要两倍</span></span><br><span class="line">STC <span class="keyword">int</span> p[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s + <span class="number">1</span>), mr = <span class="number">0</span>, mid, res = <span class="number">0</span>;</span><br><span class="line">t[++mr] = <span class="string">&#x27;$&#x27;</span>, t[++mr] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) t[++mr] = s[i], t[++mr] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">t[++mr] = <span class="string">&#x27;^&#x27;</span>;</span><br><span class="line">len = mr, mr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; ++i)</span><br><span class="line">&#123;</span><br><span class="line">p[i] = i &lt; mr ? std::<span class="built_in">min</span>(p[mid * <span class="number">2</span> - i], mr - i) : <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (t[i - p[i]] == t[i + p[i]]) ++p[i];</span><br><span class="line"><span class="keyword">if</span> (i + p[i] &gt; mr) mr = i + p[i], mid = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) res = std::<span class="built_in">max</span>(res, p[i]);</span><br><span class="line"><span class="keyword">return</span> res - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AC-自动机"><a href="#AC-自动机" class="headerlink" title="AC 自动机"></a>AC 自动机</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> AC</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ch[N][<span class="number">26</span>], tot, in[N], as[N], fail[N];</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; ed[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; *s != <span class="string">&#x27;\0&#x27;</span>; ++s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!ch[p][*s - <span class="string">&#x27;a&#x27;</span>]) ch[p][*s - <span class="string">&#x27;a&#x27;</span>] = ++tot;</span><br><span class="line">p = ch[p][*s - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line">ed[p].<span class="built_in">pb</span>(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_fail</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">fail[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) <span class="keyword">if</span> (ch[<span class="number">0</span>][i])</span><br><span class="line">&#123;</span><br><span class="line">fail[ch[<span class="number">0</span>][i]] = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push</span>(ch[<span class="number">0</span>][i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line"><span class="keyword">if</span> (v = ch[u][i])</span><br><span class="line">&#123;</span><br><span class="line">fail[v] = ch[fail[u]][i];</span><br><span class="line">++in[fail[v]];</span><br><span class="line">q.<span class="built_in">push</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> ch[u][i] = ch[fail[u]][i]; <span class="comment">//优化</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> ans[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">std::queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> ct = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; *s != <span class="string">&#x27;\0&#x27;</span>; ++s)</span><br><span class="line">&#123;</span><br><span class="line">++ct;</span><br><span class="line">p = ch[p][*s - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">++as[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) <span class="keyword">if</span> (!in[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u = q.<span class="built_in">front</span>(), v; q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : ed[u]) ans[i] = as[u];</span><br><span class="line">v = fail[u];</span><br><span class="line">as[v] += as[u];</span><br><span class="line"><span class="keyword">if</span> (!(--in[v])) q.<span class="built_in">push</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SAM"><a href="#SAM" class="headerlink" title="SAM"></a>SAM</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> SAM</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1为空节点</span></span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">1</span>, last = <span class="number">1</span>; <span class="comment">//last:未加入此字符前最长的前缀所属的节点的编号</span></span><br><span class="line"><span class="comment">//这里的节点只维护了最长的串,因为所有长度小于它但同结尾的串一定被它的祖先维护了</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> len, fa; <span class="comment">//最长长度,父节点</span></span><br><span class="line"><span class="keyword">int</span> ch[<span class="number">26</span>]; <span class="comment">//类似于Trie</span></span><br><span class="line">&#125; nd[N &lt;&lt; <span class="number">1</span>]; <span class="comment">//开2倍</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = last, np = last = ++tot;</span><br><span class="line">nd[np].len = nd[p].len + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; p &amp;&amp; !nd[p].ch[x]; p = nd[p].fa) nd[p].ch[x] = np; <span class="comment">//遍历所有长度小于它但同结尾的串,加字符</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果最后形成的新字符串没有旧串里出现过,</span></span><br><span class="line"><span class="comment">说明x实际上是一个在旧串中没有出现过的字符</span></span><br><span class="line"><span class="comment">因此不可能存在除节点1以外的祖先</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (!p) nd[np].fa = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> q = nd[p].ch[x];</span><br><span class="line"><span class="keyword">if</span> (nd[q].len == nd[p].len + <span class="number">1</span>) nd[np].fa = q; <span class="comment">//判断np是否为q的子节点</span></span><br><span class="line"><span class="keyword">else</span> <span class="comment">//不是就说明q含了不该含的子串,直接新建节点为np的父节点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nq = ++tot;</span><br><span class="line">nd[nq] = nd[q], nd[nq].len = nd[p].len + <span class="number">1</span>; <span class="comment">//这里就相当于去掉不该含的串</span></span><br><span class="line">nd[q].fa = nd[np].fa = nq;</span><br><span class="line"><span class="keyword">for</span> (; p &amp;&amp; nd[p].ch[x] == q; p = nd[p].fa) nd[p].ch[x] = nq; <span class="comment">//同理跟新</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SA"><a href="#SA" class="headerlink" title="SA"></a>SA</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_sa</span><span class="params">(<span class="keyword">int</span> _num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">STC <span class="keyword">int</span> x[N], y[N], c[N]; <span class="comment">//排序用,第一关键字,第二关键字,cnt</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++c[x[i] = s[i]]; <span class="comment">//第一次只有一个字符,不必离散化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= _num; ++i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) sa[c[x[i]]--] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>, num; k &lt;= n; k &lt;&lt;= <span class="number">1</span>) <span class="comment">//k枚举关键字长度,合并后长度应为2k</span></span><br><span class="line">&#123;</span><br><span class="line">num = <span class="number">0</span>; <span class="comment">//记录离散化后的值域</span></span><br><span class="line"><span class="comment">//先以第二关键字排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - k + <span class="number">1</span>; i &lt;= n; ++i) y[++num] = i; <span class="comment">//没有第二关键字的牌最前</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (sa[i] &gt; k) y[++num] = sa[i] - k;</span><br><span class="line"><span class="comment">//以第一关键字排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= _num; ++i) c[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++c[x[i]];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= _num; ++i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) sa[c[x[y[i]]]--] = y[i], y[i] = <span class="number">0</span>;  <span class="comment">//这里清空y实际上是清空x,因为后面交换了</span></span><br><span class="line">std::<span class="built_in">swap</span>(x, y);</span><br><span class="line"><span class="comment">//将排好序的字符串离散化</span></span><br><span class="line">x[sa[<span class="number">1</span>]] = num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) x[sa[i]] = (y[sa[i]] == y[sa[i - <span class="number">1</span>]] &amp;&amp; y[sa[i] + k] == y[sa[i - <span class="number">1</span>] + k]) ? num : ++num;</span><br><span class="line"><span class="keyword">if</span> (num == n) <span class="keyword">break</span>;</span><br><span class="line">_num = num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) rk[sa[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_hei</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (rk[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (k) --k;</span><br><span class="line"><span class="keyword">int</span> j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">while</span> (i + k &lt;= n &amp;&amp; j + k &lt;= n &amp;&amp; s[i + k] == s[j + k]) ++k;</span><br><span class="line">hei[rk[i]] = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h2><p>树上倍增法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">f[x][<span class="number">0</span>] = fa, dep[x] = dep[fa] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = e[i].ne) <span class="keyword">if</span> (e[i].ver != fa) <span class="built_in">dfs</span>(e[i].ver, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; D; ++j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i][j] = f[f[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dep[x] &gt; dep[y]) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = D - <span class="number">1</span>; ~i; --i) <span class="keyword">if</span> (dep[f[y][i]] &gt;= dep[x]) y = f[y][i];</span><br><span class="line"><span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = D - <span class="number">1</span>; ~i; --i) <span class="keyword">if</span> (f[y][i] != f[x][i]) y = f[y][i], x = f[x][i];</span><br><span class="line"><span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常数较打，优点是好打且可用于求一个点的 $k$ 级祖先</p><p>树剖：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">在前面树剖的基础上加入如下代码:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (top[x] != top[y])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dep[top[x]] &lt; dep[top[y]]) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">x = fa[top[x]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dep[x] &lt; dep[y] ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点是常数小</p><p>ST 表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dep[N &lt;&lt; <span class="number">1</span>], cnt = <span class="number">0</span>, id_b[N &lt;&lt; <span class="number">1</span>], id[N], lg2[N &lt;&lt; <span class="number">1</span>]; <span class="comment">//注意2倍</span></span><br><span class="line">PII mn[N &lt;&lt; <span class="number">1</span>][D]; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    id[x] = ++cnt, dep[cnt] = depth, id_b[cnt] = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne) <span class="keyword">if</span> ((y = e[i].ver) != fa)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(y, x, depth + <span class="number">1</span>);</span><br><span class="line">        id_b[++cnt] = x, dep[cnt] = depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prev</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lg2[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cnt; ++i) lg2[i] = lg2[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) mn[i][<span class="number">0</span>] = &#123;dep[i], id_b[i]&#125;;</span><br><span class="line">    <span class="keyword">int</span> t = lg2[cnt] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; t; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt - (<span class="number">1</span> &lt;&lt; j) + <span class="number">1</span>; ++i) mn[i][j] = std::<span class="built_in">min</span>(mn[i][j - <span class="number">1</span>], mn[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = lg2[r - l + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">min</span>(mn[l][t], mn[r - (<span class="number">1</span> &lt;&lt; t) + <span class="number">1</span>][t]).se;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">ask</span>(std::<span class="built_in">min</span>(id[a], id[b]), std::<span class="built_in">max</span>(id[a], id[b])); &#125;</span><br></pre></td></tr></table></figure><p>优点当然是 $O(1)$ 查询，缺点是有点难打</p><p>也可以用四毛子，但太难打了几乎用不到</p><h2 id="单源最短路"><a href="#单源最短路" class="headerlink" title="单源最短路"></a>单源最短路</h2><p>Dij ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dij</span><span class="params">(<span class="keyword">int</span> star)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::priority_queue&lt;PII&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) dis[i] = INF;</span><br><span class="line">    dis[star] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, star&#125;);</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        x = q.<span class="built_in">top</span>().se, q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne) <span class="keyword">if</span> (!vis[y = e[i].ver] &amp;&amp; dis[y] &gt; dis[x] + e[i].w)</span><br><span class="line">&#123;</span><br><span class="line">dis[y] = dis[x] + e[i].w;</span><br><span class="line">q.<span class="built_in">push</span>(&#123;-dis[y], y&#125;);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>spfa（慎用）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> star)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) dis[i] = INF;</span><br><span class="line">    dis[star] = <span class="number">0</span>, vis[star] = <span class="literal">true</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(star);</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        x = q.<span class="built_in">front</span>(), q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[x] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = e[i].ne) <span class="keyword">if</span> (dis[y = e[i].ver] &gt; dis[x] + e[i].w)</span><br><span class="line">&#123;</span><br><span class="line">dis[y] = dis[x] + e[i].w;</span><br><span class="line"><span class="keyword">if</span> (!vis[y]) vis[y] = <span class="literal">true</span>, q.<span class="built_in">push</span>(y);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判负环"><a href="#判负环" class="headerlink" title="判负环"></a>判负环</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> star)</span> <span class="comment">//判断是否有能从star到达的负环</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) dis[i] = INF, cnt[i] = <span class="number">0</span>, vis[i] = <span class="literal">false</span>;</span><br><span class="line">    dis[star] = <span class="number">0</span>, vis[star] = <span class="literal">true</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(star);</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        x = q.<span class="built_in">front</span>(), q.<span class="built_in">pop</span>();</span><br><span class="line">        v[x] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = e[i].ne) <span class="keyword">if</span> (dis[y = e[i].ver] &gt; dis[x] + e[i].w)</span><br><span class="line">&#123;</span><br><span class="line">dis[y] = dis[x] + e[i].w, cnt[y] = cnt[x] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (cnt[y] &gt;= n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (!vis[y]) vis[y] = <span class="literal">true</span>, q.<span class="built_in">push</span>(y);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">建图:</span><br><span class="line">对于每个形如x[i] - x[j] &lt;= c的不等式,连有向边(j, i, c)</span><br><span class="line">    增加一个<span class="number">0</span>号节点,对于每个i,连边(<span class="number">0</span>, i, <span class="number">0</span>),表示x[i] &lt;= <span class="number">0</span>(我们先求出一组负解)</span><br><span class="line">完成以后以<span class="number">0</span>为源点跑spfa,若出现负环则无解;否则dis[]即为一组负数解</span><br></pre></td></tr></table></figure><h2 id="多源最短路"><a href="#多源最短路" class="headerlink" title="多源最短路"></a>多源最短路</h2><p>Floyed ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) dis[i][i] = <span class="number">0</span>;</span><br><span class="line">用dis做邻接矩阵存图</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) dis[i][j] = std::<span class="built_in">min</span>(dis[i][j], dis[i][k] + dis[k][j]);</span><br></pre></td></tr></table></figure><p>当然也可以做 $n$ 次单源最短路</p><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>Kruskal ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span> <span class="keyword">int</span> from, to, w; &#125; e[M];</span><br><span class="line">读入数据,初始化并查集</span><br><span class="line"><span class="built_in">sort</span>(e + <span class="number">1</span>, e + <span class="number">1</span> + m, [&amp;](Edge x, Edge y)&#123; <span class="keyword">return</span> x.w &lt; y.w; &#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= m; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    x = <span class="built_in">get</span>(e[i].from), y = <span class="built_in">get</span>(e[i].to); <span class="comment">//这里的get和merge就是并查集</span></span><br><span class="line">    <span class="keyword">if</span> (x != y) ans += e[i].w, <span class="built_in">merge</span>(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Prim ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, t; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    t = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) <span class="keyword">if</span> (!vis[j] &amp;&amp; (t == <span class="number">-1</span> || dis[j] &lt; dis[t])) t = j;</span><br><span class="line">    vis[t] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) <span class="keyword">if</span> (!vis[j]) dis[j] = std::<span class="built_in">min</span>(dis[j], map[t][j]);</span><br><span class="line">&#125;</span><br><span class="line">此时dis[]的和就是答案</span><br></pre></td></tr></table></figure><h2 id="Kruskal-重构树"><a href="#Kruskal-重构树" class="headerlink" title="Kruskal 重构树"></a>Kruskal 重构树</h2><p>Kruskal 重构树的建树流程为：</p><ol><li>把所有边排序，记边为 $(x, y, z)$ ，表示 $x \to y$ ，权为 $z$ </li><li>构建 $n$ 个无权点，没有边</li><li>每次取出一条边 $(x, y, z)$ ：<ul><li>若 $x, y$ 联通（在同一棵树），不管它</li><li>否则，新建一个节点 $t$ ，记 $x, y$ 所在树的根为 $r_x, r_y$ ，让 $t$ 的左右儿子分别为 $r_x, r_y$ ，并让 $t$ 的点权为 $z$ </li></ul></li></ol><p>不难发现 kruskal 重构树有如下性质：</p><ol><li>它是一棵二叉树（更进一步，它其实就是个二叉堆），树上除叶子结点以外的点都对应着原来生成树中的边，叶子结点就是原来生成树上的节点</li><li>除叶节点外，儿子节点对应边一定排序在父亲前面，即从每个点到根节点上除叶子结点外按顺序访问到的点的点权是单调的</li><li>对于叶节点 $x, y$ ， $lca(x, y)$ 对应的边就是最小生成树中联通 $x, y$ 的“瓶颈边”（它排序在最后）</li></ol><h2 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h2><p>dp 自然可以，但不好求出具体的路径</p><p>两次 bfs/dfs 的流程如下：</p><ol><li>任选一个点出发，找到离该点最远的节点 $p$ </li><li>从 $p$ 出发，找到离 $p$ 最远的节点 $q$ </li><li> $p, q$ 间的路径就是树的一条直径；如要得到具体路径，在进行 $2$ 时记录前驱即可</li></ol><h2 id="无向图-Tarjan"><a href="#无向图-Tarjan" class="headerlink" title="无向图 Tarjan"></a>无向图 Tarjan</h2><p>判桥：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> in_e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dfn[x] = low[x] = ++num;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne)</span><br><span class="line"><span class="keyword">if</span> (!dfn[y = e[i].ver;])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">tarjan</span>(y, i);</span><br><span class="line">low[x] = std::<span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line"><span class="keyword">if</span> (low[y] &gt; dfn[x]) bridge[i] = bridge[i ^ <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i != (in_e ^ <span class="number">1</span>)) low[x] = std::<span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(!dfn[i]) <span class="built_in">tarjan</span>(i,<span class="number">-1</span>);</span><br></pre></td></tr></table></figure><p>边双联通分量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在判桥的代码后加入以下代码:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">c[x] = dcc;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne) <span class="keyword">if</span> (!bridge[i] &amp;&amp; !c[y = e[i].ver]) <span class="built_in">dfs</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (!c[i]) ++dcc, <span class="built_in">dfs</span>(i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;the num of e-DCC is %d\n&quot;</span>, dcc);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d blongs to e-DCC %d\n&quot;</span>, i, c[i]);</span><br></pre></td></tr></table></figure><p>判割点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dfn[x] = low[x] = ++num;</span><br><span class="line">    (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne)</span><br><span class="line"><span class="keyword">if</span> (!dfn[y = e[i].ver])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">tarjan</span>(y);</span><br><span class="line">low[x] = std::<span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line"><span class="keyword">if</span> (low[y] &gt;= dfn[x])</span><br><span class="line">&#123;</span><br><span class="line">++f;</span><br><span class="line"><span class="keyword">if</span> (x != root || f &gt; <span class="number">1</span>) cut[x] = <span class="literal">true</span>;</span><br><span class="line">(<span class="number">2</span>)</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> low[x] = std::<span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (!dfn[i]) root = i, <span class="built_in">tarjan</span>(i);</span><br></pre></td></tr></table></figure><p>点双联通分量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在上面求割点的代码的(<span class="number">1</span>), (<span class="number">2</span>)处加入以下两段代码:</span><br><span class="line">(<span class="number">1</span>):</span><br><span class="line">stk[++top] = x; <span class="comment">//栈记录经过的节点</span></span><br><span class="line"><span class="keyword">if</span> (x == root &amp;&amp; h[x] == <span class="number">-1</span>) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(dcc[++cnt].<span class="built_in">pb</span>(x)); <span class="comment">//孤立点</span></span><br><span class="line">(<span class="number">2</span>):</span><br><span class="line">++cnt;</span><br><span class="line"><span class="keyword">int</span> z;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    z = stk[top--];</span><br><span class="line">    dcc[cnt].<span class="built_in">pb</span>(z);</span><br><span class="line">&#125; <span class="keyword">while</span> (z != y);</span><br><span class="line">dcc[cnt].<span class="built_in">pb</span>(x);</span><br></pre></td></tr></table></figure><h2 id="有向图-Tarjan"><a href="#有向图-Tarjan" class="headerlink" title="有向图 Tarjan"></a>有向图 Tarjan</h2><p>强连通分量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dfn[x] = low[x] = ++num;</span><br><span class="line">stk[++top] = x, ins[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne)</span><br><span class="line"><span class="keyword">if</span> (!dfn[y = e[i].ver])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">tarjan</span>(y);</span><br><span class="line">low[x] = std::<span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ins[y]) low[x] = std::<span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line"><span class="keyword">if</span> (dfn[x] == low[x])</span><br><span class="line">&#123;</span><br><span class="line">++cnt;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">y = stk[top--], ins[y] = <span class="literal">false</span>;</span><br><span class="line">c[y] = cnt, scc[cnt].<span class="built_in">pb</span>(y);</span><br><span class="line">&#125; <span class="keyword">while</span> (x != y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-SAT"><a href="#2-SAT" class="headerlink" title="2-SAT"></a>2-SAT</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">建图:</span><br><span class="line">图中有<span class="number">2</span>n个节点,i表示x[i]为假,i + n表示x[i]为真</span><br><span class="line">    按命题连边:</span><br><span class="line"><span class="number">1.</span>x[i] <span class="keyword">and</span> x[j] = <span class="number">0</span>:连(i + n, j)和(j + n, i)</span><br><span class="line">        <span class="number">2.</span>x[i] <span class="keyword">and</span> x[j] = <span class="number">1</span>:连(i, i + n)和(j, j + n) (若有一个为<span class="number">0</span>就产生矛盾)</span><br><span class="line">        <span class="number">3.</span>x[i] <span class="keyword">or</span> x[j] = <span class="number">0</span>:连(i + n, i)和(j + n, j) (若有一个为<span class="number">1</span>就产生矛盾)</span><br><span class="line">        <span class="number">4.</span>x[i] <span class="keyword">or</span> x[j] = <span class="number">1</span>:连(i, j + n)和(j, i + n)</span><br><span class="line">        <span class="number">5.</span>x[i] <span class="keyword">xor</span> x[j] = <span class="number">0</span>:连(i, j), (j, i), (i + n, j + n)和(j + n, i + n)</span><br><span class="line">        <span class="number">6.</span>x[i] <span class="keyword">xor</span> x[j] = <span class="number">1</span>:连(i, j + n), (j, i + n), (i + n, j)和(j + n, i)</span><br><span class="line">    有向图Tarjan缩点,若i和i + n在一个强联通分量说明无解;否则任意一个强连通分量代表一组解</span><br></pre></td></tr></table></figure><h2 id="圆方树"><a href="#圆方树" class="headerlink" title="圆方树"></a>圆方树</h2><p>直接对原图进行无向图 Tarjan ，因为原图上每个环都是一个点双，而且在栈中的顺序就是环上点的顺序，如果一个点 $i$ 的出边 $(i, j)$ 满足 $dfn(i) &lt; low(j)$ ，说明 $(i, j)$ 是一条树边，直接加上即可；如果 $dfn(i) = low(j)$ ，那么我们找到了一个环（可能是重边造成的二元环），则从栈中取出点直到取出 $j$ 为止，设这样从栈中取出的点集为 $R$ ，则 $i$ 和 $R$ 构成一个环</p><p>对于环，我们新建一个方点，对环上每个点连边即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    low[x] = dfn[x] = ++dfc;</span><br><span class="line">    stk[++top] = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> y : G[x])</span><br><span class="line">        <span class="keyword">if</span> (!dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(y);</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">            <span class="keyword">if</span> (low[y] == dfn[x])<span class="comment">//标志着找到一个以x为根的点双连通分量</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++cnt; <span class="comment">//增加方点个数</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> z = <span class="number">0</span>; z != y; --top) <span class="comment">//这里一定要让z=0!</span></span><br><span class="line">                &#123;</span><br><span class="line">                    z = stk[top];</span><br><span class="line">                    T[cnt].<span class="built_in">push_back</span>(z);</span><br><span class="line">                    T[z].<span class="built_in">push_back</span>(cnt);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//注意x自身也要连边（但不退栈）</span></span><br><span class="line">                T[cnt].<span class="built_in">push_back</span>(x);</span><br><span class="line">                T[x].<span class="built_in">push_back</span>(cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[x] = <span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (!dfn[i]) <span class="built_in">tarjan</span>(i), --top; <span class="comment">//注意到退出Tarjan时栈中还有一个元素即根,将其退栈</span></span><br></pre></td></tr></table></figure><p>注意新图的节点数变成两倍</p><h2 id="三元环计数"><a href="#三元环计数" class="headerlink" title="三元环计数"></a>三元环计数</h2><p>要改造一下边，把无向图变成有向图，总时间为 $O(m \sqrt{m})$ ，这同时也是三元环的个数上界</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">读入数据,去掉重边,记录每个点的度(下面假设用PII存的边)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_e[i].fi &lt; _e[i].se) std::<span class="built_in">swap</span>(_e[i].fi, _e[i].se);</span><br><span class="line">dep[_e[i].fi] &gt;= dep[_e[i].se] ? <span class="built_in">add</span>(_e[i].fi, _e[i].se) : <span class="built_in">add</span>(_e[i].se, _e[i].fi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find3c</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = e[i].ne) vis[e[i].ver] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = e[i].ne)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = h[e[i].ver]; ~j; j = e[j].ne) res += vis[e[j].ver];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = e[i].ne) vis[e[i].ver] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四元环计数"><a href="#四元环计数" class="headerlink" title="四元环计数"></a>四元环计数</h2><p><strong>我们将每个点按度数大小重新编号，度数相同原来编号大的点在前</strong>的方法，就可以通过编号直接得到任意两个点的关系</p><p>设重新编号后排名为 $rk$ ，枚举四圆环中 $rk$ 最大的点 $x$ ，再枚举 $x$ 的出点 $y$ ，枚举  $y$ 的出点 $z$ （这里直接枚举无向边，注意判断 $rk(x) &gt; rk(y) &gt; rk(z)$ ）， 这里就得到了一个长度为 $2$ 的链了，再枚举一个点 $c$ ，只要 $rk(x) &gt; rk(c)$ 就计入答案的贡献，不管 $rk(c)$ 和 $rk(z)$ 的关系</p><p>时间复杂度还是 $O(m \sqrt{m})$ ，注意四元环的个数上界是 $nm\sqrt{m}$ ，可能要 <code>LL</code> </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">读入数据,记录每个点的度</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) id[i] = i;</span><br><span class="line">std::<span class="built_in">sort</span>(id + <span class="number">1</span>, id + n + <span class="number">1</span>, [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123; <span class="keyword">return</span> deg[x] == dep[y] ? x &lt; y : dep[x] &lt; dep[y]; &#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) rk[id[i]] = i;</span><br><span class="line"><span class="function">LL <span class="title">find4c</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = e[i].ne) <span class="keyword">if</span> (rk[x] &gt; rk[e[i].ver])</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = h[e[i].ver]; ~j; j = e[j].ne) <span class="keyword">if</span> (rk[x] &gt; rk[e[j].ver]) res += cnt[e[j].ver]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = e[i].ne) <span class="keyword">if</span> (rk[x] &gt; rk[e[i].ver])</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = h[e[i].ver]; j != <span class="number">-1</span>; j = e[j].ne) cnt[e[i].ver] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="欧拉回路"><a href="#欧拉回路" class="headerlink" title="欧拉回路"></a>欧拉回路</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">euler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">stk[++top] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (top)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x = stk[top], i = h[x];</span><br><span class="line"><span class="keyword">while</span> (i != <span class="number">-1</span> &amp;&amp; vis[i]) i = ne[i];</span><br><span class="line"><span class="keyword">if</span> (i != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">stk[++top] = e[i].ver;</span><br><span class="line">vis[i] = vis[i ^ <span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">//这里用了成对存储的技巧</span></span><br><span class="line">h[x] = ne[i]; <span class="comment">//保证时间复杂度</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">--top;</span><br><span class="line">ans[++cnt] = x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">最后ans[]存有一条欧拉回路</span><br></pre></td></tr></table></figure><h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><p>判定：染色法</p><p>求最大匹配：</p><p>网络流可做，这里介绍匈牙利，时间为 $O(nm)$ ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne) <span class="keyword">if</span> (!vis[y = e[i].ver])</span><br><span class="line">&#123;</span><br><span class="line">vis[y] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (!match[y] || <span class="built_in">dfs</span>(match[y])) <span class="keyword">return</span> match[y] = x, <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">dfs</span>(i)) ++ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一般图最大匹配"><a href="#一般图最大匹配" class="headerlink" title="一般图最大匹配"></a>一般图最大匹配</h2><p>智慧法（可能被卡）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::mt19937 <span class="title">rud</span><span class="params">(<span class="number">114514</span>)</span></span>;</span><br><span class="line"><span class="function">DB <span class="title">when</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> (DB)(<span class="built_in">clock</span>() - st) / CLOCKS_PER_SEC; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; match[x] = y, match[y] = x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="built_in">shuffle</span>(e[x].<span class="built_in">begin</span>(), e[x].<span class="built_in">end</span>(), rud);</span><br><span class="line">    vis[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> y : e[x]) <span class="keyword">if</span> (!match[y]) <span class="keyword">return</span> <span class="built_in">link</span>(x, y), vis[y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> y : e[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> z = match[y];</span><br><span class="line">        <span class="keyword">if</span> (vis[z]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">link</span>(x, y), match[z] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">work</span>(z)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">link</span>(y, z), match[x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">读入(用vector存图)</span><br><span class="line"><span class="keyword">clock_t</span> st = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">when</span>() &lt; <span class="number">0.9</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (!match[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis + <span class="number">1</span>, <span class="literal">false</span>, n * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">bool</span>));</span><br><span class="line">        ans += <span class="built_in">work</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">最后ans是最大匹配数,match即为匹配  </span><br></pre></td></tr></table></figure><p>带花树：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">link同上,get就是并查集</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dad</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!match[x] &amp;&amp; !match[y]) <span class="built_in">link</span>(x, y), ++ans; <span class="comment">//优化</span></span><br><span class="line">    <span class="built_in">add</span>(x, y), <span class="built_in">add</span>(y, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rev</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">if</span> (x) <span class="built_in">rev</span>(match[pre[x]]), <span class="built_in">link</span>(x, pre[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    STC <span class="keyword">int</span> dfn[N], cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    dfn是一个标记数组,一边打标即一边上跳，第一个重复点就是花根</span></span><br><span class="line"><span class="comment">花根一定是一个绿点,所以可以隔点上跳</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (++cnt; ;x = pre[match[x]], <span class="built_in">swap</span>(x, y))</span><br><span class="line"><span class="keyword">if</span> (dfn[x = <span class="built_in">get</span>(x)] == cnt) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x) dfn[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blossom</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span> <span class="comment">//缩奇环(开花)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">get</span>(x) != w; x = pre[y])</span><br><span class="line">    &#123;</span><br><span class="line">        pre[x] = y, y = match[x];</span><br><span class="line">        fa[x] = fa[y] = w;</span><br><span class="line">        <span class="keyword">if</span> (col[y] == <span class="number">2</span>) col[y] = <span class="number">1</span>, q.<span class="built_in">push</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aug</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//带花树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((ans + <span class="number">1</span>) * <span class="number">2</span> &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fa[i] = i, col[i] = pre[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (q.<span class="built_in">push</span>(x), col[x] = <span class="number">1</span>; !q.<span class="built_in">empty</span>(); q.<span class="built_in">pop</span>())</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = q.<span class="built_in">front</span>(), i = h[u], v, w; ~i; i = e[i].ne)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">get</span>(u) == <span class="built_in">get</span>(v = e[i].ver) || col[v] == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!col[v])</span><br><span class="line">            &#123;</span><br><span class="line">                col[v] = <span class="number">2</span>, pre[v] = u;</span><br><span class="line">                <span class="keyword">if</span> (!match[v]) <span class="keyword">return</span> <span class="built_in">rev</span>(v), <span class="number">1</span>;</span><br><span class="line">                col[match[v]] = <span class="number">1</span>, q.<span class="built_in">push</span>(match[v]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">blossom</span>(u, v, w = <span class="built_in">lca</span>(u, v)), <span class="built_in">blossom</span>(v, u, w); <span class="comment">//缩环两个方向各一次拼起来</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">读入，加边用<span class="function">dad</span></span><br><span class="line"><span class="function"><span class="title">for</span> <span class="params">(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span> ans +</span>= (!match[i] &amp;&amp; <span class="built_in">aug</span>(i));</span><br></pre></td></tr></table></figure><h2 id="Prufer-序列"><a href="#Prufer-序列" class="headerlink" title="Prufer 序列"></a>Prufer 序列</h2><p>每次选择一个编号最小的叶结点并删掉它，然后在序列中记录下它连接到的那个结点，重复 $n - 2$ 次后就只剩下两个结点，算法结束，得到的序列可以与原树一一对应</p><h2 id="虚树"><a href="#虚树" class="headerlink" title="虚树"></a>虚树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!top) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(stk[++top] = x);</span><br><span class="line">    <span class="keyword">int</span> z = <span class="built_in">lca</span>(stk[top], x);</span><br><span class="line">    <span class="keyword">for</span> (; tp &gt; <span class="number">1</span> &amp;&amp; dep[z] &lt; dep[stk[top - <span class="number">1</span>]]; --top) <span class="built_in">add</span>(stk[top - <span class="number">1</span>], stk[top]);</span><br><span class="line">    <span class="keyword">if</span> (dep[z] &lt; dep[stk[top]]) <span class="built_in">add</span>(z, stk[top--]);</span><br><span class="line">    <span class="keyword">if</span> (!top || stk[top] != z) stk[++top] = z;</span><br><span class="line">    stk[++top] = x;</span><br><span class="line">&#125;</span><br><span class="line">std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + k + <span class="number">1</span>, [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123; <span class="keyword">return</span> dfn[x] &lt; dfn[y]; &#125;);</span><br><span class="line">top = ans = idf = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">1</span>] != <span class="number">1</span>) stk[++top] = <span class="number">1</span>; <span class="comment">//根</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) <span class="built_in">ins</span>(a[i]);</span><br><span class="line"><span class="keyword">for</span> (; top &gt; <span class="number">1</span>; --top) <span class="built_in">adf</span>(stk[top - <span class="number">1</span>], stk[top]); <span class="comment">//在虚树上建边</span></span><br><span class="line">计算答案,记得撤销!</span><br></pre></td></tr></table></figure><p>虚树的空间和撤销是易错点</p><h1 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h1><h2 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h2><p>注意下面初始化都是 <code>0xcf</code> （最小值）</p><p> $01$ ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(f, <span class="number">0xcf</span>, <span class="keyword">sizeof</span> f), ans = -INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= v[i]; --j) f[j] = std::<span class="built_in">max</span>(f[j - v[i]] + w[i], f[j]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) ans = <span class="built_in">max</span>(ans, f[i]);</span><br></pre></td></tr></table></figure><p> $01$ 退背包（只能求方案数）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) f[i] -= f[i - <span class="number">1</span>] * x; <span class="comment">//禁用贡献为x的物品</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = m; i; --i) f[i] += f[i - <span class="number">1</span>] * x; <span class="comment">//加入贡献为x的物品</span></span><br></pre></td></tr></table></figure><p>完全：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(f, <span class="number">0xcf</span>, <span class="keyword">sizeof</span> f), ans = -INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = v[i]; j &lt;= m; ++j) f[j] = std::<span class="built_in">max</span>(f[j - v[i]] + w[i], f[j]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) ans = <span class="built_in">max</span>(ans, f[i]);</span><br></pre></td></tr></table></figure><p>多重背包二进制拆分（以下给出拆分代码）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(Node x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (x.p &gt;= p)</span><br><span class="line">&#123;</span><br><span class="line">b[++o].c = x.c * p;</span><br><span class="line">b[o].t = x.t * p;</span><br><span class="line">b[o].p = <span class="number">1</span>;</span><br><span class="line">x.p -= p;</span><br><span class="line">p &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x.p)</span><br><span class="line">&#123;</span><br><span class="line">b[++o].c = x.c * x.p;</span><br><span class="line">b[o].t = x.t * x.p;</span><br><span class="line">b[o].p = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多重背包单调队列优化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> u, <span class="keyword">int</span> k)</span></span>&#123; <span class="keyword">return</span> f[u + k * v[i]] - k * w[i]; &#125;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0xcf</span>, <span class="keyword">sizeof</span> f), f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; v[i]; ++u) <span class="comment">// u:余数</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">int</span> hh = <span class="number">1</span>, tt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxp = (m - u) / v[i];</span><br><span class="line">        <span class="comment">//将初始的候选集合插入队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = maxp - <span class="number">1</span>; k &gt;= <span class="built_in">max</span>(maxp - c[i], <span class="number">0</span>); --k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">calc</span>(i, u, q[tt]) &lt;= <span class="built_in">calc</span>(i, u, k)) --tt;</span><br><span class="line">            q[++tt] = k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dp</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p = maxp; p &gt;= <span class="number">0</span>; p--) <span class="comment">//循环状态</span></span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; q[hh] &gt; p - <span class="number">1</span>) ++hh; <span class="comment">//排除过时决策</span></span><br><span class="line">            <span class="keyword">if</span> (hh &lt;= tt) f[u + p * v[i]] = std::<span class="built_in">max</span>(f[u + p * v[i]], <span class="built_in">calc</span>(i, u, q[hh]) + p * w[i]); <span class="comment">//取队头转移</span></span><br><span class="line">            <span class="keyword">if</span> (p - c[i] - <span class="number">1</span> &gt;= <span class="number">0</span>) <span class="comment">//新决策入队,同时维护单调</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">calc</span>(i, u, q[tt]) &lt;= <span class="built_in">calc</span>(i, u, p - c[i] - <span class="number">1</span>)) --tt;</span><br><span class="line">                q[++tt] = p - c[i] - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) ans = std::<span class="built_in">max</span>(ans, f[i]);</span><br></pre></td></tr></table></figure><h2 id="单调队列优化"><a href="#单调队列优化" class="headerlink" title="单调队列优化"></a>单调队列优化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> q[N], l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r &amp;&amp; 队头不再合法) ++l;</span><br><span class="line">    用队头跟新d[i]</span><br><span class="line">   <span class="keyword">while</span> (l &lt;= r &amp;&amp; i优于队尾) --r;</span><br><span class="line">    q[++r] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各操作顺序不是严格</p><h2 id="斜率优化"><a href="#斜率优化" class="headerlink" title="斜率优化"></a>斜率优化</h2><p>考虑 $j$ 优与 $k$ 的条件，把 dp 方程化成 $\frac{Y(j) - Y(k)}{X(j) - X(k)} \le 无关j,k的值K$  的形式，然后分情况（以最大值为例）：</p><p> $X, K$ 单调：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> q[N], l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//有时候需要先把0入队</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r &amp;&amp; (<span class="built_in">Y</span>(q[l + <span class="number">1</span>]) - <span class="built_in">Y</span>(q[l])) &gt; <span class="built_in">K</span>(i) * (<span class="built_in">X</span>(q[l + <span class="number">1</span>]) - <span class="built_in">X</span>(q[l]))) ++l; <span class="comment">//至少保证队列中有一个数</span></span><br><span class="line">    用队头跟新<span class="function">i</span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="params">(l &lt; r &amp;&amp; (Y(i) - Y(q[r])) * (X(q[r]) - X(q[r - <span class="number">1</span>])) &gt;= (Y(q[r]) - Y(q[r - <span class="number">1</span>])) * (X(i) - X(q[r])))</span> --r</span>;</span><br><span class="line">    q[++r] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> $X$ 不单调， $K$ 单调：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> q[l];</span><br><span class="line">    <span class="keyword">int</span> ll = l, rr = r, mid, res;</span><br><span class="line">    <span class="keyword">while</span> (ll &lt;= rr)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = ll + rr &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">Y</span>(q[mid + <span class="number">1</span>]) - <span class="built_in">Y</span>(q[mid])) &lt;= (<span class="built_in">X</span>(q[mid + <span class="number">1</span>]) - <span class="built_in">X</span>(q[mid])) * k) res = mid, rr = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> ll = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q[res];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> q[N], l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="built_in">find</span>(i, <span class="built_in">K</span>(i));</span><br><span class="line">    用j跟新<span class="function">i</span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="params">(l &lt; r &amp;&amp; (Y(i) - Y(q[r])) * (X(q[r]) - X(q[r - <span class="number">1</span>])) &gt;= (Y(q[r]) - Y(q[r - <span class="number">1</span>])) * (X(i) - X(q[r])))</span> --r</span>;</span><br><span class="line">    q[++r] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> $X, K$ 都不单调：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">X</span>(x) == <span class="built_in">X</span>(y) ? <span class="built_in">Y</span>(x) &gt; <span class="built_in">Y</span>(y) : <span class="built_in">X</span>(x) &lt; <span class="built_in">X</span>(y); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdq</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        有时候这里有些操作</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    lp = l - <span class="number">1</span>, rp = mid;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) (p[i] &lt;= mid ? tmp[++lp] : tmp[++rp]) = p[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) p[i] = tmp[i];</span><br><span class="line">    <span class="built_in">cdq</span>(l, mid);</span><br><span class="line">    ql = <span class="number">1</span>, qr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= mid; ++i)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; l &amp;&amp; <span class="built_in">X</span>(p[i]) == <span class="built_in">X</span>(p[i - <span class="number">1</span>])) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span> (ql &lt; qr &amp;&amp; (<span class="built_in">Y</span>(q[qr]) - <span class="built_in">Y</span>(q[qr - <span class="number">1</span>])) * (<span class="built_in">X</span>(p[i]) - <span class="built_in">X</span>(q[qr])) &lt;= (<span class="built_in">Y</span>(p[i]) - <span class="built_in">Y</span>(q[qr])) * (<span class="built_in">X</span>(q[qr]) - <span class="built_in">X</span>(q[qr - <span class="number">1</span>]))) --qr;</span><br><span class="line">        q[++qr] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>, u, v; i &lt;= r; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (ql &lt; qr &amp;&amp; (<span class="built_in">Y</span>(q[ql + <span class="number">1</span>]) - <span class="built_in">Y</span>(q[ql])) &gt; (<span class="built_in">X</span>(q[ql + <span class="number">1</span>]) - <span class="built_in">X</span>(q[ql])) * <span class="built_in">K</span>(p[i])) ++ql;</span><br><span class="line">        u = p[i], v = q[ql];</span><br><span class="line">用v跟新u</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cdq</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    lp = tp = l, rp = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lp &lt;= mid &amp;&amp; rp &lt;= r) tmp[tp++] = (<span class="built_in">cmp</span>(p[lp], p[rp]) ? p[lp++] : p[rp++]);</span><br><span class="line">    <span class="keyword">while</span> (lp &lt;= mid) tmp[tp++] = p[lp++];</span><br><span class="line">    <span class="keyword">while</span> (rp &lt;= r) tmp[tp++] = p[rp++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) p[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">在进入cdq之前:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) p[i] = i;</span><br><span class="line">std::<span class="built_in">sort</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>, [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123; <span class="keyword">return</span> <span class="built_in">K</span>(x) &lt; <span class="built_in">K</span>(y); &#125;);</span><br><span class="line">初始化dp数组</span><br></pre></td></tr></table></figure><h2 id="四边形不等式"><a href="#四边形不等式" class="headerlink" title="四边形不等式"></a>四边形不等式</h2><p>式子： $a \le b \le c \le d$ 若 $w(a, d) + w(b, c) \ge w(a, c) + w(b, d)$ 则满足四边形不等式（想象一个四边形，对边和小于对角线和）</p><p>分治打法：</p><p>设函数 <code>sol(l, r, L, R)</code> 表示“当然正在处理 $d[l \sim r]$ ，最优决策存在于区间 $[L, R]$ ”，函数伪代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sol</span>(l, r, L, R)</span><br><span class="line"><span class="keyword">if</span> (l &gt; r || L &gt; R) <span class="keyword">return</span> ;</span><br><span class="line">mid &lt;- (l + r) &gt;&gt; <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i : L -&gt; R</span><br><span class="line">找到最优决策点 pos </span><br><span class="line">end <span class="keyword">for</span></span><br><span class="line">用 pos 跟新 d[mid]</span><br><span class="line"><span class="built_in">sol</span>(l, mid - <span class="number">1</span>, L, pos)</span><br><span class="line"><span class="built_in">sol</span>(mid + <span class="number">1</span>, r, pos, R)</span><br><span class="line">end sol</span><br></pre></td></tr></table></figure><p>要求 $val(i, j)$ 不含与 $d[j]$ 有关的项</p><p>队列 + 二分打法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">q[h = t = <span class="number">1</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, n&#125;; <span class="comment">//把0先入队</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, pos; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (h &lt;= t &amp;&amp; q[h].r &lt; i) ++h;</span><br><span class="line">用q[h].pos跟新i</span><br><span class="line">pos = n + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (h &lt;= t &amp;&amp; 对于q[t].l,i比q[t].pos优) pos = q[t--].l;</span><br><span class="line"><span class="keyword">if</span> (h &lt;= t &amp;&amp; 对于q[t].r,i比q[t].pos优)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> l = q[t].l, r = q[t].r, mid;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line">mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (对于mid,i比q[t].pos优) pos = mid, r = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">q[t].r = pos - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pos &lt;= n) q[++t] = &#123;i, pos, n&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SOS"><a href="#SOS" class="headerlink" title="SOS"></a>SOS</h2><p>子集：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>; ~j; --j) <span class="keyword">if</span> ((j &gt;&gt; i) &amp; <span class="number">1</span>) d[j] += d[j ^ (<span class="number">1</span> &lt;&lt; i)];</span><br></pre></td></tr></table></figure><p>超集：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>; ~j; --j) <span class="keyword">if</span> (!(j &gt;&gt; i) &amp; <span class="number">1</span>) d[j] += d[j ^ (<span class="number">1</span> &lt;&lt; i)];</span><br></pre></td></tr></table></figure><h1 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h1><h2 id="最大流（-Dinic-）："><a href="#最大流（-Dinic-）：" class="headerlink" title="最大流（ Dinic ）："></a>最大流（ Dinic ）：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    STC <span class="keyword">int</span> q[N];</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">1</span>, tt = <span class="number">1</span>, x, y;</span><br><span class="line"><span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="keyword">sizeof</span> dep), q[dep[S] = <span class="number">1</span>] = S, cur[S] = h[S]</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x = q[hh++]]; ~i; i = e[i].ne) <span class="keyword">if</span> (!dep[y = e[i].ver] &amp;&amp; e[i].w)</span><br><span class="line">&#123;</span><br><span class="line">dep[y] = dep[x] + <span class="number">1</span>, cur[y] = h[y];</span><br><span class="line"><span class="keyword">if</span> (y == T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">q[++tt] = y;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> lim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == T) <span class="keyword">return</span> lim;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, y, t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cur[x]; i != <span class="number">-1</span> &amp;&amp; flow &lt; lim;  i = e[i].ne)</span><br><span class="line">    &#123;</span><br><span class="line">        cur[x] = i; <span class="comment">//这里非常玄学,一定要这样写,压行的话可能会TLE</span></span><br><span class="line">        <span class="keyword">if</span> (dep[y = e[i].ver] == dep[x] + <span class="number">1</span> &amp;&amp; e[i].w)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(t = <span class="built_in">find</span>(y, std::<span class="built_in">min</span>(lim - flow, e[i].w)))) dep[y] = <span class="number">0</span>;</span><br><span class="line">            e[i].w -= t, e[i ^ <span class="number">1</span>].w += t, flow += t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>, flow;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">dfs</span>()) <span class="keyword">while</span>(flow = <span class="built_in">find</span>(S, INF)) res += flow;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大流（-HLPP-）："><a href="#最大流（-HLPP-）：" class="headerlink" title="最大流（ HLPP ）："></a>最大流（ HLPP ）：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hi[N], ex[N], gap[N]; <span class="comment">//hi:高度,ex:超额流,gap[i]:高度为i的节点的数量</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; B[N]; <span class="comment">// 桶B[i]中记录所有hi[x]=i的x</span></span><br><span class="line"><span class="keyword">int</span> level = <span class="number">0</span>; <span class="comment">//溢出节点的最高高度</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) hi[i] = INF;</span><br><span class="line">hi[T] = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push</span>(T);</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">x = q.<span class="built_in">front</span>(), q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (e[i ^ <span class="number">1</span>].w &amp;&amp; hi[y] &gt; hi[x] + <span class="number">1</span>) hi[y] = hi[x] + <span class="number">1</span>, q.<span class="built_in">push</span>(y); <span class="comment">//从T倒着搜回去走的是反向边,^1以后就变回正向边</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> hi[S] != INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//尽可能通过能够推送的边推送超额流</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> init = x == S;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y, k; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (!e[i].w || (init == <span class="literal">false</span> &amp;&amp; hi[x] != hi[y] + <span class="number">1</span>)) <span class="keyword">continue</span>; <span class="comment">//初始化时不考虑高度差为1</span></span><br><span class="line">k = init ? e[i].w : <span class="built_in">min</span>(e[i].w, ex[x]); <span class="comment">//取到剩余容量和超额流的最小值初始化时可以使源的溢出量为负数</span></span><br><span class="line"><span class="keyword">if</span> (y != S &amp;&amp; y != T &amp;&amp; !ex[y]) B[hi[y]].<span class="built_in">push_back</span>(y), level = <span class="built_in">max</span>(level, hi[y]);</span><br><span class="line">ex[x] -= k, ex[y] += k, e[i].w -=k, e[i ^ <span class="number">1</span>].w += k;</span><br><span class="line"><span class="keyword">if</span> (!ex[x]) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//如果已经推送完就返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">relabel</span><span class="params">(<span class="keyword">int</span> x)</span>  <span class="comment">//重贴标签(高度)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  hi[x] = INF;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)<span class="keyword">if</span> (e[i].w) hi[x] = <span class="built_in">min</span>(hi[x], hi[e[i].ver]);</span><br><span class="line">  <span class="keyword">if</span> (++hi[x] &lt; n) <span class="comment">//只处理高度小于n的节点</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="comment">//新的高度,更新gap</span></span><br><span class="line">  B[hi[x]].<span class="built_in">push_back</span>(x);</span><br><span class="line">  level = <span class="built_in">max</span>(level, hi[x]);</span><br><span class="line">  ++gap[hi[x]];  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_max</span><span class="params">()</span> <span class="comment">//选出当前高度最大的节点之一,如果已经没有溢出节点返回0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (B[level].<span class="built_in">empty</span>() &amp;&amp; level &gt; <span class="number">-1</span>) --level;</span><br><span class="line"><span class="keyword">return</span> level == <span class="number">-1</span> ? <span class="number">0</span> : B[level].<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hlpp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">bfs</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i) gap[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (hi[i] != INF) ++gap[hi[i]];</span><br><span class="line">hi[S] = n;</span><br><span class="line"><span class="built_in">push</span>(S); <span class="comment">//初始化预流</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">while</span> (x = <span class="built_in">find_max</span>())</span><br><span class="line">&#123;</span><br><span class="line">B[level].<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">push</span>(x)) <span class="comment">//仍然溢出</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!--gap[hi[x]])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">if</span> (i != S &amp;&amp; i != T &amp;&amp; hi[i] &gt; hi[x] &amp;&amp; hi[i] &lt; n + <span class="number">1</span>)</span><br><span class="line">hi[i] = n + <span class="number">1</span>;  <span class="comment">// 这里重贴成 n+1 的节点都不是溢出节点</span></span><br><span class="line">      <span class="built_in">relabel</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ex[T];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="费用流"><a href="#费用流" class="headerlink" title="费用流"></a>费用流</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) dis[i] = INF, cur[i] = h[i];</span><br><span class="line">    std::queue&lt;<span class="keyword">int</span>&gt; q; <span class="comment">//这里只能stl,因为spfa一个点可能入队多次,空间大小未知</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (dis[S] = <span class="number">0</span>, q.<span class="built_in">push</span>(S), vis[S] = <span class="literal">true</span>; !q.<span class="built_in">empty</span>(); )</span><br><span class="line">    &#123;</span><br><span class="line">        vis[x = q.<span class="built_in">front</span>()] = <span class="literal">false</span>, q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne) <span class="keyword">if</span> (dis[y = e[i].ver] &gt; dis[x] + e[i].c &amp;&amp; e[i].w)</span><br><span class="line">        &#123;</span><br><span class="line">            dis[y] = dis[x] + e[i].c;</span><br><span class="line">            <span class="keyword">if</span> (!vis[y]) vis[y] = <span class="literal">true</span>, q.<span class="built_in">push</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[T] != INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> lim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == T) <span class="keyword">return</span> lim;</span><br><span class="line">    vis[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, y, t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cur[x]; i != <span class="number">-1</span> &amp;&amp; flow &lt; lim; i = e[i].ne)</span><br><span class="line">    &#123;</span><br><span class="line">        cur[x] = i;</span><br><span class="line">        <span class="keyword">if</span> (!vis[y = e[i].ver] &amp;&amp; dis[y] == dis[x] + e[i].c &amp;&amp; e[i].w)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(t = <span class="built_in">find</span>(y, std::<span class="built_in">min</span>(lim - flow, e[i].w)))) <span class="keyword">continue</span>;</span><br><span class="line">            e[i].w -= t, e[i ^ <span class="number">1</span>].w += t, flow += t, mincost += t * e[i].c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[x] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mcmf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    maxflow = mincost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> flow;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">spfa</span>()) <span class="keyword">while</span>(flow = <span class="built_in">find</span>(S, INF)) maxflow += flow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小割树"><a href="#最小割树" class="headerlink" title="最小割树"></a>最小割树</h2><p>把 Dinic 的函数改一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _s, <span class="keyword">int</span> <span class="keyword">_t</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S = _s, T = <span class="keyword">_t</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; idx; i += <span class="number">2</span>) e[i].w = (e[i].w + e[i ^ <span class="number">1</span>].w), e[i ^ <span class="number">1</span>].w = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> _s, <span class="keyword">int</span> <span class="keyword">_t</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>(_s, <span class="keyword">_t</span>);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, flow;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">bfs</span>()) <span class="keyword">while</span> (flow = <span class="built_in">find</span>(S, INF)) res += flow;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再加上：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> GHT <span class="comment">//Gomory-Hu Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> D = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> nd[N], h[N], idx = <span class="number">0</span>, dep[N], f[N][D], mn[N][D];</span><br><span class="line">    <span class="function">std::mt19937 <span class="title">rud</span><span class="params">(<span class="number">114514</span>)</span></span>;</span><br><span class="line">    Edge e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>&#123; e[idx] = &#123;h[x], y, z&#125;, h[x] = idx++; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line">        STC <span class="keyword">int</span> tp1[N], tp2[N];</span><br><span class="line">        <span class="keyword">int</span> s, t, flow, ct1 = <span class="number">0</span>, ct2 = <span class="number">0</span>;</span><br><span class="line">        s = nd[l], t = nd[l + <span class="number">1</span>];</span><br><span class="line">        flow = Dinic::<span class="built_in">dinic</span>(s, t);</span><br><span class="line">        <span class="built_in">add</span>(s, t, flow), <span class="built_in">add</span>(t, s, flow);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) (Dinic::dep[nd[i]] ? tp1[++ct1] : tp2[++ct2]) = nd[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ct1; ++i) nd[i + l - <span class="number">1</span>] = tp1[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ct2; ++i) nd[i + l + ct1 - <span class="number">1</span>] = tp2[i];</span><br><span class="line">        <span class="built_in">build</span>(l, l + ct1 - <span class="number">1</span>), <span class="built_in">build</span>(l + ct1, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (q.<span class="built_in">push</span>(<span class="number">1</span>), dep[<span class="number">1</span>] = <span class="number">1</span>; !q.<span class="built_in">empty</span>(); )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne) <span class="keyword">if</span> (!dep[y = e[i].ver])</span><br><span class="line">            &#123;</span><br><span class="line">                dep[y] = dep[x] + <span class="number">1</span>, f[y][<span class="number">0</span>] = x, mn[y][<span class="number">0</span>] = e[i].w;</span><br><span class="line">                q.<span class="built_in">push</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; D; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                mn[i][j] = std::<span class="built_in">min</span>(mn[i][j - <span class="number">1</span>], mn[f[i][j - <span class="number">1</span>]][j - <span class="number">1</span>]);</span><br><span class="line">                f[i][j] = f[f[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) nd[i] = i;</span><br><span class="line">        <span class="built_in">shuffle</span>(nd + <span class="number">1</span>, nd + <span class="number">1</span> + n, rud); <span class="comment">//随机化</span></span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, n), <span class="built_in">bfs</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = INF;</span><br><span class="line">        <span class="keyword">if</span> (dep[x] &gt; dep[y]) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = D - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) <span class="keyword">if</span> (dep[f[y][i]] &gt;= dep[x]) res = std::<span class="built_in">min</span>(res, mn[y][i]), y = f[y][i];</span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">return</span> res == INF ? <span class="number">-1</span> : res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = D - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) <span class="keyword">if</span> (f[x][i] != f[y][i])</span><br><span class="line">        &#123;</span><br><span class="line">            res = std::<span class="built_in">min</span>(res, std::<span class="built_in">min</span>(mn[x][i], mn[y][i]));</span><br><span class="line">            x = f[x][i], y = f[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">        res = std::<span class="built_in">min</span>(res, std::<span class="built_in">min</span>(mn[x][<span class="number">0</span>], mn[y][<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> res == INF ? <span class="number">-1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h1><h2 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a>FFT</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3000000</span> + <span class="number">5</span>; <span class="comment">//注意N要大于二倍n</span></span><br><span class="line"><span class="keyword">const</span> DB PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span> //定义复数</span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">DB a, b;</span><br><span class="line"><span class="function">Complex <span class="title">make_C</span><span class="params">(<span class="keyword">const</span> DB _a, <span class="keyword">const</span> DB _b)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Complex res;</span><br><span class="line">res.a = _a, res.b = _b;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;<span class="keyword">_t</span>) <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="built_in">make_C</span>(a + <span class="keyword">_t</span>.a, b + <span class="keyword">_t</span>.b); &#125;</span><br><span class="line">Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp;<span class="keyword">_t</span>) <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="built_in">make_C</span>(a - <span class="keyword">_t</span>.a, b - <span class="keyword">_t</span>.b); &#125;</span><br><span class="line">Complex <span class="keyword">operator</span>*(<span class="keyword">const</span> Complex &amp;<span class="keyword">_t</span>) <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="built_in">make_C</span>(a * <span class="keyword">_t</span>.a - b * <span class="keyword">_t</span>.b, a * <span class="keyword">_t</span>.b + b * <span class="keyword">_t</span>.a); &#125;</span><br><span class="line">&#125; a[N], b[N];</span><br><span class="line"><span class="keyword">int</span> r[N], bit, tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(Complex x[], <span class="keyword">int</span> inv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) <span class="keyword">if</span> (i &lt; r[i]) std::<span class="built_in">swap</span>(x[i], x[r[i]]);</span><br><span class="line">Complex w1, wk, a1, a2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; tot; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">w1 = w1.<span class="built_in">make_C</span>(<span class="built_in">cos</span>(PI / mid), inv * <span class="built_in">sin</span>(PI / mid)); <span class="comment">//由于cos正负相同,不必乘inv</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i += (mid &lt;&lt; <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">wk = wk.<span class="built_in">make_C</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; ++j, wk = wk * w1)</span><br><span class="line">&#123;</span><br><span class="line">a1 = x[i + j], a2 = wk * x[i + j + mid];</span><br><span class="line">x[i + j] = a1 + a2, x[i + j + mid] = a1 - a2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; bit) &lt; n + m + <span class="number">1</span>) ++bit;</span><br><span class="line">tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (bit - <span class="number">1</span>));</span><br></pre></td></tr></table></figure><h2 id="NTT-全家桶"><a href="#NTT-全家桶" class="headerlink" title="NTT + 全家桶"></a>NTT + 全家桶</h2><p>超长警告</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>, I = <span class="number">86583718</span>, G = <span class="number">3</span>; <span class="comment">//模数,二次剩余,原根</span></span><br><span class="line"><span class="keyword">namespace</span> Poly</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> Cipolla</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> w;</span><br><span class="line"><span class="function">std::mt19937 <span class="title">rud</span><span class="params">(<span class="number">114514</span>)</span></span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="keyword">int</span> x, y;</span><br><span class="line">            Complex <span class="keyword">operator</span> * (<span class="keyword">const</span> Complex t) <span class="keyword">const</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> (Complex)&#123;((LL)x * t.x % P + (LL)y * t.y % P * w % P) % P, ((LL)x * t.y % P + (LL)y * t.x % P) % P&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; ;</span><br><span class="line">        <span class="function">Complex <span class="title">Cqpow</span><span class="params">(Complex x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Complex res = (Complex)&#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = x * x) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = res * x;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">Csqrt</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">qpow</span>(x, (P - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) == P - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> t;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                t = <span class="built_in">rud</span>();</span><br><span class="line">                w = ((LL)t * t % P - x + P) % P;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">qpow</span>(w, (P - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) == P - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="built_in">Cqpow</span>((Complex)&#123;t, <span class="number">1</span>&#125;, (P + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>).x;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(res, P - res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> r[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; ++i) x[i] = y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; ++i) x[i] = y[i]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ready</span><span class="params">(<span class="keyword">int</span> &amp;bit, <span class="keyword">int</span> &amp;tot, <span class="keyword">int</span> len)</span></span>&#123; <span class="keyword">for</span> (tot = <span class="number">1</span>, bit = <span class="number">0</span>; tot &lt; (len &lt;&lt; <span class="number">1</span>); ) tot &lt;&lt;= <span class="number">1</span>, ++bit; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get_r</span><span class="params">(<span class="keyword">int</span> bit, <span class="keyword">int</span> tot)</span></span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (bit - <span class="number">1</span>)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ntt</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> tot, <span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) <span class="keyword">if</span> (i &lt; r[i]) std::<span class="built_in">swap</span>(x[i], x[r[i]]);</span><br><span class="line">        <span class="keyword">int</span> mid, i, j, len, gn, g, a, b;</span><br><span class="line">        <span class="keyword">for</span> (mid = <span class="number">1</span>; mid &lt; tot; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            len = mid &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            gn = <span class="built_in">qpow</span>(G, (P - <span class="number">1</span>) / len);</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="number">-1</span>) gn = <span class="built_in">qpow</span>(gn, P - <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tot; i += len)</span><br><span class="line">            &#123;</span><br><span class="line">                g = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; mid; ++j, g = (LL)g * gn % P)</span><br><span class="line">                &#123;</span><br><span class="line">                    a = x[i + j], b = (LL)g * x[i + j + mid] % P;</span><br><span class="line">                    x[i + j] = (a + b) % P;</span><br><span class="line">                    x[i + j + mid] = (a - b + P) % P;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">        gn = <span class="built_in">qpow</span>(tot, P - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) x[i] = (LL)x[i] * gn % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polymul</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bit, tot;</span><br><span class="line">        <span class="built_in">ready</span>(bit, tot, len);</span><br><span class="line">        <span class="built_in">get_r</span>(bit, tot);</span><br><span class="line">        <span class="built_in">ntt</span>(x, tot, <span class="number">1</span>), <span class="built_in">ntt</span>(y, tot, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) x[i] = (LL)x[i] * y[i] % P;</span><br><span class="line">        <span class="built_in">ntt</span>(x, tot, <span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//记得把x中不用的清0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polyinv</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> len)</span> <span class="comment">//求逆,y记录答案</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(y[<span class="number">0</span>] = <span class="built_in">qpow</span>(x[<span class="number">0</span>], P - <span class="number">2</span>));</span><br><span class="line">        <span class="built_in">polyinv</span>(x, y, (len + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> bit = <span class="number">0</span>, tot = <span class="number">1</span>;</span><br><span class="line">        STC <span class="keyword">int</span> t[N];</span><br><span class="line">        <span class="built_in">ready</span>(bit, tot, len);</span><br><span class="line">        <span class="built_in">get_r</span>(bit, tot);</span><br><span class="line">        <span class="built_in">fill</span>(y, <span class="number">0</span>, (len + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, tot);</span><br><span class="line">        <span class="built_in">fill</span>(t, x, <span class="number">0</span>, len);</span><br><span class="line">        <span class="built_in">fill</span>(t, <span class="number">0</span>, len, tot);</span><br><span class="line">        <span class="built_in">ntt</span>(t, tot, <span class="number">1</span>), <span class="built_in">ntt</span>(y, tot, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) y[i] = (<span class="number">2</span> - (LL)t[i] * y[i] % P + P) % P * y[i] % P;</span><br><span class="line">        <span class="built_in">ntt</span>(y, tot, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">fill</span>(y, <span class="number">0</span>, len, tot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polydiv</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> n, <span class="keyword">int</span> y[], <span class="keyword">int</span> m, <span class="keyword">int</span> a[], <span class="keyword">int</span> b[])</span> <span class="comment">//x除以y商a余b</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        STC <span class="keyword">int</span> ta[N], tb[N];</span><br><span class="line">        <span class="keyword">int</span> dt = n - m + <span class="number">1</span>, tot, bit;</span><br><span class="line">        <span class="built_in">ready</span>(bit, tot, n);</span><br><span class="line">        <span class="built_in">fill</span>(ta, <span class="number">0</span>, <span class="number">0</span>, tot);</span><br><span class="line">        <span class="built_in">fill</span>(tb, <span class="number">0</span>, <span class="number">0</span>, tot);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) ta[i] = y[m - i - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">polyinv</span>(ta, tb, dt);</span><br><span class="line">        <span class="built_in">get_r</span>(bit, tot);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) ta[i] = x[n - i - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">ntt</span>(ta, tot, <span class="number">1</span>), <span class="built_in">ntt</span>(tb, tot, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) ta[i] = (LL)ta[i] * tb[i] %P;</span><br><span class="line">        <span class="built_in">ntt</span>(ta, tot, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dt; ++i) a[i] = ta[dt - i - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">fill</span>(ta, <span class="number">0</span>, <span class="number">0</span>, tot);</span><br><span class="line">        <span class="built_in">fill</span>(tb, <span class="number">0</span>, <span class="number">0</span>, tot);</span><br><span class="line">        <span class="built_in">fill</span>(ta, a, <span class="number">0</span>, dt);</span><br><span class="line">        <span class="built_in">fill</span>(tb, y, <span class="number">0</span>, m);</span><br><span class="line">        <span class="built_in">ntt</span>(ta, tot, <span class="number">1</span>), <span class="built_in">ntt</span>(tb, tot, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) ta[i] = (LL)ta[i] * tb[i] % P;</span><br><span class="line">        <span class="built_in">ntt</span>(ta, tot, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; ++i) b[i] = (x[i] - ta[i] + P) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polydif</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> len)</span> <span class="comment">//求导,y记录答案</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i) y[i - <span class="number">1</span>] = (LL)x[i] * i % P;</span><br><span class="line">        y[len - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polyint</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> len)</span> <span class="comment">//积分,y记录答案</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i) y[i] = (LL)x[i - <span class="number">1</span>] * <span class="built_in">qpow</span>(i, P - <span class="number">2</span>) % P;</span><br><span class="line">        y[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polyln</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        STC <span class="keyword">int</span> a[N], b[N];</span><br><span class="line">        <span class="built_in">polydif</span>(x, a, len);</span><br><span class="line">        <span class="built_in">polyinv</span>(x, b, len);</span><br><span class="line">        <span class="keyword">int</span> bit, tot;</span><br><span class="line">        <span class="built_in">ready</span>(bit, tot, len);</span><br><span class="line">        <span class="built_in">get_r</span>(bit,tot);</span><br><span class="line">        <span class="built_in">fill</span>(a, <span class="number">0</span>, len, tot);</span><br><span class="line">        <span class="built_in">fill</span>(b, <span class="number">0</span>, len, tot);</span><br><span class="line">        <span class="built_in">ntt</span>(a, tot, <span class="number">1</span>), <span class="built_in">ntt</span>(b, tot, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) a[i] = (LL)a[i] * b[i] % P;</span><br><span class="line">        <span class="built_in">ntt</span>(a, tot, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">fill</span>(a, <span class="number">0</span>, len, tot);</span><br><span class="line">        <span class="built_in">polyint</span>(a, y, len);</span><br><span class="line">        <span class="built_in">fill</span>(y, <span class="number">0</span>, len, tot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polyexp</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(y[<span class="number">0</span>] = <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">polyexp</span>(x, y, (len + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> bit, tot;</span><br><span class="line">        STC <span class="keyword">int</span> t[N];</span><br><span class="line">        <span class="built_in">ready</span>(bit, tot, len);</span><br><span class="line">        <span class="built_in">fill</span>(t, <span class="number">0</span>, <span class="number">0</span>, tot);</span><br><span class="line">        <span class="built_in">polyln</span>(y, t, len);</span><br><span class="line">        <span class="built_in">get_r</span>(bit, tot);</span><br><span class="line">        t[<span class="number">0</span>] = (x[<span class="number">0</span>] + <span class="number">1</span> - t[<span class="number">0</span>] + P) % P;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i) t[i] = (x[i] - t[i] + P) % P;</span><br><span class="line">        <span class="built_in">fill</span>(t, <span class="number">0</span>, len, tot);</span><br><span class="line">        <span class="built_in">ntt</span>(t, tot, <span class="number">1</span>), <span class="built_in">ntt</span>(y, tot, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) y[i] = (LL)y[i] * t[i] % P;</span><br><span class="line">        <span class="built_in">ntt</span>(y, tot, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">fill</span>(y, <span class="number">0</span>, len, tot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">k1是真实指数(可以是模后的)</span></span><br><span class="line"><span class="comment">k2是真实指数模P - 1(欧拉定理)</span></span><br><span class="line"><span class="comment">k3用于确定前导0个数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polypow</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> k1, <span class="keyword">int</span> k2, <span class="keyword">int</span> k3, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!x[num] &amp;&amp; num &lt; len) ++num;</span><br><span class="line">        <span class="keyword">if</span> ((LL)num * k3 &gt;= len) <span class="keyword">return</span> <span class="built_in">fill</span>(y, <span class="number">0</span>, <span class="number">0</span>, len);</span><br><span class="line">        STC <span class="keyword">int</span> t[N];</span><br><span class="line">        <span class="keyword">int</span> x0 = x[num], inv = <span class="built_in">qpow</span>(x0, P - <span class="number">2</span>);</span><br><span class="line">        len -= num;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) x[i] = (LL)x[i + num] * inv % P;</span><br><span class="line">        <span class="keyword">int</span> bit, tot;</span><br><span class="line">        <span class="built_in">ready</span>(bit, tot, len);</span><br><span class="line">        <span class="built_in">fill</span>(t, <span class="number">0</span>, <span class="number">0</span>, tot);</span><br><span class="line">        <span class="built_in">fill</span>(x, <span class="number">0</span>, len, tot);</span><br><span class="line">        <span class="built_in">polyln</span>(x, t, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) t[i] = (LL)t[i] * k1 % P;</span><br><span class="line">        <span class="built_in">fill</span>(t, <span class="number">0</span>, len, tot);</span><br><span class="line">        <span class="built_in">polyexp</span>(t, y, len);</span><br><span class="line">        len += num;</span><br><span class="line">        x0 = <span class="built_in">qpow</span>(x0, k2);</span><br><span class="line">        num = num * k3;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= num; --i) y[i] = (LL)y[i - num] * x0 % P;</span><br><span class="line">        <span class="built_in">fill</span>(y, <span class="number">0</span>, <span class="number">0</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ready_for_pow</span><span class="params">(<span class="keyword">char</span> *k, <span class="keyword">int</span> &amp;k1, <span class="keyword">int</span> &amp;k2, <span class="keyword">int</span> &amp;k3)</span> <span class="comment">//k太大,计算k1,k2,k3</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        k1 = k2 = k3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l = <span class="built_in">strlen</span>(k + <span class="number">1</span>); i &lt;= l; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            k1 = ((LL)k1 * <span class="number">10</span> + (k[i] ^ <span class="number">48</span>)) % P;</span><br><span class="line">            k2 = ((LL)k2 * <span class="number">10</span> + (k[i] ^ <span class="number">48</span>)) % (P - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> ((LL)k3 * <span class="number">10</span> + (k[i] ^ <span class="number">48</span>) &lt;= P) k3 = (LL)k3 * <span class="number">10</span> + (k[i] ^ <span class="number">48</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polysqrt</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sq = Cipolla::<span class="built_in">Csqrt</span>(x[<span class="number">0</span>]), inv = <span class="built_in">qpow</span>(x[<span class="number">0</span>], P - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) x[i] = (LL)x[i] * inv % P;</span><br><span class="line">        <span class="built_in">polypow</span>(x, y, (P + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, (P + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, <span class="number">1</span>, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) y[i] = (LL)y[i] * sq % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polysin</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        STC <span class="keyword">int</span> a[N], b[N], c[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) a[i] = (LL)x[i] * I % P;</span><br><span class="line">        <span class="built_in">polyexp</span>(a, b, len);</span><br><span class="line">        <span class="built_in">polyinv</span>(b, c, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) b[i] = (b[i] - c[i] + P) % P;</span><br><span class="line">        <span class="keyword">int</span> inv = <span class="built_in">qpow</span>((I &lt;&lt; <span class="number">1</span>) % P, P - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) y[i] = (LL)b[i] * inv % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polycos</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        STC <span class="keyword">int</span> a[N], b[N], c[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) a[i] = (LL)x[i] * I % P;</span><br><span class="line">        <span class="built_in">polyexp</span>(a, b, len);</span><br><span class="line">        <span class="built_in">polyinv</span>(b, c, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) b[i] = (b[i] + c[i]) % P;</span><br><span class="line">        <span class="keyword">int</span> inv = <span class="built_in">qpow</span>(<span class="number">2</span>, P - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) y[i] = (LL)b[i] * inv % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polytan</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        STC <span class="keyword">int</span> a[N], b[N], c[N];</span><br><span class="line">        <span class="built_in">polysin</span>(x, a, len);</span><br><span class="line">        <span class="built_in">polycos</span>(x, b, len);</span><br><span class="line">        <span class="built_in">polyinv</span>(b, c, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) y[i] = a[i] * c[i] % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polyasin</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        STC <span class="keyword">int</span> a[N], b[N], c[N];</span><br><span class="line">        <span class="built_in">polydif</span>(x, a, len);</span><br><span class="line">        <span class="keyword">int</span> bit, tot;</span><br><span class="line">        <span class="built_in">ready</span>(bit, tot, len);</span><br><span class="line">        <span class="built_in">get_r</span>(bit, tot);</span><br><span class="line">        <span class="built_in">ntt</span>(x, tot, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) b[i] = (<span class="number">1</span> - (LL)x[i] * x[i]% P + P) % P;</span><br><span class="line">        <span class="built_in">ntt</span>(b, tot, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">fill</span>(b, <span class="number">0</span>, len, tot);</span><br><span class="line">        <span class="built_in">polysqrt</span>(b, c, len);</span><br><span class="line">        <span class="built_in">fill</span>(b, <span class="number">0</span>, <span class="number">0</span>, tot);</span><br><span class="line">        <span class="built_in">polyinv</span>(c, b, len);</span><br><span class="line">        <span class="built_in">ntt</span>(a, tot, <span class="number">1</span>), <span class="built_in">ntt</span>(b, tot, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) a[i] = (LL)a[i] * b[i] % P;</span><br><span class="line">        <span class="built_in">ntt</span>(a, tot, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">polyint</span>(a, y, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polyacos</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">polyasin</span>(x, y, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) y[i] = y[i] ? P - y[i] : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polyatan</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        STC <span class="keyword">int</span> a[N], b[N], c[N];</span><br><span class="line">        <span class="built_in">polydif</span>(x, a, len);</span><br><span class="line">        <span class="keyword">int</span> bit, tot;</span><br><span class="line">        <span class="built_in">ready</span>(bit, tot, len);</span><br><span class="line">        <span class="built_in">get_r</span>(bit, tot);</span><br><span class="line">        <span class="built_in">ntt</span>(x, tot, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) b[i] = (<span class="number">1</span> + (LL)x[i] * x[i]% P) % P;</span><br><span class="line">        <span class="built_in">ntt</span>(b, tot, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">fill</span>(b, <span class="number">0</span>, len, tot);</span><br><span class="line">        <span class="built_in">polyinv</span>(b, c, len);</span><br><span class="line">        <span class="built_in">ntt</span>(a, tot, <span class="number">1</span>), <span class="built_in">ntt</span>(c, tot, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) a[i] = (LL)a[i] * c[i] % P;</span><br><span class="line">        <span class="built_in">ntt</span>(a, tot, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">polyint</span>(a, y, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h1><h2 id="浮点数比较"><a href="#浮点数比较" class="headerlink" title="浮点数比较"></a>浮点数比较</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(DB x, DB y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(x - y) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="平面最近点对"><a href="#平面最近点对" class="headerlink" title="平面最近点对"></a>平面最近点对</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LDB p[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Point &amp;t) <span class="keyword">const</span> &#123; <span class="keyword">return</span> p[<span class="number">0</span>] * p[<span class="number">1</span>] &lt; t.p[<span class="number">0</span>] * t.p[<span class="number">1</span>]; &#125;</span><br><span class="line">&#125; p[N];</span><br><span class="line"><span class="function">std::mt19937 <span class="title">rud</span><span class="params">(<span class="number">114514</span>)</span></span>;</span><br><span class="line">LDB th = <span class="built_in">rud</span>(), ans = INF;</span><br><span class="line">LDB z = <span class="built_in">sin</span>(th), w = <span class="built_in">cos</span>(th);</span><br><span class="line">LDB a, b, c, d;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%Lf %Lf&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    p[i] = &#123;a * w + b * z, -a * z + b * w, a, b&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">stable_sort</span>(p + <span class="number">1</span>, p + <span class="number">1</span> + n); <span class="comment">//stable是稳定排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    a = p[i].p[<span class="number">2</span>], b = p[i].p[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= K &amp;&amp; i + j &lt;= n; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        c = p[i + j].p[<span class="number">2</span>], d = p[i + j].p[<span class="number">3</span>];</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, (a - c) * (a - c) + (b - d) * (b - d));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="点间距离"><a href="#点间距离" class="headerlink" title="点间距离"></a>点间距离</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DB <span class="title">dist</span><span class="params">(Point x, Point y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point t = x - y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(t.x * t.x + t.y * t.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><p>用点表示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DB x, y;</span><br><span class="line">Point <span class="keyword">operator</span> + (Point t)&#123; <span class="keyword">return</span> (Point)&#123;x + t.x, y + t.y&#125;; &#125;</span><br><span class="line">Point <span class="keyword">operator</span> - (Point t)&#123; <span class="keyword">return</span> (Point)&#123;x - t.x, y - t.y&#125;; &#125;</span><br><span class="line">Point <span class="keyword">operator</span> * (DB t)&#123; <span class="keyword">return</span> (Point)&#123;x * t, y * t&#125;; &#125;</span><br><span class="line">DB <span class="keyword">operator</span> &amp; (Point t)&#123; <span class="keyword">return</span> x * t.x + y * t.y; &#125; <span class="comment">//点乘</span></span><br><span class="line">DB <span class="keyword">operator</span> * (Point t)&#123; <span class="keyword">return</span> x * t.y - y * t.x; &#125; <span class="comment">//叉乘</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DB <span class="title">mo</span><span class="params">(Point x)</span></span>&#123; <span class="keyword">return</span> std::<span class="built_in">sqrt</span>(x &amp; x); &#125; <span class="comment">//模长</span></span><br><span class="line"><span class="function">DB <span class="title">angle</span><span class="params">(Point x, Point y)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">acos</span>((x &amp; y) / <span class="built_in">mo</span>(x) / <span class="built_in">mo</span>(y)); &#125; <span class="comment">//计算向量夹角</span></span><br><span class="line"><span class="function">Point <span class="title">rot</span><span class="params">(Point x, DB theta)</span> <span class="comment">//向量(点)顺时针旋转角度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;x.x * <span class="built_in">cos</span>(theta) + x.y * <span class="built_in">sin</span>(theta), -x.x * <span class="built_in">sin</span>(theta) + x.y * <span class="built_in">cos</span>(theta)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DB <span class="title">area</span><span class="params">(Point x, Point y, Point z)</span></span>&#123; <span class="keyword">return</span> (y - x) * (z - x); &#125; <span class="comment">//计算XY,XZ围成平行四边形面积</span></span><br></pre></td></tr></table></figure><h2 id="点与线"><a href="#点与线" class="headerlink" title="点与线"></a>点与线</h2><p>点到直线距离：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DB <span class="title">dis_z</span><span class="params">(Point p, Point x, Point y)</span> <span class="comment">//p到直线(x-&gt;y)的距离</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point u = y - x, v = p - x;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>((u * v) / <span class="built_in">mo</span>(u));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点到线段距离：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DB <span class="title">dis_x</span><span class="params">(Point p, Point x, Point y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="built_in">mo</span>(p - x);</span><br><span class="line">    Point u = y - x, v = p - x, w = p - y;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cmp</span>(u &amp; v, <span class="number">0</span>) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">mo</span>(v);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cmp</span>(u &amp; w, <span class="number">0</span>) &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">mo</span>(w);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dis_z</span>(p, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点在直线上的投影：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DB <span class="title">proj</span><span class="params">(Point p, Point x, Point y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point u = y - x;</span><br><span class="line">    <span class="keyword">return</span> x + u * (u &amp; (p - x)) / (u &amp; u));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点是否在直线上：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_on</span><span class="params">(Point p, Point x, Point y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">cmp</span>((p - x) * (p - y), <span class="number">0</span>) &amp;&amp; <span class="built_in">cmp</span>((p - x) &amp; (p - y), <span class="number">0</span>) &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线与线"><a href="#线与线" class="headerlink" title="线与线"></a>线与线</h2><p>直线交点：</p><p> 注意点向式表达直线： $p = p_0 + t \vec{v}$ </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">jiao</span><span class="params">(Point p, Point u, Point q, Point v)</span> <span class="comment">//点项式</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u * v == <span class="number">0</span>) <span class="keyword">return</span> &#123;INF, INF&#125;; <span class="comment">//平行或者重合</span></span><br><span class="line">    DB t = (p - q) * v / (u * v);</span><br><span class="line">    <span class="keyword">return</span> p + u * t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断线段是否相交：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_jiao</span><span class="params">(Point x_1, Point y_1, Point x_2, Point y_2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> c1 = <span class="built_in">cross</span>(y_1 - x_1, x_2 - x_1), c2 = <span class="built_in">cross</span>(y_1 - x_1, y_2 - x_1);</span><br><span class="line">    <span class="keyword">double</span> c3 = <span class="built_in">cross</span>(y_2 - x_2, y_1 - x_2), c4 = <span class="built_in">cross</span>(y_2 - x_2, x_1 - x_2);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cmp</span>(c1, <span class="number">0</span>) * <span class="built_in">cmp</span>(c2, <span class="number">0</span>) &lt;= <span class="number">0</span> &amp;&amp; <span class="built_in">cmp</span>(c3, <span class="number">0</span>) * <span class="built_in">cmp</span>(c4, <span class="number">0</span>) &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多边形"><a href="#多边形" class="headerlink" title="多边形"></a>多边形</h2><p>按<strong>逆时针</strong>存储所有点</p><p>面积：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DB <span class="title">pgarea</span><span class="params">(Point p[], <span class="keyword">int</span> n)</span> <span class="comment">//polygon area</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DB res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i) res += (p[i] - p[<span class="number">0</span>]) * (p[i + <span class="number">1</span>] - p[<span class="number">0</span>]); <span class="comment">// //这里点编号为0~n-1</span></span><br><span class="line">    <span class="keyword">return</span> res / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断点是否在多边形内：</p><p>射线法，从该点任意做一条和所有边都不平行的射线，交点个数为偶数，则在多边形外，为奇数，则在多边形内</p><h2 id="最小圆覆盖"><a href="#最小圆覆盖" class="headerlink" title="最小圆覆盖"></a>最小圆覆盖</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::mt19937 <span class="title">rud</span><span class="params">(<span class="number">114514</span>)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span>&#123;</span> Point p; DB r; &#125; ;</span><br><span class="line"><span class="function">PR&lt;Point, Point&gt; <span class="title">get_line</span><span class="params">(Point x, Point y)</span> </span>&#123; <span class="keyword">return</span> &#123;(x + y) / <span class="number">2</span>, <span class="built_in">rotate</span>(y - x, PI / <span class="number">2</span>)&#125;; &#125; <span class="comment">//找中垂线</span></span><br><span class="line"><span class="function">Circle <span class="title">get_c</span><span class="params">(Point x, Point y, Point z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> u = <span class="built_in">get_line</span>(x, y), v = <span class="built_in">get_line</span>(x, z);</span><br><span class="line">    <span class="keyword">auto</span> p = <span class="built_in">jiao</span>(u.first, u.second, v.first, v.second);</span><br><span class="line">    <span class="keyword">return</span> &#123;p, <span class="built_in">dist</span>(p, x)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(Point p[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::<span class="built_in">shuffle</span>(q, q + n, rud);</span><br><span class="line">    <span class="function">Circle <span class="title">c</span><span class="params">(&#123;q[<span class="number">0</span>], <span class="number">0</span>&#125;)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) <span class="keyword">if</span> (<span class="built_in">cmp</span>(c.r, <span class="built_in">dist</span>(c.p, q[i])) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c = &#123;q[i], <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) <span class="keyword">if</span> (<span class="built_in">cmp</span>(c.r, <span class="built_in">dist</span>(c.p, q[j])) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            c = &#123;(q[i] + q[j]) / <span class="number">2</span>, <span class="built_in">dist</span>(q[i], q[j]) / <span class="number">2</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; j; ++k) <span class="keyword">if</span> (<span class="built_in">cmp</span>(c.r, <span class="built_in">dist</span>(c.p, q[k])) &lt; <span class="number">0</span>) c = <span class="built_in">get_c</span>(q[i], q[j], q[k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DB <span class="title">andrew</span><span class="params">(Point x[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    STC <span class="keyword">int</span> stk[N];</span><br><span class="line">    STC <span class="keyword">bool</span> used[N];</span><br><span class="line">    std::<span class="built_in">sort</span>(x, x + n);</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &gt;= <span class="number">2</span> &amp;&amp; <span class="built_in">area</span>(x[stk[top - <span class="number">1</span>]], x[stk[top]], x[i]) &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 凸包边界上的点即使被从栈中删掉，也不能删掉used上的标记</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">area</span>(x[stk[top - <span class="number">1</span>]], x[stk[top]], x[i])) --top;</span><br><span class="line">            <span class="keyword">else</span> used[stk[top--]] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stk[++top] = i;</span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    used[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (used[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//为了应对所有点共线的情况,这里不能取&lt;=</span></span><br><span class="line">        <span class="keyword">while</span> (top &gt;= <span class="number">2</span> &amp;&amp; <span class="built_in">area</span>(x[stk[top - <span class="number">1</span>]], x[stk[top]], x[i]) &lt; <span class="number">0</span>) --top;</span><br><span class="line">        stk[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    DB res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= top; ++i) res += <span class="built_in">dist</span>(x[stk[i - <span class="number">1</span>]], x[stk[i]]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数也叫 <code>convex(int x[], int n)</code> </p><h2 id="半平面交"><a href="#半平面交" class="headerlink" title="半平面交"></a>半平面交</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Point st, ed;</span><br><span class="line"><span class="function">DB <span class="title">angle</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="built_in">atan2</span>(ed.y - st.y, ed.x - st.x); &#125;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="function">Point <span class="title">jiao</span><span class="params">(Line x, Line y)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">jiao</span>(x.st, x.ed - x.st, y.st, y.ed - y.st); &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">on_r</span><span class="params">(Line &amp;x, Line y, Line z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Point o = <span class="built_in">jiao</span>(y, z);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">cmp</span>(<span class="built_in">area</span>(x.st, x.ed, o), <span class="number">0</span>) &lt;= <span class="number">0</span>; <span class="comment">//这里取不取等依题意</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DB <span class="title">halfp</span><span class="params">(Line x[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(x, x + len);</span><br><span class="line"><span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">STC <span class="keyword">int</span> q[N];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &amp;&amp; !<span class="built_in">cmp</span>(x[i].<span class="built_in">angle</span>(), x[i - <span class="number">1</span>].<span class="built_in">angle</span>())) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_r</span>(x[i], x[q[tt - <span class="number">1</span>]], x[q[tt]])) --tt;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_r</span>(x[i], x[q[hh + <span class="number">1</span>]], x[q[hh]])) ++hh;</span><br><span class="line">q[++tt] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_r</span>(x[q[hh]], x[q[tt - <span class="number">1</span>]], x[q[tt]])) --tt;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_r</span>(x[q[tt]], x[q[hh + <span class="number">1</span>]], x[q[hh]])) ++hh;</span><br><span class="line">q[++tt] = q[hh];</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = hh; i &lt; tt; ++i) ans[k++] = <span class="built_in">jiao</span>(x[q[i]], x[q[i + <span class="number">1</span>]]);</span><br><span class="line">   DB res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + <span class="number">1</span> &lt; k; ++i) res += <span class="built_in">area</span>(ans[<span class="number">0</span>], ans[i], ans[i + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> res / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="旋转卡壳"><a href="#旋转卡壳" class="headerlink" title="旋转卡壳"></a>旋转卡壳</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DB <span class="title">rot_cal</span><span class="params">(Point x[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">convex</span>(x, len);</span><br><span class="line">    <span class="keyword">if</span> (top &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">dist</span>(x[<span class="number">0</span>], x[len - <span class="number">1</span>]);</span><br><span class="line">    DB res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">2</span>; i &lt; top; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> d = x[stk[i]], e = x[stk[i + <span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">area</span>(d, e, x[stk[j]]) &lt; <span class="built_in">area</span>(d, e, x[stk[j + <span class="number">1</span>]])) j = (j + <span class="number">1</span>) % top;</span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="built_in">max</span>(<span class="built_in">dist</span>(d, x[stk[j]]), <span class="built_in">dist</span>(e, x[stk[j]])));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = <span class="built_in">LL</span>(x) * x % P) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = <span class="built_in">LL</span>(res) * x % P;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="光速幂"><a href="#光速幂" class="headerlink" title="光速幂"></a>光速幂</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BL = (<span class="number">1</span> &lt;&lt; <span class="number">16</span>) + <span class="number">5</span>, B = <span class="built_in">sqrt</span>(P);</span><br><span class="line"><span class="keyword">int</span> qp[BL][<span class="number">2</span>], ph;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= x; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) res = res / x * (x - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ph = <span class="built_in">phi</span>(P);</span><br><span class="line">    qp[<span class="number">0</span>][<span class="number">0</span>] = qp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= B; ++i) qp[i][<span class="number">0</span>] = qp[i - <span class="number">1</span>][<span class="number">0</span>] * x % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= B; ++i) qp[i][<span class="number">1</span>] = qp[i - <span class="number">1</span>][<span class="number">1</span>] * qp[B][<span class="number">0</span>] % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qqpow</span><span class="params">(<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    y %= ph;</span><br><span class="line">    <span class="keyword">return</span> qp[y % B][<span class="number">0</span>] * qp[y / B][<span class="number">1</span>] % P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="龟速乘"><a href="#龟速乘" class="headerlink" title="龟速乘"></a>龟速乘</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">mul</span><span class="params">(LL x, LL y, LL p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (x + x) % P) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (res + x) % P;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h2><p>质数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[i]) pri[++cnt] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; <span class="built_in">LL</span>(pri[j]) * i &lt;= n; ++j)</span><br><span class="line">&#123;</span><br><span class="line">vis[pri[j] * i] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>莫比乌斯函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mu[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 1特判</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[i]) pri[++cnt] = i, mu[i] = <span class="number">-1</span>; <span class="comment">//质数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; <span class="built_in">LL</span>(pri[j]) * i &lt;= n; ++j)</span><br><span class="line">&#123;</span><br><span class="line">vis[pri[j] * i] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>) <span class="comment">//若有一个质因数指数大于1</span></span><br><span class="line">&#123; </span><br><span class="line">mu[i * pri[j]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">mu[i * pri[j]] = -mu[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>欧拉函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[i]) pri[++cnt] = i, phi[i] = i - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; <span class="built_in">LL</span>(pri[j]) * i &lt;= n; ++j)</span><br><span class="line">&#123;</span><br><span class="line">vis[pri[j] * i] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">phi[i * pri[j]] = phi[i] * pri[j];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">phi[i * pri[j]] = phi[i] * (pri[j] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分解因数-质因数"><a href="#分解因数-质因数" class="headerlink" title="分解因数/质因数"></a>分解因数/质因数</h2><p>根号暴力即可</p><h2 id="数论分块"><a href="#数论分块" class="headerlink" title="数论分块"></a>数论分块</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">r = n / (n / l);</span><br><span class="line">[l, r]之间的数的(n/i)都相等</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">return</span> y ? <span class="built_in">gcd</span>(y, x % y) : x; &#125;</span><br></pre></td></tr></table></figure><p>拓展版：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!b) <span class="keyword">return</span> x = <span class="number">1</span>, y = <span class="number">0</span>, a;</span><br><span class="line"><span class="keyword">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">y -= a / b * x;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BSGS"><a href="#BSGS" class="headerlink" title="BSGS"></a>BSGS</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsgs</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> % p == b % p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> k = <span class="built_in">sqrt</span>(p) + <span class="number">1</span>;</span><br><span class="line">std::map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ha;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = b % p; i &lt; k; ++i)</span><br><span class="line">&#123;</span><br><span class="line">ha[j] = i;</span><br><span class="line">j = (LL)j * a % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ak = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) ak = (LL)ak * a % p;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = ak; i &lt;= k; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ha.<span class="built_in">find</span>(j) != ha.<span class="built_in">end</span>()) <span class="keyword">return</span> i * k - ha[j];</span><br><span class="line">j = (LL)j * ak % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -INF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拓展版：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exbsgs</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">b = (b % p + p) % p; <span class="comment">//保证b为正数</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> % p == b % p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">int</span> d = <span class="built_in">exgcd</span>(a, p, x, y);</span><br><span class="line"><span class="keyword">if</span> (d &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (b % d) <span class="keyword">return</span> -INF;</span><br><span class="line"><span class="built_in">exgcd</span>(a / d, p / d, x, y);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">exbsgs</span>(a, (LL)b / d * x % (p / d), p / d) + <span class="number">1</span>; <span class="comment">//注意加1 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">bsgs</span>(a, b, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">crt</span><span class="params">(<span class="keyword">int</span> m[], <span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL M = <span class="number">1</span>, res = <span class="number">0</span>, mt, x, y;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) M *= m[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">mt = M / m[i];</span><br><span class="line"><span class="built_in">exgcd</span>(mt, m[i], x, y);</span><br><span class="line">res += mt * a[i] * (x &lt; <span class="number">0</span> ? x + m[t] : x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拓展：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">excrt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL x, y, k, M = m[<span class="number">1</span>], res = a[<span class="number">1</span>]; <span class="comment">//第一个方程的解特判</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">LL a = M, b = m[i], c = (a[i] - res % b + b) % b; <span class="comment">// ax = c (p b)</span></span><br><span class="line">LL d = <span class="built_in">exgcd</span>(a, b, x, y), bg = b / d;</span><br><span class="line"><span class="keyword">if</span> (c % d != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//判断是否无解</span></span><br><span class="line">x = <span class="built_in">mul</span>(x, c / d, bg); <span class="comment">//龟速乘</span></span><br><span class="line">res += x * M; <span class="comment">//更新前k个方程组的答案</span></span><br><span class="line">M *= bg;  <span class="comment">// M为前k个m的lcm</span></span><br><span class="line">res = (res % M + M) % M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (res % M + M) % M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逆元递推式"><a href="#逆元递推式" class="headerlink" title="逆元递推式"></a>逆元递推式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) inv[i] = -(P / i) * inv[P % i];</span><br></pre></td></tr></table></figure><h2 id="斐波拉契数列推导"><a href="#斐波拉契数列推导" class="headerlink" title="斐波拉契数列推导"></a>斐波拉契数列推导</h2><p>$$<br>\begin{aligned}<br>&amp; 设系数r,s使得: \\<br>&amp; F(n) - r F(n - 1) = s[F(n - 1) - rF(n - 2)] \\<br>&amp; F(n) = (s + r)F(n - 1) - sr F(n - 2) \\<br>&amp; 那么有: \\<br>&amp; r + s = 1, rs = -1 \\<br>&amp; 再考虑这些式子: \\<br>&amp; \begin{cases}<br>F(n) - rF(n - 1) = s [F(n - 1) - rF(n - 2)] \\<br>F(n - 1) - rF(n - 2) = s [F(n - 2) - rF(n - 3)] \\<br>…\\<br>F(3) - F(2) = s [F(2) - r F(1)]<br>\end{cases} \\<br>&amp; 联立得: \\<br>&amp; F(n) - rF(n - 1) = s^{n - 2} [F(2) - F(1)] \\<br>&amp; 又因为: s = 1 - r, F(1) = F(2) = 1 \\<br>&amp; 有: F(n) = s^{n - 1} + r F(n - 1) \\<br>&amp; F(n) = s^{n - 1} + r F(n - 1) \\<br>&amp; F(n) = s^{n - 1} + r s^{n - 2} + r^{2} F(n - 2) \\<br>&amp; … \\<br>&amp; F(n) = s^{n - 1} + r s^{n - 2} + r^{2} s^{n - 3} + … + r^{n - 2} s + r^{n - 1} \\<br>&amp; 等比数列求和得: F(n) = \frac{s^{n - 1} - r^{n - 1}\frac{r}{s}}{1 - \frac{r}{s}} \\<br>&amp; F(n) = \frac{s^n - r^n}{s - r} \\<br>&amp; 再由: r + s = 1, rs = -1得: \\<br>&amp; \begin{cases}<br>s = \frac{1 + \sqrt{5}}{2} \\<br>r = \frac{1 - \sqrt{5}}{2}<br>\end{cases} \\<br>&amp; 于是 F(n) = \frac{\sqrt{5}}{5}[(\frac{1 + \sqrt{5}}{2})^n - (\frac{1 - \sqrt{5}}{2})^n]<br>\end{aligned}<br>$$</p><h2 id="威尔逊定理"><a href="#威尔逊定理" class="headerlink" title="威尔逊定理"></a>威尔逊定理</h2><p>$(P - 1)! \equiv -1 \pmod P$ </p><h2 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h2><p>$a^b \equiv a^{b \mod \varphi(P)} \pmod P$ </p><p>顺便还有欧拉函数的一个运用：<br>$$<br>[1 \sim n] 之间与 m 互质的数的个数为 Ans = \frac{n}{m} \varphi(m)<br>$$<br>再给出计算式： $\varphi(x) = x \prod \frac{p - 1}{p}, 其中p是x的质因数$ </p><h2 id="Miller-Rabin-素数测试"><a href="#Miller-Rabin-素数测试" class="headerlink" title="Miller-Rabin 素数测试"></a>Miller-Rabin 素数测试</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="function">std::mt19937 <span class="title">rud</span><span class="params">(<span class="number">114514</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>) <span class="keyword">return</span> a % p;</span><br><span class="line">    <span class="keyword">int</span> w = <span class="built_in">exp</span>(a, m / <span class="number">2</span>, p);</span><br><span class="line">    w = <span class="built_in">LL</span>(w) * w % p;</span><br><span class="line">    <span class="keyword">if</span> (m &amp; <span class="number">1</span>) w = <span class="built_in">LL</span>(w) * a % p;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">miller_rabin</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="built_in">rud</span>() % (n - <span class="number">2</span>) + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">exp</span>(a, n, n) != a) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="组合计数"><a href="#组合计数" class="headerlink" title="组合计数"></a>组合计数</h1><h2 id="组合数计算"><a href="#组合数计算" class="headerlink" title="组合数计算"></a>组合数计算</h2><p>$A_n^m = \frac{n!}{(n - m)!}$ </p><p>$C_n^m = \binom{n}{m} =  \frac{A_n^m}{m!} = \frac{n!}{m!(n - m)!}$ </p><p>特别的，当 $m &gt; n$ 时， $C_n^m = A_n^m = 0$ </p><p>多重排列： $\binom{n}{n_1, n_2, …, n_k} = \frac{n!}{\prod n_i!}$ </p><p>错位排列： $f(n) = (n - 1)(f(n - 1) + f(n - 2))$ </p><p>错位排列2 ： $f(n) = n!(\frac{1}{1!} - \frac{1}{2!} + \frac{1}{3!} - … + (-1)^{n - 1} \frac{1}{n!})$ </p><p> 圆排： $Q_n^r = \frac{A_n^r}{r}$  </p><p>组合数的一些性质：<br>$$<br>\begin{aligned}<br>&amp; \binom{n}{m} = \binom{n}{n - m} \\<br>&amp; \binom{n}{k} = \frac{n}{k} \binom{n - 1}{k - 1} \\<br>&amp; \binom{n}{m} = \binom{n - 1}{m} + \binom{n - 1}{m} \\<br>&amp; \binom{n}{0} + \binom{n}{1} + … + \binom{n}{n} = 2^n \\<br>&amp; \sum_{0}^n (-1)^i \binom{n}{i} = [n == 0] \<br>&amp; \sum_{i = 0}^{m} \binom{n}{i} \binom{m}{m - i} = \binom{m + n}{m} (n \ge m)\\<br>&amp; \sum_{i = 0}^n \binom{n}{i}^2 = \binom{2n}{n} \\<br>&amp; \sum_{i = 0}^n i \binom{n}{i} = n 2^{n - 1} \\<br>&amp; \sum_{i = 0}^n i^2 \binom{n}{i} = n (n + 1) 2^{n - 2} \\<br>&amp; \sum_{i = 0}^n \binom{i}{k} = \binom{n + 1}{k + 1} \\<br>&amp; \binom{n}{t} \binom{t}{k} = \binom{n}{k} = \binom{n - k}{t - k} \\<br>&amp; \sum_{i = 0}^n \binom{n - i}{i} = F(n + 1) (其中F(n + 1)表示斐波拉契数列)<br>\end{aligned}<br>$$</p><p>做 $k$ 次前缀异或和，对于最后一个数，第 $i$ 个数被计算次数为 $\binom{n - i + k - 1}{k - 1} = \binom{n - i + k - 1}{n - i}$ </p><h2 id="Lucas-定理"><a href="#Lucas-定理" class="headerlink" title="Lucas 定理"></a>Lucas 定理</h2><p>$\binom{n}{m} \mod P = \binom{\lfloor n / P \rfloor}{\lfloor m / P \rfloor} * \binom{n \mod P}{m \mod P} \mod P$ </p><p>推论： $\binom{n}{m} \equiv 1 \pmod 2$ 的充要条件是 $m \subseteq n$ </p><h2 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h2><p>$$<br>\begin{aligned}<br>&amp; Cat(n) = \frac{\binom{2n}{n}}{n + 1} \\<br>&amp; Cat(n) =<br>\begin{cases}<br>\sum_{i = 1}^n Cat(i - 1)Cat(n - i) &amp; n \ge 2 \\<br>1 &amp; n = 0, 1<br>\end{cases} \\<br>&amp; Cat(n) = \frac{Cat(n - 1)(4n - 2)}{n + 1} \\<br>&amp; Cat(n) = \binom{2n}{n} - \binom{2n}{n - 1}<br>\end{aligned}<br>$$</p><h2 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h2><p>$$<br>\begin{aligned}<br>&amp; F(n) = \sum_{d \mid n} f(d) \Rightarrow f(n) = \sum_{d \mid n} \mu(d) F(\frac{n}{d}) \\<br>&amp; F(n) = \sum_{n \mid d} f(d) \Rightarrow f(n) = \sum_{n \mid d} \mu(\frac{d}{n}) F(d) \\<br>&amp; \sum_{d \mid n} \mu(d) = [n == 1] \\<br>&amp; \sum_{d \mid n} \frac{\mu(d)}{d} = \frac{\varphi(n)}{n} \\<br>&amp; d(nm) = \sum_{i \mid n} \sum_{j \mid m} [\gcd(i, j) == 1] (其中d(x)表示x的约数个数)<br>\end{aligned}<br>$$</p><h2 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h2><p>普通型 OGF ：<br>$$<br>\begin{aligned}<br>&amp; \prod_{i = 1}^n( \sum_{m \in M_i} x^m) (其中M_i是a_i的出现次数集合) \\<br>&amp; 常见的有: \\<br>&amp; \frac{1}{(1 - x)^n} = 1 + nx + \frac{n * (n + 1)}{2!}x^2 + \frac{n * (n + 1) * (n + 2)}{3!} + … \\<br>&amp; \frac{1}{1 - x} = 1 + x + x^2 + x^3 + …<br>\end{aligned}<br>$$<br>指数型 EGF ：<br>$$<br>\begin{aligned}<br>&amp; \prod_{i = 1}^n( \sum_{m \in M_i} \frac{x^m}{m!}) (其中M_i是a_i的出现次数集合) \\<br>&amp; 常见的有: \\<br>&amp; e^x = \sum_{n = 0}^{\infty} \frac{x^n}{n!} = 1 + x + \frac{x^2}{2!} + … \\<br>&amp; \frac{e^x + e{-x}}{2} = \sum_{n = 0}^{\infty} \frac{x^{2n}}{(2n)!} = 1 + \frac{x^2}{2!} + \frac{x^4}{4!} + … \\<br>&amp; \frac{e^x - e^{-x}}{2} = \sum_{n = 0}^{\infty} \frac{x^{2n + 1}}{(2n + 1)!} = x + \frac{x^3}{3!} + \frac{x^5}{5!} + …<br>\end{aligned}<br>$$</p><h1 id="群论"><a href="#群论" class="headerlink" title="群论"></a>群论</h1><h2 id="置换群"><a href="#置换群" class="headerlink" title="置换群"></a>置换群</h2><p> $n$ 个元素 $1, 2, …, n$ 之间的一个置换 $f = \binom{1, 2, 3, …, n}{a_1, a_2, a_3, …, a_n}$ ，表示“ $1$ 被 $a_1$ 取代， $2$ 被 $a_2$ 取代，依此类推”，其中 $a_1, a_2, …, a_n$是 $1 \sim n$ 的一个排列</p><h2 id="Burnside-引理"><a href="#Burnside-引理" class="headerlink" title="Burnside 引理"></a>Burnside 引理</h2><p>$$<br>L = \frac{1}{\mid G \mid} \sum_{j = 1}^s D(a_j)<br>$$</p><p>其中 $L$ 表示本质不同的方案数，$D(a_j)$  表示在置换 $a_i$ 下不变的元素个数， $\mid G \mid$ 是置换群大小</p><h2 id="Polya-定理"><a href="#Polya-定理" class="headerlink" title="Polya 定理"></a>Polya 定理</h2><p>记 $c(f)$ 为置换 $f$ 的循环节个数， .$m$ 为颜色总数，有 $D(f) = m^{c(f)}$  ，则有：<br>$$<br>L = \frac{1}{\mid G \mid} (\sum_{j = 1}^s m^{c(a_j)})<br>$$</p><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mtx</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DB x[N][N];</span><br><span class="line">    DB* <span class="keyword">operator</span> [] (<span class="keyword">int</span> id)&#123; <span class="keyword">return</span> x[id]; &#125;</span><br><span class="line">&#125; a;</span><br></pre></td></tr></table></figure><h2 id="LU分解"><a href="#LU分解" class="headerlink" title="LU分解"></a>LU分解</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> DLT <span class="comment">//Doolittle</span></span><br><span class="line">&#123;</span><br><span class="line">    Mtx l, u;</span><br><span class="line">    DB X[N], Y[N];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_lu</span><span class="params">(Mtx x, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k, i, j, r;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= len; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = k; j &lt;= len; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                u[k][j] = x[k][j];</span><br><span class="line">                <span class="keyword">for</span> (r = k - <span class="number">1</span>; r; --r) u[k][j] -= l[k][r] * u[r][j];</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">fabs</span>(u[k][j]) &lt; eps) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!(<span class="built_in">fabs</span>(u[k][j]) &gt; eps)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i = k; i &lt;= len; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                l[i][k] = x[i][k];</span><br><span class="line">                <span class="keyword">for</span> (r = k - <span class="number">1</span>; r; --r) l[i][k] -= l[i][r] * u[r][k];</span><br><span class="line">                l[i][k] /= u[k][k];</span><br><span class="line">            &#125;</span><br><span class="line">            l[k][k] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(DB x[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k, r;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= len; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            Y[k] = x[k];</span><br><span class="line">            <span class="keyword">for</span> (r = k - <span class="number">1</span>; r; --r) Y[k] -= l[k][r] * Y[r];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (k = len; k; --k)</span><br><span class="line">        &#123;</span><br><span class="line">            X[k] = Y[k];</span><br><span class="line">            <span class="keyword">for</span> (r = k + <span class="number">1</span>; r &lt;= len; ++r) X[k] -= u[k][r] * X[r];</span><br><span class="line">            X[k] /= u[k][k];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(X[k]) &lt; eps) X[k] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">guass</span><span class="params">(Mtx &amp;x, <span class="keyword">int</span> len)</span> <span class="comment">//注意传实参</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, t, now;</span><br><span class="line">    <span class="keyword">for</span> (i = now = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t = now;</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &lt;= len; ++j) <span class="keyword">if</span> (<span class="built_in">fabs</span>(x[j][i]) &gt; <span class="built_in">fabs</span>(x[t][i])) t = j;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(x[t][i]) &lt; eps) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (t != now) std::<span class="built_in">swap</span>(x.x[t], x.x[now]);</span><br><span class="line">        <span class="keyword">for</span> (j = len + <span class="number">1</span>; j &gt;= i; --j) x[now][j] /= x[now][i];</span><br><span class="line">        <span class="keyword">for</span> (j = now + <span class="number">1</span>; j &lt;= len; ++j) <span class="keyword">if</span> (<span class="built_in">fabs</span>(x[j][i]))</span><br><span class="line">            <span class="keyword">for</span> (k = len + <span class="number">1</span>; k &gt;= i; --k) x[j][k] -= x[j][i] * x[now][k];</span><br><span class="line">        ++now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (now &lt;= len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = now; i &lt;= len; ++i) <span class="keyword">if</span> (<span class="built_in">fabs</span>(x[i][len + <span class="number">1</span>]) &gt; eps) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> len - now + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = len; i; --i)</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= len; ++j) x[i][len + <span class="number">1</span>] -= x[i][j] * x[j][len + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = len; i; --i) <span class="keyword">if</span> (<span class="built_in">fabs</span>(x[i][len + <span class="number">1</span>]) &lt; eps) x[i][len + <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//防止出现-0.00</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="矩阵求逆"><a href="#矩阵求逆" class="headerlink" title="矩阵求逆"></a>矩阵求逆</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mtxinv</span><span class="params">(Mtx &amp;x, Mtx &amp;as, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, t;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (t = i; t &lt;= len; ++t) <span class="keyword">if</span> (x[t][i]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (t &gt; len) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (t != i) std::<span class="built_in">swap</span>(x.x[t], x.x[i]), std::<span class="built_in">swap</span>(as.x[t], as.x[i]);</span><br><span class="line">        <span class="keyword">if</span> (x[i][i] != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = len, t = <span class="built_in">qpow</span>(x[i][i], P - <span class="number">2</span>); j &gt;= <span class="number">1</span>; --j) as[i][j] = <span class="built_in">LL</span>(t) * as[i][j] % P;</span><br><span class="line">            <span class="keyword">for</span> (j = len, t = <span class="built_in">qpow</span>(x[i][i], P - <span class="number">2</span>); j &gt;= i; --j) x[i][j] = <span class="built_in">LL</span>(t) * x[i][j] % P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= len; ++j) <span class="keyword">if</span> (x[j][i])</span><br><span class="line">            <span class="keyword">for</span> (k = len; k &gt;= <span class="number">1</span>; --k) <span class="built_in">adj</span>(as[j][k] -= <span class="built_in">LL</span>(x[j][i]) * as[i][k] % P);</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= len; ++j) <span class="keyword">if</span> (x[j][i])</span><br><span class="line">            <span class="keyword">for</span> (k = len; k &gt;= i; --k) <span class="built_in">adj</span>(x[j][k] -= <span class="built_in">LL</span>(x[j][i]) * x[i][k] % P);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = len; i; --i)</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= len; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (k = len; k &gt;= <span class="number">1</span>; --k) <span class="built_in">adj</span>(as[i][k] -= <span class="built_in">LL</span>(x[i][j]) * as[j][k] % P);</span><br><span class="line">            <span class="built_in">adj</span>(x[i][len + <span class="number">1</span>] -= <span class="built_in">LL</span>(x[i][j]) * x[j][len + <span class="number">1</span>] % P);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">det</span><span class="params">(Mtx x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>, i, j, t, k, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (x[i][i]) <span class="comment">//对第i行和第j行做辗转相减</span></span><br><span class="line">            &#123;</span><br><span class="line">                t = x[j][i] / x[i][i];</span><br><span class="line">                <span class="keyword">for</span> (k = i; k &lt;= n; ++k) <span class="built_in">adj</span>(x[j][k] -= <span class="built_in">LL</span>(t) * x[i][k] % p);</span><br><span class="line">                std::<span class="built_in">swap</span>(x.x[i], x.x[j]), f ^= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            std::<span class="built_in">swap</span>(x.x[i], x.x[j]), f ^= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">LL</span>(res) * x[i][i] % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!f) <span class="built_in">adj</span>(res = -res); <span class="comment">//注意res=0时</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用前要保证是正数</p><h2 id="Matrix-Tree"><a href="#Matrix-Tree" class="headerlink" title="Matrix-Tree"></a>Matrix-Tree</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">det</span><span class="params">(<span class="keyword">int</span> x[][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>, w = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">2</span>; i &lt;= n; ++i) <span class="comment">//以1为根,故删掉1行1列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (x[i][i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> div = x[j][i] / x[i][i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= n; ++k)</span><br><span class="line">x[j][k] = (x[j][k] - (LL)div * x[i][k] % P + P) % P;</span><br><span class="line"><span class="built_in">swap</span>(x[i], x[j]);</span><br><span class="line">w = -w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(x[i], x[j]);</span><br><span class="line">w = -w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">res = (LL)x[i][i] * res % P;</span><br><span class="line">res *= w;</span><br><span class="line"><span class="keyword">return</span> (res + P) % P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  $k$ 是度数矩阵减邻接矩阵 </p><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><h2 id="快读快输"><a href="#快读快输" class="headerlink" title="快读快输"></a>快读快输</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> FIO</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L = (<span class="number">1</span> &lt;&lt; <span class="number">20</span>) + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">char</span> buf[L], out[L], *S, *E;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gh() (S == E ? E = (S = buf) + fread(buf, 1, L, stdin), (S == E ? EOF : *S++) : *S++)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flus</span><span class="params">()</span></span>&#123; <span class="built_in">fwrite</span>(out, <span class="number">1</span>, l, stdout), l = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chk</span><span class="params">()</span></span>&#123; <span class="keyword">if</span> (l &gt;= L - <span class="number">100</span>) <span class="built_in">flus</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putc</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123; out[l++] = x, <span class="built_in">chk</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rd</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch = <span class="built_in">gh</span>();</span><br><span class="line"><span class="keyword">while</span> (ch &lt; <span class="number">33</span> || ch &gt; <span class="number">126</span>) ch = <span class="built_in">gh</span>();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt;= <span class="number">33</span> &amp;&amp; ch &lt;= <span class="number">126</span>; ch = <span class="built_in">gh</span>()) *s++ = ch;</span><br><span class="line">*s = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wt</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123; <span class="keyword">while</span> (*s != <span class="string">&#x27;\0&#x27;</span>) <span class="built_in">putc</span>(*s++); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>&#123; <span class="keyword">while</span> (*s != <span class="string">&#x27;\0&#x27;</span>) <span class="built_in">putc</span>(*s++); &#125; <span class="comment">//这是为了可以直接&quot;&quot;构造字符串输出</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rd</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch = <span class="built_in">gh</span>(), t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>; ch = <span class="built_in">gh</span>()) t |= ch == <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">0</span>; ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>; ch = <span class="built_in">gh</span>()) x = x * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line"><span class="keyword">if</span> (t) x = -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wt</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">0</span>) x = -x;</span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">9</span>) <span class="built_in">wt</span>(x / <span class="number">10</span>);</span><br><span class="line">out[l++] = x % <span class="number">10</span> + <span class="number">48</span>, <span class="built_in">chk</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rd</span><span class="params">(T &amp;x, Args &amp;...args)</span></span>&#123; <span class="built_in">rd</span>(x), <span class="built_in">rd</span>(args...); &#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rd</span><span class="params">(<span class="keyword">char</span> *x, Args ...args)</span></span>&#123; <span class="built_in">rd</span>(x), <span class="built_in">rd</span>(args...); &#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wt</span><span class="params">(T x, Args ...args)</span></span>&#123; <span class="built_in">wt</span>(x), <span class="built_in">wt</span>(args...); &#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wt</span><span class="params">(<span class="keyword">char</span> *x, Args ...args)</span></span>&#123; <span class="built_in">wt</span>(x), <span class="built_in">wt</span>(args...); &#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *x, Args ...args)</span></span>&#123; <span class="built_in">wt</span>(x), <span class="built_in">wt</span>(args...); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> gh</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> FIO::flus;</span><br><span class="line"><span class="keyword">using</span> FIO::rd;</span><br><span class="line"><span class="keyword">using</span> FIO::wt;</span><br></pre></td></tr></table></figure><p>无法读入浮点数；不可以字符串和整型一起读入（但可以一起输出）；注意最后要 <code>flus()</code> 一下；只能文件输入（但可以随意输出），如果要本地输入请 <code>#define gh() getchar()</code>  </p><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><p>只会很不优美的写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> l, r, mid, res;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line">    mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">chk</span>(mid)) l = mid + <span class="number">1</span>, res = mid;</span><br><span class="line">    <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><h2 id="三分"><a href="#三分" class="headerlink" title="三分"></a>三分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> l, r, lm, rm, res, len;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line">    len = (r - l + <span class="number">1</span>) / <span class="number">3</span>;</span><br><span class="line">    lm = l + len;</span><br><span class="line">    rm = lm + len;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">f</span>(lm) &lt; <span class="built_in">f</span>(rm)) res = rm, l = lm + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">f</span>(lm) &gt; <span class="built_in">f</span>(rm)) res = lm, r = rm - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><h2 id="模拟退火"><a href="#模拟退火" class="headerlink" title="模拟退火"></a>模拟退火</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> DB T0 = <span class="number">1e4</span>, TE = <span class="number">1e-4</span>, C = <span class="number">0.99</span>, SP = <span class="number">1e3</span>; <span class="comment">//这是参数,影响时间和精度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">E</span><span class="params">()</span></span>&#123; 这是一个估计函数(同时会跟新ans),越优的状态其估计越小 &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simulate_anneal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    预处理</span><br><span class="line">    DB now = <span class="built_in">E</span>(), np, dt, ct;</span><br><span class="line">    <span class="keyword">for</span> (DB t = E0; t &gt; TE; t *= C)</span><br><span class="line">    &#123;</span><br><span class="line">        随机进入新的状态,新状态与现状态的差异大小最好和t正相关</span><br><span class="line">        np = <span class="built_in">E</span>();</span><br><span class="line">        dt = np - now;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">exp</span>(-dt / t) &gt; 生成的一个(<span class="number">0</span>, <span class="number">1</span>)之间的随机数)</span><br><span class="line">        &#123;</span><br><span class="line">            跳至新状态</span><br><span class="line">           now = np；</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            恢复原状态</span><br><span class="line">            <span class="keyword">if</span> ((++ct) &gt; SP) <span class="keyword">return</span> ; <span class="comment">//一个优化:多次为转移就直接以当前状态做最优解</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">一般会多次调用simulate_anneal或调小C以保证正确性</span><br></pre></td></tr></table></figure><h2 id="取模优化"><a href="#取模优化" class="headerlink" title="取模优化"></a>取模优化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adj</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123; x += (x &gt;&gt; <span class="number">31</span>) &amp; P; &#125;</span><br></pre></td></tr></table></figure><p>仅限 $x$ 为负数时可用，当 $x$ 是 <code>LL</code> 时把 $31$ 改成 $63$ </p><h2 id="Min-Max-容斥"><a href="#Min-Max-容斥" class="headerlink" title="Min-Max 容斥"></a>Min-Max 容斥</h2><p>$$<br>\begin{aligned}<br>&amp; \max(S) = \sum_{T \subseteq S} (-1)^{\mid T \mid - 1} \min(T) \\<br>&amp; \min(S) = \sum_{T \subseteq S} (-1)^{\mid T \mid - 1} \max(T) \\<br>&amp; kmax(S) = \sum_{T \subseteq S} (-1)^{\mid T \mid - k} \binom{\mid T \mid - 1}{k - 1} \min(T)<br>\end{aligned}<br>$$</p><h2 id="FWT"><a href="#FWT" class="headerlink" title="FWT"></a>FWT</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> FWT</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> iv2 = <span class="number">499122177</span>; <span class="comment">//2的逆元</span></span><br><span class="line"><span class="keyword">void</span> _or(<span class="keyword">int</span> x[], <span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; i &lt;&lt;= <span class="number">1</span>) <span class="comment">//当前区间长度</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = i &gt;&gt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; len; j += i) <span class="comment">//j当前区间前端</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k) <span class="built_in">adj</span>(x[k + mid] += x[k] - P);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">u_or</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = i &gt;&gt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; len; j += i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k) <span class="built_in">adj</span>(x[k + mid] -= x[k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _and(<span class="keyword">int</span> x[], <span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = i &gt;&gt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; len; j += i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k) <span class="built_in">adj</span>(x[k] += x[k + mid] - P);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">u_and</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = i &gt;&gt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; len; j += i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k) <span class="built_in">adj</span>(x[k] -= x[k + mid]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _xor(<span class="keyword">int</span> x[], <span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, t1, t2; i &lt;= len; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = i &gt;&gt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; len; j += i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k)</span><br><span class="line">&#123;</span><br><span class="line">t1 = x[k], t2 = x[k + mid];</span><br><span class="line"><span class="built_in">adj</span>(x[k] = t1 + t2 - P), <span class="built_in">adj</span>(x[k + mid] = t1 - t2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">u_xor</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, t1, t2; i &lt;= len; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = i &gt;&gt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; len; j += i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k)</span><br><span class="line">&#123;</span><br><span class="line">t1 = x[k], t2 = x[k + mid];</span><br><span class="line"><span class="built_in">adj</span>(x[k] = t1 + t2 - P), <span class="built_in">adj</span>(x[k + mid] = t1 - t2);</span><br><span class="line">x[k] = <span class="built_in">LL</span>(iv2) * x[k] % P, x[k + mid] = <span class="built_in">LL</span>(iv2) * x[k + mid] % P;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="子集卷积"><a href="#子集卷积" class="headerlink" title="子集卷积"></a>子集卷积</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pct(x) __builtin_popcount(x)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;bit), n = (<span class="number">1</span> &lt;&lt; bit);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;f[<span class="built_in">pct</span>(i)][i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;g[<span class="built_in">pct</span>(i)][i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= bit; ++i) <span class="built_in">fwt</span>(f[i], n), <span class="built_in">fwtor</span>(g[i], n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= bit; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j + i &lt;= bit; ++j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; n; ++s) <span class="built_in">adj</span>(h[i + j][s] += <span class="built_in">LL</span>(f[i][s]) * g[j][s] % P - P);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= bit; ++i) <span class="built_in">ufwtor</span>(h[i], n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, h[<span class="built_in">pct</span>(i)][i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性基"><a href="#线性基" class="headerlink" title="线性基"></a>线性基</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STC static</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">int</span> n; <span class="comment">//n是题目中插入到线性基里的个数</span></span><br><span class="line"><span class="keyword">namespace</span> LB  <span class="comment">//Linear Basis</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">63</span>;</span><br><span class="line">    LL a[L + <span class="number">5</span>], si;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123; <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a), si = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(LL  x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L; ~i; --i) <span class="keyword">if</span> ((x &gt;&gt; i) &amp; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> (!a[i]) <span class="keyword">return</span> ++si, <span class="built_in"><span class="keyword">void</span></span>(a[i] = x);</span><br><span class="line">            <span class="keyword">else</span> x ^= a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">LL <span class="title">gmx</span><span class="params">()</span> <span class="comment">//get max</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LL res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L; ~i; --i) res = std::<span class="built_in">max</span>(res ^ a[i], res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">LL <span class="title">gmn</span><span class="params">()</span> <span class="comment">//get min</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (si &lt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= L; ++i) <span class="keyword">if</span> (a[i]) <span class="keyword">return</span> a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L; ~i; --i) <span class="keyword">if</span> ((x &gt;&gt; i) &amp; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> (!a[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> x ^= a[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reb</span><span class="params">()</span> <span class="comment">//rebuild</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        STC <span class="keyword">int</span> tp[L + <span class="number">5</span>];</span><br><span class="line">        si = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= L; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; ~j; --j) <span class="keyword">if</span> ((a[i] &gt;&gt; j) &amp; <span class="number">1</span>) a[i] ^= a[j];</span><br><span class="line">            <span class="keyword">if</span> (a[i]) tp[si++] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; si; ++i) a[i] = tp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">LL <span class="title">gk</span><span class="params">(LL k)</span> <span class="comment">//get k</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LL res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (si &lt; n &amp;&amp; !(--k)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= (<span class="number">1ll</span> &lt;&lt; si)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; si; ++i) <span class="keyword">if</span> ((k &gt;&gt; i) &amp; <span class="number">1</span>) res ^= a[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="脚本和指令"><a href="#脚本和指令" class="headerlink" title="脚本和指令"></a>脚本和指令</h2><p>win：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g++ %<span class="number">1</span>.cpp -o %<span class="number">1</span>.exe -O2 -std=c++<span class="number">11</span> -Wall -Wextra -Wl,--stack=<span class="number">1145141919</span></span><br><span class="line"><span class="keyword">if</span> &quot;<span class="variable">%errorlevel%</span>&quot; == &quot;<span class="number">0</span>&quot; (</span><br><span class="line">    %<span class="number">1</span>.exe</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>linux：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">g++ $1.cpp -o $1 -O2 -std=c++11 -Wall -Wextra</span><br><span class="line">if [ $? -eq 0 ]</span><br><span class="line">then </span><br><span class="line">    ./$1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; rt&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="模板" scheme="https://dyd-true.github.io/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>CF1119H Triple</title>
    <link href="https://dyd-true.github.io/2022/05/28/CF1119H-Triple/"/>
    <id>https://dyd-true.github.io/2022/05/28/CF1119H-Triple/</id>
    <published>2022-05-28T06:51:50.000Z</published>
    <updated>2022-05-28T09:11:22.678Z</updated>
    
    <content type="html"><![CDATA[<p> FWT + 解方程 高级版</p><span id="more"></span><p><a href="https://codeforces.com/problemset/problem/1119/H">Triple</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定常数 $k \le 17$ 和常数 $x, y, z \le 10^9$ ，现在有 $n \le 10^5$ 个数组，对于每个数组，给定 $a_i, b_i, c_i \le 2^k$ ，表示该数组有 $x$ 个 $a_i$ ， $y$ 个 $b_i$ ， $z$ 个 $c_i$ ，现在从每个数组中选一个数字异或起来得到 $sum$ ，对于每个 $sum \in [0, 2^k)$ ，输出方案数</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先考虑暴力 FWT ：构造幂级数 $f_i(t) = xt^{a_i} + yt^{b_i} + zt^{c_i}$ ，定义幂级数乘法为异或卷积，那么设 $F = \prod f_i$ ，则 $F[i]$ 即为 $sum = i$ 的方案数，直接暴力 FWT 是 $O(nk2^k)$ </p><p>任然考虑手玩一下 FWT ，记幂级数 $f’ = FWT(f)$ ，有 $f’[s] = (-1)^{\mid a_i \&amp; s\mid} x + (-1)^{\mid b_i \&amp; s\mid} y + (-1)^{\mid c_i \&amp; s\mid} z$  $f’[s] = (-1)^{\mid a_i &amp; s\mid} x + (-1)^{\mid b_i &amp; s\mid} y + (-1)^{\mid c_i &amp; s\mid} z$ </p><p>这有点痛苦，考虑把三元组 $(a_i, b_i, c_i)$ 变成 $(a_i \oplus c_i, b_i \oplus c_i, 0)$ ，记 $C = c_1 \oplus c_2 \oplus … \oplus c_n$ ，最后 $sum$ 的答案存在 $sum \oplus C$ 处；以下的讨论中，$a, b, sum$ 都是已经变换了的</p><p>那么 $f’[s] = (-1)^{\mid a_i \&amp; s\mid} x + (-1)^{\mid b_i \&amp; s\mid} y + z$  $f’[s] = (-1)^{\mid a_i &amp; s\mid} x + (-1)^{\mid b_i &amp; s\mid} y + z$ ，就只有四种情况：</p><ol><li> $x + y + z$ </li><li> $x - y + z$ </li><li> $-x + y + z$ </li><li> $-x - y + z$ </li></ol><p>不妨记以上四种情况出现的次数分别为 $d_1, d_2, d_3, d_4$ ，可得： $F’[s] = (x + y + z)^{d_1}(x - y + z)^{d_2}(-x + y + z)^{d_3}(-x - y + z)^{d_4}$ ，于是问题变成求 $d_1, d_2, d_3, d_4$ </p><p>考虑解方程，我们现在有 $d_1 + d_2 + d_3 + d_4 = n$ ，还要再找到 $3$ 个方程，我们使用 FWT 找方程：</p><ol><li>构造 $G(t) = \sum_{i = 1}^{n} t^{a_i}$ ，那么 $G’[s] = (-1)^{\mid s \&amp; a_i \mid}$ $G’[s] = (-1)^{\mid s &amp; a_i \mid}$ ，即只有 $x$ 符号的贡献，那么有 $G’[s] = d_1 + d_2 - d_3 - d_4$ ，不妨记作 $d_1 + d_2 - d_3 - d_4 = p_1$ </li><li>同理构造 $G(t) = \sum_{i = 1}^{n} t^{b_i}$ ，有 $G’[s] = d_1 + d_3 - d_2 - d_4$ 不妨记作 $d_1 - d_2 + d_3 - d_4 = p_2$ </li><li>最后再构造 $G(t) = \sum_{i = 1}^{n} t^{a_i \oplus b_i}$ ，有 $G’[s] = d_1 + d_4 - d_2 - d_3$ ，不妨记作 $d_1 - d_2 - d_3 + d_4 = p_3$ </li></ol><p>于是我们有：<br>$$<br>\begin{cases}<br>d_1 + d_2 + d_3 + d_4 = n \\<br>d_1 + d_2 - d_3 - d_4 = p_1 \\<br>d_1 - d_2 + d_3 - d_4 = p_2 \\<br>d_1 - d_2 - d_3 + d_4 = p_3<br>\end{cases}<br>$$<br>手玩解得：<br>$$<br>\begin{cases}<br>d_1 = \frac{n + p_1 + p_2 + p_3}{4} \\<br>d_2 = \frac{n + p_1 - p_2 - p_3}{4} \\<br>d_3 = \frac{n - p_1 + p_2 - p_3}{4} \\<br>d_4 = \frac{n - p_1 - p_2 + p_3}{4}<br>\end{cases}<br>$$<br>时间复杂度 $O(k2^k)$ </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">100</span>, K = <span class="number">20</span>, P = <span class="number">998244353</span>, iv2 = <span class="number">499122177</span>, iv4 = <span class="number">748683265</span>;</span><br><span class="line"><span class="keyword">int</span> n, tot, C;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N], c[N], g[N &lt;&lt; <span class="number">1</span>], f[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line">std::array&lt;<span class="keyword">int</span>, 4&gt; d[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adj</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123; x += (x &gt;&gt; <span class="number">31</span>) &amp; P; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = <span class="built_in">LL</span>(x) * x % P) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = <span class="built_in">LL</span>(res) * x % P;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fwtor</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, t1, t2; i &lt;= len; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> mid = i &gt;&gt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; len; j += i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                t1 = x[k], t2 = x[k + mid];</span><br><span class="line">                <span class="built_in">adj</span>(x[k] = t1 + t2 - P), <span class="built_in">adj</span>(x[k + mid] = t1 - t2);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ifwtor</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, t1, t2; i &lt;= len; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> mid = i &gt;&gt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; len; j += i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                t1 = x[k], t2 = x[k + mid];</span><br><span class="line">                <span class="built_in">adj</span>(x[k] = t1 + t2 - P), <span class="built_in">adj</span>(x[k + mid] = t1 - t2);</span><br><span class="line">                x[k] = <span class="built_in">LL</span>(iv2) * x[k] % P, x[k + mid] = <span class="built_in">LL</span>(iv2) * x[k + mid] % P;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;tot), tot = <span class="number">1</span> &lt;&lt; tot;</span><br><span class="line">    <span class="keyword">int</span> u, v, w, t0, t1, t2, t3;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">    t0 = (<span class="built_in">LL</span>(u) + v + w) % P;</span><br><span class="line">    t1 = ((<span class="built_in">LL</span>(u) - v + w ) % P + P) % P;</span><br><span class="line">    t2 = ((<span class="built_in">LL</span>(-u) + v + w) % P + P) % P;</span><br><span class="line">    t3 = ((<span class="built_in">LL</span>(-u) - v + w) % P + P) % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a[i], &amp;b[i], &amp;c[i]);</span><br><span class="line">        a[i] ^= c[i], b[i] ^= c[i], C ^= c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= tot; ++i) d[i] = &#123;n, n, n, n&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">adj</span>(++g[a[i]]);</span><br><span class="line">    <span class="built_in">fwtor</span>(g, tot);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= tot; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">adj</span>(d[i][<span class="number">0</span>] += g[i] - P);</span><br><span class="line">        <span class="built_in">adj</span>(d[i][<span class="number">1</span>] += g[i] - P);</span><br><span class="line">        <span class="built_in">adj</span>(d[i][<span class="number">2</span>] -= g[i]);</span><br><span class="line">        <span class="built_in">adj</span>(d[i][<span class="number">3</span>] -= g[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0</span>, (tot + <span class="number">1</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">adj</span>(++g[b[i]]);</span><br><span class="line">    <span class="built_in">fwtor</span>(g, tot);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= tot; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">adj</span>(d[i][<span class="number">0</span>] += g[i] - P);</span><br><span class="line">        <span class="built_in">adj</span>(d[i][<span class="number">1</span>] -= g[i]);</span><br><span class="line">        <span class="built_in">adj</span>(d[i][<span class="number">2</span>] += g[i] - P);</span><br><span class="line">        <span class="built_in">adj</span>(d[i][<span class="number">3</span>] -= g[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0</span>, (tot + <span class="number">1</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">adj</span>(++g[a[i] ^ b[i]]);</span><br><span class="line">    <span class="built_in">fwtor</span>(g, tot);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= tot; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">adj</span>(d[i][<span class="number">0</span>] += g[i] - P);</span><br><span class="line">        <span class="built_in">adj</span>(d[i][<span class="number">1</span>] -= g[i]);</span><br><span class="line">        <span class="built_in">adj</span>(d[i][<span class="number">2</span>] -= g[i]);</span><br><span class="line">        <span class="built_in">adj</span>(d[i][<span class="number">3</span>] += g[i] - P);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= tot; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        d[i][<span class="number">0</span>] = <span class="built_in">LL</span>(iv4) * d[i][<span class="number">0</span>] % P;</span><br><span class="line">        d[i][<span class="number">1</span>] = <span class="built_in">LL</span>(iv4) * d[i][<span class="number">1</span>] % P;</span><br><span class="line">        d[i][<span class="number">2</span>] = <span class="built_in">LL</span>(iv4) * d[i][<span class="number">2</span>] % P;</span><br><span class="line">        d[i][<span class="number">3</span>] = <span class="built_in">LL</span>(iv4) * d[i][<span class="number">3</span>] % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= tot; ++i) f[i] = <span class="built_in">LL</span>(<span class="built_in">qpow</span>(t0, d[i][<span class="number">0</span>])) * <span class="built_in">qpow</span>(t1, d[i][<span class="number">1</span>]) % P * <span class="built_in">qpow</span>(t2, d[i][<span class="number">2</span>]) % P * <span class="built_in">qpow</span>(t3, d[i][<span class="number">3</span>]) % P;</span><br><span class="line">    ifwtor(f, tot);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, f[i ^ C]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; FWT + 解方程 高级版&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="数论,数学" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
    <category term="CF" scheme="https://dyd-true.github.io/tags/CF/"/>
    
    <category term="FWT" scheme="https://dyd-true.github.io/tags/FWT/"/>
    
  </entry>
  
  <entry>
    <title>UOJ310黎明前的巧克力</title>
    <link href="https://dyd-true.github.io/2022/05/28/UOJ310%E9%BB%8E%E6%98%8E%E5%89%8D%E7%9A%84%E5%B7%A7%E5%85%8B%E5%8A%9B/"/>
    <id>https://dyd-true.github.io/2022/05/28/UOJ310%E9%BB%8E%E6%98%8E%E5%89%8D%E7%9A%84%E5%B7%A7%E5%85%8B%E5%8A%9B/</id>
    <published>2022-05-28T06:08:16.000Z</published>
    <updated>2022-05-28T07:00:35.523Z</updated>
    
    <content type="html"><![CDATA[<p> FWT + 解方程</p><span id="more"></span><p><a href="https://uoj.ac/problem/310">黎明前的巧克力</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>设集合 $S$ 中的数异或和为 $0$ ，那么显然集合 $S$ 的任意一种划分方案都是答案，即答案为 $2^{\mid S \mid}$ ，考虑 FWT ，对于每个数 $a_i$ ，构造幂级数 $f_i(x) = (1 + 2x^{a_i})$ （不选为 $1$ ，选了集合大小 $+1$ ，在指数上就是 $\times 2$ ），那么定义乘法为异或卷积，记 $A = \max(a_i), F = \prod_{i = 1}^n f_i$ ， $F[0]$ 显然就是答案（其实要 $-1$ 因为不能划分成空集），但直接暴力 FWT 时间为 $O(nA \log A)$ 无法接受</p><p>这里引入一个技巧，考虑到 $f_i$ 其实只要两项，它 FWT 变换后的数组 $f’_i$ 其实可以手玩，即 $f’<em>i = \sum</em>{s = 0}^A (1 + (-1)^{\mid a_i \&amp; s \mid} \times 2)x^s$ $f’<em>i(x) = \sum</em>{s = 0}^A (1 + (-1)^{\mid a_i &amp; s \mid} \times 2)x^s$，不难发现 $f’<em>i$ 的每一位其实只有 $-1$ 和 $3$ 两种取值，把它们连乘，得到 $F’(x) = \sum</em>{s = 0}^A (-1)^{n - t_s} \times 3^t_s x^s$ ，那么我们只要得到每一个 $t_s$ 即可得到 $F’$ </p><p>考虑幂级数 $G = \sum_{i = 1}^n f_i$  ，由于 FWT 的线性，它的 FWT 变换为  $G’(x) = \sum_{i = 1}^n f’<em>i(x) = \sum</em>{s = 0}^A (-1 \times (n - t_s) + 3 \times t_s) x^s$ ，那么只要求得 $G’$ 即可解出 $t_s$ ，得到 $F’$ 后再 IFWT 回去即得 $F$ </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>注意由于 $tot$ 是 $2$ 的次幂，数组要开两倍</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span> + <span class="number">100</span>, P = <span class="number">998244353</span>, iv2 = <span class="number">499122177</span>, iv4 = <span class="number">748683265</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N], mx, tot;</span><br><span class="line"><span class="keyword">int</span> f[N], pw3[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adj</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123; x += (x &gt;&gt; <span class="number">31</span>) &amp; P; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fwtor</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, t1, t2; i &lt;= len; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> mid = i &gt;&gt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; len; j += i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                t1 = x[k], t2 = x[k + mid];</span><br><span class="line">                <span class="built_in">adj</span>(x[k] = t1 + t2 - P), <span class="built_in">adj</span>(x[k + mid] = t1 - t2);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ifwtor</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, t1, t2; i &lt;= len; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> mid = i &gt;&gt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; len; j += i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                t1 = x[k], t2 = x[k + mid];</span><br><span class="line">                <span class="built_in">adj</span>(x[k] = t1 + t2 - P), <span class="built_in">adj</span>(x[k + mid] = t1 - t2);</span><br><span class="line">                x[k] = <span class="built_in">LL</span>(x[k]) * iv2 % P, x[k + mid] = <span class="built_in">LL</span>(x[k + mid]) * iv2 % P;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    pw3[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) pw3[i] = <span class="built_in">LL</span>(pw3[i - <span class="number">1</span>]) * <span class="number">3</span> % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        f[<span class="number">0</span>] += <span class="number">1</span>, f[a[i]] += <span class="number">2</span>;</span><br><span class="line">        mx = std::<span class="built_in">max</span>(mx, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    tot = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (tot &lt;= mx) tot &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">fwtor</span>(f, tot);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t; i &lt; tot; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t = <span class="built_in">LL</span>(f[i] + n) * iv4 % P;</span><br><span class="line">        <span class="built_in">adj</span>(f[i] = pw3[t] * ((n - t) &amp; <span class="number">1</span> ? <span class="number">-1</span> : <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    ifwtor(f, tot);</span><br><span class="line">    <span class="built_in">adj</span>(f[<span class="number">0</span>] -= <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; FWT + 解方程&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="数论,数学" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
    <category term="FWT" scheme="https://dyd-true.github.io/tags/FWT/"/>
    
    <category term="UOJ" scheme="https://dyd-true.github.io/tags/UOJ/"/>
    
  </entry>
  
  <entry>
    <title>luoguP4655 [CEOI2017]Building Bridges</title>
    <link href="https://dyd-true.github.io/2022/05/27/luoguP4655-CEOI2017-Building-Bridges/"/>
    <id>https://dyd-true.github.io/2022/05/27/luoguP4655-CEOI2017-Building-Bridges/</id>
    <published>2022-05-27T01:49:48.000Z</published>
    <updated>2022-05-27T07:55:37.784Z</updated>
    
    <content type="html"><![CDATA[<p> 斜率优化 + cdq分治</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P4655">Building Bridges</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>直接上 dp ，设 $d[i]$ 表示“连接 $1$ 和 $i$ 的最小代价” ，并令 $s[i]$ 表示 $w$ 的前缀和，那么有：<br>$$<br>d[i] = \min(d[j] + (h[i] - h[j])^2 + s[i - 1] - s[j])<br>$$<br>同样考虑决策 $j$ 优于 $k$ ，有：<br>$$<br>\begin{aligned}<br>d_j + (h_i - h_j)^2 + s_{i - 1} - s_j &amp;&lt; d_k + (h_i - h_k)^2 + s_{i - 1} - s_k \\<br>d_j + h_j^2 - 2h_ih_j - s_j &amp;&lt; d_k + h_k^2 - 2h_ih_k - s_k \\<br>\frac{(d_j + h_j^2 - s_j) - (d_k + h_k^2 - s_k)}{h_j - h_k} &amp;&lt; 2h_i<br>\end{aligned}<br>$$<br>发现 $h_j$ 和 $2h_i$ 都不单调，考虑 cdq 分治，先按 $2h_i$ 排序，每次先递归计算 $[l, mid]$ ，回来时把它们按 $h_j$ 排序，然后用 $[l, mid]$ 去跟新 $[mid + 1, r]$ ，再递归 $[mid + 1, r]$ 即可</p><p>时间 $O(n \log n)$ </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>一定要注意是 $p[i]$ 不是 $i$ ！一定要考虑 $X$ 相同的情况！</p><p>另外，实测加了 <code>inline</code> 的函数打法和 <code>#define</code> 的打法一样快</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IL inline</span></span><br><span class="line"><span class="comment">// #define X(x) (h[x])</span></span><br><span class="line"><span class="comment">// #define Y(x) (d[x] + h[x] * h[x] - s[x])</span></span><br><span class="line"><span class="comment">// #define K(x) (2 * h[x])</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> p[N], tmp[N], lp, rp, tp, q[N], ql, qr;</span><br><span class="line">IL LL s[N], d[N], h[N]; </span><br><span class="line"><span class="function">IL LL <span class="title">X</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> h[x]; &#125;</span><br><span class="line"><span class="function">IL LL <span class="title">Y</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> d[x] + h[x] * h[x] - s[x]; &#125;</span><br><span class="line"><span class="function">IL LL <span class="title">K</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> <span class="number">2</span> * h[x]; &#125;</span><br><span class="line"><span class="function">IL <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">X</span>(x) == <span class="built_in">X</span>(y) ? <span class="built_in">Y</span>(x) &lt; <span class="built_in">Y</span>(y) : <span class="built_in">X</span>(x) &lt; <span class="built_in">X</span>(y); &#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">cdq</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    lp = l - <span class="number">1</span>, rp = mid;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) (p[i] &lt;= mid ? tmp[++lp] : tmp[++rp]) = p[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) p[i] = tmp[i];</span><br><span class="line">    <span class="built_in">cdq</span>(l, mid);</span><br><span class="line">    ql = <span class="number">1</span>, qr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= mid; ++i)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; l &amp;&amp; <span class="built_in">X</span>(p[i]) == <span class="built_in">X</span>(p[i - <span class="number">1</span>])) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span> (ql &lt; qr &amp;&amp; (<span class="built_in">Y</span>(q[qr]) - <span class="built_in">Y</span>(q[qr - <span class="number">1</span>])) * (<span class="built_in">X</span>(p[i]) - <span class="built_in">X</span>(q[qr])) &gt;= (<span class="built_in">Y</span>(p[i]) - <span class="built_in">Y</span>(q[qr])) * (<span class="built_in">X</span>(q[qr]) - <span class="built_in">X</span>(q[qr - <span class="number">1</span>]))) --qr;</span><br><span class="line">        q[++qr] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>, u, v; i &lt;= r; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (ql &lt; qr &amp;&amp; (<span class="built_in">Y</span>(q[ql + <span class="number">1</span>]) - <span class="built_in">Y</span>(q[ql])) &lt; (<span class="built_in">X</span>(q[ql + <span class="number">1</span>]) - <span class="built_in">X</span>(q[ql])) * <span class="built_in">K</span>(p[i])) ++ql;</span><br><span class="line">        u = p[i], v = q[ql];</span><br><span class="line">d[u] = std::<span class="built_in">min</span>(d[u], d[v] + (h[u] - h[v]) * (h[u] - h[v]) + s[u - <span class="number">1</span>] - s[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cdq</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    lp = tp = l, rp = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lp &lt;= mid &amp;&amp; rp &lt;= r) tmp[tp++] = (<span class="built_in">cmp</span>(p[lp], p[rp]) ? p[lp++] : p[rp++]);</span><br><span class="line">    <span class="keyword">while</span> (lp &lt;= mid) tmp[tp++] = p[lp++];</span><br><span class="line">    <span class="keyword">while</span> (rp &lt;= r) tmp[tp++] = p[rp++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) p[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;h[i]), p[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;s[i]), s[i] += s[i - <span class="number">1</span>];</span><br><span class="line">    std::<span class="built_in">sort</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>, [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123; <span class="keyword">return</span> <span class="built_in">K</span>(x) &lt; <span class="built_in">K</span>(y); &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) d[i] = INF;</span><br><span class="line">    <span class="built_in">cdq</span>(<span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, d[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 斜率优化 + cdq分治&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
    <category term="斜率优化" scheme="https://dyd-true.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
    <category term="CDQ" scheme="https://dyd-true.github.io/tags/CDQ/"/>
    
  </entry>
  
  <entry>
    <title>luoguP3628 [APIO2010]特别行动队</title>
    <link href="https://dyd-true.github.io/2022/05/26/luoguP3628-APIO2010-%E7%89%B9%E5%88%AB%E8%A1%8C%E5%8A%A8%E9%98%9F/"/>
    <id>https://dyd-true.github.io/2022/05/26/luoguP3628-APIO2010-%E7%89%B9%E5%88%AB%E8%A1%8C%E5%8A%A8%E9%98%9F/</id>
    <published>2022-05-26T12:54:02.000Z</published>
    <updated>2022-05-26T13:03:13.777Z</updated>
    
    <content type="html"><![CDATA[<p> 斜率优化</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P3628">特别行动队</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先上个前缀和，设 $d[i]$ 表示“前 $i$ 个数能得到的最大值”，转移为：<br>$$<br>d[i] = \max(d[j] + a(s[i] - s[j])^2 + b(s[i] - s[j]) + c)<br>$$<br>显然斜率优化，化式子，考虑 $j$ 优于 $k$ 的条件：<br>$$<br>\begin{aligned}<br>d[j] + a(s[i] - s[j])^2 + b(s[i] - s[j]) + c &amp;&gt; d[k] + a(s[i] - s[k])^2 + b(s[i] - s[k]) + c \\<br>d[j] + as[i]^2 - 2as[i]s[j] + as[j]^2 + bs[i] -  bs[j] + c &amp;&gt; d[k] + as[i]^2 - 2as[i]s[k] + as[k]^2 + bs[i] -  bs[k] + c \\<br>d[j] - 2as[i]s[j] + as[j]^2 -  bs[j] &amp;&gt; d[k] - 2as[i]s[k] + as[k]^2 -  bs[k] \\<br>\frac{(d[j] + as[j]^2 - bs[j]) - (d[k] + as[k]^2 - bs[k])}{s[j] - s[k]} &amp;&gt; 2as[i]<br>\end{aligned}<br>$$<br>显然维护斜率递增即可，考虑到 $X(t) = s[t]$ ， $K(t) = 2as[t]$ 都是单调的，直接上单调队列即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>太久没打了，调了半天</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n, a, b, c, s[N], q[N], l, r;</span><br><span class="line">LL d[N];</span><br><span class="line"><span class="function">LL <span class="title">X</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> s[x]; &#125;</span><br><span class="line"><span class="function">LL <span class="title">Y</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> d[x] + <span class="built_in">LL</span>(a) * s[x] * s[x] - <span class="built_in">LL</span>(b) * s[x]; &#125;</span><br><span class="line"><span class="function">LL <span class="title">K</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> <span class="number">2ll</span> * a * s[x]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) s[i] += s[i - <span class="number">1</span>];</span><br><span class="line">    q[l = r = <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; (<span class="built_in">Y</span>(q[l + <span class="number">1</span>]) - <span class="built_in">Y</span>(q[l])) &gt; (<span class="built_in">X</span>(q[l + <span class="number">1</span>]) - <span class="built_in">X</span>(q[l])) * <span class="built_in">K</span>(i)) ++l;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= r) d[i] = d[q[l]] + <span class="built_in">LL</span>(s[i] - s[q[l]]) * (s[i] - s[q[l]]) * a + <span class="built_in">LL</span>(s[i] - s[q[l]]) * b + c;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; (<span class="built_in">Y</span>(q[r]) - <span class="built_in">Y</span>(q[r - <span class="number">1</span>])) * (<span class="built_in">X</span>(i) - <span class="built_in">X</span>(q[r])) &lt;= (<span class="built_in">Y</span>(i) - <span class="built_in">Y</span>(q[r])) * (<span class="built_in">X</span>(q[r]) - <span class="built_in">X</span>(q[r - <span class="number">1</span>]))) --r;</span><br><span class="line">        q[++r] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, d[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 斜率优化&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
    <category term="斜率优化" scheme="https://dyd-true.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>luoguP2989 [USACO10MAR]Need For Speed S</title>
    <link href="https://dyd-true.github.io/2022/05/26/luoguP2989-USACO10MAR-Need-For-Speed-S/"/>
    <id>https://dyd-true.github.io/2022/05/26/luoguP2989-USACO10MAR-Need-For-Speed-S/</id>
    <published>2022-05-26T11:53:04.000Z</published>
    <updated>2022-05-26T12:09:29.508Z</updated>
    
    <content type="html"><![CDATA[<p> 01分数规划</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P2989">Need For Speed S</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>一眼望过去就是01分数规划的板子题，但又要求保证 $M + \sum M_i X_i$ 最小</p><p>结论是：按照 $\frac{F_i}{M_i}$ 降序排序可以保证</p><p>证明：反设无法保证，那么，对于当前二分的答案 $e$ ，存在 $a, b, c, d$ 满足：</p><ol><li> $a$ 是已选中的但不在最优答案的 $i$ 的 $F_i$ 之和</li><li> $b$ 是已选中的但不在最优答案的 $i$ 的 $M_i$ 之和</li><li> $c$ 是未选中的但在最优答案的 $i$ 的 $F_i$ 之和</li><li> $d$ 是未选中的但在最优答案的 $i$ 的 $M_i$ 之和</li></ol><p>再设 $e = \frac{A}{B}$ ，那么有：<br>$$<br>\begin{aligned}<br>&amp; \frac{A - a + c}{B - b + d} = e \\<br>\Rightarrow &amp; \frac{a - c}{b - d} = e<br>\end{aligned}<br>$$<br>且 $b &gt; d$ （因为 $c, d$ 更优）</p><p>不妨设 $a = c + ke$ （这个 $k$ 不是题目中的 $k$ ），则 $b = d + k$ ，那么由于我们假设的是无法保证，所以 $\frac{c}{d}$ 排在 $\frac{a}{b}$ 的后面，即：<br>$$<br>\begin{aligned}<br>&amp; \frac{c + ke}{d + k} &gt; \frac{c}{d} \\<br>\Rightarrow &amp; ed &gt; c<br>\end{aligned}<br>$$<br>但考虑设 $A’ = A - a, B’ = B - b$ ，有 $\frac{A’ + c}{B’ + d} = e$ ，必有 $\frac{c}{d} &gt; e$ ，因为如果 $\frac{c}{d} &lt; e$ ，我们可推得 $\frac{A’}{B’} &gt; e$ ，选了反而让答案变小，这和 $c, d$ 是最优解矛盾，所以 $\frac{c}{d} &gt; e$ ，那么有 $c &gt; ed$ ，又矛盾</p><p>综上，原命题成立</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> DB = <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">const</span> DB eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">100</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">DB m, f;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> DB f, m; <span class="keyword">int</span> id; &#125; a[N];</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; ans, as;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(DB x, DB y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(x - y) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(DB x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">as.<span class="built_in">clear</span>();</span><br><span class="line">DB t = m * x - f, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (<span class="built_in">cmp</span>(a[i].f - a[i].m * x, <span class="number">0</span>) == <span class="number">1</span>) </span><br><span class="line">&#123;</span><br><span class="line">as.<span class="built_in">push_back</span>(a[i].id);</span><br><span class="line">sum += a[i].f - a[i].m * x;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">cmp</span>(sum, t) != <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">cmp</span>(sum, t) != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">ans = as;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf %d&quot;</span>, &amp;f, &amp;m, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf&quot;</span>, &amp;a[i].f, &amp;a[i].m), a[i].id = i;</span><br><span class="line">std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, [&amp;](Node x, Node y)&#123; <span class="keyword">return</span> x.f * y.m &gt; y.f * x.m; &#125;);</span><br><span class="line">DB l = <span class="number">0</span>, r = INF, mid;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cmp</span>(l, r) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">chk</span>(mid)) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid;</span><br><span class="line">&#125;</span><br><span class="line">std::<span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">if</span> (!ans.<span class="built_in">size</span>()) <span class="built_in">puts</span>(<span class="string">&quot;NONE&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">for</span> (<span class="keyword">int</span> i : ans) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 01分数规划&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="贪心" scheme="https://dyd-true.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="二分" scheme="https://dyd-true.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
    <category term="01分数规划" scheme="https://dyd-true.github.io/tags/01%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>luoguP2254 [NOI2005] 瑰丽华尔兹</title>
    <link href="https://dyd-true.github.io/2022/05/26/luoguP2254-NOI2005-%E7%91%B0%E4%B8%BD%E5%8D%8E%E5%B0%94%E5%85%B9/"/>
    <id>https://dyd-true.github.io/2022/05/26/luoguP2254-NOI2005-%E7%91%B0%E4%B8%BD%E5%8D%8E%E5%B0%94%E5%85%B9/</id>
    <published>2022-05-26T11:22:03.000Z</published>
    <updated>2022-05-26T11:53:38.280Z</updated>
    
    <content type="html"><![CDATA[<p> 实现有点麻烦</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P2254">瑰丽华尔兹</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>不难发现，对于每一段，如果要停，就在最后停，答案不变，考虑设 $d[i][x][y]$ 表示“第 $i$ 段时间，在 $x, y$  停下的最长路”，转移显然是：<br>$$<br>d[i][x][y] = \max(d[i - 1][x’][y’]) + abs(x - x’) + abs(y - y’)<br>$$<br>不难发现，对于每个 $i$ ，方向是固定的， $x, y$ 中只会有一个变化，且是单调的，所以直接上单调队列，第一维可以滚动掉，时间为 $O(knm)$ </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>单调队列一定要看清楚队头和队尾！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> PII = std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200</span> + <span class="number">100</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, num, a, b, d[<span class="number">2</span>][N][N], l, r, ans, dx[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dy[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">PII q[N]; </span><br><span class="line"><span class="keyword">char</span> mp[N][N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Time</span>&#123;</span> <span class="keyword">int</span> s, t, d; &#125; c[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">return</span> x &gt;= <span class="number">1</span> &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; x &lt;= n &amp;&amp; y &lt;= m; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> sx, <span class="keyword">int</span> sy, <span class="keyword">int</span> len)</span></span>&#123; <span class="keyword">return</span> std::<span class="built_in">abs</span>(x - sx) + std::<span class="built_in">abs</span>(y - sy) &lt;= len; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> sx, <span class="keyword">int</span> sy, <span class="keyword">int</span> len, <span class="keyword">int</span> o, <span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">in</span>(sx, sy); sx += dx[id], sy += dy[id])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mp[sx][sy] == <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r &amp;&amp; d[o][q[r].fi][q[r].se] + std::<span class="built_in">abs</span>(sx - q[r].fi) + std::<span class="built_in">abs</span>(sy - q[r].se) &lt;= d[o][sx][sy]) --r;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r &amp;&amp; !<span class="built_in">in</span>(q[l].fi, q[l].se, sx, sy, len)) ++l;</span><br><span class="line">        q[++r] = &#123;sx, sy&#125;;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= r) d[o ^ <span class="number">1</span>][sx][sy] = d[o][q[l].fi][q[l].se] + std::<span class="built_in">abs</span>(sx - q[l].fi) + std::<span class="built_in">abs</span>(sy - q[l].se);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d %d&quot;</span>, &amp;n, &amp;m, &amp;a, &amp;b, &amp;num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, mp[i] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;c[i].s, &amp;c[i].t, &amp;c[i].d);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) d[<span class="number">0</span>][i][j] = -INF;</span><br><span class="line">    d[<span class="number">0</span>][a][b] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, o = <span class="number">0</span>, len; i &lt;= num; ++i, o ^= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        len = c[i].t - c[i].s + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (c[i].d == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) <span class="built_in">work</span>(n, j, len, o, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c[i].d == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) <span class="built_in">work</span>(<span class="number">1</span>, j, len, o, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c[i].d == <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) <span class="built_in">work</span>(j, m, len, o, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) <span class="built_in">work</span>(j, <span class="number">1</span>, len, o, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) ans = std::<span class="built_in">max</span>(ans, d[num &amp; <span class="number">1</span>][i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 实现有点麻烦&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="单调队列" scheme="https://dyd-true.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
  </entry>
  
  <entry>
    <title>luoguP3631 [APIO2011]方格染色</title>
    <link href="https://dyd-true.github.io/2022/05/23/luoguP3631-APIO2011-%E6%96%B9%E6%A0%BC%E6%9F%93%E8%89%B2/"/>
    <id>https://dyd-true.github.io/2022/05/23/luoguP3631-APIO2011-%E6%96%B9%E6%A0%BC%E6%9F%93%E8%89%B2/</id>
    <published>2022-05-23T02:18:17.000Z</published>
    <updated>2022-05-23T02:42:11.104Z</updated>
    
    <content type="html"><![CDATA[<p> 边带权并查集</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P3631">方格染色</a></p><p>转化有点多</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给一个转化：我们就是要保证任意一个 $2 \times 2$ 的矩阵异或和为 $1$ </p><p>那么不难发现，只要第一行和第一列定了，整个矩阵就出来了，所以，如果 $k = 0$ 的话，答案就是 $2^{n + m - 1}$ </p><p>考虑每个确定的点，这里有一个结论：任意一个 $a \times b$ 的矩阵四个角的异或值只和 $a, b$ 的奇偶性有关，证明：把 $2 \times 2$ 的矩阵依次覆盖在上面，当且仅当 $a, b$ 同时为偶数时，四个角异或和为 $1$ （因为最后只有四个角只被覆盖了一次，而只有 $a, b$ 为偶数的时候，所有 $2 \times 2$ 的矩阵异或和为 $1$ ）</p><p>那么对于给定 $(x, y) = c$ ，有 $(1, 1) \oplus (1, y) \oplus (x, 1) \oplus c = [x, y同时为偶数]$ ，我们发现，当 $(1, 1)$ 确定后， $(1, y)$ 和 $(x, 1)$ 的关系（相等或不等）就定了，用带权并查集维护这个关系，最后答案就是 $2^{联通个数 - 1}$ </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>一个特别难调的地方：合并时一定要先 $get()$ 再计算权值，因为 $get()$ 里面会修改权值！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">100</span>, P = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, num, nm, fa[N &lt;&lt; <span class="number">1</span>], w[N &lt;&lt; <span class="number">1</span>], rk[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Q</span>&#123;</span> <span class="keyword">int</span> x, y, c; &#125; q[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = <span class="built_in">LL</span>(x) * x % P) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = <span class="built_in">LL</span>(res) * x % P;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="built_in">get</span>(fa[x]);</span><br><span class="line">    w[x] ^= w[fa[x]];</span><br><span class="line">    <span class="keyword">return</span> fa[x] = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = <span class="built_in">get</span>(x), fy = <span class="built_in">get</span>(y);</span><br><span class="line">    v ^= w[x] ^ w[y];</span><br><span class="line">    <span class="keyword">if</span> (fx == fy) <span class="keyword">return</span> !v;</span><br><span class="line">    <span class="keyword">if</span> (rk[fx] &gt; rk[fy]) std::<span class="built_in">swap</span>(fx, fy);</span><br><span class="line">    fa[fx] = fy, w[fx] = v, rk[fy] += rk[fx] == rk[fy];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nm; ++i) fa[i] = i, w[i] = <span class="number">0</span>;</span><br><span class="line">    fa[n + <span class="number">1</span>] = <span class="number">1</span>; <span class="comment">//n+1和1是一个点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y, c; i &lt;= num; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        x = q[i].x, y = q[i].y, c = q[i].c;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span> &amp;&amp; y == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> (c == col) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        c ^= !(x &amp; <span class="number">1</span>) &amp;&amp; !(y &amp; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">1</span> &amp;&amp; y &gt; <span class="number">1</span>) c ^= col; </span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">merge</span>(x, y + n, c)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nm; ++i) res += <span class="built_in">get</span>(i) == i;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">qpow</span>(<span class="number">2</span>, res - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;num);</span><br><span class="line">    nm = n + m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;q[i].x, &amp;q[i].y, &amp;q[i].c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (<span class="built_in">work</span>(<span class="number">0</span>) + <span class="built_in">work</span>(<span class="number">1</span>)) % P);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 边带权并查集&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="并查集" scheme="https://dyd-true.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="数论,数学" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
  </entry>
  
  <entry>
    <title>UVA1316 Supermarket</title>
    <link href="https://dyd-true.github.io/2022/05/22/UVA1316-Supermarket/"/>
    <id>https://dyd-true.github.io/2022/05/22/UVA1316-Supermarket/</id>
    <published>2022-05-22T13:54:31.000Z</published>
    <updated>2022-05-22T13:58:52.477Z</updated>
    
    <content type="html"><![CDATA[<p> 简单题？</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/UVA1316">Supermarket</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>按 $p_i$ 排序，贪心取，用并查集维护每一天，使用它就让 $fa[x] = x - 1$ 即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>最开始打的 <code>scanf(&quot;%d&quot;, &amp;n) != EOF</code> 一直 TLE</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> PII = std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n, fa[N], mxt, ans;</span><br><span class="line">PII a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">get</span>(fa[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (std::cin &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        mxt = ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a[i].fi, &amp;a[i].se), mxt = std::<span class="built_in">max</span>(mxt, a[i].se);</span><br><span class="line">        std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, [&amp;](PII x, PII y)&#123; <span class="keyword">return</span> x.fi &gt; y.fi; &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= mxt; ++i) fa[i] = i; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, t; i &lt;= n; ++i) <span class="keyword">if</span> ((t = <span class="built_in">get</span>(a[i].se)) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += a[i].fi;</span><br><span class="line">            fa[t] = t - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 简单题？&lt;/p&gt;</summary>
    
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="并查集" scheme="https://dyd-true.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="贪心" scheme="https://dyd-true.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>luoguP3243 [HNOI2015]菜肴制作</title>
    <link href="https://dyd-true.github.io/2022/05/22/luoguP3243-HNOI2015-%E8%8F%9C%E8%82%B4%E5%88%B6%E4%BD%9C/"/>
    <id>https://dyd-true.github.io/2022/05/22/luoguP3243-HNOI2015-%E8%8F%9C%E8%82%B4%E5%88%B6%E4%BD%9C/</id>
    <published>2022-05-22T13:29:11.000Z</published>
    <updated>2022-05-22T13:32:39.123Z</updated>
    
    <content type="html"><![CDATA[<p> 反过来做大根堆的转化很巧妙</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P3243">菜肴制作</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>建反图，跑拓扑，每次取时贪心取最大，最后反过来输出即可，正确性显然，因为最大的往后了小的就更有机会向前（说的简单但当时想半天每想到）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span> <span class="keyword">int</span> ne, ver; &#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> h[N], idx = <span class="number">0</span>, du[N];</span><br><span class="line">std::priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; e[idx] = &#123;h[x], y&#125;, h[x] = idx++; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (!du[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        ans.<span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne)</span><br><span class="line">        &#123;</span><br><span class="line">            --du[y = e[i].ver];</span><br><span class="line">            <span class="keyword">if</span> (!du[y]) q.<span class="built_in">push</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T); T--; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="built_in">memset</span>(h + <span class="number">1</span>, <span class="number">-1</span>, n &lt;&lt; <span class="number">2</span>), idx = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(du + <span class="number">1</span>, <span class="number">0</span>, n &lt;&lt; <span class="number">2</span>), ans.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">            <span class="built_in">add</span>(v, u), ++du[u];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">topu</span>();</span><br><span class="line">        <span class="keyword">bool</span> f = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; f; ++i) <span class="keyword">if</span> (du[i]) f = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!f) <span class="built_in">printf</span>(<span class="string">&quot;Impossible!&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = ans.<span class="built_in">size</span>() - <span class="number">1</span>; ~i; --i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 反过来做大根堆的转化很巧妙&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="贪心" scheme="https://dyd-true.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="堆" scheme="https://dyd-true.github.io/tags/%E5%A0%86/"/>
    
    <category term="拓扑" scheme="https://dyd-true.github.io/tags/%E6%8B%93%E6%89%91/"/>
    
  </entry>
  
  <entry>
    <title>主席树</title>
    <link href="https://dyd-true.github.io/2022/05/21/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    <id>https://dyd-true.github.io/2022/05/21/%E4%B8%BB%E5%B8%AD%E6%A0%91/</id>
    <published>2022-05-21T11:12:31.000Z</published>
    <updated>2022-05-21T12:39:00.286Z</updated>
    
    <content type="html"><![CDATA[<p> 就是可持久化线段树</p><span id="more"></span><h1 id="主席树"><a href="#主席树" class="headerlink" title="主席树"></a>主席树</h1><p>名字似乎有点来历，但懒得考究了，发现同机房就我这个蒟蒻还不会，所以来补补</p><h2 id="普通"><a href="#普通" class="headerlink" title="普通"></a>普通</h2><p>其实就是可持久化线段树，这里说几个个人认为的要点：</p><ol><li>最初的树不必一个个插，可以直接建</li><li>区间修改的化必须标记永久化</li><li>空间要开够，大概是 $O(4n + m \log n)$ 的</li></ol><p>这里给出一个实现（最快的用时是我的一半，我是大常数选手实锤了）：</p><p><a href="https://www.luogu.com.cn/problem/P3834">可持久化线段树 2</a></p><p>就是维护静态区间第 $k$ 大，建值域线段树，把每个点依次加入然后线段树上二分即可， $O(n \log n)$ </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n, num, m;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; xx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lsh</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    xx.<span class="built_in">reserve</span>(n + <span class="number">1</span>);</span><br><span class="line">    xx.<span class="built_in">pb</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) xx.<span class="built_in">pb</span>(a[i]);</span><br><span class="line">    std::<span class="built_in">sort</span>(xx.<span class="built_in">begin</span>(), xx.<span class="built_in">end</span>());</span><br><span class="line">    xx.<span class="built_in">erase</span>(std::<span class="built_in">unique</span>(xx.<span class="built_in">begin</span>(), xx.<span class="built_in">end</span>()), xx.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = std::<span class="built_in">lower_bound</span>(xx.<span class="built_in">begin</span>(), xx.<span class="built_in">end</span>(), a[i]) - xx.<span class="built_in">begin</span>();</span><br><span class="line">    num = xx.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> CT <span class="comment">//Chairman Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> NN = <span class="number">5e6</span> + <span class="number">100</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> <span class="keyword">int</span> lc, rc, dat; &#125; tr[NN];</span><br><span class="line">    <span class="keyword">int</span> rt[N], tot = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc(x) tr[(x)].lc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc(x) tr[(x)].rc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> dat(x) tr[(x)].dat</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">(<span class="keyword">int</span> &amp;u, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        u = ++tot;</span><br><span class="line">        tr[u] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) <span class="built_in">bd</span>(<span class="built_in">lc</span>(u), l, mid), <span class="built_in">bd</span>(<span class="built_in">rc</span>(u), mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cg</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> d, <span class="keyword">int</span> &amp;u, <span class="keyword">int</span> la, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        u = ++tot;</span><br><span class="line">        tr[u] = tr[la];</span><br><span class="line">        <span class="built_in">dat</span>(u) += d;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line">        (pos &lt;= mid) ? <span class="built_in">cg</span>(pos, d, <span class="built_in">lc</span>(u), <span class="built_in">lc</span>(la), l, mid) : <span class="built_in">cg</span>(pos, d, <span class="built_in">rc</span>(u), <span class="built_in">rc</span>(la), mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> ul, <span class="keyword">int</span> ur, <span class="keyword">int</span> k, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="built_in">dat</span>(<span class="built_in">lc</span>(ur)) - <span class="built_in">dat</span>(<span class="built_in">lc</span>(ul));</span><br><span class="line">        <span class="keyword">return</span> (t &gt;= k) ? <span class="built_in">ask</span>(<span class="built_in">lc</span>(ul), <span class="built_in">lc</span>(ur), k, l, mid) : <span class="built_in">ask</span>(<span class="built_in">rc</span>(ul), <span class="built_in">rc</span>(ur), k - t, mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> dat</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> mid </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> CT::rt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">lsh</span>(), CT::<span class="built_in">bd</span>(rt[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) CT::<span class="built_in">cg</span>(a[i], <span class="number">1</span>, rt[i], rt[i - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l, r, k; m--; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;l, &amp;r, &amp;k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, xx[CT::<span class="built_in">ask</span>(rt[l - <span class="number">1</span>], rt[r], k)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="带修"><a href="#带修" class="headerlink" title="带修"></a>带修</h2><p>看看这个：</p><p><a href="https://www.luogu.com.cn/problem/P2617">Dynamic Rankings</a></p><p>上面问题的带修版本</p><p>直接考虑把主席树套到树状数组上（反正 BIT 擅长维护前缀和），代码也很好写，时空都是 $O(n \log^2 n)$ </p><p>实现的时候，由于套上的一个 BIT 不好建最初的树，反正那棵树里面啥都没有，就懒得建了（其实感觉已经不是主席树，或者可持久化线段树了，因为没有从上一个状态继承，而是完全动态开点），一个要点是 BIT 是建在“时间“上的，大小该是 $n$ ，而主席树是建在值域上的、</p><p>代码（我常数过大被整体二分做法吊打）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, num;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Q</span>&#123;</span> <span class="keyword">int</span> op, l, r, k; &#125; q[N];</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; xx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lsh</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    xx.<span class="built_in">reserve</span>(n + m + <span class="number">1</span>);</span><br><span class="line">    xx.<span class="built_in">pb</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) xx.<span class="built_in">pb</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="keyword">if</span> (!q[i].k) xx.<span class="built_in">pb</span>(q[i].r);</span><br><span class="line">    std::<span class="built_in">sort</span>(xx.<span class="built_in">begin</span>(), xx.<span class="built_in">end</span>());</span><br><span class="line">    xx.<span class="built_in">erase</span>(std::<span class="built_in">unique</span>(xx.<span class="built_in">begin</span>(), xx.<span class="built_in">end</span>()), xx.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = std::<span class="built_in">lower_bound</span>(xx.<span class="built_in">begin</span>(), xx.<span class="built_in">end</span>(), a[i]) - xx.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="keyword">if</span> (!q[i].k) q[i].r = std::<span class="built_in">lower_bound</span>(xx.<span class="built_in">begin</span>(), xx.<span class="built_in">end</span>(), q[i].r) - xx.<span class="built_in">begin</span>();</span><br><span class="line">    num = xx.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> BIT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> NN = <span class="number">6e7</span> + <span class="number">100</span>, D = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> rts[<span class="number">2</span>][D];</span><br><span class="line">    <span class="keyword">namespace</span> CT</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> <span class="keyword">int</span> lc, rc, cnt; &#125; tr[NN];</span><br><span class="line">        <span class="keyword">int</span> rt[N], tot = <span class="number">0</span>;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> lc(x) tr[(x)].lc</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> rc(x) tr[(x)].rc</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> ct(x) tr[(x)].cnt</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">cg</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> d, <span class="keyword">int</span> &amp;u, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = num)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!u) u = ++tot;</span><br><span class="line">            <span class="built_in">ct</span>(u) += d;</span><br><span class="line">            <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line">            (pos &lt;= mid) ? <span class="built_in">cg</span>(pos, d, <span class="built_in">lc</span>(u), l, mid) : <span class="built_in">cg</span>(pos, d, <span class="built_in">rc</span>(u), mid + <span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = num)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = rts[<span class="number">1</span>][<span class="number">0</span>]; i; --i) sum += <span class="built_in">ct</span>(<span class="built_in">lc</span>(rts[<span class="number">1</span>][i]));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = rts[<span class="number">0</span>][<span class="number">0</span>]; i; --i) sum -= <span class="built_in">ct</span>(<span class="built_in">lc</span>(rts[<span class="number">0</span>][i]));</span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = rts[<span class="number">1</span>][<span class="number">0</span>]; i; --i) rts[<span class="number">1</span>][i] = <span class="built_in">lc</span>(rts[<span class="number">1</span>][i]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = rts[<span class="number">0</span>][<span class="number">0</span>]; i; --i) rts[<span class="number">0</span>][i] = <span class="built_in">lc</span>(rts[<span class="number">0</span>][i]);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">ask</span>(k, l, mid);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = rts[<span class="number">1</span>][<span class="number">0</span>]; i; --i) rts[<span class="number">1</span>][i] = <span class="built_in">rc</span>(rts[<span class="number">1</span>][i]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = rts[<span class="number">0</span>][<span class="number">0</span>]; i; --i) rts[<span class="number">0</span>][i] = <span class="built_in">rc</span>(rts[<span class="number">0</span>][i]);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">ask</span>(k - sum, mid + <span class="number">1</span>, r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">undef</span> ct</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">undef</span> mid</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">using</span> CT::rt;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lb(x) ((x) &amp; (-(x)))</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cg</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span></span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += <span class="built_in">lb</span>(i)) CT::<span class="built_in">cg</span>(a[x], d, rt[i]); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        rts[<span class="number">0</span>][<span class="number">0</span>] = rts[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i; i ^= <span class="built_in">lb</span>(i)) rts[<span class="number">1</span>][++rts[<span class="number">1</span>][<span class="number">0</span>]] = rt[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l - <span class="number">1</span>; i; i ^= <span class="built_in">lb</span>(i)) rts[<span class="number">0</span>][++rts[<span class="number">0</span>][<span class="number">0</span>]] = rt[i];</span><br><span class="line">        <span class="keyword">return</span> CT::<span class="built_in">ask</span>(k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> lb</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> c[<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, c);</span><br><span class="line">        <span class="keyword">if</span> (c[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;q[i].l, &amp;q[i].r, &amp;q[i].k);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;q[i].l, &amp;q[i].r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">lsh</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) BIT::<span class="built_in">cg</span>(i, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) </span><br><span class="line">        <span class="keyword">if</span> (q[i].k) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, xx[BIT::<span class="built_in">ask</span>(q[i].l, q[i].r, q[i].k)]);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            BIT::<span class="built_in">cg</span>(q[i].l, <span class="number">-1</span>);</span><br><span class="line">            a[q[i].l] = q[i].r;</span><br><span class="line">            BIT::<span class="built_in">cg</span>(q[i].l, <span class="number">1</span>);</span><br><span class="line">        &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 就是可持久化线段树&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="线段树" scheme="https://dyd-true.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    <category term="笔记" scheme="https://dyd-true.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="可持久化" scheme="https://dyd-true.github.io/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
    <category term="主席树" scheme="https://dyd-true.github.io/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    
  </entry>
  
</feed>
