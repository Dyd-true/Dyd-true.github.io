<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dyd&#39;s Blog</title>
  
  <subtitle>He who has a strong enough why can bear almost any how.</subtitle>
  <link href="https://dyd-true.github.io/atom.xml" rel="self"/>
  
  <link href="https://dyd-true.github.io/"/>
  <updated>2022-05-19T13:09:57.800Z</updated>
  <id>https://dyd-true.github.io/</id>
  
  <author>
    <name>Dyd</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>虚树</title>
    <link href="https://dyd-true.github.io/2022/05/19/%E8%99%9A%E6%A0%91/"/>
    <id>https://dyd-true.github.io/2022/05/19/%E8%99%9A%E6%A0%91/</id>
    <published>2022-05-19T11:02:04.000Z</published>
    <updated>2022-05-19T13:09:57.800Z</updated>
    
    <content type="html"><![CDATA[<p> 构造只包含有用信息的新图，减少数据规模</p><span id="more"></span><h1 id="虚树"><a href="#虚树" class="headerlink" title="虚树"></a>虚树</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>对于一棵树 $T$ ，构造一棵新树 $T’$ ，使得 $T’$ 中包含一些给定的节点和它们的 lca 且节点数尽量少，这个 $T’$ 就是虚树</p><p>明显， $T’$ 的点数少于 $T$ ，不妨假设 $n$ 为 $T$ 中节点个数，给定的关键节点集合为 $S$ ，那么对于每组 $S$ ，回答询问的时间复杂度可优化至 $O(\mid S \mid (\log n + \log \mid S \mid) + f( \mid S \mid))$ ，其中 $f(x)$ 表示对于一个 $x$ 个点的树回答询问的时间，另外，这只是一组点集，虚树可以处理多组点集，对于每组点集，可以证明，虚树的节点个数最多为 $2 \mid S \mid$ 个</p><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>其实是有点暴力的</p><p>处理出 lca 和 dfn 序，然后对于每个点集 $S$ 按 dfn 序进行排序 ，同时维护一个栈，对于当前节点 $x$ ，记 $z = lca(x, stk[top])$  ：</p><ol><li>若 $z = stk[top]$ ，说明 $x$ 是 $stk[top]$ 的儿子，把 $x$ 入栈</li><li>否则，不断弹出 $stk[top]$ 直到 $dep[stk[top]] \le dep[z]$ ，每次弹出连边 $stk[top - 1] \to stk[top]$ ；弹完后，若 $z \ne stk[top]$ ，把 $z$ 入栈，最后把 $x$ 入栈</li><li>最后，当所有点的跟新结束后，还要弹出栈</li></ol><p>具体实现时，有更简洁的打法（另外，为了简单，我们一般会把根先丢进栈）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!top) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(stk[++top] = x);</span><br><span class="line">    <span class="keyword">int</span> z = <span class="built_in">lca</span>(stk[top], x);</span><br><span class="line">    <span class="keyword">for</span> (; tp &gt; <span class="number">1</span> &amp;&amp; dep[z] &lt; dep[stk[top - <span class="number">1</span>]]; --top) <span class="built_in">add</span>(stk[top - <span class="number">1</span>], stk[top]);</span><br><span class="line">    <span class="keyword">if</span> (dep[z] &lt; dep[stk[top]]) <span class="built_in">add</span>(z, stk[top--]);</span><br><span class="line">    <span class="keyword">if</span> (!top || stk[top] != z) stk[++top] = z;</span><br><span class="line">    stk[++top] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若用的是 $O(\log n)$ 的 lca ， $O(\mid S \mid \log \mid S \mid)$ 的排序，时间为 $O(\mid S \mid (\log n + \log \mid S \mid))$ </p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>还是给一题</p><p><a href="https://codeforces.com/contest/613/problem/D">Kingdom and its Cities</a></p><p>直接每次询问建虚树，然后把关键节点的 $si$ 设为 $1$ ，其它为 $0$ ，在虚树上 dfs ，对于一个节点：</p><ol><li>若它的 $si \ne 0$ ，那么它的每一个 $si \ne 0$ 的儿子都不能和它联通，必须删掉（删掉该子树的任何一个点都一样）</li><li>否则，令它的 $si$  等于所有子树 $si$ 和，计算出来若它的 $si &gt; 1$ ，显然把它删除就是最优的办法</li></ol><p>一个要注意的是，邻接表和 $si$ 的清空不能 <code>memset</code> ，否则时间会退化，记 $K = \sum k$ 下面的代码时间为 $O(n \log n + K(\log n + \log K) + K)$ </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">100</span>, D = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">int</span> n, num = <span class="number">0</span>, q, k, ans;</span><br><span class="line"><span class="keyword">int</span> a[N], si[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span> <span class="keyword">int</span> ne, ver; &#125; e[N &lt;&lt; <span class="number">1</span>], ef[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> h[N], idx = <span class="number">0</span>, hf[N], idf = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> f[N][D], dep[N], dfn[N];</span><br><span class="line"><span class="keyword">int</span> stk[N], top;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; e[idx] = &#123;h[x], y&#125;, h[x] = idx++; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adf</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; ef[idf] = &#123;hf[x], y&#125;, hf[x] = idf++; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x] = ++num, f[x][<span class="number">0</span>] = fa, dep[x] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = e[i].ne) <span class="keyword">if</span> (e[i].ver != fa) <span class="built_in">dfs1</span>(e[i].ver, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &gt; dep[y]) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = D - <span class="number">1</span>; ~i; --i) <span class="keyword">if</span> (dep[f[y][i]] &gt;= dep[x]) y = f[y][i];</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = D - <span class="number">1</span>; ~i; --i) <span class="keyword">if</span> (f[y][i] != f[x][i]) y = f[y][i], x = f[x][i];</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!top) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(stk[++top] = x);</span><br><span class="line">    <span class="keyword">int</span> z = <span class="built_in">lca</span>(x, stk[top]);</span><br><span class="line">    <span class="keyword">for</span> (; top &gt; <span class="number">1</span> &amp;&amp; dep[z] &lt; dep[stk[top - <span class="number">1</span>]]; --top) <span class="built_in">adf</span>(stk[top - <span class="number">1</span>], stk[top]);</span><br><span class="line">    <span class="keyword">if</span> (dep[z] &lt; dep[stk[top]]) <span class="built_in">adf</span>(z, stk[top--]);</span><br><span class="line">    <span class="keyword">if</span> (!top || stk[top] != z) stk[++top] = z;</span><br><span class="line">    stk[++top] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (si[x])</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = hf[x], y; ~i; i = ef[i].ne)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs2</span>(y = ef[i].ver);</span><br><span class="line">            <span class="keyword">if</span> (si[y]) si[y] = <span class="number">0</span>, ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = hf[x], y; ~i; i = ef[i].ne)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs2</span>(y = ef[i].ver);</span><br><span class="line">            si[x] += si[y];</span><br><span class="line">            si[y] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (si[x] &gt; <span class="number">1</span>) si[x] = <span class="number">0</span>, ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">    hf[x] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + k + <span class="number">1</span>, [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123; <span class="keyword">return</span> dfn[x] &lt; dfn[y]; &#125;);</span><br><span class="line">    top = ans = idf = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">1</span>] != <span class="number">1</span>) stk[++top] = <span class="number">1</span>; <span class="comment">//根</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) <span class="built_in">ins</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span> (; top; --top) <span class="built_in">adf</span>(stk[top - <span class="number">1</span>], stk[top]);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>), si[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h), <span class="built_in">memset</span>(hf, <span class="number">-1</span>, <span class="keyword">sizeof</span> hf);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u, v), <span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; D; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i][j] = f[f[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q); q--; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">            si[a[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) <span class="keyword">if</span> (si[f[a[i]][<span class="number">0</span>]])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(k) si[a[k--]] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!k) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">work</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 构造只包含有用信息的新图，减少数据规模&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="图论" scheme="https://dyd-true.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="笔记" scheme="https://dyd-true.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="lca" scheme="https://dyd-true.github.io/tags/lca/"/>
    
  </entry>
  
  <entry>
    <title>AtCoder ABC250 EX</title>
    <link href="https://dyd-true.github.io/2022/05/17/AtCoder-ABC250-EX/"/>
    <id>https://dyd-true.github.io/2022/05/17/AtCoder-ABC250-EX/</id>
    <published>2022-05-17T12:16:52.000Z</published>
    <updated>2022-05-17T12:32:52.251Z</updated>
    
    <content type="html"><![CDATA[<p> dij求“多源”最短</p><span id="more"></span><p><a href="https://atcoder.jp/contests/abc250/tasks/abc250_h">Trespassing Takahashi</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>据说有最小生成树的做法，但没看懂</p><p>考虑转化，用 dij 求出每个点的 $dis$ 表示”该点到最近的特殊点的距离“，这可以 $O(m \log m)$ 做到，然后对于每条边，其权值改为 $c_i’ = dis_{a_i} + dis_{b_i} + c_i$ ，然后，对于新图，两个点在 $t$ 时间内可达当且仅当两点之间的路径中所有权值 $c_i’ \le t$ ，可以用瓶颈生成树做，但直接离线 + 并查集更简单</p><p>关于上述转化的证明：</p><p>记 $dis(a, b)$ 表示“点 $a, b$ 的最短路径长”</p><ul><li><p>必要性：</p><p>任取原图答案中某一条边 $(a, b, c)$ ，我们必然是通过关键点 $k_1$ 走到关键点 $k_2$ ，即 $dis(k_1, a) + c + dis(b, k_2) \le t$ ，由 $dis_{a_i}, dis_{b_i}$ 的最小性质不难得到 $dis_{a_i} + dis_{b_i} + c = c’ \le dis(k_1, a) + c + dis(b, k_2) \le t$ </p></li><li><p>充分性：</p><p>只要 $c’ \le t$ ，我们一定可以“安全”走过对应的边，又因为新图中找到的路径联通了两个关键点，其间的边都是“安全”的，所以必定可以走到</p></li></ul><p>时间复杂度 $O(m \log m)$ </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k, tq, fa[N], h[N], idx = <span class="number">0</span>, ct = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span> <span class="keyword">int</span> ne, ver, w; &#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge2</span>&#123;</span> <span class="keyword">int</span> u, v; LL w; &#125; e2[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Q</span>&#123;</span> <span class="keyword">int</span> x, y, id; LL t; &#125; que[N];</span><br><span class="line">LL dis[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N], ans[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">get</span>(fa[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>&#123; e[idx] = &#123;h[x], y, z&#125;, h[x] = idx++; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dij</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    std::priority_queue&lt; std::pair&lt;LL, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k + <span class="number">1</span>; i &lt;= n; ++i) dis[i] = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, i&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.<span class="built_in">top</span>().second; q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne) <span class="keyword">if</span> (!vis[y = e[i].ver])</span><br><span class="line">            <span class="keyword">if</span> (dis[y] &gt; dis[x] + e[i].w) </span><br><span class="line">            &#123;</span><br><span class="line">                dis[y] = dis[x] + e[i].w;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;-dis[y], y&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; fa[<span class="built_in">get</span>(x)] = <span class="built_in">get</span>(y); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, w; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        <span class="built_in">add</span>(u, v, w), <span class="built_in">add</span>(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dij</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; idx; i += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = e[i].ver, v = e[i ^ <span class="number">1</span>].ver, w = e[i].w;</span><br><span class="line">        e2[++ct] = &#123;u, v, dis[u] + dis[v] + w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(e2 + <span class="number">1</span>, e2 + ct + <span class="number">1</span>, [&amp;](Edge2 a, Edge2 b)&#123; <span class="keyword">return</span> a.w &lt; b.w; &#125;);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tq);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tq; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %lld&quot;</span>, &amp;que[i].x, &amp;que[i].y, &amp;que[i].t);</span><br><span class="line">        que[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(que + <span class="number">1</span>, que + tq + <span class="number">1</span>, [&amp;](Q a, Q b)&#123; <span class="keyword">return</span> a.t &lt; b.t; &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= tq; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt;= ct &amp;&amp; e2[j].w &lt;= que[i].t; ++j) <span class="built_in">merge</span>(e2[j].u, e2[j].v);</span><br><span class="line">        ans[que[i].id] = <span class="built_in">get</span>(que[i].x) == <span class="built_in">get</span>(que[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tq; ++i)</span><br><span class="line">        <span class="keyword">if</span> (ans[i]) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; dij求“多源”最短&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="AtCoder" scheme="https://dyd-true.github.io/tags/AtCoder/"/>
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="图论" scheme="https://dyd-true.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="最短路" scheme="https://dyd-true.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
    <category term="并查集" scheme="https://dyd-true.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>AtCoder ABC250 G</title>
    <link href="https://dyd-true.github.io/2022/05/16/AtCoder-ABC250-G/"/>
    <id>https://dyd-true.github.io/2022/05/16/AtCoder-ABC250-G/</id>
    <published>2022-05-16T08:43:19.000Z</published>
    <updated>2022-05-17T12:17:22.689Z</updated>
    
    <content type="html"><![CDATA[<p> 贪心</p><span id="more"></span><p><a href="https://atcoder.jp/contests/abc250/tasks/abc250_g">Stonks</a></p><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p>记 $b[i] = -1/1/0$ 表示卖出/买入/什么都不干，再记 $s[i]$ 为 $b[i]$ 的前缀和，显然，要求 $s[i] \ge 0$ ，且答案就是 $-\sum b[i] * a[i]$ </p><p>先令所有 $b[i] = 1$ ，计算出 $s[i]$  ，以 $a[i]$ 降序考虑每一个 $i$ ，把它变成 $b[i] = -1$ ，要求 $\forall j \in[i, n], s[j] \ge 2$ ；或者变成 $b[i] = 0$ ，要求 $\forall j \in[i, n], s[j] \ge 1$ ，用线段树维护，跟新即可</p><p>时间 $O(n \log n)$ </p><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>然鹅不用这么麻烦，直接贪心（官方题解写的太复杂了我看了半天），用一个小根堆维护买入，对于当前天数：</p><ol><li>若最小的买入比当前小（即可以赚），就从堆中弹出堆顶，跟新答案，然后插入两个当前天</li><li>否则，只插入一个当前天</li></ol><p>这里插入两个当前天有点带悔贪心的味道，第一个是为了取消当前天的卖出，第二个是保证当前天可以买入</p><p>时间仍然是 $O(n \log n)$ </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line">std::priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    q.<span class="built_in">push</span>(-a[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (-q.<span class="built_in">top</span>() &lt; a[i])</span><br><span class="line">        &#123;</span><br><span class="line">            ans += a[i] + q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            q.<span class="built_in">push</span>(-a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">push</span>(-a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 贪心&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="AtCoder" scheme="https://dyd-true.github.io/tags/AtCoder/"/>
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="贪心" scheme="https://dyd-true.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="数据结构" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="线段树" scheme="https://dyd-true.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>AtCoder ABC250 F</title>
    <link href="https://dyd-true.github.io/2022/05/16/AtCoder-ABC250-F/"/>
    <id>https://dyd-true.github.io/2022/05/16/AtCoder-ABC250-F/</id>
    <published>2022-05-16T03:59:51.000Z</published>
    <updated>2022-05-17T12:17:31.593Z</updated>
    
    <content type="html"><![CDATA[<p> 比较基础的计算几何，但架不住我计几拉吖</p><span id="more"></span><p><a href="https://atcoder.jp/contests/abc250/tasks/abc250_f">One Fourth</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先把面积算出来，记为 $s$ </p><p>然后有一个滑动窗口的技巧，枚举 $l$ ，若当前面积小于四分之一，就让 $r$ 加 $1$ ，计算面积；每次 $l$  加 $1$ 后面积减小；</p><p>因为 $l, r$ 都是单调的，所以是 $O(n)$ 的</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>一个坑是 <code>abs()</code> 的返回值是 <code>int</code> ，只有 <code>std::abs()</code> 的返回值才可以是任意类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">8e18</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">LL s = <span class="number">0</span>, ans = INF, e = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LL x, y;</span><br><span class="line">    Point <span class="keyword">operator</span> - (Point <span class="keyword">_t</span>)&#123; <span class="keyword">return</span> &#123;x - <span class="keyword">_t</span>.x, y - <span class="keyword">_t</span>.y&#125;; &#125;</span><br><span class="line">    LL <span class="keyword">operator</span> * (Point <span class="keyword">_t</span>)&#123; <span class="keyword">return</span> x * <span class="keyword">_t</span>.y - y * <span class="keyword">_t</span>.x; &#125;</span><br><span class="line">&#125; p[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) s += std::<span class="built_in">abs</span>((p[i] - p[<span class="number">1</span>]) * (p[i + <span class="number">1</span>] - p[<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">2</span>; l &lt;= n; ++l)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">4</span> * e &lt; s)</span><br><span class="line">        &#123;</span><br><span class="line">            e += std::<span class="built_in">abs</span>((p[r] - p[l]) * (p[r % n + <span class="number">1</span>] - p[l]));</span><br><span class="line">            r = r % n + <span class="number">1</span>;</span><br><span class="line">            ans = std::<span class="built_in">min</span>(ans, std::<span class="built_in">abs</span>(s - <span class="number">4</span> * e));</span><br><span class="line">        &#125;</span><br><span class="line">        e -= std::<span class="built_in">abs</span>((p[l] - p[r]) * (p[l % n + <span class="number">1</span>] - p[r]));</span><br><span class="line">        ans = std::<span class="built_in">min</span>(ans, std::<span class="built_in">abs</span>(s - <span class="number">4</span> * e));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 比较基础的计算几何，但架不住我计几拉吖&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="AtCoder" scheme="https://dyd-true.github.io/tags/AtCoder/"/>
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="计算几何" scheme="https://dyd-true.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
    <category term="单调队列" scheme="https://dyd-true.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>CF1033G Chip Game</title>
    <link href="https://dyd-true.github.io/2022/05/15/CF1033G-Chip-Game/"/>
    <id>https://dyd-true.github.io/2022/05/15/CF1033G-Chip-Game/</id>
    <published>2022-05-15T10:10:47.000Z</published>
    <updated>2022-05-15T12:32:22.569Z</updated>
    
    <content type="html"><![CDATA[<p> 神仙数学题，感觉很考思维</p><span id="more"></span><p><a href="https://codeforces.com/problemset/problem/1033/G">Chip Game</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p> $n$ 堆石子，每堆有 $v_i$ 个，两个人 $A, B$ ，每次分别可以取 $a, b$ 个，且满足 $a, b \in [1, m]$ ，给定 $n, m, v$ 求满足以下条件的 $(a, b)$ 的对数：</p><ol><li> $A$ 必胜</li><li> $B$ 必胜</li><li>先手必胜</li><li>后手必胜</li></ol><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>瞟题解瞟了一下午才看懂</p><p>先考虑已知 $(a, b)$  如何判胜负，不妨让 $a \le b$  ，显然 $v_i$ 和 $v_i \mod (a+ b)$  等价（赢家一定可以通过 $k$ 此次和对方一起取，在胜负不变的情况下使石子多 $k(a + b)$ 个），我们讨论模后的 $v_i$ ：</p><ol><li> $v_i \in [0, a)$ ，它没用</li><li> $v_i \in [a, b)$ ，它只有 $a$ 可以取，所以只要存在这种情况， $A$ 必胜（ $A$ 可以先留着这堆和 $B$ 一起取其它堆石子），它是有利于小者的</li><li> $v_i \in [b, 2a)$ ，它对 $A, B$ 都只可取一次，是中性的，注意 $b \ge 2a$ 时不存在这种情况</li><li> $v_i \in [\max(2a, b), a + b)$ ，若 $A$ 先手取它，它变成 $2$ ，使 $A$ 必胜；若 $B$ 先手取它，它变成 $1$ ，没用</li></ol><p>于是：</p><ol><li>当存在 $2$  或者存在两个以上 $4$ 时，小者必胜</li><li>否则，若只存在一个 $4$ ，若有小者 + 先手则必胜；否则统计 $3$ 的个数，奇数个小的（同时是后手）胜，偶数个大的胜</li><li>否则，统计 $3$ 的个数，奇数个先手胜，偶数个后手胜</li></ol><p>于是枚举 $(a, b)$ 就有了 $O(m^2n)$  的做法，考虑优化</p><p>枚举 $sum = a + b$ ，我们钦定 $B$ 为后手（但不保证 $a, b$ 的大小关系）来计算后手胜的个数，在 $b$ 从小增大的途中，必定存在 $pos$ 使 $b$ 大于 $pos$ 后必败（显然后手、大的是不利的），更具体的，如图：</p><p><img src="https://s2.loli.net/2022/05/15/qF7HDMz1aGnwCEv.png" alt="tu"></p><p> $A, B$ 必胜显然是对称的，一样多，就是 $\min(pos - l + 1, r - pos)$ 个，那么后手必胜就有 $pos - l + 1 - \min(pos - l + 1, r - pos)$ 个，先手必胜最后用总方案数减即得</p><p>那么现在考虑如何如何求 $pos$ ，大力分讨，同样设 $v_i$ 为模后的：</p><ol><li><p>若 $b &lt; a$ ，则它的胜利条件为以下两者之一：</p><ul><li>存在 $v_i \in [b, a)$ </li><li>存在多于两个 $v_i \in [2b, sum)$ </li></ul><p>对于第二个，考虑记录最大值 $mx$  和次大值 $mx2$ ，那么 $b \le \frac{mx2}{2}$ 都满足第二个，所以 $pos \ge \frac{mx2}{2}$ </p><p>对于第一个，即 $b \le v_i &lt; sum - b$ ，得 $b \le v_i$  和 $b &lt; sum - v_i$ 即 $b \le sum - v_i - 1$ ，所以 $b \le \min(v_i, sum - v_i - 1)$ ，由于存在即可， $pos$ 当取所有 $v_i$ 计算得的最大值</p></li><li><p>若 $b = a$ ，统计 $v_i \ge \frac{sum}{2}$ 的个数，偶数数个则可以使 $pos = \frac{sum}{2}$ ；这里结束后，若 $pos &lt; \frac{sum}{2}$ ，说明已经无法在让 $pos$ 变大了（过不去 $b = a = \frac{sum}{2}$ 这个点），直接返回</p></li><li><p>若 $b &gt; a$ ，则它的胜利条件必须满足：</p><ul><li>所有 $v_i \in [0， a) \cup [b, 2a)$ </li></ul><p>我们有 $0 \le v_i &lt; sum - b$ 或 $b \le v_i &lt; 2(sum - b)$ ，化简得 $b \le \max(v_i, sum - v_i - 1)$ ， $b \le sum - \frac{v_i}{2} - 1$ ，最后一个条件可以直接带 $mx$ ，第一个只好枚举，由于是必须满足，所以 $pos$ 当取所有计算值的最小值</p></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, b[N];</span><br><span class="line">LL a[N], ans[<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>, mx2 = <span class="number">0</span>, res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((b[i] = a[i] % sum) &gt;= (sum + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) ++cnt;</span><br><span class="line">        <span class="keyword">if</span> (b[i] &gt; mx) mx2 = mx, mx = b[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (b[i] &gt; mx2) mx2 = b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    res = mx2 &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) res = std::<span class="built_in">max</span>(res, std::<span class="built_in">min</span>(b[i], sum - b[i] - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (!(cnt &amp; <span class="number">1</span>)) res = sum &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (res &lt; (sum &gt;&gt; <span class="number">1</span>)) <span class="keyword">return</span> res;</span><br><span class="line">    res = sum - (mx &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) res = std::<span class="built_in">min</span>(res, std::<span class="built_in">max</span>(b[i], sum - b[i] - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">2</span>, pos, l, r; s &lt;= (m &lt;&lt; <span class="number">1</span>); ++s)</span><br><span class="line">    &#123;</span><br><span class="line">        l = std::<span class="built_in">max</span>(<span class="number">1</span>, s - m), r = std::<span class="built_in">min</span>(s - <span class="number">1</span>, m);</span><br><span class="line">        pos = std::<span class="built_in">min</span>(std::<span class="built_in">max</span>(<span class="built_in">find</span>(s), l - <span class="number">1</span>), r);</span><br><span class="line">        ans[<span class="number">0</span>] += std::<span class="built_in">min</span>(pos - l + <span class="number">1</span>, r - pos);</span><br><span class="line">        ans[<span class="number">1</span>] += pos - l + <span class="number">1</span> - std::<span class="built_in">min</span>(pos - l + <span class="number">1</span>, r - pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld %lld %lld\n&quot;</span>, ans[<span class="number">0</span>], ans[<span class="number">0</span>], <span class="built_in">LL</span>(m) * m - (ans[<span class="number">0</span>] &lt;&lt; <span class="number">1</span>) - ans[<span class="number">1</span>], ans[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 神仙数学题，感觉很考思维&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="数论,数学" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
    <category term="博弈论" scheme="https://dyd-true.github.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>kmp 乱讲</title>
    <link href="https://dyd-true.github.io/2022/05/03/kmp-%E4%B9%B1%E8%AE%B2/"/>
    <id>https://dyd-true.github.io/2022/05/03/kmp-%E4%B9%B1%E8%AE%B2/</id>
    <published>2022-05-03T09:08:23.000Z</published>
    <updated>2022-05-03T09:18:36.696Z</updated>
    
    <content type="html"><![CDATA[<p> 好像以前写过一个</p><span id="more"></span><h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h2 id="题"><a href="#题" class="headerlink" title="题"></a>题</h2><p> <a href="https://www.luogu.com.cn/problem/P2375">动物园</a></p><p><a href="https://www.luogu.com.cn/problem/P7114">字符串匹配</a></p><h2 id="Z"><a href="#Z" class="headerlink" title="Z"></a>Z</h2><p>板子+上题</p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>感觉自己好水啊</p>]]></content>
    
    
    <summary type="html">&lt;p&gt; 好像以前写过一个&lt;/p&gt;</summary>
    
    
    
    <category term="others" scheme="https://dyd-true.github.io/categories/others/"/>
    
    
    <category term="字符串" scheme="https://dyd-true.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="备讲" scheme="https://dyd-true.github.io/tags/%E5%A4%87%E8%AE%B2/"/>
    
  </entry>
  
  <entry>
    <title>luoguP7735 [NOI2021] 轻重边</title>
    <link href="https://dyd-true.github.io/2022/05/03/luoguP7735-NOI2021-%E8%BD%BB%E9%87%8D%E8%BE%B9/"/>
    <id>https://dyd-true.github.io/2022/05/03/luoguP7735-NOI2021-%E8%BD%BB%E9%87%8D%E8%BE%B9/</id>
    <published>2022-05-03T06:13:02.000Z</published>
    <updated>2022-05-03T06:37:15.288Z</updated>
    
    <content type="html"><![CDATA[<p> 第一步的转化非常巧妙</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P7735">轻重边</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最开始想的 LCT ，发现取消重边这个操作不好维护，这里有一个巧妙的转化：把每次操作当成一次染色，每次染一种新颜色，一条边是重边当且仅当两端点颜色相同，然后就是上树剖维护连续颜色即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p> dbug 时的几个点：</p><ol><li>一条链上边比点少一个，所以 <code>ct = len - 1</code> </li><li>初始化 <code>num</code> </li><li> <code>up</code> 时记得改 <code>col</code> </li></ol><p>最后， <code>ask</code> 里我是把 lca 求得然后两端分开跳的，但好像也可以不必，只要交换 $u, v$ 的同时也交换 $lastu, lastv$ 即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, h[N], idx, id[N], num, dep[N], si[N], top[N], fa[N], son[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span> <span class="keyword">int</span> ver, ne; &#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; e[idx] = &#123;y, h[x]&#125;, h[x] = idx++; &#125;</span><br><span class="line"><span class="keyword">namespace</span> LT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> <span class="keyword">int</span> tag, lcol, rcol, cnt, len; &#125; tr[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> tg(x) tr[(x)].tag</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> cl(x) tr[(x)].lcol</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> cr(x) tr[(x)].rcol</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ct(x) tr[(x)].cnt</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> len(x) tr[(x)].len</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc (u &lt;&lt; 1)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc ((u &lt;&lt; 1) | 1)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">tg</span>(u) = <span class="built_in">cl</span>(u) = <span class="built_in">cr</span>(u) = <span class="built_in">ct</span>(u) = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">len</span>(u) = r - l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) <span class="built_in">bd</span>(lc, l, mid), <span class="built_in">bd</span>(rc, mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adt</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> d)</span></span>&#123; <span class="built_in">tg</span>(u) = <span class="built_in">cl</span>(u) = <span class="built_in">cr</span>(u) = d, <span class="built_in">ct</span>(u) = <span class="built_in">len</span>(u) - <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dw</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123; <span class="keyword">if</span> (<span class="built_in">tg</span>(u))&#123; <span class="built_in">adt</span>(lc, <span class="built_in">tg</span>(u)), <span class="built_in">adt</span>(rc, <span class="built_in">tg</span>(u)), <span class="built_in">tg</span>(u) = <span class="number">0</span>; &#125; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">ct</span>(u) = <span class="built_in">ct</span>(lc) + <span class="built_in">ct</span>(rc);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">cl</span>(rc) == <span class="built_in">cr</span>(lc) &amp;&amp; <span class="built_in">cl</span>(rc) != <span class="number">0</span>) ++<span class="built_in">ct</span>(u);</span><br><span class="line">        <span class="built_in">cl</span>(u) = <span class="built_in">cl</span>(lc), <span class="built_in">cr</span>(u) = <span class="built_in">cr</span>(rc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mdf</span><span class="params">(<span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> d, <span class="keyword">int</span> u = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) <span class="keyword">return</span> <span class="built_in">adt</span>(u, d);</span><br><span class="line">        <span class="built_in">dw</span>(u);</span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= mid) <span class="built_in">mdf</span>(ql, qr, d, lc, l, mid);</span><br><span class="line">        <span class="keyword">if</span> (qr &gt; mid) <span class="built_in">mdf</span>(ql, qr, d, rc, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">up</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::array&lt;<span class="keyword">int</span>, 3&gt; <span class="title">ask</span><span class="params">(<span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> u = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) <span class="keyword">return</span> &#123;<span class="built_in">ct</span>(u), <span class="built_in">cl</span>(u), <span class="built_in">cr</span>(u)&#125;;</span><br><span class="line">        <span class="built_in">dw</span>(u);</span><br><span class="line">        <span class="keyword">if</span> (ql &gt; mid) <span class="keyword">return</span> <span class="built_in">ask</span>(ql, qr, rc, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (qr &lt;= mid) <span class="keyword">return</span> <span class="built_in">ask</span>(ql, qr, lc, l, mid);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> rl = <span class="built_in">ask</span>(ql, qr, lc, l, mid), rr = <span class="built_in">ask</span>(ql, qr, rc, mid + <span class="number">1</span>, r);</span><br><span class="line">            rl[<span class="number">0</span>] = rl[<span class="number">0</span>] + rr[<span class="number">0</span>] + (rl[<span class="number">2</span>] == rr[<span class="number">1</span>] &amp;&amp; rl[<span class="number">2</span>] != <span class="number">0</span>);</span><br><span class="line">            rl[<span class="number">2</span>] = rr[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">return</span> rl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> tg</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> cl</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> cr</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> ct</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> len</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> mid</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[x] = d, fa[x] = f, si[x] = <span class="number">1</span>, son[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne) <span class="keyword">if</span> ((y = e[i].ver) != f)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs1</span>(y, x, d + <span class="number">1</span>);</span><br><span class="line">        si[x] += si[y];</span><br><span class="line">        <span class="keyword">if</span> (si[son[x]] &lt; si[y]) son[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    id[x] = ++num, top[x] = t;</span><br><span class="line">    <span class="keyword">if</span> (!son[x]) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[x], t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne) <span class="keyword">if</span> ((y = e[i].ver) != fa[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (y == son[x]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(y, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[u] != top[v])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[u]] &lt; dep[top[v]]) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">        u = fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (dep[u] &lt; dep[v]) ? u : v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mdf</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[u] != top[v])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[u]] &lt; dep[top[v]]) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">        LT::<span class="built_in">mdf</span>(id[top[u]], id[u], d);</span><br><span class="line">        u = fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dep[u] &lt; dep[v]) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">    LT::<span class="built_in">mdf</span>(id[v], id[u], d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, lastu = <span class="number">0</span>, lastv = <span class="number">0</span>, w = <span class="built_in">lca</span>(u, v);</span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>&amp;, <span class="keyword">int</span>&amp;)&gt; jump = [&amp;](<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;last)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (top[x] != top[w])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = LT::<span class="built_in">ask</span>(id[top[x]], id[x]);</span><br><span class="line">            res += t[<span class="number">0</span>] + (t[<span class="number">2</span>] == last &amp;&amp; last != <span class="number">0</span>);</span><br><span class="line">            last = t[<span class="number">1</span>];</span><br><span class="line">            x = fa[top[x]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; ;</span><br><span class="line">    <span class="built_in">jump</span>(u, lastu), <span class="built_in">jump</span>(v, lastv);</span><br><span class="line">    <span class="keyword">if</span> (dep[u] &lt; dep[v]) std::<span class="built_in">swap</span>(u, v), std::<span class="built_in">swap</span>(lastu, lastv);</span><br><span class="line">    <span class="keyword">auto</span> t = LT::<span class="built_in">ask</span>(id[v], id[u]);</span><br><span class="line">    res += t[<span class="number">0</span>] + (t[<span class="number">1</span>] == lastv &amp;&amp; lastv != <span class="number">0</span>) + (t[<span class="number">2</span>] == lastu &amp;&amp; lastu != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T); T--; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h), idx = num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++i)&#123; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v), <span class="built_in">add</span>(u, v), <span class="built_in">add</span>(v, u); &#125;</span><br><span class="line">        <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>), <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>), LT::<span class="built_in">bd</span>(<span class="number">1</span>, <span class="number">1</span>, num);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> op, a, b, ccol = <span class="number">0</span>; m--; )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;op, &amp;a, &amp;b);</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="number">1</span>) <span class="built_in">mdf</span>(a, b, ++ccol);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">ask</span>(a, b));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 第一步的转化非常巧妙&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="数据结构" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="线段树" scheme="https://dyd-true.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    <category term="树链剖分" scheme="https://dyd-true.github.io/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>luoguP4364 [九省联考 2018] IIIDX</title>
    <link href="https://dyd-true.github.io/2022/05/02/luoguP4364-%E4%B9%9D%E7%9C%81%E8%81%94%E8%80%83-2018-IIIDX/"/>
    <id>https://dyd-true.github.io/2022/05/02/luoguP4364-%E4%B9%9D%E7%9C%81%E8%81%94%E8%80%83-2018-IIIDX/</id>
    <published>2022-05-01T23:11:17.000Z</published>
    <updated>2022-05-01T23:24:27.283Z</updated>
    
    <content type="html"><![CDATA[<p> 细节很多</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P4364">IIIDX</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>发现就是给一个森林排权值，要求浅的（编号小的）尽量大，且儿子都大于等于父亲，没有重复数的时候直接贪心即可，考虑有重复，此时贪心挂了，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 2.0</span><br><span class="line">1 1 1 2</span><br></pre></td></tr></table></figure><p>答案是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 1 2 1</span><br></pre></td></tr></table></figure><p>不妨先给权值排序，考虑用线段树维护“每个点右边可选的点还有几个”（不妨记做 $mn[]$ ），对于当前点，若它的子树大小为 $si$ ，那么就要在保证它左边所有点的 $mn[] \ge si$ 的前提下尽可能往右（大），然后让它所选节点的左边（包括自己）的 $mn$ 减 $si$ 来为它的子树预留数，而当真正进到它的子树时在把预留的数加回来， 本题有一个很好的性质：它的儿子编号都是连续的，所以在扫到第一个儿子时加即可</p><p>需要注意的是，若有多个相同的数，应取最左的，这可以二分实现；以及线段树上二分时最后取的点可能并不满足条件，此时应该取它左边的点</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n, si[N], fa[N], d[N], ans[N];</span><br><span class="line"><span class="keyword">bool</span> used[N];</span><br><span class="line"><span class="keyword">namespace</span> LT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> mn[N &lt;&lt; <span class="number">2</span>], tg[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc (u &lt;&lt; 1)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc ((u &lt;&lt; 1) | 1)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">(<span class="keyword">int</span> u = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mn[u] = n - r + <span class="number">1</span>, tg[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) <span class="built_in">bd</span>(lc, l, mid), <span class="built_in">bd</span>(rc, mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123; mn[u] = std::<span class="built_in">min</span>(mn[lc], mn[rc]); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adt</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> d)</span></span>&#123; mn[u] += d, tg[u] += d; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dn</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tg[u])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">adt</span>(lc, tg[u]), <span class="built_in">adt</span>(rc, tg[u]);</span><br><span class="line">            tg[u] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mdf</span><span class="params">(<span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> d, <span class="keyword">int</span> u = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) <span class="keyword">return</span> <span class="built_in">adt</span>(u, d);</span><br><span class="line">        <span class="built_in">dn</span>(u);</span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= mid) <span class="built_in">mdf</span>(ql, qr, d, lc, l, mid);</span><br><span class="line">        <span class="keyword">if</span> (qr &gt; mid) <span class="built_in">mdf</span>(ql, qr, d, rc, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">up</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> u = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = n)</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> (mn[u] &gt;= x) ? l : (l - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dn</span>(u);</span><br><span class="line">        <span class="keyword">return</span> (x &lt;= mn[lc]) ? <span class="built_in">ask</span>(x, rc, mid + <span class="number">1</span>, r) : <span class="built_in">ask</span>(x, lc, l, mid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> mid</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = x, mid, res = x;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (d[mid] == d[x] &amp;&amp; !used[mid]) res = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %lf&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fa[i] = std::<span class="built_in">floor</span>(i / k);</span><br><span class="line">    std::<span class="built_in">fill</span>(si + <span class="number">1</span>, si + n + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) si[fa[i]] += si[i];</span><br><span class="line">    std::<span class="built_in">sort</span>(d + <span class="number">1</span>, d + n + <span class="number">1</span>), LT::<span class="built_in">bd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fa[i] &amp;&amp; fa[i] != fa[i - <span class="number">1</span>]) LT::<span class="built_in">mdf</span>(<span class="number">1</span>, ans[fa[i]], si[fa[i]] - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> id = LT::<span class="built_in">ask</span>(si[i]);</span><br><span class="line">        id = <span class="built_in">find</span>(id);</span><br><span class="line">        ans[i] = id, used[id] = <span class="literal">true</span>;</span><br><span class="line">        LT::<span class="built_in">mdf</span>(<span class="number">1</span>, id, -si[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, d[ans[i]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 细节很多&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="线段树" scheme="https://dyd-true.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    <category term="二分" scheme="https://dyd-true.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
    <category term="排序" scheme="https://dyd-true.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>luoguP7113 [NOIP2020] 排水系统</title>
    <link href="https://dyd-true.github.io/2022/04/28/luoguP7113-NOIP2020-%E6%8E%92%E6%B0%B4%E7%B3%BB%E7%BB%9F/"/>
    <id>https://dyd-true.github.io/2022/04/28/luoguP7113-NOIP2020-%E6%8E%92%E6%B0%B4%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-04-28T11:01:55.000Z</published>
    <updated>2022-04-28T11:04:32.753Z</updated>
    
    <content type="html"><![CDATA[<p> 不开int128见祖宗</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P7113">排水系统</a></p><p>水题，但是感觉对分数的处理可能会用，记一下</p><p>记得开 <code>int128</code> </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> I128 = __int128;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function">I128 <span class="title">gcd</span><span class="params">(I128 x, I128 y)</span></span>&#123; <span class="keyword">return</span> (!y) ? (x) : (<span class="built_in">gcd</span>(y, x % y)); &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fen</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    I128 p, q;</span><br><span class="line">    Fen <span class="keyword">operator</span> + (Fen y)</span><br><span class="line">    &#123;</span><br><span class="line">        I128 _p = p * y.q + y.p * q, _q = q * y.q;</span><br><span class="line">        I128 d = <span class="built_in">gcd</span>(_p, _q);</span><br><span class="line">        _p /= d, _q /= d;</span><br><span class="line">        <span class="keyword">return</span> &#123;_p, _q&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    Fen <span class="keyword">operator</span> / (I128 y)</span><br><span class="line">    &#123;</span><br><span class="line">        I128 d = <span class="built_in">gcd</span>(y, p);</span><br><span class="line">        I128 _p = p / d;</span><br><span class="line">        y /= d;</span><br><span class="line">        I128 _q = q * y;</span><br><span class="line">        <span class="keyword">return</span> &#123;_p, _q&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; a[N];</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; to[N];</span><br><span class="line">std::queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> du[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wt</span><span class="params">(I128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">9</span>) <span class="built_in">wt</span>(x / <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="number">48</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, d; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, t; j &lt;= d; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">            to[i].<span class="built_in">pb</span>(t), ++du[t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) a[i] = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, q.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (!to[x].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">        a[x] = a[x] / to[x].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y : to[x])</span><br><span class="line">        &#123;</span><br><span class="line">            a[y] = a[y] + a[x];</span><br><span class="line">            <span class="keyword">if</span> (!(--du[y])) q.<span class="built_in">push</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (!to[i].<span class="built_in">size</span>()) <span class="built_in">wt</span>(a[i].p), <span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>), <span class="built_in">wt</span>(a[i].q), <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 不开int128见祖宗&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="STL" scheme="https://dyd-true.github.io/tags/STL/"/>
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
    <category term="gcd" scheme="https://dyd-true.github.io/tags/gcd/"/>
    
  </entry>
  
  <entry>
    <title>排序算法乱讲</title>
    <link href="https://dyd-true.github.io/2022/04/27/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%B1%E8%AE%B2/"/>
    <id>https://dyd-true.github.io/2022/04/27/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%B1%E8%AE%B2/</id>
    <published>2022-04-27T08:23:04.000Z</published>
    <updated>2022-05-03T09:09:05.226Z</updated>
    
    <content type="html"><![CDATA[<p> 我也不知道为啥这都要讲</p><span id="more"></span><h1 id="排序算法乱讲"><a href="#排序算法乱讲" class="headerlink" title="排序算法乱讲"></a>排序算法乱讲</h1><p>我觉得这东西对小朋友们帮助大点，但还是总结一下吧</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于一种排序算法，我将从<strong>稳定性、时空复杂度、特殊性质</strong>这三个方面来（he）阐（bo）述（ke）</p><p>as we all know ，基于比较的排序算法最优时间复杂度为 $O(n \log n)$ ，所以一般我们不讨论时间复杂度高于这个的算法</p><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>典型的以空间换时间，故时间复杂度为 $O(n + V)$ ，其中 $V$ 是值域，空间复杂度为 $O(V)$ ，稳定</p><p>代码咕了</p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>桶排的问题在于值域太大就没法，基数排序可以缩小值域，所以一般和计数一起用</p><p>但为了放在限制巨佬们的思维，这里给出更一般的形式：先将每个待处理元素分成 $k$ 个关键字，按优先级升序记做 $v_1, v_2, …, v_k$ ，然后依次用一种<strong>稳定排序方法</strong>以每个关键字排序，注意，这里一定要稳定，时间为 $O(kn + \sum V_i)$ ，其中 $V_i$ 为第 $i$ 个关键字的值域大小</p><p>yxc 打 SA 时讲过基数排序，但其实它更常和计数一起用，基数一般取 $65536$ 或 $256$ ，当然，基数排序是稳定的</p><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p>yyds</p><p>不必说， STL 的板子非常优秀，且时间<strong>不会退化</strong>，因为有三数取中（防有序）、短段插排（优化时间）、三路聚数（防重复元素）、内省（递归过深就换成堆排）等等优化</p><p>值得一提的是，快排可以用来线性求第 $k$ 大， STL 也有，另外还有 <code>std::stable_sort</code> 和 <code>std::partial_sort</code> </p><p>但很可惜，它是不稳定的</p><h2 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h2><p>分治思想，代码重点在双指针合并，可以同时计算逆序对</p><p>稳定排序， $O(n \log n)$ ，但需要额外空间</p><h2 id="堆排"><a href="#堆排" class="headerlink" title="堆排"></a>堆排</h2><p>我还有什么话说呢？</p><p>把原数列调整成堆，然后直接取，不稳定， $O(n \log n)$ ，空间 $O(n)$ </p><p>但有什么意义啊？</p><h2 id="桶排"><a href="#桶排" class="headerlink" title="桶排"></a>桶排</h2><p>桶排不是计数排序！</p><p>对于给定的元素，开 $m$ 个桶，把每个数按照规则放桶里（规则要保证对于桶之间的顺序可求），桶内元素再排序</p><p>类似于 hash，时间完全取决于冲突的个数</p><h2 id="树形选择"><a href="#树形选择" class="headerlink" title="树形选择"></a>树形选择</h2><p>可以理解成直接在这 $n$ 个数上建线段树，然后根上就是最值，取走最值并把叶子上的点改成 $\infty$ ，然后 push up ，重复</p><p>当然，实现的时候不用建出线段树，只要有树形结构就行，修改直接改叶子，时间不是 $O(\log n)$ 而是 $O(1)$ </p><h2 id="一些例题"><a href="#一些例题" class="headerlink" title="一些例题"></a>一些例题</h2><p>其实它们和排序几乎无关~~~</p><p><a href="https://www.luogu.com.cn/problem/P1966">火柴排队</a></p><p>关键在正确性的证明，用排序不等式</p><p><a href="https://www.luogu.com.cn/problem/P4364">IIIDX</a></p><p>LT + 二分，不要想当然</p>]]></content>
    
    
    <summary type="html">&lt;p&gt; 我也不知道为啥这都要讲&lt;/p&gt;</summary>
    
    
    
    <category term="others" scheme="https://dyd-true.github.io/categories/others/"/>
    
    
    <category term="备讲" scheme="https://dyd-true.github.io/tags/%E5%A4%87%E8%AE%B2/"/>
    
  </entry>
  
  <entry>
    <title>Z函数（拓展KMP）</title>
    <link href="https://dyd-true.github.io/2022/04/24/Z%E5%87%BD%E6%95%B0%EF%BC%88%E6%8B%93%E5%B1%95KMP%EF%BC%89/"/>
    <id>https://dyd-true.github.io/2022/04/24/Z%E5%87%BD%E6%95%B0%EF%BC%88%E6%8B%93%E5%B1%95KMP%EF%BC%89/</id>
    <published>2022-04-24T13:12:47.000Z</published>
    <updated>2022-04-24T14:10:58.240Z</updated>
    
    <content type="html"><![CDATA[<p> 感觉和 KMP 关系不大啊</p><span id="more"></span><h1 id="Z函数（拓展KMP）"><a href="#Z函数（拓展KMP）" class="headerlink" title="Z函数（拓展KMP）"></a>Z函数（拓展KMP）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>故名思意， Z 函数是个函数，若我们定义一个长度为 $n$ 的字符串以第 $i$ 个字符开头，第 $j$ 个字符结尾（下标从 $1$ 开始）的子串为 $s[i \sim j]$ ，再定义 $LCP(x, y)$ 代表字符串 $x, y$ 的<strong>最长公共前缀</strong>长度，那么，有 $ Z[i] = LCP(s[i \sim n], s[0 \sim n])$  ，即 <strong>$Z[i]$ 表示以 $i$ 开头的后缀与原串的最长公共前缀</strong></p><h2 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h2><p>直接求显然不好，类似 kmp 考虑用已有的信息，结论是，我们同时维护已与前缀匹配上的位置为 $s[l, r]$ ，如有多个（肯定有多个）取 $r$ 最大</p><p>当枚举到 $i$ 时，把 $Z[i]$ 初始化为 $\min(Z[i - l + 1], r - i + 1)$ （要保证 $i \le r$ ），而每次计算完后用 $Z[i]$ 跟新 $l, r$ ，关于正确性，对图理解很显然：<img src="https://s2.loli.net/2022/04/24/C6HJseyu7jdLU51.png" alt="Z"></p><p>考虑时间复杂度，由于 $l, r$ 单调，直接用初始化匹配的复杂度是线性的，而暴力匹配时，原串的每个字符最多被匹配一次，所以是 $O(n)$ 的</p><p>注意， $Z[1]$ 要单独处理</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://www.luogu.com.cn/problem/P5410">板子</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int LL</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e7</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">char</span> a[N], b[N];</span><br><span class="line"><span class="keyword">int</span> la, lb, Z[N], p[N], ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_Z</span><span class="params">(<span class="keyword">char</span> x[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Z[<span class="number">1</span>] = len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, l = <span class="number">0</span>, r = <span class="number">0</span>; i &lt;= len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= r) Z[i] = std::<span class="built_in">min</span>(Z[i - l + <span class="number">1</span>], r - i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (Z[i] + i &lt;= len &amp;&amp; x[Z[i] + <span class="number">1</span>] == x[Z[i] + i]) ++Z[i];</span><br><span class="line">        <span class="keyword">if</span> (i + Z[i] - <span class="number">1</span> &gt; r) r = i + Z[i] - <span class="number">1</span>, l = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exkmp</span><span class="params">(<span class="keyword">char</span> x[], <span class="keyword">int</span> len, <span class="keyword">char</span> y[])</span> <span class="comment">//y已有Z数组</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l = <span class="number">0</span>, r = <span class="number">0</span>; i &lt;= len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= r) p[i] = std::<span class="built_in">min</span>(Z[i - l + <span class="number">1</span>], r - i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (p[i] + i &lt;= len &amp;&amp; y[p[i] + <span class="number">1</span>] == x[p[i] + i]) ++p[i];</span><br><span class="line">        <span class="keyword">if</span> (i + p[i] - <span class="number">1</span> &gt; r) r = i + p[i] - <span class="number">1</span>, l = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s %s&quot;</span>, a + <span class="number">1</span>, b + <span class="number">1</span>);</span><br><span class="line">    la = <span class="built_in">strlen</span>(a + <span class="number">1</span>), lb = <span class="built_in">strlen</span>(b + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">get_Z</span>(b, lb), ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lb; ++i) ans ^= (Z[i] + <span class="number">1</span>) * i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="built_in">exkmp</span>(a, la, b), ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= la; ++i) ans ^= (p[i] + <span class="number">1</span>) * i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 感觉和 KMP 关系不大啊&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="字符串" scheme="https://dyd-true.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="笔记" scheme="https://dyd-true.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>luoguP3646 [APIO2015]巴厘岛的雕塑</title>
    <link href="https://dyd-true.github.io/2022/04/22/luoguP3646-APIO2015-%E5%B7%B4%E5%8E%98%E5%B2%9B%E7%9A%84%E9%9B%95%E5%A1%91/"/>
    <id>https://dyd-true.github.io/2022/04/22/luoguP3646-APIO2015-%E5%B7%B4%E5%8E%98%E5%B2%9B%E7%9A%84%E9%9B%95%E5%A1%91/</id>
    <published>2022-04-22T11:03:30.000Z</published>
    <updated>2022-04-22T11:40:22.897Z</updated>
    
    <content type="html"><![CDATA[<p> 又卡空间又卡时间的</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P3646">巴厘岛的雕塑</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>套路的把二进制下每位分开考虑，从高到低贪心判断该位能否为 $0$ </p><p>考虑 $n^2$ 个三元组 $(l, r, sum)$ ，表示“从 $l$ 到 $r$ 和为 $sum$ ”，记当前可选集合为 $S$ ，初始时 $S$ 包含所有三元组</p><p>对于当前位，把 $sum$ 为 $1$ 的从 $S$ 中去除，然后 $O(n^3)$ 暴力 dp 判断可否用剩下的三元组凑出 $1 \sim n$ ，不行就再把删的数加回去，一看时间， $O(40 * n^3)$ ，虽然跑不满可过 $70 \sim 85 pts$ 但明显再卡常也过不了</p><p>发现最后一个满数据的 Sub 有性质，即 $A = 1$ ，那 dp 不就只用求个最小值，变成 $O(n^2)$ ，可过</p><p>但，我伞兵的要把 $n^2$ 个二元组真的用 <code>long long</code> 记下来，导致空间爆炸，在空间只给 $64 MiB$ 的 loj 上直接 MLE ，用 <code>short</code> 卡了半天，最后发现只要记录 $l, r$ ，用前缀和现场算 $sum$ 即可</p><p>唉，一波三折啊</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>由于为了卡空间 STL 用的多，不开 $O2$ 会很慢</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STC static</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">short</span> N = <span class="number">2000</span> + <span class="number">5</span>, INF = <span class="number">0x3f3f</span>;</span><br><span class="line"><span class="keyword">short</span> n, l, r;</span><br><span class="line"><span class="keyword">int</span> top;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans, sum[N];</span><br><span class="line">std::bitset&lt;N&gt; d[N];</span><br><span class="line">std::pair&lt;<span class="keyword">short</span>, <span class="keyword">short</span>&gt; stk[N * N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmn</span><span class="params">(<span class="keyword">short</span> &amp;x, <span class="keyword">short</span> y)</span></span>&#123; <span class="keyword">return</span> x &gt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>; &#125;</span><br><span class="line"><span class="keyword">void</span> _work(<span class="keyword">short</span> bit)</span><br><span class="line">&#123;</span><br><span class="line">STC <span class="keyword">short</span> f[N];</span><br><span class="line">top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">short</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">short</span> j = i; j &lt;= n; ++j) <span class="keyword">if</span> (d[i][j] &amp;&amp; ((sum[j] - sum[i - <span class="number">1</span>]) &gt;&gt; bit) &amp; <span class="number">1</span>) stk[++top] = &#123;i, j&#125;, d[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!top) <span class="keyword">return</span> ;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">short</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">short</span> j = <span class="number">0</span>; j &lt; i; ++j) <span class="keyword">if</span> (d[j + <span class="number">1</span>][i] &amp;&amp; f[j] &lt; r) <span class="built_in">cmn</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (f[n] &lt;= r) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">for</span> (; top; --top) d[stk[top].fi][stk[top].se] = <span class="number">1</span>;</span><br><span class="line">ans |= (<span class="number">1ll</span> &lt;&lt; bit);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">short</span> bit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">STC std::bitset&lt;N&gt; f[N];</span><br><span class="line">top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">short</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">short</span> j = i; j &lt;= n; ++j) <span class="keyword">if</span> (d[i][j] &amp;&amp; ((sum[j] - sum[i - <span class="number">1</span>]) &gt;&gt; bit) &amp; <span class="number">1</span>) stk[++top] = &#123;i, j&#125;, d[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!top) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">short</span> i = <span class="number">0</span>; i &lt;= r; ++i) f[i].<span class="built_in">reset</span>();</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">short</span> i = <span class="number">1</span>; i &lt;= r; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">short</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">short</span> k = <span class="number">0</span>; k &lt; j &amp;&amp; !f[i][j]; ++k) <span class="keyword">if</span> (d[k + <span class="number">1</span>][j]) f[i][j] = f[i][j] | f[i - <span class="number">1</span>][k];</span><br><span class="line"><span class="keyword">if</span> (i &gt;= l &amp;&amp; f[i][n]) <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (; top; --top) d[stk[top].fi][stk[top].se] = <span class="number">1</span>;</span><br><span class="line">ans |= (<span class="number">1ll</span> &lt;&lt; bit);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%hd %hd %hd&quot;</span>, &amp;n, &amp;l, &amp;r); <span class="comment">//short的读入是hd</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">short</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;sum[i]), sum[i] += sum[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">short</span> i = <span class="number">1</span>; i &lt;= n; ++i) d[i].<span class="built_in">set</span>();</span><br><span class="line"><span class="keyword">short</span> t = (sum[n]) ? (<span class="built_in">log2</span>(sum[n]) + <span class="number">1</span>) : (<span class="number">0</span>); <span class="comment">//log2(0)会出锅</span></span><br><span class="line"><span class="keyword">if</span> (l != <span class="number">1</span>) <span class="keyword">for</span> (<span class="keyword">short</span> i = t; ~i; --i) <span class="built_in">work</span>(i);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">for</span> (<span class="keyword">short</span> i = t; ~i; --i) _work(i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 又卡空间又卡时间的&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="贪心" scheme="https://dyd-true.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="二分" scheme="https://dyd-true.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
    <category term="数位" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E4%BD%8D/"/>
    
  </entry>
  
  <entry>
    <title>luoguP2150 [NOI2015] 寿司晚宴</title>
    <link href="https://dyd-true.github.io/2022/04/22/luoguP2150-NOI2015-%E5%AF%BF%E5%8F%B8%E6%99%9A%E5%AE%B4/"/>
    <id>https://dyd-true.github.io/2022/04/22/luoguP2150-NOI2015-%E5%AF%BF%E5%8F%B8%E6%99%9A%E5%AE%B4/</id>
    <published>2022-04-22T07:18:23.000Z</published>
    <updated>2022-04-22T07:27:38.753Z</updated>
    
    <content type="html"><![CDATA[<p> 毒瘤根号分治出处</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P2150">寿司晚宴</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>考虑 dp ，设 $d[S_1][S_2]$ 表示“第一个人选的质数集合为 $S_1$ ，第二个人为 $S_2$ 的方案数”，枚举每个数转移，显然为 $O(n 2^{\mid S \mid})$ ，问题在于 $\mid S \mid$ 太大</p><p>用根号分治，考虑到 $\le \sqrt{n}$ 的质数由且仅有 $8$ 个，且每个数最多含一个 $&gt; \sqrt{n}$ 的质数，我们可以把每个数处理成小质数集合 + 一个大质数的形式，然后 dp </p><p>考虑如何保证大质数，不妨排序（保证大质数相同的在一其），那么大质数相同的就只有一个人能选，我们另设 $f_1[S_1][S_2]/f_2[S_1][S_2]$ 表示“该大质数由 $1/2$ 号来选，且第一个人选的质数集合为 $S_1$ ，第二个人为 $S_2$ 的方案数”，初值就是 $d[S_1][S_2]$ ， dp 完成后，再让 $d[S_1][S_2] = f_1[S_1][S_2] + f_2[S_1][S_2] - d[S_1][S_2]$ ，这里再减一下说因为该大质数相同的数一个都不选的方案被算了两遍</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STC static</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF std::function</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500</span> + <span class="number">100</span>, B = <span class="number">19</span>, V = (<span class="number">1</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> id[<span class="number">20</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">LL p, d[V + <span class="number">100</span>][V + <span class="number">100</span>], ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> <span class="keyword">int</span> sm, bg; &#125; a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adj</span><span class="params">(LL &amp;x)</span></span>&#123; x += (x &gt;&gt; <span class="number">63</span>) &amp; p; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prev</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FF&lt;<span class="built_in"><span class="keyword">void</span></span>(Node&amp;, <span class="keyword">int</span>)&gt; ins = [&amp;](Node &amp;x, <span class="keyword">int</span> pr)&#123; (pr &lt;= B) ? x.sm |= (<span class="number">1</span> &lt;&lt; (id[pr] - <span class="number">1</span>)) : x.bg = pr; &#125;;</span><br><span class="line">STC <span class="keyword">int</span> vis[N], pri[N], ct;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[i])&#123; pri[++ct] = vis[i] = i, <span class="built_in">ins</span>(a[i], i); &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= ct &amp;&amp; pri[j] * i &lt;= n; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[i] &lt; pri[j]) <span class="keyword">break</span>;</span><br><span class="line">vis[i * pri[j]] = pri[j];</span><br><span class="line">a[i * pri[j]].sm |= a[i].sm; <span class="comment">//这里调了我半天</span></span><br><span class="line">a[i * pri[j]].bg = a[i].bg;</span><br><span class="line"><span class="built_in">ins</span>(a[i * pri[j]], pri[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">STC LL f1[V + <span class="number">100</span>][V + <span class="number">100</span>], f2[V + <span class="number">100</span>][V + <span class="number">100</span>];</span><br><span class="line">std::<span class="built_in">memcpy</span>(f1, d, <span class="keyword">sizeof</span> d), std::<span class="built_in">memcpy</span>(f2, d, <span class="keyword">sizeof</span> d);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = V - <span class="number">1</span>; ~j; --j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = V - <span class="number">1</span>; ~k; --k) <span class="keyword">if</span> (!(j &amp; k))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (f1[j][k] &amp;&amp; !(k &amp; a[i].sm)) <span class="built_in">adj</span>(f1[j | a[i].sm][k] += f1[j][k] - p);</span><br><span class="line"><span class="keyword">if</span> (f2[j][k] &amp;&amp; !(j &amp; a[i].sm)) <span class="built_in">adj</span>(f2[j][k | a[i].sm] += f2[j][k] - p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; V; ++j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; V; ++k) <span class="keyword">if</span> (!(j &amp; k)) <span class="built_in">adj</span>(d[j][k] = -d[j][k]), <span class="built_in">adj</span>(d[j][k] += f1[j][k] - p), <span class="built_in">adj</span>(d[j][k] += f2[j][k] - p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %lld&quot;</span>, &amp;n, &amp;p), <span class="built_in">prev</span>();</span><br><span class="line">std::<span class="built_in">sort</span>(a + <span class="number">2</span>, a + n + <span class="number">1</span>, [&amp;](Node x, Node y)&#123; <span class="keyword">return</span> x.bg &lt; y.bg; &#125;);</span><br><span class="line">d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>, a[n + <span class="number">1</span>].bg = a[n + <span class="number">1</span>].sm = <span class="number">-1</span>; <span class="comment">//防越界</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (!a[<span class="number">2</span>].bg) <span class="comment">//特判没有大质数</span></span><br><span class="line"><span class="keyword">for</span> (; !a[i].bg; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = V - <span class="number">1</span>; ~j; --j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = V - <span class="number">1</span>; ~k; --k) <span class="keyword">if</span> (d[j][k])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!(k &amp; a[i].sm)) <span class="built_in">adj</span>(d[j | a[i].sm][k] += d[j][k] - p);</span><br><span class="line"><span class="keyword">if</span> (!(j &amp; a[i].sm)) <span class="built_in">adj</span>(d[j][k | a[i].sm] += d[j][k] - p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; a[j].bg != <span class="number">-1</span>; ++i) <span class="keyword">if</span> (a[i].bg != a[j].bg) <span class="built_in">dp</span>(j, i - <span class="number">1</span>), j = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; V; ++j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; V; ++k) <span class="keyword">if</span> (!(j &amp; k) &amp;&amp; d[j][k]) <span class="built_in">adj</span>(ans += d[j][k] - p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 毒瘤根号分治出处&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
    <category term="根号分治" scheme="https://dyd-true.github.io/tags/%E6%A0%B9%E5%8F%B7%E5%88%86%E6%B2%BB/"/>
    
    <category term="状压" scheme="https://dyd-true.github.io/tags/%E7%8A%B6%E5%8E%8B/"/>
    
  </entry>
  
  <entry>
    <title>luoguP8292 [省选联考 2022] 卡牌</title>
    <link href="https://dyd-true.github.io/2022/04/21/luoguP8292-%E7%9C%81%E9%80%89%E8%81%94%E8%80%83-2022-%E5%8D%A1%E7%89%8C/"/>
    <id>https://dyd-true.github.io/2022/04/21/luoguP8292-%E7%9C%81%E9%80%89%E8%81%94%E8%80%83-2022-%E5%8D%A1%E7%89%8C/</id>
    <published>2022-04-21T13:27:31.000Z</published>
    <updated>2022-04-27T08:24:17.593Z</updated>
    
    <content type="html"><![CDATA[<p> 巧妙的根号分治</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P8292">卡牌</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>看到 $s_i \le 2000$ ，感觉很小，但打个表有 $300$ 多个质数，爆炸</p><p>这里有一个很套路的办法：考虑到大于 $\sqrt{s}$ 的质因数最多只有一个，我们可以单独记录那个质因数（不妨叫它大质数），剩下的质因数就只有 $14$ 个了；那么我们把每个 $s_i$ 就变成了 $\le 14$ 个小质数 + 一个大质数</p><p>（到了这里好像就可以大力容斥，比较 $2000$ 以内每个数只有 $\le 4$ 个质因数，但我容斥辣鸡的一批）</p><p>对于每次询问，依次考虑每一个大质数，把所有含有它的 $s_i$ 的小质数压缩成二进制 $k$ ，然后加到 $g[k]$ 中去，对 $g$ 做 FWT ，把所有 $g$ 乘起来即可，注意没有大质数的数也要乘，如果把 $g$ 的 FWT 放在外面预处理，时间为 $O(2^{14} (m + \sum c_i))$  ，我们发现这样常数巨大，不好卡（但好像确实可以卡过）</p><p>考虑换一种想法，显然我们只需要考虑所有询问了的质因数，平均一下每次询问也就十来个，不妨每次给 $s_i$ 重新分解，分解的范围也就仅限这十来个，我们给这些质数重新标 $id$ ，每次重新算 $g$ （因为质数不多，所以 FWT 很快），实测飞快</p><p>另外，对于过大（乘 $2$ 都超出范围）的质数，可以直接统计答案</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>实现的时候有些细节：</p><ol><li>所有因数只保留一次即可</li><li>注意真的贡献是 $2^{g(k)} - 1$ （对于没有大质数的数，就是 $2^{g(k)}$ ），所以 FWT 时要 $\mod \varphi(P)$ </li><li>清空！尤其是清空 <code>vector</code> 时还要单独写函数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> S = <span class="number">2000</span> + <span class="number">100</span>, P = <span class="number">998244353</span>, V = (<span class="number">1</span> &lt;&lt; <span class="number">14</span>), C = <span class="number">18000</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, pri[S], ct, si[S], mxv = <span class="number">0</span>, B, num[S], vis[S], lg[V + <span class="number">100</span>], p[C], id[S], f[V + <span class="number">100</span>], g[V + <span class="number">100</span>], id2[S], bit[V + <span class="number">100</span>];</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; dv[S], v[S], dv2[S];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt; &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; t;</span><br><span class="line">std::<span class="built_in">swap</span>(x, t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> bit)</span></span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; bit); ++i) x[i] = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = <span class="built_in">LL</span>(x) * x % P) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = <span class="built_in">LL</span>(res) * x % P; </span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adj</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> _p = P)</span></span>&#123; x += (x &gt;&gt; <span class="number">31</span>) &amp; _p; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prev</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">num[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; S; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[i])&#123; vis[i] = num[i] = pri[++ct] = i; &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, t; j &lt;= ct &amp;&amp; (t = pri[j] * i) &lt; S; ++j)</span><br><span class="line">&#123;</span><br><span class="line">vis[t] = pri[j];</span><br><span class="line"><span class="keyword">if</span> (!(i % pri[j]))&#123; num[t] = num[i]; <span class="keyword">break</span>; &#125;</span><br><span class="line">num[t] = num[i] * pri[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">lg[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= V; ++i) lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fwt</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = i &gt;&gt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; len; j += i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k) <span class="built_in">adj</span>(x[k + mid] += x[k] - P);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ifwt</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = i &gt;&gt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; len; j += i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k) <span class="built_in">adj</span>(x[k + mid] -= x[k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">prev</span>();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, t; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">++si[num[t]], mxv = std::<span class="built_in">max</span>(num[t], mxv);</span><br><span class="line">&#125;</span><br><span class="line">B = std::<span class="built_in">sqrt</span>(mxv);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= mxv; ++i) <span class="keyword">if</span> (si[i])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i, t; j &gt; <span class="number">1</span>; )</span><br><span class="line"><span class="keyword">do</span> dv[i].<span class="built_in">pb</span>(t = vis[j]), j /= t; <span class="keyword">while</span> (!(j % t));</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> tot, sol, ans, tt2; m--; )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), tot = <span class="number">0</span>, ans = sol = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p[i]);</span><br><span class="line">std::<span class="built_in">sort</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>), n = std::<span class="built_in">unique</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>) - p - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) id[p[i]] = i, <span class="built_in">clear</span>(v[i]), tot += (p[i] &lt;= B);</span><br><span class="line"><span class="built_in">clear</span>(f, tot);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, t, sm, bg; i &lt;= mxv; ++i) <span class="keyword">if</span> (si[i])</span><br><span class="line">&#123;</span><br><span class="line">sm = bg = <span class="number">0</span>, <span class="built_in">clear</span>(dv2[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j : dv[i]) <span class="keyword">if</span> (t = id[j])</span><br><span class="line">&#123;</span><br><span class="line">dv2[i].<span class="built_in">pb</span>(j);</span><br><span class="line">(p[t] &lt;= B) ? sm |= (<span class="number">1</span> &lt;&lt; (t - <span class="number">1</span>)) : bg = t; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!bg) <span class="built_in">adj</span>(f[sm] += si[i] - (P - <span class="number">1</span>), P - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> v[bg].<span class="built_in">pb</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fwt</span>(f, <span class="number">1</span> &lt;&lt; tot);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; tot); ++i) f[i] = <span class="built_in">qpow</span>(<span class="number">2</span>, f[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, sm, t; i &lt;= n &amp;&amp; sol; ++i) <span class="keyword">if</span> (p[i] &gt; B)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!v[i].<span class="built_in">size</span>()) sol = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p[i] * <span class="number">2</span> &gt; mxv) ans = <span class="built_in">LL</span>(<span class="built_in">qpow</span>(<span class="number">2</span>, si[p[i]]) - <span class="number">1</span>) * ans % P;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j : v[i])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k : dv2[j]) vis[id[k]] = <span class="number">1</span>;</span><br><span class="line">tt2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n &amp;&amp; p[i] * p[j] &lt;= mxv; ++j) <span class="keyword">if</span> (vis[j])</span><br><span class="line">&#123;</span><br><span class="line">vis[j] = <span class="number">0</span>;</span><br><span class="line">id2[j] = ++tt2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">clear</span>(g, tt2);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j : v[i])</span><br><span class="line">&#123;</span><br><span class="line">sm = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k : dv2[j]) <span class="keyword">if</span> (t = id2[id[k]]) sm |= (<span class="number">1</span> &lt;&lt; (t - <span class="number">1</span>));</span><br><span class="line"><span class="built_in">adj</span>(g[sm] += si[j] - (P - <span class="number">1</span>), P - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fwt</span>(g, <span class="number">1</span> &lt;&lt; tt2);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; tt2); ++i) g[i] = <span class="built_in">qpow</span>(<span class="number">2</span>, g[i]) - <span class="number">1</span>;</span><br><span class="line">f[<span class="number">0</span>] = <span class="built_in">LL</span>(f[<span class="number">0</span>]) * g[<span class="number">0</span>] % P;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; tot); ++i)</span><br><span class="line">&#123;</span><br><span class="line">t = id2[lg[i &amp; -i] + <span class="number">1</span>];</span><br><span class="line">bit[i] = bit[i &amp; (i - <span class="number">1</span>)] | (t ? (<span class="number">1</span> &lt;&lt; (t - <span class="number">1</span>)) : <span class="number">0</span>);</span><br><span class="line">f[i] = <span class="built_in">LL</span>(f[i]) * g[bit[i]] % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n &amp;&amp; p[i] * p[j] &lt;= mxv; ++j) id2[j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sol)</span><br><span class="line">&#123;</span><br><span class="line">ifwt(f, <span class="number">1</span> &lt;&lt; tot);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">LL</span>(ans) * f[(<span class="number">1</span> &lt;&lt; tot) - <span class="number">1</span>] % P);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) id[p[i]] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 巧妙的根号分治&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
    <category term="根号分治" scheme="https://dyd-true.github.io/tags/%E6%A0%B9%E5%8F%B7%E5%88%86%E6%B2%BB/"/>
    
    <category term="FWT" scheme="https://dyd-true.github.io/tags/FWT/"/>
    
  </entry>
  
  <entry>
    <title>子集卷积</title>
    <link href="https://dyd-true.github.io/2022/04/21/%E5%AD%90%E9%9B%86%E5%8D%B7%E7%A7%AF/"/>
    <id>https://dyd-true.github.io/2022/04/21/%E5%AD%90%E9%9B%86%E5%8D%B7%E7%A7%AF/</id>
    <published>2022-04-21T12:50:54.000Z</published>
    <updated>2022-04-21T13:25:43.175Z</updated>
    
    <content type="html"><![CDATA[<p> FWT 的简单运用</p><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>考虑如下问题：<br>$$<br>h(n) = (f * g)(n) = \sum_{i \&amp; j = 0 \wedge i \mid j = n} f(i) * g(j)<br>$$<br>也就是 $h(n)$ 等于所有把 $n$ 划分成为两个集合的方案权值积的和，也可以写成集合形式，即求：<br>$$<br>h(S) = (f * g)(S) = \sum_{A \cap B = 0 \wedge A \cup B = S} f(A) * g(S)<br>$$<br>所以叫子集卷积</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>发现比 FWT 多个条件，让人讨厌</p><p>考虑限制，设 $f’(i, S) = \sum_{\mid T \mid = i \wedge T \in S} f(T)$ ，这样的好处是， $i$ 记录了 $T$ 的大小，那么要保证 $i + j = \mid S \mid$ ，就可以保证对应子集没有交集了</p><p>那么如何求 $f’(i, S)$ 呢？我们先符初始值 $f’(\mid S \mid, S) = f(S)$ ，然后直接对 $f’(\mid S \mid)$ 做或卷积，就可以得到所有 $f’(\mid S \mid, X)$ 了</p><p>时间复杂度 $O(n \log^2 n)$ ，其中 $n$ 是多项式长度</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://www.luogu.com.cn/problem/P6097">子集卷积</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pct(x) __builtin_popcount(x)</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = (<span class="number">1</span> &lt;&lt; <span class="number">20</span>) + <span class="number">100</span>, P = <span class="number">1e9</span> + <span class="number">9</span>, BT = <span class="number">20</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> bit, n, f[BT][N], g[BT][N], h[BT][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adj</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123; x += (x &gt;&gt; <span class="number">31</span>) &amp; P; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fwt</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = i &gt;&gt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; len; j += i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k) <span class="built_in">adj</span>(x[k + mid] += x[k] - P);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ufwt</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = i &gt;&gt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; len; j += i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k) <span class="built_in">adj</span>(x[k + mid] -= x[k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;bit), n = (<span class="number">1</span> &lt;&lt; bit);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;f[<span class="built_in">pct</span>(i)][i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;g[<span class="built_in">pct</span>(i)][i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= bit; ++i) <span class="built_in">fwt</span>(f[i], n), <span class="built_in">fwt</span>(g[i], n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= bit; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j + i &lt;= bit; ++j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; n; ++s) <span class="built_in">adj</span>(h[i + j][s] += <span class="built_in">LL</span>(f[i][s]) * g[j][s] % P - P);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= bit; ++i) <span class="built_in">ufwt</span>(h[i], n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, h[<span class="built_in">pct</span>(i)][i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; FWT 的简单运用&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数论,数学" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
    <category term="笔记" scheme="https://dyd-true.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="FWT" scheme="https://dyd-true.github.io/tags/FWT/"/>
    
  </entry>
  
  <entry>
    <title>快速沃尔什变换</title>
    <link href="https://dyd-true.github.io/2022/04/20/%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80%E5%8F%98%E6%8D%A2/"/>
    <id>https://dyd-true.github.io/2022/04/20/%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80%E5%8F%98%E6%8D%A2/</id>
    <published>2022-04-20T06:50:54.000Z</published>
    <updated>2022-04-21T12:46:40.579Z</updated>
    
    <content type="html"><![CDATA[<p>  不要记混就好</p><span id="more"></span><h1 id="快速沃尔什变换"><a href="#快速沃尔什变换" class="headerlink" title="快速沃尔什变换"></a>快速沃尔什变换</h1><p>即所谓的FWT</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>从函数卷积的角度看，多项式乘法就是一个卷积：<br>$$<br>(f * g)(n) = \sum_{i + j = n} f(i) * g(j)<br>$$<br>而当这种卷积拓展到二进制下（大多用于集合运算）时，我们考虑这个问题：<br>$$<br>(f * g)(n) = \sum_{i \circ  j = n} f(i) * g(j)<br>$$<br>其中 $\circ $ 代表或（ $\mid$ ）、与（ $\&amp;$ ）以及异或（ $\oplus$ ）</p><p>此时问题变得麻烦了起来，直接做当然是 $O(n^2)$ 的，其中 $n$ 是多项式长度；于是，类似于 FFT ，我们考虑用分治加速，可以得到 $O(n \log n)$ 的复杂度</p><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>FFT 做到了多项式系数表示与点值表示的快速变换，使得我们可以利用点值表示的优势很快得到答案，FWT 也是这么个思想：用一种<strong>可逆线性变换</strong>（这个“线性”不是指时间，而是指满足线性运算）将原多项式变成某种好计算的表示方法，然后快速得答案；而好消息是， FWT 不必要用复数单位根这种麻烦的东西，只要分治就好了</p><p>在开始之前，我们定义 $merge(f, g)$ 表示将两个多项式像字符串拼接一样拼在一起， $f + g$ 表示将两个多项式对于位置相加</p><h2 id="或运算"><a href="#或运算" class="headerlink" title="或运算"></a>或运算</h2><p>我们从最好理解的或开始，即求 $h(n) = (f * g)(n) = \sum_{i \mid j = n} f(i) * g(j)$ </p><p>考虑构造 $f’(i) = \sum_{i = i \mid j} f(j)$ ，那么显然 $h’(i) = f’(i) * g’(i)$ ，不妨让 $f$ 的长度为 $n = 2^{bit}$ ，考虑将 $f$ 分成前、后两段 $f_0, f_1$ ，长度都为 $2^{bit - 1}$ ，我们递归构造 $f_0, f_1$ 的 FWT 记作 $f_0’, f_1’$ ，则有<br>$$<br>f’ =<br>\begin{cases}<br>f &amp; bit = 0 \\<br>merge(f_0’, f_1’ + f_0’) &amp; bit &gt; 0<br>\end{cases}<br>$$<br>解释一下：显然，对于所有 $i &lt; 2^{bit - 1}$ （即二进制下第 $bit - 1$ 位为 $0$ ）， $f_1’$ 是不会对它这个位置产生影响的，反而它会影响 $f_1’$ ，而影响的位置就是恰好二进制下只在 $bit - 1$ 位和它不一样（即为 $1$ 的位置），又因为 $f_1’$ 的下标是 $0 \sim 2^{bit - 1} - 1$ ，所有下标就是对应位置</p><p>当然，不可能真的递归去做，具体实现是时和 FFT 一样化成迭代</p><p>对于逆变换，就是 $merge(f_0’, f_1’ - f_0’)$ </p><h2 id="与运算"><a href="#与运算" class="headerlink" title="与运算"></a>与运算</h2><p>求 $h(n) = (f * g)(n) = \sum_{i \&amp; j = n} f(i) * g(j)$ </p><p>直接给式子了：<br>$$<br>f’ =<br>\begin{cases}<br>f &amp; bit = 0 \\<br>merge(f_0’ + f_1’, f_1’) &amp; bit &gt; 0<br>\end{cases}<br>$$<br>逆变换就是 $merge(f_0’ - f_1’, f_1’)$</p><h2 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h2><p>求 $h(n) = (f * g)(n) = \sum_{i \oplus j = n} f(i) * g(j)$ </p><p>式子：<br>$$<br>f’ =<br>\begin{cases}<br>f &amp; bit = 0 \\<br>merge(f_0’ + f_1’, f_0’ - f_1’) &amp; bit &gt; 0<br>\end{cases}<br>$$<br>逆变换有点不一样了，是 $merge(\frac{f_0’ + f_1’}{2}, \frac{f_0’ - f_1’}{2})$</p><p>其实，在 $\oplus$ 的操作下， $f’(i) = \sum_{\mid i \&amp; j \mid \% 2 = 0} f(j) - \sum_{\mid i \&amp; j \mid \% 2 = 1} f(j)$ </p><h2 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h2><p><a href="https://www.luogu.com.cn/problem/P4717">luoguP4717</a></p><p>要注意如果长度不为 $2$ 的整次幂，要补足</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = (<span class="number">1</span> &lt;&lt; <span class="number">17</span>) + <span class="number">100</span>, P = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adj</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123; x += (x &gt;&gt; <span class="number">31</span>) &amp; P; &#125;</span><br><span class="line"><span class="keyword">namespace</span> FWT</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> iv2 = <span class="number">499122177</span>; <span class="comment">//2的逆元</span></span><br><span class="line"><span class="keyword">void</span> _or(<span class="keyword">int</span> x[], <span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; i &lt;&lt;= <span class="number">1</span>) <span class="comment">//当前区间长度</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = i &gt;&gt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; len; j += i) <span class="comment">//j当前区间前端</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k) <span class="built_in">adj</span>(x[k + mid] += x[k] - P);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">u_or</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = i &gt;&gt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; len; j += i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k) <span class="built_in">adj</span>(x[k + mid] -= x[k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _and(<span class="keyword">int</span> x[], <span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = i &gt;&gt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; len; j += i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k) <span class="built_in">adj</span>(x[k] += x[k + mid] - P);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">u_and</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = i &gt;&gt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; len; j += i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k) <span class="built_in">adj</span>(x[k] -= x[k + mid]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _xor(<span class="keyword">int</span> x[], <span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, t1, t2; i &lt;= len; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = i &gt;&gt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; len; j += i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k)</span><br><span class="line">&#123;</span><br><span class="line">t1 = x[k], t2 = x[k + mid];</span><br><span class="line"><span class="built_in">adj</span>(x[k] = t1 + t2 - P), <span class="built_in">adj</span>(x[k + mid] = t1 - t2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">u_xor</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, t1, t2; i &lt;= len; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = i &gt;&gt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; len; j += i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k)</span><br><span class="line">&#123;</span><br><span class="line">t1 = x[k], t2 = x[k + mid];</span><br><span class="line"><span class="built_in">adj</span>(x[k] = t1 + t2 - P), <span class="built_in">adj</span>(x[k + mid] = t1 - t2);</span><br><span class="line">x[k] = <span class="built_in">LL</span>(iv2) * x[k] % P, x[k + mid] = <span class="built_in">LL</span>(iv2) * x[k + mid] % P;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N], aa[N], bb[N], n, bit;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;bit), n = (<span class="number">1</span> &lt;&lt; bit);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) aa[i] = a[i], bb[i] = b[i];</span><br><span class="line">FWT::_or(aa, n), FWT::_or(bb, n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) aa[i] = <span class="built_in">LL</span>(aa[i]) * bb[i] % P;</span><br><span class="line">FWT::<span class="built_in">u_or</span>(aa, n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, aa[i]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) aa[i] = a[i], bb[i] = b[i];</span><br><span class="line">FWT::_and(aa, n), FWT::_and(bb, n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) aa[i] = <span class="built_in">LL</span>(aa[i]) * bb[i] % P;</span><br><span class="line">FWT::<span class="built_in">u_and</span>(aa, n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, aa[i]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) aa[i] = a[i], bb[i] = b[i];</span><br><span class="line">FWT::_xor(aa, n), FWT::_xor(bb, n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) aa[i] = <span class="built_in">LL</span>(aa[i]) * bb[i] % P;</span><br><span class="line">FWT::<span class="built_in">u_xor</span>(aa, n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, aa[i]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;  不要记混就好&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数论,数学" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
    <category term="笔记" scheme="https://dyd-true.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="FWT" scheme="https://dyd-true.github.io/tags/FWT/"/>
    
    <category term="多项式" scheme="https://dyd-true.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>矩阵</title>
    <link href="https://dyd-true.github.io/2022/04/17/%E7%9F%A9%E9%98%B5/"/>
    <id>https://dyd-true.github.io/2022/04/17/%E7%9F%A9%E9%98%B5/</id>
    <published>2022-04-17T06:41:37.000Z</published>
    <updated>2022-04-17T14:37:45.466Z</updated>
    
    <content type="html"><![CDATA[<p> 系统的看一下</p><span id="more"></span><p>前面递归式学习时浅尝其苦，现在真的来受苦</p><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><ul><li><p><strong>矩阵</strong>：由 $m \times n$ 个元素排列成 $m$ 行 $n$ 列的数表叫矩阵，即：<br>$$<br>\begin{aligned}<br>A =<br>\begin{bmatrix}<br>a_{1, 1}, a_{1, 2}, …, a_{1, n} \\<br>a_{2, 1}, a_{2, 2}, …, a_{2, n} \\<br>… \\<br>a_{m, 1}, a_{m, 2}, …, a_{m, n} \\<br>\end{bmatrix}<br>\end{aligned}<br>$$</p></li><li><p>奇/偶排列：逆序对数为奇/偶数的排列，一下记排列 $a_1, a_2, …, a_n$ 的逆序对数为 $\tau(a_1, a_2, …, a_n)$ </p></li><li><p><strong>方阵</strong>： $n \times n$ 的矩阵，一般记作方阵 $A, B, C …$ ，其中 $n$ 叫做该方阵的<strong>阶</strong></p></li><li><p><strong>行列式</strong>：一个 $n$ 阶方阵的行列式等于取自所有不同行不同列的 $n$ 个元素的乘积的“代数和”（即按奇/偶排列带负/正号），记作 $det(A)$ （也有记作 $\mid A \mid$ ），形式化的：<br>$$<br>\begin{aligned}<br>对于 n 阵方阵 A &amp; =<br>\begin{bmatrix}<br>a_{1, 1}, a_{1, 2}, …, a_{1, n} \\<br>a_{2, 1}, a_{2, 2}, …, a_{2, n} \\<br>… \\<br>a_{n, 1}, a_{n, 2}, …, a_{n, n} \\<br>\end{bmatrix} \\<br>其行列式 det(A) &amp; =<br>\begin{vmatrix}<br>a_{1, 1}, a_{1, 2}, …, a_{1, n} \\<br>a_{2, 1}, a_{2, 2}, …, a_{2, n} \\<br>… \\<br>a_{n, 1}, a_{n, 2}, …, a_{n, n} \\<br>\end{vmatrix} \\<br>&amp; = \sum_{j_1, j_2, …j_n 是 1 \sim n 的一个排列} (-1)^{\tau(j_1, j_2, …, j_n)} a_{1, j_1} a_{2, j_2} … a_{n, j_n}<br>\end{aligned}<br>$$<br>不难看出，直接求 $det$ 是 $O(n!)$ 的</p></li><li><p><strong>代数余子式</strong>：把一个 $n$ 阶行列式去掉第 $i$ 行和第 $j$ 列后，留下的 $n - 1$ 阶行列式叫做元素 $a_{i, j}$ 的<strong>余子式</strong>，记作 $M_{i, j}$ ，记 $A_{i, j} = (-1)^{i + j} M_{i, j}$ ，叫做 $a_{i, j}$ 的<strong>代数余子式</strong></p></li><li><p><strong>主/副对角线</strong>：对于一个方阵，所有 $i = j$ 的元素 $a_{i, j}$ 组成其主对角线；所有 $i + j = n + 1$ 的元素 $a_{i, j}$ 组成其副对角线</p></li><li><p><strong>上/下三角矩阵</strong>：主对角线左下方/右上方全为 $0$ 的矩阵</p></li><li><p>同型矩阵：行列数一样的矩阵</p></li><li><p>主子式：在 $n$ 阶行列式中，任意选取 $i$ 个行号，再选取与行号相同的列号，只保留所选行、列的行列式即为 $n$ 阶行列式的 $i$ 阶主子式</p></li><li><p>给定一个无向图 $G(V, E)$ </p><ul><li><p>度数矩阵 $D$ ：当 $i \ne j$ 时，  $D[i][j] = 0$ ，否则  $D[i][j] = 点 i(j) 的度数$ </p></li><li><p>邻接矩阵 $A$ ：当 $(u, v) \in E$ 时， $A[u][v] = 1$ ，否则 $A[u][v] = 0$ </p></li><li><p><strong>基尔霍夫矩阵</strong>( Kirchhoff )  $K$ ，也称拉普拉斯算子：定义为 $K = D - A$ ，如图：</p><p><img src="https://s2.loli.net/2021/12/22/VatPLREvlyDocXh.png" alt="K"></p></li><li><p>关联矩阵：对于一个 $n$ 个点 $m$ 条边的无向图，我们把边任意定向，那么其关联矩阵是一个 $n$ 行 $m$ 列的矩阵，其中元素满足：<br>$$<br>b_{i, j} =<br>\begin{cases}<br>1 &amp; (i 是边 j 的终点) \\<br>1 &amp; (i 是边 j 的起点) \\<br>0 &amp; (其它)<br>\end{cases}<br>$$</p></li></ul></li></ul><h3 id="计算类"><a href="#计算类" class="headerlink" title="计算类"></a>计算类</h3><ul><li><p>线性运算：</p><ol><li><p>加法：两个同型矩阵 $A, B$ 的加法运算得到同型矩阵 $C$ ，且 $C$ 中元素满足 $c_{i, j} = a_{i, j} + b_{i, j}$ </p></li><li><p>减法：两个同型矩阵 $A, B$ 的加法运算得到同型矩阵 $C$ ，且 $C$ 中元素满足 $c_{i, j} = a_{i, j} - b_{i, j}$ </p></li><li><p>数乘：一个矩阵 $A$ 乘一个数 $\lambda $ 得到同型矩阵 $C$ ，且 $C$ 中元素满足 $c_{i, j} = \lambda a_{i, j}$ </p><p>显然，数乘满足分配律和结合律</p></li></ol></li><li><p>矩阵乘法：若 $A$ 是 $m \times n$ 的矩阵， $B$ 是 $n \times p$ 的矩阵，它们的乘积是一个 $m \times p$ 的矩阵 $C$ ，且满足 $c_{i, j} = \sum_{r = 1}^n a_{i, r} b_{r, j}$ </p><p>矩阵乘法满足结合律、左/右分配律，但没有交换律</p></li><li><p><strong>转置</strong>：把矩阵的行换成同序数的列叫做矩阵的转置，记作 $A^{T}$ ，例如：</p><p>$$<br>\begin{bmatrix}<br>1, 2 , 3 \\<br>4, 5, 6 \\<br>\end{bmatrix}<br>^{T}<br>=<br>\begin{bmatrix}<br>1, 4 \\<br>2, 3 \\<br>5, 6 \\<br>\end{bmatrix}<br>$$<br>明显有以下运算律：<br>$$<br>\begin{aligned}<br>&amp; (A^T)^T = A \\<br>&amp; (\lambda A)^T = \lambda A^T \\<br>&amp; (AB)^T = B^T A^T (这里注意顺序)\\<br>\end{aligned}<br>$$</p></li><li><p>行列式的数学计算式： $n$ 阶方阵的行列式等于其任意行/列元素与对应代数余子式乘积之和，即 $det(A) = \sum_{j = 1}^n a_{i, j} A_{i, j} = \sum_{i = 1}^n a_{i, j} A_{i, j}$ （注意代数余子式是有符号的）</p></li></ul><h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><p>一般的，对于线性递推式 $f_i = a_1 f_{i - 1} + a_2 f_{i - 2} + … + a_k f_{i - k}$ ，我们令 $F = \begin{bmatrix} f_{i - 1} \\ f_{i - 2} \\ … \\ f_{i - k} \end{bmatrix}, F’ = \begin{bmatrix} f_{i} \\ f_{i - 1} \\ … \\ f_{i - k + 1} \end{bmatrix}$ ，不难得到转移矩阵 $A = \begin{bmatrix} a_1 &amp; a_2 &amp; … &amp; a_{k - 1} &amp;a_k \\ 1 &amp;0 &amp;… &amp;0 &amp;0 \\ 0 &amp;1 &amp;… &amp;0 &amp;0 \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\ 0 &amp;0 &amp;… &amp;1 &amp;0 \end{bmatrix}$ ，于是有 $F’ = AF$ ，那么，若 $F_0$ 已知，则 $F_i = A^i F_0$ ，可以先用类似快速幂的方法求 $A^i$ ，把时间降至 $O(k^3 \log n)$ </p><h2 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h2><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>关于行列式，有几个性质：</p><ol><li><p>交换对应方阵的 $1$ 行和 $1$ 列（进行一次<strong>矩阵转置</strong>），行列式不变；直接定义展开可证，其实没啥用</p></li><li><p>交换对应方阵的 $2$ 行（列），行列式取反；</p><p>简证：交换一个排列中的两个数，除开它们两个，其它数的逆序对数一定成对变化（变化偶数），只有它们两个导致逆序对变 $1$ ，所以 $det$ 中每一项都取反</p></li><li><p>若有一行（列）相等，行列式为 $0$ </p><p>简证：交换相等的这两行，得 $det = -det$ </p></li><li><p>任意行（列）所有元素等比例变化，则行列式也等比例变化；展开后由乘法分配律可得</p></li><li><p>任意两行/列成比例，行列式为 $0$ ；由性质 $3, 4$ 可得</p></li><li><p>如果行列式对应方阵 $A$ 中有一行（列），是对应2个方阵 $B, C$ 中分别的 $2$ 行（列）所有元素之和，且 $A$ 中其它元素都等于 $B, C$ 中对应元素，则有 $det(A) = det(B) + det(C)$ ；写成行列式，由乘法分配律可证</p></li><li><p>把一个矩阵的一行（列）的值全部乘一个常数加到另一行（列）上，行列式值不变；由性质 $5, 6$ 可得</p></li><li><p>上三角矩阵的行列式就等于对角线元素乘积；展开可得</p></li><li><p> $det(AB) = det(A) \times det(B)$ </p></li></ol><h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><p>直接计算行列式是 $O(n!)$ ，用数学算法要大量分治递归（实测 $n &gt; 12$ 时几乎就是暴力），所以我们考虑性质 $8$ ，只要通过行列式的变换把它变成上三角矩阵，我们就可以 $O(n)$ 计算了，又由性质 $2, 4, 7$ ，我们可以直接高斯消元 $O(n^3)$ </p><p>实现时注意若没有逆元，要辗转相除，此时虽然多个 $\log $ ，但每次做两次消元 $a_{i, i}$ 至少会变为原来的一半，而这个势能是不会上升的，均摊下去复杂度为 $O(n^2 (\log p + n))$ </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">600</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n, p;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mtx</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x[N][N];</span><br><span class="line">    <span class="keyword">int</span>* <span class="keyword">operator</span> [] (<span class="keyword">int</span> id)&#123; <span class="keyword">return</span> x[id]; &#125;</span><br><span class="line">&#125; a;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adj</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123; x += (x &gt;&gt; <span class="number">31</span>) &amp; p; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">det</span><span class="params">(Mtx x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>, i, j, t, k, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= n; ++j) <span class="comment">//这里不找最大直接消是因为在取模意义下没有精度误差</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (x[i][i]) <span class="comment">//对第i行和第j行做辗转相减</span></span><br><span class="line">            &#123;</span><br><span class="line">                t = x[j][i] / x[i][i];</span><br><span class="line">                <span class="keyword">for</span> (k = i; k &lt;= n; ++k) <span class="built_in">adj</span>(x[j][k] -= <span class="built_in">LL</span>(t) * x[i][k] % p);</span><br><span class="line">                std::<span class="built_in">swap</span>(x.x[i], x.x[j]), f ^= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            std::<span class="built_in">swap</span>(x.x[i], x.x[j]), f ^= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">LL</span>(res) * x[i][i] % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!f) <span class="built_in">adj</span>(res = -res); <span class="comment">//注意res=0时</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">            <span class="built_in">adj</span>(a[i][j] %= p); <span class="comment">//保证正数</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">det</span>(a));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，若模数是质数，还是直接取逆元好，而且长得和gauss 消元更像（但其实这是高斯-约旦消去法）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">600</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n, p;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mtx</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x[N][N];</span><br><span class="line">    <span class="keyword">int</span>* <span class="keyword">operator</span> [] (<span class="keyword">int</span> id)&#123; <span class="keyword">return</span> x[id]; &#125;</span><br><span class="line">&#125; a;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adj</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123; x += (x &gt;&gt; <span class="number">31</span>) &amp; p; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = <span class="built_in">LL</span>(x) * x % p) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = <span class="built_in">LL</span>(res) * x % p;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">det</span><span class="params">(Mtx x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>, i, j, t, k, iv, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &lt;= n; ++j) <span class="keyword">if</span> (x[j][i])</span><br><span class="line">        &#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(x.x[i], x.x[j]);</span><br><span class="line">            <span class="keyword">if</span> (i != j) f ^= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!x[i][i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = i + <span class="number">1</span>, iv = <span class="built_in">qpow</span>(x[i][i], p - <span class="number">2</span>);j &lt;= n; ++j)</span><br><span class="line">&#123;</span><br><span class="line">t = <span class="built_in">LL</span>(x[j][i]) * iv % p;</span><br><span class="line"><span class="keyword">for</span>(k = i; k &lt;= n; ++k) <span class="built_in">adj</span>(x[j][k] -= <span class="built_in">LL</span>(t) * x[i][k] % p);</span><br><span class="line">&#125;</span><br><span class="line">        res = <span class="built_in">LL</span>(res) * x[i][i] % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!f) <span class="built_in">adj</span>(res = -res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">            <span class="built_in">adj</span>(a[i][j] %= p); <span class="comment">//gauss 消元要保证正数</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">det</span>(a));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于行列式的运用，还有几个东西，我懒了，可以查阅 OI Wiki ，它们是</p><ul><li><p>LGV 引理</p></li><li><p>BEST 定理</p></li><li><p>Binet-Cauchy定理</p></li></ul><p>咕咕咕</p><h2 id="Matrix-Tree-定理（矩阵树定理）"><a href="#Matrix-Tree-定理（矩阵树定理）" class="headerlink" title="Matrix-Tree 定理（矩阵树定理）"></a>Matrix-Tree 定理（矩阵树定理）</h2><p><strong>无向图 $G$ 的所有生成树个数等于其 kirchhoff 矩阵 $K(G)$ 任何一个 $n - 1$ 阶主子式的绝对值</strong></p><h3 id="几条引理"><a href="#几条引理" class="headerlink" title="几条引理"></a>几条引理</h3><p>由于证明太麻烦就不写了，可以参考<a href="https://zhuanlan.zhihu.com/p/108209378">这个</a></p><ul><li><p>一个 kirchhoff 矩阵 $K$ 的行列式总是为 $0$ </p></li><li><p>如果图 $G$ 不构成树，那么 $K(G)$ 的任意一个 $n - 1$ 阶主子式都为 $0$ </p></li><li><p>如果图 $G$ 构成树，则 $K(G)$ 的任意一个 $n - 1$ 阶主子式绝对值都为 $1$ </p></li><li><p>设图 $G$ 的关联矩阵为 $B$ ，有 $B B^T = K$  </p></li></ul><h3 id="常见变形"><a href="#常见变形" class="headerlink" title="常见变形"></a>常见变形</h3><ul><li>若存在必选边，考虑将必选边连接的点缩点，对压缩后的图求生成树</li><li>如果图中边有边权，可以把<strong>度数矩阵 $D$ 变成边的权值和</strong>，直接用Matrix-Tree 定理，求得的就是<strong>所有生成树边权乘积的总和</strong></li><li>如果求有向图生成树，首先要把邻接矩阵 $A$ 变成有向图的邻接矩阵，然后对于 $D$ ，如果它记录的是<strong>到该点入的边权总和</strong>，那么求得的就是<strong>外向树</strong> (从根向外)，即 $D[i][j] = \sum_{j = 1}^n A[j][i]$ ；类似的，如果它记录的是<strong>到该点出的边权总和</strong>，那么求得的就是<strong>内向树</strong> (从外向根)，关于如何保证根，巨佬们说：去掉第 $k$ 行 $k$ 列就是以 $k$ 为根</li></ul><h2 id="线性方程"><a href="#线性方程" class="headerlink" title="线性方程"></a>线性方程</h2><p>一般来说，线性方程形式如下：<br>$$<br>\begin{cases}<br>a_{1, 1} x_1 + a_{1, 2} x_2 + … + a_{1, n} x_n = b_1 \\<br>a_{2, 1} x_1 + a_{2, 2} x_2 + … + a_{2, n} x_n = b_2 \\<br>… \\<br>a_{m, 1} x_1 + a_{m, 2} x_2 + … + a_{m, n} x_n = b_m \\<br>\end{cases}<br>$$<br>我们常记为 $AX = B$ ，其中 $A, B$ 是系数/常数矩阵，而 $X$ 是未知数构成的矩阵（ $X, B$ 也可理解为向量）</p><h3 id="guass-消元"><a href="#guass-消元" class="headerlink" title="guass 消元"></a>guass 消元</h3><p>不多说，给代码</p><p>实数版：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> DB = <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> DB eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mtx</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DB x[N][N];</span><br><span class="line">    DB* <span class="keyword">operator</span> [] (<span class="keyword">int</span> id)&#123; <span class="keyword">return</span> x[id]; &#125;</span><br><span class="line">&#125; a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">guass</span><span class="params">(Mtx &amp;x, <span class="keyword">int</span> len)</span> <span class="comment">//注意传实参</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, t, now;</span><br><span class="line">    <span class="keyword">for</span> (i = now = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t = now;</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &lt;= len; ++j) <span class="keyword">if</span> (<span class="built_in">fabs</span>(x[j][i]) &gt; <span class="built_in">fabs</span>(x[t][i])) t = j;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(x[t][i]) &lt; eps) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (t != now) std::<span class="built_in">swap</span>(x.x[t], x.x[now]);</span><br><span class="line">        <span class="keyword">for</span> (j = len + <span class="number">1</span>; j &gt;= i; --j) x[now][j] /= x[now][i];</span><br><span class="line">        <span class="keyword">for</span> (j = now + <span class="number">1</span>; j &lt;= len; ++j) <span class="keyword">if</span> (<span class="built_in">fabs</span>(x[j][i]))</span><br><span class="line">            <span class="keyword">for</span> (k = len + <span class="number">1</span>; k &gt;= i; --k) x[j][k] -= x[j][i] * x[now][k];</span><br><span class="line">        ++now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (now &lt;= len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = now; i &lt;= len; ++i) <span class="keyword">if</span> (<span class="built_in">fabs</span>(x[i][len + <span class="number">1</span>]) &gt; eps) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> len - now + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = len; i; --i)</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= len; ++j) x[i][len + <span class="number">1</span>] -= x[i][j] * x[j][len + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = len; i; --i) <span class="keyword">if</span> (<span class="built_in">fabs</span>(x[i][len + <span class="number">1</span>]) &lt; eps) x[i][len + <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//防止出现-0.00</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n + <span class="number">1</span>; ++j) <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;a[i][j]);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">guass</span>(a, n)) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, a[i][n + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No Solution&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取模版：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = <span class="built_in">LL</span>(x) * x % P) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = <span class="built_in">LL</span>(res) * x % P;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adj</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123; x += (x &gt;&gt; <span class="number">31</span>) &amp; P; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">guass</span><span class="params">(Mtx &amp;x, <span class="keyword">int</span> len)</span> <span class="comment">//进入前保证系数非负</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, now, t;</span><br><span class="line">    <span class="keyword">for</span> (i = now = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (t = i; t &lt;= len; ++t) <span class="keyword">if</span> (x[t][i]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (t &gt; len) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (t != now) std::<span class="built_in">swap</span>(x.x[t], x.x[now]);</span><br><span class="line">        <span class="keyword">if</span> (x[now][i] != <span class="number">1</span>) <span class="keyword">for</span> (j = len + <span class="number">1</span>, t = <span class="built_in">qpow</span>(x[now][i], P - <span class="number">2</span>); j &gt;= i; --j) x[now][j] = <span class="built_in">LL</span>(t) * x[now][j] % P;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= len; ++j) <span class="keyword">if</span> (x[j][i])</span><br><span class="line">            <span class="keyword">for</span> (k = len + <span class="number">1</span>; k &gt;= i; --k) <span class="built_in">adj</span>(x[j][k] -= <span class="built_in">LL</span>(x[j][i]) * x[i][k] % P);</span><br><span class="line">        ++now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (now &lt;= len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = now; i &lt;= len; ++i) <span class="keyword">if</span> (x[i][len + <span class="number">1</span>]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> len - now + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = len; i; --i)</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= len; ++j) <span class="built_in">adj</span>(x[i][len + <span class="number">1</span>] -= <span class="built_in">LL</span>(x[i][j]) * x[j][len + <span class="number">1</span>] % P);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LU分解法"><a href="#LU分解法" class="headerlink" title="LU分解法"></a>LU分解法</h3><p>在系数矩阵不变，仅仅是常数改变时，LU分解法有很大的优势</p><p>顾名思义，LU分解就是把系数矩阵 $A$ 分解成两个矩阵 $L, U$ ，满足 $LU = A$ 且 $L$ 为下三角矩阵且主对角线为 $1$ ， $U$ 为上三角矩阵，即：<br>$$<br>\begin{bmatrix}<br>a_{1, 1} &amp; a_{1, 2} &amp; …    &amp; a_{n, n} \\<br>a_{2, 1} &amp; a_{2, 2} &amp; …    &amp; a_{2, n} \\<br>\vdots   &amp; \vdots   &amp; \ddots &amp; \vdots   \\<br>a_{n, 1} &amp; a_{n, 2} &amp; …    &amp; a_{n, n} \\<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>1        &amp; 0        &amp; …    &amp; 0      \\<br>l_{2, 1} &amp; 1        &amp; …    &amp; 0      \\<br>\vdots   &amp; \vdots   &amp; \ddots &amp; \vdots \\<br>l_{n, 1} &amp; l_{n, 2} &amp; …    &amp; 1      \\<br>\end{bmatrix}<br>\begin{bmatrix}<br>u_{1, 1} &amp; u_{1, 2} &amp; …    &amp; u_{1, n} \\<br>0        &amp; u_{2, 2} &amp; …    &amp; u_{2, n} \\<br>\vdots   &amp; \vdots   &amp; \ddots &amp; \vdots   \\<br>0        &amp; 0        &amp; …    &amp; u_{n, n} \\<br>\end{bmatrix}<br>$$<br>于是，有 $LUX = B$ ，即 $UX = Y, LY = B$ </p><p>你可能在担心该如何求 $L, U, X, Y$ ，没有关系，前人已经帮我们总结了公式（这也叫 Doolittle 算法）：</p><ol><li><p>求 $L, U$ ，对于 $k = 1, 2, …, n$ ：<br>$$<br>\begin{cases}<br>u_{k, j} = a_{k, j} - \sum_{r = 1}^{k - 1} l_{k, r} u_{r, j} &amp; j = k, k + 1, …, n \\<br>u_{i, k} = (a_{i, k} - \sum_{r = 1}^{k - 1} l_{i, r} u_{r, k}) / u_{k, k} &amp; i = k, k + 1, …, n\\<br>l_{k, k} = 1<br>\end{cases}<br>$$</p></li><li><p>求 $Y$ ，对于 $k = 1, 2, …, n$ ：<br>$$<br>y_k = b_k - \sum_{r = 1}^{k - 1} l_{k, r} y_{r}<br>$$</p></li><li><p>求 $X$ ，对于 $k = n, n - 1, …, 1$ ：<br>$$<br>x_k = (y_k - \sum_{r = k + 1}^n u_{k, r} x_r) / u_{k, k}<br>$$</p></li></ol><p>不难发现，第一步是 $O(n^3)$ ，另外两步都是 $O(n^2)$ 的，要支持取模也很方便（背公式就好了，这不比高斯香？）</p><p>ps：如果方程有多解或者无解， $L, U$ 中会有 <code>nan</code> ，注意处理</p><h2 id="矩阵求逆"><a href="#矩阵求逆" class="headerlink" title="矩阵求逆"></a>矩阵求逆</h2><p>在 guass 的同时对单位矩阵进行一样的操作即可（一定要先操作单位矩阵）</p><p>ps：其实，对于 $AX = B$ ，可以 $X = A^{-1} B$ 来解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">400</span> + <span class="number">100</span>, P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mtx</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x[N][N];</span><br><span class="line">    <span class="keyword">int</span>* <span class="keyword">operator</span> [] (<span class="keyword">int</span> id)&#123; <span class="keyword">return</span> x[id]; &#125;</span><br><span class="line">&#125; a, b;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = <span class="built_in">LL</span>(x) * x % P) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = <span class="built_in">LL</span>(res) * x % P;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adj</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123; x += (x &gt;&gt; <span class="number">31</span>) &amp; P; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mtxinv</span><span class="params">(Mtx &amp;x, Mtx &amp;as, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, t;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (t = i; t &lt;= len; ++t) <span class="keyword">if</span> (x[t][i]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (t &gt; len) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (t != i) std::<span class="built_in">swap</span>(x.x[t], x.x[i]), std::<span class="built_in">swap</span>(as.x[t], as.x[i]);</span><br><span class="line">        <span class="keyword">if</span> (x[i][i] != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = len, t = <span class="built_in">qpow</span>(x[i][i], P - <span class="number">2</span>); j &gt;= <span class="number">1</span>; --j) as[i][j] = <span class="built_in">LL</span>(t) * as[i][j] % P;</span><br><span class="line">            <span class="keyword">for</span> (j = len, t = <span class="built_in">qpow</span>(x[i][i], P - <span class="number">2</span>); j &gt;= i; --j) x[i][j] = <span class="built_in">LL</span>(t) * x[i][j] % P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= len; ++j) <span class="keyword">if</span> (x[j][i])</span><br><span class="line">            <span class="keyword">for</span> (k = len; k &gt;= <span class="number">1</span>; --k) <span class="built_in">adj</span>(as[j][k] -= <span class="built_in">LL</span>(x[j][i]) * as[i][k] % P);</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= len; ++j) <span class="keyword">if</span> (x[j][i])</span><br><span class="line">            <span class="keyword">for</span> (k = len; k &gt;= i; --k) <span class="built_in">adj</span>(x[j][k] -= <span class="built_in">LL</span>(x[j][i]) * x[i][k] % P);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = len; i; --i)</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= len; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (k = len; k &gt;= <span class="number">1</span>; --k) <span class="built_in">adj</span>(as[i][k] -= <span class="built_in">LL</span>(x[i][j]) * as[j][k] % P);</span><br><span class="line">            <span class="built_in">adj</span>(x[i][len + <span class="number">1</span>] -= <span class="built_in">LL</span>(x[i][j]) * x[j][len + <span class="number">1</span>] % P);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) b[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mtxinv</span>(a, b, n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i, <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>))    </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No Solution&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 系统的看一下&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>luoguP7116 [NOIP2020] 微信步数</title>
    <link href="https://dyd-true.github.io/2022/04/15/luoguP7116-NOIP2020-%E5%BE%AE%E4%BF%A1%E6%AD%A5%E6%95%B0/"/>
    <id>https://dyd-true.github.io/2022/04/15/luoguP7116-NOIP2020-%E5%BE%AE%E4%BF%A1%E6%AD%A5%E6%95%B0/</id>
    <published>2022-04-15T07:36:40.000Z</published>
    <updated>2022-04-17T06:31:11.427Z</updated>
    
    <content type="html"><![CDATA[<p> 难点在推式子</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P7116">微信步数</a></p><h2 id="本人思路"><a href="#本人思路" class="headerlink" title="本人思路"></a>本人思路</h2><p>然鹅卡死只有 $80pts$ </p><p>首先发现随着步数的增加，每一维的取值范围在减小，所以暴力维护每一位取值范围，对每个步数进行计算即可， $O(nwk)$ ，实测 $35pts$ ，然后我看到 $w \le 10^9$ 猜要化式子去掉那个 $w$ ，但限于我 sb 的数学水平，并没有推出来</p><p>但想了个拆贡献的做法：一个点走了多少步后不合法一定是有一维限制了它，考虑处理出 $step[j][i]$ 表示“第 $j$ 维为 $i$ 时只考虑第 $j$ 维最多走多少步”（为了避免使用 <code>long long</code> ，具体存的时候可以用 <code>pair</code> ），然后枚举每一维的每一个值，查找其它维的 $step$ 比它大的数乘起来就是它的贡献，关于如何查找，考虑给 $step$ 排序，指针单调扫即可，时间 $O(k w \log w)$ ，卡常后可得 $80pts$ </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IL inline</span></span><br><span class="line"><span class="keyword">namespace</span> FIO</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L = (<span class="number">1</span> &lt;&lt; <span class="number">20</span>) + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> buf[L], out[L], *S, *E;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gh() (S == E ? E = (S = buf) + fread(buf, 1, L, stdin), (S == E ? EOF : *S++) : *S++)</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">rd</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch = <span class="built_in">gh</span>(), t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>; ch = <span class="built_in">gh</span>()) t |= (ch == <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">0</span>; ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>; ch = <span class="built_in">gh</span>()) x = x * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line"><span class="keyword">if</span> (t) x = -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">flus</span><span class="params">()</span></span>&#123; <span class="built_in">fwrite</span>(out, <span class="number">1</span>, l, stdout), l = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">chk</span><span class="params">()</span></span>&#123; <span class="keyword">if</span> (l &gt;= L - <span class="number">5</span>) <span class="built_in">flus</span>(); &#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123; out[l++] = x, <span class="built_in">chk</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">wt</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="built_in">pc</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">9</span>) <span class="built_in">wt</span>(x / <span class="number">10</span>);</span><br><span class="line">out[l++] = x % <span class="number">10</span> + <span class="number">48</span>, <span class="built_in">chk</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> FIO::flus;</span><br><span class="line"><span class="keyword">using</span> FIO::rd;</span><br><span class="line"><span class="keyword">using</span> FIO::pc;</span><br><span class="line"><span class="keyword">using</span> FIO::wt;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> PII = std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">100</span>, P = <span class="number">1e9</span> + <span class="number">7</span>, K = <span class="number">10</span> + <span class="number">5</span>, INF = <span class="number">0x3f3f3f3f</span>, V = <span class="number">1e6</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, w[K], ans = <span class="number">0</span>, mx[K][N], mn[K][N], dt[K][N], it[K];</span><br><span class="line">PII a[N], step[K][V];</span><br><span class="line"><span class="keyword">bool</span> vis[K][V];</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">adj</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123; x += (x &gt;&gt; <span class="number">31</span>) &amp; P; &#125;</span><br><span class="line"><span class="function">IL <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> j, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = n, mid, res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line">mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i + mn[j][mid - <span class="number">1</span>] &gt;= <span class="number">1</span> &amp;&amp; i + mx[j][mid - <span class="number">1</span>] &lt;= w[j]) res = mid, l = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL PII <span class="title">get_step</span><span class="params">(<span class="keyword">int</span> j, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[j][i]) <span class="keyword">return</span> step[j][i];</span><br><span class="line"><span class="keyword">if</span> (i + mx[j][n] &lt;= w[j] &amp;&amp; i + mn[j][n] &gt;= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dt[j][n]) step[j][i] = <span class="built_in">get_step</span>(j, i + dt[j][n]), ++step[j][i].fi;</span><br><span class="line"><span class="keyword">else</span> step[j][i] = &#123;INF, INF&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> step[j][i] = &#123;<span class="number">0</span>, <span class="built_in">find</span>(j, i)&#125;;</span><br><span class="line">vis[j][i] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> step[j][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">rd</span>(n), <span class="built_in">rd</span>(k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) <span class="built_in">rd</span>(w[j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">rd</span>(a[i].fi), <span class="built_in">rd</span>(a[i].se);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) dt[a[i].fi][i] = a[i].se;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j)</span><br><span class="line">&#123;</span><br><span class="line">mx[j][<span class="number">1</span>] = mn[j][<span class="number">1</span>] = dt[j][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">dt[j][i] += dt[j][i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (dt[j][i] &gt; mx[j][i - <span class="number">1</span>]) mx[j][i] = dt[j][i];</span><br><span class="line"><span class="keyword">else</span> mx[j][i] = mx[j][i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (dt[j][i] &lt; mn[j][i - <span class="number">1</span>]) mn[j][i] = dt[j][i];</span><br><span class="line"><span class="keyword">else</span> mn[j][i] = mn[j][i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = w[j]; i; --i) <span class="keyword">if</span> (!vis[j][i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i + mx[j][n] &lt;= w[j] &amp;&amp; i + mn[j][n] &gt;= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dt[j][n]) step[j][i] = <span class="built_in">get_step</span>(j, i + dt[j][n]), ++step[j][i].fi;</span><br><span class="line"><span class="keyword">else</span> step[j][i] = &#123;INF, INF&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> step[j][i] = &#123;<span class="number">0</span>, <span class="built_in">find</span>(j, i)&#125;;</span><br><span class="line">vis[j][i] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> not_sol = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k &amp;&amp; not_sol; ++j)</span><br><span class="line">&#123;</span><br><span class="line">not_sol = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = w[j]; i &amp;&amp; !not_sol; --i) not_sol |= (step[j][i].fi == INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (not_sol) <span class="built_in">pc</span>(<span class="string">&#x27;-&#x27;</span>), <span class="built_in">pc</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) std::<span class="built_in">sort</span>(step[j] + <span class="number">1</span>, step[j] + w[j] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, as; j &lt;= k; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> o = <span class="number">1</span>; o &lt;= k; ++o) it[o] = w[o];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = w[j]; i; --i) <span class="keyword">if</span> (step[j][i].fi != INF)</span><br><span class="line">&#123;</span><br><span class="line">as = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> o = <span class="number">1</span>; o &lt;= k; ++o) <span class="keyword">if</span> (o != j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (it[o] &amp;&amp; (step[o][it[o]] &gt; step[j][i]) || (step[o][it[o]] == step[j][i] &amp;&amp; o &gt; j) ) --it[o];</span><br><span class="line">as = <span class="built_in">LL</span>(w[o] - it[o]) * as % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">adj</span>(ans += (<span class="built_in">LL</span>(step[j][i].fi) * n + step[j][i].se) % P * as % P - P);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">wt</span>(ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pc</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">flus</span>(), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h2><p>我们不难发现 $80pts$ 的思路没有前途，因为 $w \le 10^9$ ，所以 <del>瞟一眼题解</del> 回到 $O(nwk)$ 的思路，考虑搞掉那个 $w$ </p><p>为了推式子，我们先把 $O(n w k)$ 的式子写一下，我们维护 $up[j], dw[j]$ 表示“第 $j$ 维仍在当前范围内的值的上/下界”，并记 $len[j] = up[j] - dw[j] + 1$ ，设当前步改变了第 $c_i$ 维，不难发现 $uo[j], dw[j]$ 最多只减少一个数，也就只有第 $j$ 维为那个数的点会在此步被淘汰，所以：<br>$$<br>\begin{aligned}<br>Ans = \sum_{i}^{n * w} (i * \prod_{j \ne c_i} len[j])<br>\end{aligned}<br>$$<br><del>打表找规律</del> 不难发现，设 $n$ 步为 $1$ 轮，则除第二轮外，每一轮到前一轮的每一维变化量相等，形式化的，记 $dt[j]$ 表示第 $j$ 维一轮的变化量，有 $第 i 轮的 len[j] = 第 2 轮的 len[j] - (i - 2) * dt[j]$ （这里第一轮特殊的原因是它每有前一轮给它的偏移量），那么就可以把步数按 $\mod n$ 分开，所以答案变成：<br>$$<br>\begin{aligned}<br>Ans = \sum_{i = n + 1}^{2n} \sum_{k} ((i + (k - 2)n) \prod_{j \ne c_i} (len[j] - (k - 2) dt[j]))<br>\end{aligned}<br>$$<br>解释一下这个式子：第一次枚举 $i$ 表示“第二轮的每一步（所以 $n + 1 \le i \le 2n$ ）”，它们代表 $\mod n$ 意义下的一类步数；然后枚举 $k$ 表示“其实是在第 $k$ 轮（注意这里和题目的 $k$ 不一样）”，这样就确定了现在是第 $i + (k - 2)n$ 步，然后乘贡献即可</p><p>不难发现，我们消去了 $w$ ，但引入了一层新的枚举，而且我们不知道 $k$ 会枚举到那里，明显会挂，继续推式子<br>$$<br>\begin{aligned}<br>Ans<br>&amp; = \sum_{i = n + 1}^{2n} \sum_{k} ((i + (k - 2)n) \prod_{j \ne c_i} (len[j] - (k - 2) dt[j])) \\<br>令 x &amp; = k - 2, 有: \\<br>Ans<br>&amp; = \sum_{i = n + 1}^{2n} \sum_{x} ((i + x * n) \prod_{j \ne c_i} (len[j] - x * dt[j])) \\<br>&amp; = \sum_{x} \sum_{i = n + 1}^{2n} ((i + x * n) \prod_{j \ne c_i} (len[j] - x * dt[j])) \\<br>再令 f(x) &amp;= ((i + x * n) \prod_{j \ne c_i} (len[j] - x * dt[j])) \\<br>&amp;= \sum_{i = 0}^{k} a_i x^i \\<br>就是要求 Ans &amp; = \sum_{i = n + 1}^{2n} \sum_{x}  f(x) \\<br>&amp; = \sum_{i = n + 1}^{2n} \sum_{x} \sum_{i = 0}^{k} a_i x^i \\<br>&amp; = \sum_{i = n + 1}^{2n} \sum_{i = 0}^{k} a_i \sum_{x} x^i<br>\end{aligned}<br>$$<br>关于上面的变形， $f(x)$ 那步需要暴力求一下多项式的卷积（用 $O(k^2)$ ），而 $x$ 的范围可以直接检查每个 $len$ 得到，然后发现 $\sum_{x} x^i$ 可以直接拉格朗日插值，总时间为 $O(n k^2)$ </p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STC static</span></span><br><span class="line"><span class="keyword">using</span> PII = std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">100</span>, K = <span class="number">10</span> + <span class="number">5</span>, P = <span class="number">1e9</span> + <span class="number">7</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, w[K], up[K], dw[K], len[K], dt[K], ans, f[K], g[K], lf, dtt[K];</span><br><span class="line">PII a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adj</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123; x += (x &gt;&gt; <span class="number">31</span>) &amp; P; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = <span class="built_in">LL</span>(x) * x % P) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = <span class="built_in">LL</span>(res) * x % P;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">polymul</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> lx, <span class="keyword">int</span> ly)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">STC <span class="keyword">int</span> tmp[K];</span><br><span class="line"><span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="keyword">sizeof</span> tmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lx; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ly; ++j) <span class="built_in">adj</span>(tmp[i + j] += <span class="built_in">LL</span>(x[i]) * y[j] % P - P);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = lx + ly - <span class="number">1</span>; ~i; --i) x[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> La <span class="comment">// 插值</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> pl[K][K];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rdy</span><span class="params">(<span class="keyword">int</span> o)</span> <span class="comment">//ready</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">STC <span class="keyword">int</span> tp[K], tp2[K], v[K];</span><br><span class="line"><span class="keyword">int</span> *p = pl[o];</span><br><span class="line">++o; <span class="comment">//o+1次多项式</span></span><br><span class="line"><span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="keyword">sizeof</span> v);</span><br><span class="line">v[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= o; ++i) <span class="built_in">adj</span>(v[i] += v[i - <span class="number">1</span>] + <span class="built_in">qpow</span>(i + <span class="number">1</span>, o - <span class="number">1</span>) - P);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, b; i &lt;= o; ++i)</span><br><span class="line">&#123;</span><br><span class="line">b = v[i], tp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, l = <span class="number">1</span>, t; j &lt;= o; ++j) <span class="keyword">if</span> (i != j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">adj</span>(t = i - j);</span><br><span class="line"><span class="built_in">adj</span>(tp2[<span class="number">0</span>] = -(j + <span class="number">1</span>)), tp2[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">polymul</span>(tp, tp2, l, <span class="number">2</span>), ++l;</span><br><span class="line">b = <span class="built_in">LL</span>(b) * <span class="built_in">qpow</span>(t, P - <span class="number">2</span>) % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= o; ++j) tp[j] = <span class="built_in">LL</span>(tp[j]) * b % P;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= o; ++j) <span class="built_in">adj</span>(p[j] += tp[j] - P);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>, *p = pl[o];</span><br><span class="line">++o;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, tx = x; i &lt;= o; ++i, tx = <span class="built_in">LL</span>(tx) * x % P) <span class="built_in">adj</span>(res += <span class="built_in">LL</span>(p[i]) * tx % P - P); <span class="comment">//肯定没有常数项</span></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]), up[i] = w[i], dw[i] = <span class="number">1</span>, len[i] = w[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, t; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a[i].fi, &amp;a[i].se);</span><br><span class="line"><span class="keyword">if</span> ((dt[t = a[i].fi] += a[i].se) &gt;= <span class="number">0</span>) up[t] = std::<span class="built_in">min</span>(up[t], w[t] - dt[t]);</span><br><span class="line"><span class="keyword">else</span> dw[t] = std::<span class="built_in">max</span>(dw[t], -dt[t] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> fail = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k &amp;&amp; fail; ++i) fail &amp;= (up[i] &gt;= dw[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k &amp;&amp; fail; ++i) fail &amp;= (!dt[i]);</span><br><span class="line"><span class="keyword">if</span> (fail) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; ++i) La::<span class="built_in">rdy</span>(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) up[i] = w[i], dw[i] = <span class="number">1</span>, len[i] = w[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, ll, t, as; i &lt;= n; ++i) <span class="comment">//第一轮</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((dtt[t = a[i].fi] += a[i].se) &gt;= <span class="number">0</span>) up[t] = std::<span class="built_in">min</span>(up[t], w[t] - dtt[t]);</span><br><span class="line"><span class="keyword">else</span> dw[t] = std::<span class="built_in">max</span>(dw[t], -dtt[t] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> ((ll = std::<span class="built_in">max</span>(<span class="number">0</span>, up[t] - dw[t] + <span class="number">1</span>)) &lt; len[t])</span><br><span class="line">&#123;</span><br><span class="line">as = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) <span class="keyword">if</span> (j != t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!len[j])&#123; as = <span class="number">0</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">as = <span class="built_in">LL</span>(as) * len[j] % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">adj</span>(ans += as - P), len[t] = ll;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, ll, t, as, x; i &lt;= n; ++i) <span class="comment">//二轮及以后</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((dtt[t = a[i].fi] += a[i].se) &gt;= <span class="number">0</span>) up[t] = std::<span class="built_in">min</span>(up[t], w[t] - dtt[t]);</span><br><span class="line"><span class="keyword">else</span> dw[t] = std::<span class="built_in">max</span>(dw[t], -dtt[t] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> ((ll = std::<span class="built_in">max</span>(<span class="number">0</span>, up[t] - dw[t] + <span class="number">1</span>)) &lt; len[t])</span><br><span class="line">&#123;</span><br><span class="line">as = i + n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) <span class="keyword">if</span> (j != t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!len[j])&#123; as = <span class="number">0</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">as = <span class="built_in">LL</span>(as) * len[j] % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">adj</span>(ans += as - P);</span><br><span class="line">f[<span class="number">0</span>] = i + n, f[<span class="number">1</span>] = n, lf = <span class="number">2</span>; <span class="comment">//求f</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) <span class="keyword">if</span> (j != t)</span><br><span class="line">&#123;</span><br><span class="line">g[<span class="number">0</span>] = len[j], <span class="built_in">adj</span>(g[<span class="number">1</span>] = -<span class="built_in">abs</span>(dt[j]));</span><br><span class="line"><span class="built_in">polymul</span>(f, g, lf, <span class="number">2</span>), ++lf;</span><br><span class="line">&#125;</span><br><span class="line">x = INF; <span class="comment">//求x</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j)</span><br><span class="line"><span class="keyword">if</span> (!len[j]) x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (dt[j]) x = std::<span class="built_in">min</span>(x, (len[j] - <span class="number">1</span>) / <span class="built_in">abs</span>(dt[j]));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; ++j) <span class="built_in">adj</span>(ans += <span class="built_in">LL</span>(f[j]) * La::<span class="built_in">calc</span>(j, x) % P - P);</span><br><span class="line">len[t] = ll;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 难点在推式子&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="数论,数学" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
    <category term="二分" scheme="https://dyd-true.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
    <category term="暴力" scheme="https://dyd-true.github.io/tags/%E6%9A%B4%E5%8A%9B/"/>
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
    <category term="拉格朗日插值" scheme="https://dyd-true.github.io/tags/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>luoguP7114 [NOIP2020] 字符串匹配</title>
    <link href="https://dyd-true.github.io/2022/04/13/luoguP7114-NOIP2020-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    <id>https://dyd-true.github.io/2022/04/13/luoguP7114-NOIP2020-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</id>
    <published>2022-04-13T08:11:41.000Z</published>
    <updated>2022-04-27T08:15:20.155Z</updated>
    
    <content type="html"><![CDATA[<p> 暴力骗分？其实是 Z 函数</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P7114">字符串匹配</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>正解是广义 KMP （ Z 函数）</p><p>但如果你和我一样不会的话（upd ：没想到吧，我会了！），也可以用 KMP 骗到 $84pts$ </p><p>考虑枚举每一个 $c$ ，设 $s$ 去掉 $c$ 后为 $t$ ，求出 $t$ 的最小循环节，发现 $|AB|$ 必须是它的约数，直接枚举约数，计算贡献即可</p><p>关于求最小循环节，有一个结论：对于长度为 $len$ 的串，若 $len - ne[len] \mid len$ ，则最小循环节就是 $len - ne[len]$ ，否则就是 $len$ </p><p>打个表发现范围内约数最多的数有 $240$ 个约数，总时间为 $O(240Tn)$ ，只有 $1s$ 就只有 $84pts$ 了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>一个细节是 <code>vector</code> 存约数因为内存不连续慢点一比（预处理就用了 $1.2s$ ，所以我手动分配内存）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IL inline</span></span><br><span class="line"><span class="keyword">namespace</span> FIO</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L = (<span class="number">1</span> &lt;&lt; <span class="number">20</span>) + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> buf[L], out[L], *S, *E;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gh() (S == E ? E = (S = buf) + fread(buf, 1, L, stdin), (S == E ? EOF : *S++) : *S++)</span></span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">flus</span><span class="params">()</span></span>&#123; <span class="built_in">fwrite</span>(out, <span class="number">1</span>, l, stdout), l = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">chk</span><span class="params">()</span></span>&#123; <span class="keyword">if</span> (l &gt;= L - <span class="number">5</span>) <span class="built_in">flus</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch = <span class="built_in">gh</span>(), t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>; ch = <span class="built_in">gh</span>()) t |= ch == <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">0</span>; ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>; ch = <span class="built_in">gh</span>()) x = x * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line"><span class="keyword">if</span> (t) x = -x;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">readc</span><span class="params">(<span class="keyword">char</span> *x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch = <span class="built_in">gh</span>();</span><br><span class="line"><span class="keyword">for</span> (; ch &lt; <span class="string">&#x27;a&#x27;</span> || ch &gt; <span class="string">&#x27;z&#x27;</span>; ch = <span class="built_in">gh</span>());</span><br><span class="line"><span class="keyword">for</span> (; ch &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;z&#x27;</span>; ch = <span class="built_in">gh</span>()) *x++ = ch;</span><br><span class="line">        *x = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">putc</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123; out[l++] = x, <span class="built_in">chk</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">write</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="built_in">putc</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">9</span>) <span class="built_in">write</span>(x / <span class="number">10</span>);</span><br><span class="line">out[l++] = x % <span class="number">10</span> + <span class="number">48</span>, <span class="built_in">chk</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> gh</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">using</span> FIO::flus;</span><br><span class="line"><span class="keyword">using</span> FIO::read;</span><br><span class="line"><span class="keyword">using</span> FIO::putc;</span><br><span class="line"><span class="keyword">using</span> FIO::write;</span><br><span class="line"><span class="keyword">using</span> FIO::readc;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = (<span class="number">1</span> &lt;&lt; <span class="number">20</span>) + <span class="number">1</span>, A = <span class="number">30</span>, FN = <span class="number">14698342</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n, ne[N + <span class="number">5</span>], num[N + <span class="number">5</span>][A], ct, cnt[A], b[N + <span class="number">5</span>], fac[FN];</span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> s[N + <span class="number">5</span>];</span><br><span class="line"><span class="function">IL LL <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> up)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num[r][up] - (l ? num[l - <span class="number">1</span>][up] : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; <span class="built_in">LL</span>(i) * j &lt; N; ++j) ++b[i * j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i) b[i] += b[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i; --i) b[i] = b[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; <span class="built_in">LL</span>(i) * j &lt; N; ++j) fac[++b[i * j]] = i;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">read</span>(T); T--; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">readc</span>(s + <span class="number">1</span>), n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">        ne[<span class="number">1</span>] = ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &amp;&amp; s[i] != s[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j + <span class="number">1</span>]) ++j;</span><br><span class="line">            ne[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span> num);</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt), ct = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ((++cnt[s[i] - <span class="string">&#x27;a&#x27;</span>]) &amp; <span class="number">1</span>) ? ++ct :--ct;</span><br><span class="line">            num[i][ct] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">26</span>; ++j) num[i][j] += num[i][j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) num[i][j] += num[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt), ct = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n, len = i - <span class="number">1</span>, p, np, now, last, si; i &gt;= <span class="number">2</span>; --i, --len)</span><br><span class="line">        &#123;</span><br><span class="line">            ((++cnt[s[i] - <span class="string">&#x27;a&#x27;</span>]) &amp; <span class="number">1</span>) ? ++ct : --ct;</span><br><span class="line">            <span class="keyword">if</span> (len % (p = len - ne[len])) p = len;</span><br><span class="line">            np = len / p, last = <span class="number">0</span>, si = b[np] - b[np - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = b[np - <span class="number">1</span>] + <span class="number">1</span>, t = b[np]; j &lt;= t; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                now = fac[j];</span><br><span class="line">                ans += <span class="built_in">ask</span>(last * p, now * p - <span class="number">1</span>, ct) * si;</span><br><span class="line">                --si, last = now;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">write</span>(ans), <span class="built_in">putc</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">flus</span>(), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="upd：可过的思路"><a href="#upd：可过的思路" class="headerlink" title="upd：可过的思路"></a>upd：可过的思路</h2><p>被迫学了 Z 函数，现在回来填坑</p><p>考虑枚举 $AB$ ，设当前枚举到 $AB = s[1 \sim i]$ ，且 $AB$ 循环了 $k$ 次，那么必有 $ik \le i + Z[i + 1]$ （这也是循环串的一个结论，类似 kmp 画个图其实很显然），于是有 $k \le K = \lfloor \frac{i + Z[i + 1]}{i} \rfloor$ ，那明显，当前 $AB$ 会被算 $K$ 次</p><p>但问题在于必须保证 $A$ 中奇数字符不多于 $C$ ，不难发现 $C$ 的奇数字符个数其实只有两种（因为它每次加一个循环节），如果我们有最短的 $C$ 的每个字符的出现次数和当前 $AB$ 中每个每个字符的出现次数，提前预处理每一个最短的 $C$ ，就可以在 $O(26)$ 的时间里计算出这两个值，且它们在 $K$ 次中各一半</p><p>有了这两个值，考虑同时维护一个树状数组，可以 $O(\log 26)$ 查询“所有满足 $j &lt; i$ ， $A = s[1 \sim j]$ 的 $A$ 中奇数字符个数 $\le x$ 的个数”</p><p>发现时间瓶颈在计算 $C$ 的奇数字符个数，其实对于每个字符我们只关心它的奇偶性不关心具体数量，所以用一个 <code>bitset</code> 优化，时间降至 $O(\frac{26}{w}) &lt; O(1)$ （瓶颈就直接变成树状数组了），总时间变成 $O(Tn(\log n + \frac{26}{w}))$ 可过</p><p>ps：好像有巨佬用桶 + 每次加减变化量可以做到 $O(n)$ 但实测没快多少，反正目前（2022/4/27）loj 上我的代码是最快的</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = (<span class="number">1</span> &lt;&lt; <span class="number">20</span>) + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n, Z[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line">LL ans;</span><br><span class="line">std::bitset&lt;26&gt; ab, a, c[N];</span><br><span class="line"><span class="keyword">namespace</span> BIT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lb(x) ((x) &amp; (-(x)))</span></span><br><span class="line">    <span class="keyword">int</span> ct[<span class="number">30</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span></span>&#123; <span class="keyword">for</span> (++x; x &lt;= <span class="number">27</span>; x += <span class="built_in">lb</span>(x)) ct[x] += d; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (++x; x; x ^= <span class="built_in">lb</span>(x)) res += ct[x];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123; <span class="built_in">memset</span>(ct, <span class="number">0</span>, <span class="keyword">sizeof</span> ct); &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> lb</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_z</span><span class="params">(<span class="keyword">char</span> x[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(Z, <span class="number">0</span>, <span class="keyword">sizeof</span> Z);</span><br><span class="line">    Z[<span class="number">1</span>] = len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, l = <span class="number">0</span>, r = <span class="number">0</span>; i &lt;= len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= r) Z[i] = std::<span class="built_in">min</span>(Z[i - l + <span class="number">1</span>], r - i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (i + Z[i] &lt;= len &amp;&amp; x[i + Z[i]] == x[<span class="number">1</span> + Z[i]]) ++Z[i];</span><br><span class="line">        <span class="keyword">if</span> (r &lt; Z[i] + i - <span class="number">1</span>) r = Z[i] + i - <span class="number">1</span>, l = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_c</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    c[n].<span class="built_in">reset</span>(), c[n].<span class="built_in">flip</span>(s[n] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">3</span>; --i) c[i] = c[i + <span class="number">1</span>], c[i].<span class="built_in">flip</span>(s[i] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T); T--; <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>), n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">get_z</span>(s, n), ab.<span class="built_in">reset</span>(), a.<span class="built_in">reset</span>(), BIT::<span class="built_in">clear</span>(), <span class="built_in">get_c</span>(), ans = <span class="number">0</span>;</span><br><span class="line">        ab.<span class="built_in">set</span>(s[<span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, k, t1, t2; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            k = (Z[i + <span class="number">1</span>]) ? (i + Z[i + <span class="number">1</span>]) / i : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i * k &gt;= n) --k;</span><br><span class="line">            a.<span class="built_in">flip</span>(s[i - <span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            BIT::<span class="built_in">add</span>(a.<span class="built_in">count</span>(), <span class="number">1</span>);</span><br><span class="line">            ab.<span class="built_in">flip</span>(s[i] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            <span class="keyword">auto</span> cc = c[i * k + <span class="number">1</span>];</span><br><span class="line">            t1 = BIT::<span class="built_in">ask</span>(cc.<span class="built_in">count</span>());</span><br><span class="line">            cc = cc ^ ab;</span><br><span class="line">            t2 = BIT::<span class="built_in">ask</span>(cc.<span class="built_in">count</span>());</span><br><span class="line">            ans += <span class="built_in">LL</span>(t1 + t2) * (k &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (k &amp; <span class="number">1</span>) ans += t1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 暴力骗分？其实是 Z 函数&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="字符串" scheme="https://dyd-true.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="数论,数学" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
    <category term="kmp" scheme="https://dyd-true.github.io/tags/kmp/"/>
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
  </entry>
  
  <entry>
    <title>dcoj矩阵操作</title>
    <link href="https://dyd-true.github.io/2022/04/11/dcoj%E7%9F%A9%E9%98%B5%E6%93%8D%E4%BD%9C/"/>
    <id>https://dyd-true.github.io/2022/04/11/dcoj%E7%9F%A9%E9%98%B5%E6%93%8D%E4%BD%9C/</id>
    <published>2022-04-11T08:24:18.000Z</published>
    <updated>2022-04-11T08:33:05.176Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="094aade146170b01bb6723233c696d9d19ea9104f71c78b1a23d1db6ada8d509">ff29f3b5512c5b3b94ff0833e12f201a01cfdcc8f4e5920484433fb8ac009018f96284a3e0e24143a457134b6880eb7d7b1f1ce622cfd1c7e1d2fb67369b62d8c07b2daf0afc7f88c08d386df5e838cbad66dcfe0514e19c3ee138194bdde87cd5116527eef788ad46cbbba646881d3e3c11e51c2d9e45e5987fa895300d63f4109e0b92c9f351732b575720700e2139b503c57a6d01289faa9e330159487c9ce23fcbaeb5ea6364cae55a4af74c2d9e251478a11163ef8a5c205c97bb6c5cc11e89f10f84784bdf285de2942dcdf7f4b656e28cfe1911e0c78ef4d538a507e80807247968ec8a0a61bde90b87dfb40a0339e6c2a79625ee3d1c28484d4323a030fb0a4caebdc60607c80c760c20214dab34a9c1aa7b077eb28ee1aa567982465f4335196379c02d99648ff7381d5eaa75715a10a1a05cc3228f1923e31ffbaefb1253313d36aff76da14fd0d95f0843ff72b696286beba56d413afacbfeaa1c41624e9ac2f04dc1ee6122deb6a06b7d76edca5309cd3ccb6542bafb45fe4a7ec16916ebb75b978d928407b214f8992d846d2e6a522a899a21a95935ac6324ea8362307f17528a50350a2c444fbc754013c041b448f1c7c6d8de17b38725ba1b4972666cbed11a99380ead77a15f8397d2a878fad3c2f6d3fdad54ae560775555548a07f08cb341747dd6f32b314b48edc47eb27211cfb948a96482869db54233f64f6d691bd1a077525bd6b34e1f055d625a3808527b6b6430b034e76e16b83f71d59164260077984f972ebbb44dbfa36b35e6ab93ec63d5806e3f505914bc91816cbc369e63729fe02919a00159f22ac00eabe151861ebb57ed8faccfa1c642ed2c0dfa3be22e27cbe57867652e1bb2a8213e17aa25bd269fc3745ede0c621946c900f10c79a406d9114b8af16564d59368ff0a048caded858ee15cfcf3ab04df7510ff03f9a525f7ccb2d64b8b1844eb351059e4c8400029798f4a9c5abe3f4a9c824d565c812ab99e8f1d37a709bc67229bcaa47cd2466ce9fa73d870d3fe11584bb7ee457579e4a4024fe08b467948e3a1912670c32d6f5d57844d6205c2101376d422bb525127fe19d72f066a96c4e675baeef7db22d7bee11c5aba34a6dbef907265c197b81d864169977985bd22b1dfd0b29901656e2198428787dcf66d51991178b2d6a716bb6f7ac5cd9bf96a83eee9b7bec5e509096431cfa9bed407a1a6fce52206b235196822d9cbd15d9154688d1a3f4d8978fb3bc6ff36ae0f453ca9b1af89c202c2decee91c26de15d9af2a533d63e97b52b3ef03a4c0c1b5d4d161b556464c3b783f1e23eca6ae5a2161d49a275f80c97899aa19fb101e9b12ea6001d17df9d9c55c58e8bbe4006537dac5b4fa43bebba34187b7683bc0359468f75e21f807e0dbfe49f6a2b3176e30e7bc0ad754e0608331f1a7a32e1429711fa3659fa9f1c5764005eb4739508b61b13969ef1781ac0f85c564f3e119ca742e770d38be7842fd6b670b36634a6a6d704e5eec1d2ee0675a11652b6182afa25550dc6b8767b5b8257263b330d525609f8ceb9ae68faeb75cf2522389a30fbf7791b66de31bf5fedf060c19866caaff992ed0d02896e01f87e6131f8b0f19877707b92e72e3a7e1e5f4fbec2c8a32742ebfd9cfd128dc4ada4a7b3eec419f53da62a504bb4c539ebe942c5df6017e0f56f6ba520be2c47795822803e22e78b366bcb57b501c5a5845e34992db2289ca7570e696b0836ac5eb828d8623bb3ae28b71a73d7a419c0014f3ca39b80441937322b932900c237c8e9363685148dac6f1106b5ce13fa7c3b952211a6f6e632c83555c26f6a546dc17ee8da139ea6dc5bc34771c0cd56c64f210cf669c4de73f18f39e25b07ef0812a7fbf2baf1b61fb4ffb661bdb7ff2c7b77cca8cc3ca664cd0ef25321d0637ca54e2b4c73f98777f7c9fc2d700495aedfc0cd709f746028bc49d708fd4fd46814eb67697c228e69447eb86163967efd9f7a81ae0e83acb8beff0183360bd7df448d30688c719f77853b71aaedc085bfed8cce29f7207ba4039a71135ae2f8219dc40d4eabb499dcb6d6f61204ee5ffb96d436161ba9d096e8802c6e395ee5ce3e6f78e4122cc218dc99a2409210f1d5c05822ae1c831339079c6aa02f651c38bb134b8032b7fd92f91398cf7ab7e8c22b15ad6b22bf9ebe7e66ad2d7b77eea104ffc2d39ec32e259af02eff35922a39596c61d5bd7b8b71f40d1422b5b4f14be5bb7c7096ffe8d6d452b5f60477fef5e2b5a03e9255cf619969d8cfdd63ddb3c932baffc2fbc1381cdda239ae4e5aff82b576a6e97c0781ddeab0aa98edc8af000b26b4efe1db9a4a2b56552e6da9149d5070787a40c8bb905fb8becfdfda45e0703ee01049cc6b8740b4c5fc744fe1af8b2f0714bd55b4f5e367da89c81d7dd0be8a0a2bbcb6f02c2353cccd1edb095a779deb9dc6684cb6560e26336466378022e7f0ad7a60bc3409c900246a9b7e1fbf9be9d0dd6553e734c8dcb191f28fc08f97bb74ce8f1959773ac02520c469647bde2ee2932012b3144df6efa2c8b39e93f4633614d7acb171365a477b9a382e9212fdf4ba0b1623dfa90946b95d2883d056fca851474d25ece1d57ed79554922423b999a2b51e7a69c9ad2dc4960e09a855cc8c3024d5e53b377ab7b6d3bb7db0908bb6e35ccd9cc275f2f03e650fef35c0462d1ab0cf676979713ccefb6097c5a3060a4738e1cb8a019e3be8385895f0d99beb98e1b1f23d050e1dc4917a430d1347bb34a36c9df18edf21ee3c9909f2ff9c9af1f515868f19a636a1da6a4b1fe8ba6fac3c8f862a09d79cb19450759151b14f56bbe536fe959b02191bd7555a61ce52ecc15279d6da54880f722f2b8250448a8da03211a1b8e2f27e22f0c505b62e390f2c2738848296d0c16af09c52edbc562b8387ce29c203f33ab9f925b26f99b545a86030915925a673abb39a6f9ef45f217b8588d29c97651f3de518504093f0565eb323f7d14750588d76ee742007cfa7fc10874d2df6e6673628b1ed333b3a866ee5c3bc0f52cc2702ec2bd2dba2f9925504156810baf67e4fade741be666be69f17cd35e1147c070c49f109fae3395edfe72e3a1d8b465c744f3ea754d68a55766e65fc3c21ef6523aa70d992b20e3d6a40d09a6bf3d6f4008fb4120755a8e870cca9a1e575695814b4a727fc13edaba7e6d1f41e81fbdf9bc8e0eb9449d08ed33ae5d1a9a2ac67f4c43e49feda9b56894b15c8c80d6e6510c7d14f30a33c07e5384ccdb6b2ccd14088e2c7ad37d61697b406f7c304726b66ebd35d1f7f2619ce7852105391cdac66c71f267f1fe1ef61f234e89ed060f25405dd523c2a2ef7df0b27c452edc4f69b299f2fcd777af8241d093fd398000178851956ff8e990f462b4c99de5f306e0c0ed43f6fefb643d38f0ca6223a5ce046b8e93f65c2fe8c5530ca52eef1a403f76505ee0c5de6ca70ca1b3693ac9d0aafc0bc5b846cb34926e2e3250f39526e4d2451822b1303cac37a003f5e3fecbda3e886e705f6d385b9bdf7c1247b517b683931f5d6d259a53d1a76a2f2bed58427c4eedaca5fdf6c062a9fed2b6b9ae70ad32b7f07d5d5cd55b05cfc782d1d21441403260ee92b1c94b73422f6b4f907d7c418b1b41ddcfd7aa6cf9b0bd140b65cee53c8ff2f2e327ca4affe9f471358bd3ee74773c03aec09a73b7236448210fd38846e4957b70c69565dd706194f0fd4096f02f477d11ca341715c310f316ad1662b316f84cff1f108d16fa4d45b4045491e1798af49fa92a9bc48b816f3a70838d5b3d24bcc539295ef12b543b8875bed6f7b523ccbb036578f35196eafeaa48eb622ca999f1dbc1421ebed31fb4b5af4889cf201451a68655a01afa18490f2f91a78da67a947b5ea29beb29578be32d8e75c99cc517571f59fa18f5a2eae16759f1cc893c2f8cfa631cef4600af5a46d63bab5fd7d75ddbb93635d6f0358da764eb667d9ca0db8c003da930c01c86b26b66173913894db0a9b91bed6fa0b8203fe7adeb3409fe62aa54be2cfd5a309547223470817b14837f440ec64eeec0fa415931e3290935e7de318c69f7eb9dec3b3c585dc5b1baf88f955da938089ce4a090f5addfc23435ab1a13dd80554ff85b39e968ad514595d03104d0b59dfd033f330d5a626d7cc41459ee6699427a79dabb74a33c99ef0d9bbcab63c2198bbf03265875a4fc860e1a35352a6f515e59d65959c91c5ae38e9ab6fcd0a425f3b4864aa7ff6f2a0c3a42b88db7f38f484806d50362417b1c8783cf2fb66ac1dd03176d7b44e76fa0b048a3b5400d24c5353da3738fd37038fd5fc8472fcc5e1f3f5ae48380b61c84649f78a6cf44daad11c6216872fd0772a07fe300d63011a3d3882e0e98d67250c92248e34ebf4c1807700eeedcfc52d2657076ee55dbc4d880a3c84b059575372497115030994d04e629032f59dd88934a24c0a28608f29785aeb30e67fce22c77d3cdbf70ca265439d3307b164f198af5b83f9ba9fe3bb46ea374fcea7928df544746295095bd4cbe44d20c2c9a247734460fab8a0858cfb2c5abd7aa97b621f81e080383c7e44668dbed1342d0fd35bfb0ef7659fcf6ccb74c2e1bd64711db6e7486cc40b506b0eb1cb86d7e80f89b0327333e64aa393402f8dc2b1d09a961574dd41e6d1fc8a8c28a598ec6e80572d7e27caeaff5daf3d8954786794f784f03fe6665e3b4d07ebc817f8e65aad07daad71563f36a27ecff202cebb3e8cb1bfbae5241cee1023edfc41b54b48d9d55ad07c6835c5cfcaec776fa528eb622e0b9081e59ee8664eebd8c69ab01cef2fdb7cf7779e21f966a1967dd87ace4675df929a3e72b4da8c575c9e74820cbf2ec1822c7ba421e1c3e76159204c5e42a7e34c146f851c3381e57d53d1d5e7cc7f82aab9dac447a764c604b51083e62c2bf3acc3ee83214086895f4074639ce5b869cd5601f6b09e7c84fedc26475b6ebc896858b854880c81c68371d38ca95953bcf523b2ddb0c8f8d8044aaa03b840cc2d465f7bf14890240af825ac346317a7c33a452718eecaaba545c7794980851e76a5731727f7b2f79fd676e7cf760f797b350db7ed107d0eeb2648b3aede6fe4a9bf1ec67e7f70065803d268e0a97b6e553f966c5542971d1ce791f79553f8dbff837e66b12a431c71dd69a439531fb18f98e03e64a016e2cb06cb2e7836308948430c9fa27e4e61b02e51001ed0c6334567ebc73656fb8d907b7e8f28d7db5f07bee3f9fef5b5b84b19a35cc3c9944aaa79fee3d83bc74c2b3f180ce225c16d941ad70fe8269ea474fa073459cdf13197bd6d548df18a1a4c74605e2d7c365e79c6478ac19aa28ab2eaf7a63919a1e378b593000faf1c5d720cfc7d020df876eeefa50f2f25c111c69847222abe88c0d97f486b171288a3fc465f3a2da78ffb608380518ac3fe0639b2fbcefd98e0d3bdc062416909f7d2e5df227ce3675e50ec11c8a04e31e79b1551533df54714e336d62ad8e28bf31c71b4103817f206c39d42ce9832636de10f68ca4b8528f37010550654accc7720879823381108f16135d22612882e46cf6b8ab5cb455a728bda0d67666765dba861d215b8e72b44887b01af61a48b792836c0e36a1696830ff43138914b116fcf9fef630e044a2d5ae80aefc6ecb620e01fedb685ebd6e14b317f496e08745610d5956ead074511590021da9f9f073e719f2b42211149cbd2d9c361a5dc2fef65bac8569ad8155e0294a36bdd25d1ca21c012ed943f54323bdf18f0671cc037b05ebaba03437212ea36312b7a0b817ef5097d7095dc99047c96355a91a15ed9174090f2f225f98fa7e461709224cf855ee580057389c528790104d33b958d7e39fa1a883600013c43fe76e88b0e15a6ac58611f97c42b360f6d2865cf4cca40d989ccb40ae1f89fecd7ecf2b26a48a70e961ce7140fdaa6a41c3d71e22a39b99ad1ce4dc711c6c8bdcfb9e2a59fcc86b6e993a3eca569984c04082d50dcc5c1798a4a1fbf2d8ec3caa2e00eeaa32f34d628a2fb3cad6713a79cf85744001b4247b5986f55e8ce2eaaa42e3fceb0992aaef0d5674ab848159017c4a84b10b7eed55e6c93f4f1c58385b566d589a762df73645d2f03dc8e843e5d4babfb0d7cd461b5daa1729376b49b39a1d1c604918b64610bb4210a2cbb85c704c3119c90fae823af45555e7a8a7e799482599871698bf6d39b9a4cf9dbf5461a3bc9730687612af3733bd48d28397f072294bdf6fe5b052febfddeafba43724fe6fe09bcc710e9c4cd9cfeaaf36d425ca309daff9275d83e643c1e5d24154a06b00883dfdb2d84180100f7b9f0f889902fcc8c6c06865b286fb15379468f04d8aef078c38b8f4f643021407b3a52759e4356e9ce4e2e5c973a6664ca36e5d95444002568722da281bd653c0fe1e9786a48ee778df0849ea1d5c53663ded1df4e76581620aa65773becd40087257c24ad707a5bbd08030c5064f8117b6c6e32ec96ee96b61596955b49de1622cc12397c468f75b1026eab29fa5cb25ef5b6f6177607837c5228d6ba2392c7900d59d5ca860780aeb6eeb4ac7044a0eff0875fac44d6f028931875043673b79cdf074f1b25c181c0a78b24611eb9f0899eab34a4fd1434845e324731229d4eab16eb3648bd17e10d9423568864ac9f9f431b2c69bf6836775f0a612cdc11cab3fc8f62d2384cef968e0fa93bb12d2c0a41af370f6f7e9d037fa182843c7207fef4db75e247cb761ff9f68996c5f609c06f277a43db49eb111c7cd7ddcb4ba4990b7a03ae7e1bde991b4a7506121d08df6e8410d20610955d945a169cfd32dc9999e75ea02c7bc26bff79e31cea32044d9d8b67b8aa60faaff195ce5f2a74e88a0762281b96a69b0bdd94043a8aabd3abddcf7947706c42dceb1d74849edc24ae11aee578817712594057892b03caa97e9e9a992f416a15b61c68ec7fc97c56a057496b0c02f9a76e407c69887f3b192e305c1427cccb88d2edbff18064a5e294ceebbbbfea41eef2aeeab8c5c4bd81e9fb487e72299a9e6d3463bb4465914a6457b530a6892e27cea1b337f1c0dcf931e02f946f7a1f024f9779d5e2a1871a7cd5fc40b58a6827e98eef4409a4722d90208bb06cb04cc7191b01f993b41999087dd3077db8379805f0216884d8b6eb436f0223ede8e8ca0ead213638cea4b3177dbd1db6f64416dcee0234d4f375247a3d1e5149e057bc546e2567650efc5fe09ad47831d310356a7eb7045a54b71765b14dc6885650cb457e3d4272647f829b2bacc92b73cdb3d3f8e2e4f600c3719e56c75f19a1b772636c060f85e37ac8f678211d0375f5d26e5e329a61069deddd21f4d9220a1b20082b71fd3ae57dc4eba6df98563c569ccaa31bd3455657e65bf8d6fe845fc513da3436bd0abae75af8dccbce41152033774862f91e9576c7f3b0fc155a115827ca0bab29e11350684caf78a2397bf60bff63793557888fe2a504016fa80f8e1d395f2c92987a4d8c2e2da59baccc495f61e69473a754eed668cd7fc0e21737c4d81b2b4bfc16703e326f2b4bd32c93df199f53e9b0a593dbc6d59c640640dd5eda2aca9004190ad22638827f90f5c8656acebf0448cc12d14b5d18cb038b91fe5e45538ade827ecb0789f688783abd3a4e04312f1beb2fc55c1d04df3238db20a6ecc355b04a1c66b30ba53d87bc28de54d7f22d9699652fc8a220ab029e401dfe48aae7c7dad661624892616e7f1f740bafd3bebed554934ddf3ea64703df96ac9a3e54a5317d7e9a3287fd380bdac1c41db6421f6d1914bc4a57e7013d7d64c8b67b74e4a765b8ebd4f015b43bced8240f87528412d8180b49a16ad59e18b4850021a2c8c28ac3d420fc28be118f574fb0e59b0b6c7f224733b2caefe1f54e8615d91d5b7fbe0bf55ae28df527bde82b46b6b47d18a0cb96c627ec96144fc68ff03434d1a3040ee7c3931096c2bbb86e4d6a796a8acd0bbc99d261a3f41c1c947499064f8dd068a7806d792f2983b2dd1a025c2e4b745e474865dd83f97321b1f83739197223865858c27e00db131c4bd7e29bc824cb289c113b1a7cf51b4b9e3878b5d0ff4c175ea76213bc9300783b8fee43cc3a7f1f08b842adad561c90f944aa9fb147433de49bfb73376b0ef3ca31cdef97979cb93b35d7ac8b907172671390f54caaa20a3714a3adbf3d54fa0d0a3f98d2a34cf2a31462f21dff228639692d5508d6f7c38a2d08353399f54a6264b4e5db92fd84a8d8c545659f0fe5bc3e61958c937728e44aa00abc811b24cca0b48333492e0b16ca59408471de9de5ad0f21c3cd45dde33ef7295b7eb223e4285d08e8d2015bdce7c155192f41e906ccf1590d2ac0eafe267619f6112354cea3fa0c45b9db8c7ae2d47af53bf4888485ebc9034e1ce3023d2314964e8cd3ec82c2bff5104fbec95d22cb63fb13f285d84cbde084faefa5a4d2f220c9b97f30fd1402d03b41f006655cfffcec05fa03e6d8a24d0ee1decf9ff2e825c9054a8aff624a4c971559fd17d79324a6c94d1f7c42c3d8fe8d170e9502e0a7e63b4f096067a5e722330cccedb2d930025eccfa9af5fc755b24300fd2ded5f05da046716bd9584ebb722f1f680fdb31c6a7195cac0a7d40b46c9b540324b842ab22c10e994620b6fdd1a6a70401cc8e183361ac7f73ada0e45b1b37b782b6409184fab2c6ad6f9bc9ce6bd3e105eaf9f3495f54d25c285bb41a765b854aebb861122be9e361fe4328857832410cc3b325f2458178a8ef87aa5300ba816ea9c867f6910818cea5e978dd89ea40f8156f0ddba35c1a4f0fc09a18ce18232a717fca1bed8734141f65183cc4e8d124b9f6684ea8024248395078c269ac2dc9addb489e5a5e96c07938c4610c61198c34827e3f343c2d5fae18b271b72c3763046d078f005a3d2d4a0b70fc02c77b4bf5c27d208db061993e2236c5c16f5d7f66d55108ec07b4adc0b881ad2d6c18ebd0f0d739bd73365eecb0ffb132b028f36e74ba05a85b25dbe858562dc47a2135dc2db04813e75a89338ea3b9ea4cb0b6150ded98ba3c3c39dccd73756f5c24f509104e2832c3d69f2688c3ce07a9b9aef1edbd827590f7aa4abaa13f558cda54fe8b5c15f807026615dd9707278d2bb3053f687d6b8b1c76fd11dd9f1b716166b7f6c4ccb9dfc54e92059c1c562dd5cf61dd1c6aa0e86d66e96ebc8c7f867e55f8e62b9bc02dba65c67014b21ad645cece2f553798f2e82db8f964b78baf1194fb76eabf52c3bcd2f55394428e31722d88b12c05ff905ab204b9cd4a65e2c2a9c49d34aeb48ecd746ad598e08f90578143d145a9a5bda6be08cb03eb8ea5e5d536a2f594f21e2d86102538101dbe6950ee10e7397093ffd2c7609df96e9bfe25f7735e92ad4f8912546a71fe90ac0e1eb9e0375cad4c5822a3e3e0f4b26ad70bd7c45fe99e5bdd24c847bb76d421eaae868d65b05a77a39e421aaeb7d09ad74dc7be71a9cce36a079bf7b82a87ae07e8f5972ffdc453ab8b7974a4e80bc13f6ff4bdbd8d8780105da1aca850f6bf51857010c56de9d43b20eb339b0bf543eded65d3a048e00fadad594b2e9f7bc96aa38dfdaddb76cd9a294f40f6a634c119e559be6128079454dcb3356a3c6628b8d17e8ef710db1f61fe65e5d75615eaeedffc71340afb77252f0a4425e5d602601964899c9593ca73fc034de1d82ec6cde12bb10b0f242742652e5c6d45bcd8b502cd2da8c4bf57cb0fee08f5e98e90f909605d41afdb4fd1742d5e725b44d6d30e3fc2f521b8579026ce4f89743a876cb4a8bc7278751e00328a5086136b357df853df0c145fa98e783178bee4c32a7099bad8d773ec6bc3868100bc1fe60cd66a1f0d90c1dce24e0041d135df3360c7f199ea396633cc3ec4f76d8672d7a824acc4a8b8f820fe855dcb5af67a0ce0dc86cef76a39b1fead7e69c865527c78dbef9f2cf895ad625f1a09cc65bf150035112d37928537fe93da900558d5467cc49113f2bbe4eaf68aaa4da658e956737dedf4ec024771e18fe353e09f8228eacc81db447c289efb850464d57dc9da3399d58e4576ec84d29eded61ed0816398836727435b5cdc6f96149f3930ca01000454c72924a69da5066419a4dbf43163e04908e9ffb0ff225fdeb3142853e8c5b916010ab846e3a0038f9c249cc7b1097f05ac039da6d832af7045d8634abdc6add48ed86c260acfc4fffd42aaf5d6aaea51cf3273e89e0264b540771d5a265c55c9e7e973bd935769b71a2356f73154affe95928610be6470cf8038d52329cf6a75ab845b0cb1e36db23bbb30e304f75549203ac2218c013d3bd7b0e011b545c302511e96b6be4f273ae1eb4dc2a128f55720ab2e8f53902ac20f385363fc049abd4b46a8376338750beae42cead571bf8b3a6839fc3d34c1ab173c106bce41fb217ae67662cacb0534ac44dbb71e54da2717becce5ddb937cb8c1a6aa511a7ba1143f414575e83f964f14bfe6ad11fde8acfdb1d514436a0eadc369b346dbbb616e7c2c1586181e6aa6e6714bf0fe1726e22fec3199f48dfd6089e144869f6137ab52b3f421befe8f82b31b7d8cf28332650ef05a0137ea73d01450278206e2363792b74419b6cbda996abf21779e7619cbbe7184dd1adb74ae83ca2d797251df6d17c100952a0668fabefecafe9ffab1d2ed2dd51e5eefaef6e2199dc69782a7fc8eef87e7463f4818a1beacd6b27ee493956478f34f05cc0534ed1dd04019822d17ae86717e11945b8f12a428c7456ad860dfd1ef62b5fe34a8b57e7f29022aad7d7e39333ea96b2b72705e4e2aaf11adec6167383b572c84842577fea983e979e9362eec8740b6741d4b532bdcebe2005047406b0aef459abea4a3e0606b0be8c26d2b14d12d05132d6dc089525f80da76bd731c5007b6f4e0f27e254ec6b204bb427da9358820568923a9d966c92ffa5754f3f40107c8929441366b23f7b8840913c53ae032e36da8714067a8515cfb57d04c25210fbb1d87be2062197a33b678d8a35b241503708cb4ba1ce3f330bcb253165877194179c0294e5de8e45e6f5e5964a8ba98f097db8a87b071b1b1f0fc7338078ceb63c644394dce135f2123ea3a566f53fc0fe32f16012e740ec6296e80ff204a47d01b580eefb53266bc2cd54894b34f75b1d118cd8b36146759d3cb669f6b562ff01fa37a2eb802534ad5e186c59f3233c3c7e5b76ee695e675483d804b11df15f0160256b5280a811da400dab3bf4b1bf797f636d303be56f37867c1dec0bcbd6cac444d6708d68f77287ad580a6d848c84693542fae8793153258c40c8e1f799ed41f54859014493d7b89bfaef46b2d9ea302f6b92cd629cb4d1049b4dfb87c167a6340e2d63f4470a99962ca6f1273a900366adc06d9175ee1d1da4ee52f99ddc25945dc13af6ef69094c61f7aacd9ab6cbc133c546a2d15b46ff7d27b935d87af0c029a5d2e3c241e6fb31e046fa7ffc7ed424788274ed6e729b37351588faf4f4b9192ff9ec81c1f28dd38c5f5a32afe94789260be5562d81f9deb7a2477d01e9f540c03f73261d04e0bf7716ed43b15ba9fc0ae61adefd216c93866a637c396f32e8e9a39f7d1287b810128f1c5b90a5541f8b36a9644797a62e8172ed676161a3539dd8dd122bb82ddcfeed0f436db0fcf9898017de4611d9a983ac1cee073178fbcc18fb271bc7c163d69b3cccff19c0c9c7ad9d7dc22e9d89bd2ef9144f5ad94a16651fdcd02db91c3797fb4d1391aceda68dcc87534e404dc67f534cb9240947307b87aca1ec0379cd9aa6234bf65e494c0ee64b666b30cc830a271cda4f58f8ab9a11b009d9b45b53ab05465bf8ab4a84e523360131e4a013616e737ccd9b59f5db9e7d14f8131b7f09a5edf1644e9deaf5827d82adfb44f37859af9579105080067c10b2bc4c9e558e5b7a9915cb82e467797c7c5bba6d3259d51646d0c2b77a4802ab4e5a49242ef72f1ca71e6d68c0cffe67578780d4b57c8f3f04159b55819dd0fcd4a3fad324307551f4904799edebe5049664f398559dccb2e4598098532a6739c3ea8bf72f39d0aefc5869f6c078051d18a00ec5956d3e2343f5aa3543c3adb225228ce5fdb3b2482be29b696fec39000342e1502831e11621828da00f705ab71b2a734429e779ab633be91857c4e337deb1a8450e6d9ce6eea010a2f04d225e0a63018531bfb5815a3412a9772161dbc59055e6f112cbdfeaa835c1a697339fa1b2cad809dfd3c6c19b91b84e3e7bb6cf7608f084283d3a43e0a714a14b4f6ebfe2cef978df775ac9174bf0630ec4391c8897af34b39d430d2973ea16fa73b5f6c4dbd886b5fadae998addc6153e113457aac75b52fd2b1a6cf64d0ff4b4eca4f1b8b7ba76e33e050038de09f618329be7200208637af76eedccaa2d6cbb00aa97106fef96f1dedc8d6062773236362c11b05130d64c5040dd11dbd89850b654e3a78bd3f5b8e55d09b4253859d4e833efaf3bfba73ae1e92698246ebb1ce28efa2a15f4f28754f1b8e3c027c2f54f640c7c5dbece2d295c8224739ee2eaffe611c6b10e61ec28feecaef0bb4832c9efcc3d88b2c465bb6c743d4a7bac66a9e350e8deb31eeed1f6f64165fa73892291f627a4c68f8776e9e51739da770b214630504f38d6606fbea840ce671524c5732ed8716e2c30737722b6804d84a761bf8d2a59c718591eb6cf3438bba960be18ae7aac94d2c25f5f6705c85d6f02a4b20bc4da91d6bfbbdc7841784c8e3a2bef4fed6f76379802de3e014ee138b6e1f8189ca1ca5aaa097baba060cd1db020bc295f5037c770cdf72adb1cca6ef4592eb01edc472fe21b5a48b9bf3834b6ed3353a440c4640315bc89fc780bd395f923e1f6fc8fcbc4a22ca2599b1558075944e67f304cf05951faea3eeeeb45315cd36e9be27a3f8d502b527a91202a35f657a7c7e5f72349ed3383117b05cd279308d6e852b021180ba4c323fb755896df082f25d4c17b9ed984a676152268201faa72cff744bce038c9a020261d0d3a57f68847c77ba01ebfedf6bd7aae52cbfbad95968b67e6f6f5c3d18516aaf6724862d40f4d1d3c6aebf9e86d4aefc7545129570ad283651acca6032d0e26e0778bd2b5ebe2d5d8b32161d8358c998367cfa4077b117aef6e9874fc3a69c19b832164a4efc937fd0f2b58e31bb4fd1390e596660</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Dydは、パスワードを入力するように求められます</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">拆贡献 + 卡常</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="数据结构" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="dcoj" scheme="https://dyd-true.github.io/tags/dcoj/"/>
    
    <category term="树状数组" scheme="https://dyd-true.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
</feed>
