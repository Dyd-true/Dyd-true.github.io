<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dyd&#39;s Blog</title>
  
  <subtitle>He who has a strong enough why can bear almost any how.</subtitle>
  <link href="https://dyd-true.github.io/atom.xml" rel="self"/>
  
  <link href="https://dyd-true.github.io/"/>
  <updated>2022-02-13T13:56:12.111Z</updated>
  <id>https://dyd-true.github.io/</id>
  
  <author>
    <name>Dyd</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>函数的极限</title>
    <link href="https://dyd-true.github.io/2022/02/12/%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%81%E9%99%90/"/>
    <id>https://dyd-true.github.io/2022/02/12/%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%81%E9%99%90/</id>
    <published>2022-02-12T13:03:14.000Z</published>
    <updated>2022-02-13T13:56:12.111Z</updated>
    
    <content type="html"><![CDATA[<p> 突然感觉数列的极限有用了（<del>用来“证明略”</del>）</p><span id="more"></span><h1 id="函数的极限"><a href="#函数的极限" class="headerlink" title="函数的极限"></a>函数的极限</h1><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>类似于数列的极限</p><h2 id="邻域"><a href="#邻域" class="headerlink" title="邻域"></a>邻域</h2><p>对于实数 $a, \delta$ ：</p><p>定义数集 $\{x \in R \mid a - \delta &lt; x &lt; a + \delta\}$ 为 $a$ 以 $\delta$ 为半径的<strong>邻域</strong>，记做 $U(a, \delta)$ </p><p>定义数集 $\{x \in R \mid a - \delta &lt; x &lt; a 或 a &lt; x &lt; a + \delta\}$ 为 $a$ 以 $\delta$ 为半径的<strong>去心邻域</strong>，记做 $\mathring{U}(a, \delta)$ </p><p> 定义数集 $\{x \in R \mid a - \delta &lt; x &lt; a\}$ 为 $a$ 以 $\delta$ 为半径的<strong>去心左邻域</strong>，记做 $\mathring{U} _- (a, \delta)$ </p><p> 定义数集 $\{x \in R \mid a &lt; x &lt; a + \delta\}$ 为 $a$ 以 $\delta$ 为半径的<strong>去心右邻域</strong>，记做 $\mathring{U} _+ (a, \delta)$ </p><h2 id="函数的极限-1"><a href="#函数的极限-1" class="headerlink" title="函数的极限"></a>函数的极限</h2><p>对于一个<strong>连续</strong>函数 $f(x)$ ，若 $\exists a \in R, s.t. \forall \epsilon &gt; 0, \exists M, s.t. \forall x &gt; M , \mid f(x) - a \mid &lt; \epsilon$ ，我们就称 $a$ 为<strong>函数 $f(x)$ 的极限</strong>，记作 $\lim \limits _{x \to + \infty} f(x) = a$ ，也可简记为 $f(x) \to a(x \to + \infty)$ </p><p>注意到函数 $x$ 可负，故对于一个<strong>连续</strong>函数 $f(x)$ ，若 $\exists a \in R, s.t. \forall \epsilon &gt; 0, \exists M, s.t. \forall x &lt; M , \mid f(x) - a \mid &lt; \epsilon$ ，我们也称 $a$ 为<strong>函数 $f(x)$ 的极限</strong>，记作 $\lim \limits _{x \to - \infty} f(x) = a$ </p><p>如果 $a$ 两个都满足，可记作 $\lim \limits _{x \to \infty} f(x) = a$ </p><p>对于一个<strong>连续</strong>函数 $f(x)$ ，若它在 $\mathring{U}(x _0, M)$ 上有定义，且 $\exists a \in R, s.t. \forall \epsilon &gt; 0, \exists \delta, s.t. \forall x \in \mathring{U}(x _0, \delta), \mid f(x) - a \mid &lt; \epsilon$ ，我们就称 $a$ 为<strong>函数 $f(x)$ 的点极限</strong>，记作 $\lim \limits _{x \to x _0} f(x) = a$ </p><p>对于一个<strong>连续</strong>函数 $f(x)$ ，若它在 $\mathring{U} _- (x _0, M)$ 上有定义，且 $\exists a \in R, s.t. \forall \epsilon &gt; 0, \exists \delta, s.t. \forall x \in \mathring{U} _- (x _0, \delta), \mid f(x) - a \mid &lt; \epsilon$ ，我们就称 $a$ 为<strong>函数 $f(x)$ 的左极限</strong>，记作 $\lim \limits _{x \to {x _0}^-} f(x) = a$ </p><p>对于一个<strong>连续</strong>函数 $f(x)$ ，若它在 $\mathring{U} _+ (x _0, M)$ 上有定义，且 $\exists a \in R, s.t. \forall \epsilon &gt; 0, \exists \delta, s.t. \forall x \in \mathring{U} _+ (x _0, \delta), \mid f(x) - a \mid &lt; \epsilon$ ，我们就称 $a$ 为<strong>函数 $f(x)$ 的右极限</strong>，记作 $\lim \limits _{x \to {x _0}^+} f(x) = a$ </p><p>函数的左极限和右极限统称为<strong>单侧极限</strong></p><p>明显， $\lim \limits _{x \to {x _0}^+} f(x) = a$ 且 $\lim \limits _{x \to {x _0}^-} f(x) = a$ 与 $\lim \limits _{x \to x _0} f(x) = a$ 互为充要条件</p><h2 id="连续函数"><a href="#连续函数" class="headerlink" title="连续函数"></a>连续函数</h2><p>以下认为自变量都在定义域内</p><p>若 $\lim \limits _{x \to x _0} f(x) = f(x _0)$ 我们就称 <strong>$f(x)$ 在点 $x$ 处连续</strong></p><p>若 $\forall x_0 \in (l, r)$ ，$f(x)$ 在 $x _0$ 处都连续，我们就称 $f(x)$ <strong>在区间 $(l, r)$ 连续</strong></p><h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><h2 id="唯一性"><a href="#唯一性" class="headerlink" title="唯一性"></a>唯一性</h2><p>若 $f(x) \to a(x \to r)$ 且 $f(x) \to b (x \to r)$ ，则 $a = b$ </p><p>证明类似数列极限，这里略</p><h2 id="局部有界"><a href="#局部有界" class="headerlink" title="局部有界"></a>局部有界</h2><p>若 $f(x) \to a(x \to x _0)$ 则 $\exists \delta &gt; 0, M &gt; 0, s.t. \forall x \in \mathring{U}(x_0, \delta), \mid f(x) \mid \le M$  </p><p>点连续/区间连续同样有局部有界性</p><p>证明略</p><h2 id="局部保号"><a href="#局部保号" class="headerlink" title="局部保号"></a>局部保号</h2><p>若 $f(x) \to a(x \to x _0)$  且 $a &lt; a’$ 则 $\exists \delta &gt; 0, s.t. \forall x \in \mathring{U}(x_0, \delta), f(x) &lt; a’$  </p><p>点连续/区间连续同样有局部保号性</p><p>证明略</p><h2 id="迫敛性"><a href="#迫敛性" class="headerlink" title="迫敛性"></a>迫敛性</h2><p>若 $f(x) \to a(x \to x_0)$ ， $g(x) \to a (x \to x_0)$ ，且有 $\exists \delta &gt; 0, s.t. \forall x \in \mathring{U}(x_0, \delta), f(x) \le h(x) \le g(x)$ 则 $h(x) \to a(x \to x_0)$ </p><p>点连续/区间连续同样有迫敛性，即</p><p>若 $f(x), g(x)$ 在点 $x _0$ 处连续，且有 $f(x_0) = g(x _0)$ ， $f(x) \le h(x) \le g(x)$ ，则 $h(x)$ 在 $x_0$ 处连续 </p><p>证明略</p><h2 id="局部保不等式"><a href="#局部保不等式" class="headerlink" title="局部保不等式"></a>局部保不等式</h2><p>若 $f(x) \to a(x \to x_0)$ ， $g(x) \to b (x \to x_0)$ ，且有 $\exists \delta &gt; 0, s.t. \forall x \in \mathring{U}(x_0, \delta), f(x) &lt;  g(x)$ 则 $a &lt; b$  </p><p>点连续/区间连续同样有局部不等式性</p><p>证明：</p><p>反设 $a &gt; b$ ，则有 $a &gt; \frac{a + b}{2} &gt; b$ </p><p>由局部保号， $\forall x \in \mathring{U}(x_0, \delta_1), f(x) &gt; \frac{a + b}{2}$ ，  $\forall x \in \mathring{U}(x_0, \delta_2), g(x) &lt; \frac{a + b}{2}$ </p><p>故 $\forall x \in \mathring{U}(x_0, \delta_1) \land \mathring{U}(x_0, \delta_2), f(x) &gt; \frac{a + b}{2} &gt; g(x)$ 与题设矛盾</p><p>QED</p><h2 id="极限的四则运算"><a href="#极限的四则运算" class="headerlink" title="极限的四则运算"></a>极限的四则运算</h2><p>设下面的取值都落在定义域内：</p><p>若 $f(x) \to a(x \to x_0)$ ， $g(x) \to b (x \to x_0)$ ，且 $h(x) = f(x) \odot g(x)$ （  $\odot$ 代表 $+, - , \times, \div$ ，若为 $\div$ 则保证 $g(x) \ne 0$ ） ，则 $h(x) \to a \odot b (x \to x_0)$ </p><p>点连续/区间连续同理</p><p>证明太长且类似于数列，就略了</p><h2 id="归结定理（海涅定理）"><a href="#归结定理（海涅定理）" class="headerlink" title="归结定理（海涅定理）"></a>归结定理（海涅定理）</h2><p> $f(x) \to a(x \to x_0)$ 的充要条件是：对于任意的数列 $\{x _n\} _{n = 1}^{+ \infty}$ ，满足 $x _n \to x _0$ 有数列 $\{f(x _n)\} _{n = 1}^{+ \infty}$ 的极限为 $a$ </p><p>证明较繁琐，这里略</p><h2 id="区间有界"><a href="#区间有界" class="headerlink" title="区间有界"></a>区间有界</h2><p>若 $f(x)$ 在 $[l, r]$ 连续，则 $f(x)$ 在 $[l, r]$ 上有界</p>]]></content>
    
    
    <summary type="html">&lt;p&gt; 突然感觉数列的极限有用了（&lt;del&gt;用来“证明略”&lt;/del&gt;）&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数论,数学" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
    <category term="其它" scheme="https://dyd-true.github.io/tags/%E5%85%B6%E5%AE%83/"/>
    
    <category term="笔记" scheme="https://dyd-true.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>优化dp3</title>
    <link href="https://dyd-true.github.io/2022/02/12/%E4%BC%98%E5%8C%96dp3/"/>
    <id>https://dyd-true.github.io/2022/02/12/%E4%BC%98%E5%8C%96dp3/</id>
    <published>2022-02-12T08:25:42.000Z</published>
    <updated>2022-02-14T13:27:49.046Z</updated>
    
    <content type="html"><![CDATA[<p> 然而我 dp 废的一比（四大皆空）</p><span id="more"></span><h1 id="优化dp3"><a href="#优化dp3" class="headerlink" title="优化dp3"></a>优化dp3</h1><p>书接上回：<a href="https://dyd-true.github.io/2022/02/09/%E4%BC%98%E5%8C%96dp2/#more">优化dp2</a></p><h1 id="四边形不等式优化"><a href="#四边形不等式优化" class="headerlink" title="四边形不等式优化"></a>四边形不等式优化</h1><p>以下未特殊说明，就认为 $w(x, y)$ 是定义在整数集合上的二元函数，下面的 $\ge, &gt;$ 是对于 $\min$ 形转移来说的，如果 dp 方程要求的是 $\max$ ，则应该反过来（但其实你定义函数时取个负也行）</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>对于任意的 $a \le b \le c \le d$ ，若有 $w(a, d) + w(b, c) \ge w(a, c) + w(b, d)$ ，则称 $w(x, y)$ 满足<strong>四边形不等式</strong>（蒟蒻个人的记忆方法为“两边加中间大于错位相加”）</p><p>对于任意的 $l \le l’ \le r’ \le r$ ，若有 $w(l, r) \ge w(l’, r’)$ ，就称 $w(x, y)$ 满足<strong>区间包含单调性</strong>（蒟蒻个人的记忆方法为“大区间大于小区间”）</p><h3 id="判定定理"><a href="#判定定理" class="headerlink" title="判定定理"></a>判定定理</h3><p>这里有一个定理（或者说是四边形不等式的另外一个形式）：</p><p>$w(x, y)$ 满足四边形不等式的充要条件是：对于任意的 $a &lt; b$ （注意这里不取等），有 $w(a, b + 1) + w(a + 1, b) \ge w(a, b) + w(a + 1, b + 1)$ （蒟蒻个人的记忆方法为“分开加大于同进退”）</p><p>必要性显然，下面证明充分性：</p><p>对于 $a &lt; c$ 有 $w(a, c + 1) + w(a + 1, c) \ge w(a, c) + w(a + 1, c + 1)$ </p><p>对于 $a + 1 &lt; c$ 有 $w(a + 1, c + 1) + w(a + 2, c) \ge w(a + 1, c) + w(a + 2, c + 1)$ </p><p>两式相加，得 $w(a, c + 1) + w(a + 2, c) \ge w(a, c) + w(a + 2, c + 1)$ </p><p>以此类推，对于任意的 $a \le b \le c$ 有 $w(a, c + 1) + w(b, c) \ge w(a, c) + w(b , c + 1)$ </p><p>同理，对于任意的 $a \le b \le c \le d$ 有 $w(a, d) + w(b, c) \ge w(a, c) + w(b, d)$ </p><p>QED</p><h2 id="1D-1D-的四边形不等式优化"><a href="#1D-1D-的四边形不等式优化" class="headerlink" title="1D/1D 的四边形不等式优化"></a>1D/1D 的四边形不等式优化</h2><p>还是来看 1D/1D 型 dp 方程：<br>$$<br>d[i] = \min_{l(i) \le j \le r(i)} (d[j] + val(i, j))<br>$$<br>我们记 $bp[i]$ （ best pos ）表示 $d[i]$ 的最优决策点，即使 $d[i]$ 取得最小的 $j$ 的值，若 $bp$ 单调（不要求严格）且 $l(i), r(i)$ 也单调，则称 $d$ 具有<strong>决策单调性</strong></p><h3 id="1D-决策单调性定理"><a href="#1D-决策单调性定理" class="headerlink" title="1D 决策单调性定理"></a>1D 决策单调性定理</h3><p>对于 1D/1D 型 dp 方程： $d[i] = \min_{l(i) \le j \le r(i)} (d[j] + val(i, j))$ ，若 $val(i, j)$ 满足四边形不等式，且 $r(i) \le i$ ，则 $d$ 具有决策单调性</p><p>证明：<br>$$<br>\begin{aligned}<br>&amp; \forall i \in [1, n], \forall j \in [l(i), bp[i] - 1]由 bp[i] 的最优性可得: \\<br>&amp; d[bp[i]] + val(i, bp[i]) \le d[j] + val(i, j) &amp; (1) \\<br>&amp; \forall k \in [i + 1, n], 由四边形不等式得: \\<br>&amp; val(k, j) + val(i, bp[i]) \ge val(i, j) + val(k, bp[i]) \\<br>&amp; val(k, bp[i]) - val(i, bp[i]) \le val(k, j) - val(i, j) &amp; (2) \\<br>(1) + (2) 得: \\<br>&amp; d[bp[i]] + val(k, bp[i]) \le d[j] + val(k, j)<br>\end{aligned}<br>$$<br>也就是说， $\forall k &gt; i$ ，以 $bp[i]$ 做为决策一定比以 $j &lt; bp[i]$ 作为决策优（或者相等），所以 $k$ 的最优决策不可能小于 $bp[i]$ ，即 $bp[k] \ge bp[i]$ ，则 $bp$ 单调递增，故 $d$ 具有决策单调性（但这里一定要有 $l(i), r(i)$ 也单调，否则可能出现 $bp[i]$ 不能做 $k$ 的决策，但 $j$ 可以的情况）</p><p>QED</p><p>所以，四边形不等式优化 1D/1D dp 的方法其实就是推出决策单调性，然后用单调性维护（这里有一个蒟蒻专用技巧，那就是直接猜它有单调性，这样就可以直接做了 <del>蒟蒻的挣扎</del> ，不行还可以先打个暴力 dp 然后把最优决策输出来看看有没有单调性）当 $d$ 具有决策单调性时，我们可以把 $O(n^2)$ 的 1D/1D dp 优化到 $O(n \log n)$ （这里未考虑计算 $val$ 的时间）</p><h3 id="队列-二分"><a href="#队列-二分" class="headerlink" title="队列 + 二分"></a>队列 + 二分</h3><p>一般可以用<strong>队列 + 二分</strong>：</p><p>考虑对于 $bp$ 进行维护，我们每次直接修改 $bp$ 数组是很低效的，我们维护若干个三元组 $(j, l, r)$ ，表示“在 $i \in [l, r]$ 时， $j$ 是最优决策，即 $bp[l \sim r] = j$ ”然后用队列维护，对于每个 $i$ ，进行如下操作：</p><ul><li>检查队头三元组 $(j _0, l _0, r _0)$ ，若 $r _0 &lt; i$ 删除队头，否则令 $l_0 = i$ </li><li>取队头的 $j$ 为最优决策进行转移</li><li>尝试插入决策 $i$ ，初始化 $pos = r_t + 1$ ，其中 $r_t$ 为队尾三元组执行如下步骤：<ol><li>取出队尾，记为 $(j _t, l _t, r _t)$ </li><li>若对于 $d[l _t]$ 决策 $i$ 优于 $j$ ，删除队尾，记 $pos = l _t$ ，回到第 $1$ 步</li><li>否则，若对于 $d[r _t]$ ， $j$ 优于 $i$ ，去向第 $5$ 步</li><li>否则，在 $[l _t, r _t]$ 上二分一个位置 $pos$ ，把 $r _t$ 赋为 $pos - 1$ ，去第 $5$ 步</li><li>把三元组 $(i, pos, n)$ 插入队尾</li></ol></li></ul><p>不难发现每个 $i$ 最多出/如队一次， $\log n$ 消耗在二分上</p><h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><p>有一种特殊情况，如果 dp 方程是与 $d[j]$ 无关的，即：<br>$$<br>d[i] = \min_{l(i) \le j \le r(i)} (val(i, j))<br>$$<br>其中 $val(i, j)$ 不含有关 $d[j]$ 的项，那么我们可以用分治</p><p>要注意，这里的“无关于 $d[j]$ ”指的是“无关于本层的 $d[j]$ ”，如果 dp 状态还有几维，而在把外层变量当常量后，前几层的 $d[j]$ 已经计算完毕，也是常量，就可以用了（关于为什么，可以看下面）</p><p>设函数 <code>sol(l, r, L, R)</code> 表示“当然正在处理 $d[l \sim r]$ ，最优决策存在于区间 $[L, R]$ ”，函数伪代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sol(l, r, L, R)</span><br><span class="line">if (l &gt; r || L &gt; R) return </span><br><span class="line">mid &lt;- l + r &gt;&gt; 1</span><br><span class="line">for i : L -&gt; R</span><br><span class="line">找到最优决策点 pos </span><br><span class="line">end for</span><br><span class="line">用 pos 跟新 d[mid]</span><br><span class="line">sol(l, mid - 1, L, pos)</span><br><span class="line">sol(mid + 1, r, pos, R)</span><br><span class="line">end sol</span><br></pre></td></tr></table></figure><p>很明显（<del>分治好打的多</del>）共会递归 $\log n$ 层，每层一共会扫一个 $n$ ，总共是 $O(n \log n)$ </p><p>现在我们来看为什么要保证方程无关于本层的 $d[j]$ ，其实这很明显，我们是跟新完 $d[mid]$ 再去求 $d[l \sim mid - 1]$ 和 $d[mid + 1 \sim r]$ 的，所以我们跟新 $d[mid]$ 时，本层其它的 $d$ 根本还没算，怎么能用呢？</p><p>由此可以看出，队列 + 二分的方法泛用性更广，但考虑到分治的过程中可以同时计算一些信息（如 $val$ 或者题目中的其它问题）有些题用分治会更好</p><h2 id="例题九"><a href="#例题九" class="headerlink" title="例题九"></a>例题九</h2><p><a href="https://www.luogu.com.cn/problem/P1912">诗人小G</a></p><p>老经典题了</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先记 $len[i]$ 为第 $i$ 句诗的长度， $sum[i]$ 为 $len[i]$ 的前缀和，设 $d[i]$ 表示“前 $i$ 句诗的最小不协调度”，有：<br>$$<br>d[i] = \min _{0 \le j &lt; i} (d[j] + (\mid sum[i] - sum[j] + i - j - 1 - L \mid)^P)<br>$$<br>其中 $i - j - 1$ 是空格的个数</p><p>典型的 1D/1D ，为简单记 $f(i) = sum[i] + i$ ，有 $val(i, j) = (\mid f(i) - f(j) - (1 + L) \mid)^P$ 很明显由于次数过高，无法斜率优化，考虑四边形不等式</p><p>用判定定理， $\forall a &lt; b$ ，我们要证明 $val(a, b + 1) + val(a + 1, b) \ge val(a, b) + val(a + 1, b + 1)$ </p><p>变形：<br>$$<br>\begin{aligned}<br>val(a, b + 1) + val(a + 1, b) &amp; \ge val(a, b) + val(a + 1, b + 1) \\<br>(\mid f(a) - f(b + 1) - (1 + L) \mid)^P + (\mid f(a + 1) - f(b) - (1 + L) \mid)^P &amp; \ge (\mid f(a) - f(b) - (1 + L) \mid)^P + (\mid f(a + 1) - f(b + 1) - (1 + L) \mid)^P \\<br>因为 f(x + 1) &amp; = f(x) + len[x + 1] + 1 \\<br>故化为: \\<br>(\mid f(a) - f(b + 1) - (1 + L) \mid)^P + (\mid f(a) - f(b) - (1 + L) + len[a + 1] + 1 \mid)^P &amp; \ge (\mid f(a) - f(b) - (1 + L) \mid)^P + (\mid f(a) - f(b + 1) - (1 + L) + len[a + 1] + 1 \mid)^P \\<br>记 u = f(a) - f(b) - (1 + L), v = f(a) - f(b + 1) &amp;- (1 + L) , t = len[a + 1] + 1\\<br>明显有 v = u - len[b + 1] - 1 &amp; &lt; u \\<br>于是原式化为: \\<br>(\mid v \mid)^P + (\mid u + t\mid)^P &amp; \ge (\mid u \mid)^P + (\mid v + t \mid)^P \\<br>(\mid v \mid)^P - (\mid v + t \mid)^P &amp; \ge (\mid u \mid)^P - (\mid u + t\mid)^P \\<br>\end{aligned}<br>$$<br>那么，我们只要证明函数 $g(x) = (\mid x \mid)^P - (\mid x + c \mid)^P$ （其中 $P, c$ 是常数）为减函数，则四边形不等式得证</p><p>而证明减函数只要分类讨论去掉绝对值，然后求导就可以了（分类讨论太长，这里就不打了）</p><p>无论如何，我们证得原函数满足四边形不等式，可得决策单调性</p><p>至于维护，本题方程中用到了本层的其它 $d$ （<del>废话，一共只有一层啊</del>），所以<strong>不能分治</strong>，我们<strong>采用队列 + 二分</strong></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>细节颇多，输出格式尤其要注意（行末没有空格！）</p><p>另外中间转移时会炸 <code>long long</code> 开 <code>__int128</code> 也不行，只能开 <code>long double</code> </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LD long double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, S = <span class="number">35</span>;</span><br><span class="line"><span class="keyword">const</span> LD INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">int</span> n, L, P, sum[N], h, t, from[N];</span><br><span class="line"><span class="keyword">char</span> s[N][S];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Date</span>&#123;</span> <span class="keyword">int</span> bp, l, r; &#125; q[N];</span><br><span class="line">LD d[N];</span><br><span class="line"><span class="function">LD <span class="title">qpow</span><span class="params">(LD x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LD res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; x *= x, y &gt;&gt;= <span class="number">1</span>) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res *= x;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LD <span class="title">calc</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123; <span class="keyword">return</span> d[j] + <span class="built_in">qpow</span>(<span class="built_in">abs</span>(sum[i] - sum[j] + i - j - <span class="number">1</span> - L), P); &#125; <span class="comment">//dp方程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l != <span class="number">1</span>) <span class="built_in">print</span>(from[l - <span class="number">1</span>] + <span class="number">1</span>, l - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, s[i] + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s[r] + <span class="number">1</span>); <span class="comment">//行末不空格</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T); T--; <span class="built_in">puts</span>(<span class="string">&quot;--------------------&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;L, &amp;P);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s[i] + <span class="number">1</span>), sum[i] = <span class="built_in">strlen</span>(s[i] + <span class="number">1</span>) + sum[i - <span class="number">1</span>];</span><br><span class="line">        q[h = t = <span class="number">1</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, n&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, pos; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (; h &lt;= t &amp;&amp; q[h].r &lt; i; ++h);</span><br><span class="line">            d[i] = <span class="built_in">calc</span>(i, q[h].bp), from[i] = q[h].bp;</span><br><span class="line">            <span class="keyword">for</span> (pos = n + <span class="number">1</span>; h &lt;= t &amp;&amp; <span class="built_in">calc</span>(q[t].l, i) &lt;= <span class="built_in">calc</span>(q[t].l, q[t].bp); pos = q[t--].l);</span><br><span class="line">            <span class="keyword">if</span> (h &lt;= t &amp;&amp; <span class="built_in">calc</span>(q[t].r, i) &lt;= <span class="built_in">calc</span>(q[t].r, q[t].bp))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> l = q[t].l, r = q[t].r, mid;</span><br><span class="line">                <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">                &#123;</span><br><span class="line">                    mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    <span class="built_in">calc</span>(mid, i) &lt;= <span class="built_in">calc</span>(mid, q[t].bp) ? r = (pos = mid) - <span class="number">1</span> : l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                q[t].r = pos - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pos &lt;= n) q[++t] = &#123;i, pos, n&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (d[n] &gt; INF) <span class="built_in">puts</span>(<span class="string">&quot;Too hard to arrange&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%.0Lf\n&quot;</span>, d[n]), <span class="built_in">print</span>(from[n] + <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题十"><a href="#例题十" class="headerlink" title="例题十"></a>例题十</h2><p><a href="https://codeforces.com/contest/321/problem/E">Ciel and Gondolas</a></p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有 $n \le 10^5$ 个数（记为 $a_i$ ），要将它们划分成连续的 $k \le 20$ 段，每段的代价是该段中相同元素的对数，求所有子段的费用之和的最小值</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>明显的区间 dp ，先写方程，设 <code>d[i, j]</code> 表示“前 $i$ 个数分成 $j$ 段的最小代价”，明显，设 $val(l, r)$ 表示“ $[l, r]$ 中相同的数的对数”，有：<br>$$<br>d[i, j] = \min _{0 \le k &lt; i} (d[k, j - 1] + val(k + 1, i))<br>$$<br>如果直接 dp ，时间明显是 $O(n^2 k * O(计算val(k + 1, i)))$ </p><p>呃呃，先把 $O(计算val(k + 1, i))$ 放一下，因为在如何 dp 不确定的情况下，我们也不太好考虑如何计算 $val$ （当然，暴力计算挂的死死的）</p><p>明显 $j$ 做外层循环，这就又是个 1D/1D ，我们连如何算 $val$ 都不知道，当然没法斜率优化，考虑四边形不等式</p><p>我们要证明，对于任意的 $i &lt; j$ ，有 $val(i, j + 1) + val(i + 1, j) \ge val(i, j) + val(i + 1, j + 1)$ </p><p>设区间 $[i + 1, j]$ 中有 $x$ 个数与 $a_i$ 相同，有 $y$ 个数与 $a_{j + 1}$ 相同</p><p>我们要证：<br>$$<br>(x + y + [a_i == a_{j + 1}] + val(i + 1, j)) + val(i + 1, j) \ge (x + val(i + 1, j)) + (y + val(i + 1, j))<br>$$<br>（其中 $[…]$ 表示“当 $…$ 成立时为 $1$ ”）</p><p>而上式正确性显然，故 $val$ 满足四边形不等式，决策具有单调性，理论上来讲，我们可以把 dp 的时间从 $O(n^2 k)$ 优化到 $O(n k \log n)$ ，观察数据范围，我们希望 $O(计算val(k + 1, i))$ 要做到 $O(1)$ </p><p>预处的想法是不行的，因为 $n \le 10^5$ 太大了存不下，所以我们只能每次直接求，但每次扫区间很明显是挂了的，我们考虑用上次的 $val$ 计算这次的 $val$ ，发现“统计区间内”是莫队的经典问题，考虑像莫队一样维护双指针，但莫队的时间复杂度有保证是因为调整了询问的顺序，所以我们也想到调整 dp 顺序</p><p>观察方程，不难发现，  $d[i, j]$ 与 $d[k, j]$ 无关（只由 $d[k, j - 1]$ 转移），于是<strong>可以用分治</strong>的方法，而选择分治的好处在于<strong>分治的计算顺序恰好可以保证莫队的时间复杂度</strong>，简证如下：</p><p>首先，对于分治的每一层单独来看（就不考虑进入下一层的情况，直接把本层的连起来，类似 <code>sort</code> 的分析方法），会发现两个指针在每一层一定<strong>最多扫过每个元素各一遍</strong>（因为在每一层，两个指针都是单调的），有 $\log n$ 层，故层内指针总共移动 $O(n \log n)$ 次</p><p>再考虑进入下一层/从下一层返回的额外移动，设 $(l, r, L, R)$ 表示当前计算区间为 $d[l \sim r]$ ，最优决策存在于区间 $[L, R]$ ，设最优决策为 $pos$ ，设 $mid = l + r &gt;&gt; 1$ ，设双指针为 $il, ir$ 在这个区间计算完成后，一定有 $il = pos + 1, ir = mid$ （ $il$ 要加一，原因自己去看方程），而下一层 $(l, mid - 1, L, pos)$ 开始时会把指针移动到 $il = L + 1, ir = (l + mid - 1) &gt;&gt; 1$ ，两个指针移动的距离都小于等于当前区间长度 $r - l + 1$ ，从左区间回来时先把两个指针移回（显然耗时与移去相同），再进入右区间 $(mid + 1, r, pos, R)$ ，开始时会把指针移动到 $il = pos, ir = (mid + 1 + r) &gt;&gt; 1$  两个指针移动的距离也都小于等于当前区间长度 $r - l + 1$ ，故对于当前区间，进入下一层/从下一层返回的额外移动是 $O(r - l + 1)$ 级的；每层区间的长度加起来等于 $n$ ，故每层进入下一层/从下一层返回的额外移动是 $O(n)$ 级的，而一共有 $\log n$ 层，故额外的移动总时间也是 $O(n \log n)$ 的</p><p>本题就体现了分治的优势，在题目转移顺序<strong>允许分治</strong>的情况下，分治的计算顺序为我们计算额外信息提供便利，且代码也好打</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>明显 $j$ 可以滚动压掉</p><p>注意转移时用的是 $val(k + 1, i)$ ，而决策点是 $k$ ，所以注意 $0 \le k &lt; i$ </p><p>关于 $0$ ，要注意 <code>d[0][0] = 0</code> ，而其它 <code>d[i][0] = INF</code> （明显把 $i$ 个人分成 $0$ 段方案不存在）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], n, k, o;</span><br><span class="line">LL d[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">namespace</span> MD <span class="comment">//莫队</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt[N], il = <span class="number">1</span>, ir = <span class="number">0</span>;</span><br><span class="line">    LL val;</span><br><span class="line">    <span class="function">LL <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> <span class="comment">//把指针移动到[l, r]</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; il &lt; l; val -= --cnt[a[il++]]);</span><br><span class="line">        <span class="keyword">for</span> (; il &gt; l; val += cnt[a[--il]]++);</span><br><span class="line">        <span class="keyword">for</span> (; ir &lt; r; val += cnt[a[++ir]]++);</span><br><span class="line">        <span class="keyword">for</span> (; ir &gt; r; val -= --cnt[a[ir--]]);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sol</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r || L &gt; R) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>, pos = L;</span><br><span class="line">    LL t;</span><br><span class="line">    d[mid][o ^ <span class="number">1</span>] = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L, Rr = <span class="built_in">min</span>(R, mid - <span class="number">1</span>); i &lt;= Rr; ++i)</span><br><span class="line">        <span class="keyword">if</span> ((t = d[i][o] + MD::<span class="built_in">calc</span>(i + <span class="number">1</span>, mid)) &lt; d[mid][o ^ <span class="number">1</span>]) d[mid][o ^ <span class="number">1</span>] = t, pos = i;</span><br><span class="line">    <span class="built_in">sol</span>(l, mid - <span class="number">1</span>, L, pos), <span class="built_in">sol</span>(mid + <span class="number">1</span>, r, pos, R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]), d[i][<span class="number">0</span>] = d[i][<span class="number">1</span>] = INF;</span><br><span class="line">    d[<span class="number">0</span>][o] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i, o ^= <span class="number">1</span>) <span class="built_in">sol</span>(<span class="number">1</span>, n, <span class="number">0</span>, n - <span class="number">1</span>); <span class="comment">//这里减1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, d[n][o]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2D-1D-的四边形不等式优化"><a href="#2D-1D-的四边形不等式优化" class="headerlink" title="2D/1D 的四边形不等式优化"></a>2D/1D 的四边形不等式优化</h2><p>如果只是优化 1D/1D dp，四边形不等式显然不是很强，所以我们来看看更高维的 dp </p><p> 2D/1D dp 的方程模型如下：<br>$$<br>d[i, j] = \min_{l(i, j) \le k \le r(k, j)} (d[i, k] + d[k + 1, j] + val(i, j))<br>$$<br>其中 2D 指枚举的状态数， 1D 指枚举的决策数，最典型的是区间 dp ，明显，直接 dp 时间为 $O(n^3)$ （一定要注意 $val(i, j)$ 与 $k$ 无关）</p><p><strong>警告！下面的证明都很繁琐且没啥用（完全不影响做题），可以只记结论</strong></p><h3 id="2D-状态四边形不等式判定"><a href="#2D-状态四边形不等式判定" class="headerlink" title="2D 状态四边形不等式判定"></a>2D 状态四边形不等式判定</h3><p>对于 2D/1D dp 的方程：<br>$$<br>d[i, j] = \min_{l(i, j) \le k \le r(k, j)} (d[i, k] + d[k + 1, j] + val(i, j))<br>$$<br>若 $val$ 满足<strong>四边形不等式</strong>和<strong>区间包含单调性</strong>（忘了的回去翻定义）， $d$ 满足 $d[i, i] =  val(i, i) = 0$ ，且 $i \le l(i, j) \le r(i, j) &lt; j$ 则 $d[i, j]$ 满足四边形不等式</p><p>证明（又臭又长）：</p><p>当 $j = i + 1$ 时， $d[i, j + 1] + d[i + 1, j] = d[i, i + 2] + d[i + 1, i + 1]$ ，又因为 $d[i + 1, i + 1] = 0$ ，故 $d[i, j + 1] + d[i + 1, j] = d[i, i + 2]$ </p><p>由于 $i \le l(i, j) \le r(i, j) &lt; j$ ， $d[i, i + 2]$ 的决策最多只有 $i$ 和 $i + 1$ </p><ol><li><p>若 $d[i, i + 2]$ 的最优决策为 $i + 1$ ，则<br>$$<br>d[i, i + 2] = d[i, i + 1] + d[i + 2, i + 2] + val(i, i + 2) = d[i, i + 1] + val(i, i + 2)<br>$$<br> ，发现 $d[i, i + 1]$ 的决策只有 $i$ ，故 $d[i, i + 1] = d[i, i] + d[i + 1, i + 1] + val(i, i + 1) = val(i, i + 1)$ ，综合两式，有 $d[i, i + 2] = val(i, i + 1) + val(i, i + 2) = d[i, j + 1] + d[i + 1, j]$  </p><p>同样因为 $d[i, i] = 0$ ，有 $d[i, i + 1] + d[i + 1, i + 2] = val(i, i + 2) + val(i + 1, i + 2) = d[i, j] + d[i + 1, j + 1]$ </p><p>由于 $val$ 满足四边形不等式，有 $val(i, i + 1) + val(i, i + 2) \ge val(i, i + 1) + val(i + 1, i + 2)$ </p><p>故 $d[i, j + 1] + d[i + 1, j] \ge d[i, j] + d[i + 1, j + 1]$ ，即 $d$ 满足四边形不等式</p></li><li><p>若 $d[i, i + 2]$ 的最优决策为 $i$  ，同理有<br>$$<br>d[i, i + 2] = d[i, i] + d[i + 1, i + 2] + val(i, i + 2) = d[i + 1, i + 2] + val(i, i + 2) = val(i + 1, i + 2) + val(i, i + 2)<br>$$<br>$d[i + 1, i + 2] + d[i, i + 1] = val(i + 1, i + 2) + val(i, i + 1) = d[i + 1, j + 1] + d[i, j]$ </p><p>同样由 $val$ 满足四边形不等式，得 $d[i, j + 1] + d[i + 1, j] \ge d[i, j] + d[i + 1, j + 1]$ </p></li></ol><p>综上，当 $j = i + 1$ ，即 $j - i = 1$ 时， $d$ 满足四边形不等式</p><p>假设当 $j - i &lt; k$ 时四边形不等式成立，下面证明 $j - i = k$ 时成立</p><p>设 $d[i, j + 1]$ 最优决策为 $x$ ， $d[i + 1, j]$ 最优决策为 $y$  </p><p>有等式 $(1)$ ：<br>$$<br>d[i, j + 1] + d[i + 1, j] = d[i, x] + d[x + 1, j + 1] + val(i, j + 1) + d[i + 1, y] + d[y + 1, j] + val(i + 1, j)<br>$$<br>而对于 $d[i, j]$ 和 $d[i + 1, j + 1]$ ，  $x, y$ 就不一定是最优决策了</p><p>当 $x \le y$ 时，取 $x$ 为 $d[i, j]$ 的决策， $y$ 为 $d[i + 1, j + 1]$ 的决策，由不优得不等式 $(2)$ ：<br>$$<br>d[i, x] + d[x + 1, j] + val(i, j) + d[i + 1, y] + d[y + 1, j + 1] + val(i + 1, j + 1) \ge d[i, j] + d[i + 1, j + 1]<br>$$<br> $(1) + (2)$ 得 $(3)$ ：<br>$$<br>\begin{aligned}<br>d[i, x] + d[x + 1, j] + val(i, j) + d[i + 1, y] + d[y + 1, j + 1] + val(i + 1, j + 1) + d[i, j + 1] + d[i + 1, j] &amp; \ge d[i, j] + d[i + 1, j + 1] + d[i, x] + d[x + 1, j + 1] + val(i, j + 1) + d[i + 1, y] + d[y + 1, j] + val(i + 1, j) \\<br>d[x + 1, j] + d[i + 1, y] + d[y + 1, j + 1] + d[i, j + 1] + d[i + 1, j] + val(i, j) + val(i + 1, j + 1) &amp; \ge d[i, j] + d[i + 1, j + 1] + d[x + 1, j + 1] + d[y + 1, j] + val(i, j + 1) + val(i + 1, j) \\<br>\end{aligned}<br>$$<br>有 $x + 1 \le y + 1 \le j &lt; j + 1$ ，由归纳假设，有 $d[x + 1, j + 1] + d[y + 1, j] \ge d[x + 1, j] + d[y + 1, j + 1]$ ，结合 $val$ 满足四边形不等式，与 $(3)$ 比较得：<br>$$<br>d[i, j + 1] + d[i + 1, j] \ge d[i, j] + d[i + 1, j + 1]<br>$$<br>则 $j - i = k$ 时满足四边形不等式；</p><p>当 $x \ge y$ 时，取 $y$ 为 $d[i, j]$ 的决策， $x$ 为 $d[i + 1, j + 1]$ 的决策，同理可证得 $j - i = k$ 时满足四边形不等式</p><p>由数学归纳法原理，原命题得证</p><p>QED</p><h3 id="2D-决策单调性定理"><a href="#2D-决策单调性定理" class="headerlink" title="2D 决策单调性定理"></a>2D 决策单调性定理</h3><p>对于 2D/1D dp 的方程：<br>$$<br>d[i, j] = \min_{l(i, j) \le k \le r(k, j)} (d[i, k] + d[k + 1, j] + val(i, j))<br>$$<br>记 $d[i, j]$ 的最优决策点为 $bp[i, j]$ ，若 $\forall i &lt; j$ 有 $bp[i, j - 1] \le bp[i, j] \le bp[i + 1, j]$ ，则称 $d$ 具有决策单调性</p><p>若 $d$ 满足 $d[i, i] =  val(i, i) = 0$ ， $i \le l(i, j) \le r(i, j) &lt; j$ ，且 $d$ 满足四边形不等式，则 $d$ 具有决策单调性</p><p>证明：</p><p>记 $p = bp[i, j]$ ，则 $\forall i &lt; k \le p$ ，因为 $d$ 满足四边形不等式，有：<br>$$<br>\begin{aligned}<br>d[i, p] + d[i + 1, k] &amp; \ge d[i, k] + d[i + 1, p] \\<br>d[i + 1, k] - d[i + 1, p] &amp; \ge d[i, k] - d[i, p] \\<br>\end{aligned}<br>$$<br>又由 $p$ 的最优性（带 dp 方程消去 $val$ 可得）：<br>$$<br>\begin{aligned}<br>d[i, k] + d[k + 1, j] &amp; \ge d[i, p] + d[p + 1, j] \\<br>d[i, k] - d[i, p] + d[k + 1, j] - d[p + 1, j] &amp; \ge 0 \\<br>\end{aligned}<br>$$<br>考虑对于 $d[i + 1, j]$ 用 $k$ 为决策减用 $p$ 为决策：<br>$$<br>\begin{aligned}<br>&amp; (d[i + 1, k] + d[k + 1, j] + val(i + 1, j)) - (d[i + 1, p] + d[p + 1, j] + val(i + 1, j)) \\<br>= &amp; (d[i + 1, k] - d[i + 1, p]) + (d[k + 1, j] - d[p + 1, j]) \\<br>\ge &amp; (d[i, k] - d[i, p]) + (d[k + 1, j] - d[p + 1, j]) \\<br>\ge &amp; 0<br>\end{aligned}<br>$$<br>也就是说，对于 $d[i + 1, j]$ ， $p$ 比任意 $k \le p$ 更优，故 $bp[i + 1, j] \ge bp[i, j]$ ，同理可证明 $bp[i, j - 1] \le bp[i, j]$ </p><p>QED</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p> 2D/1D 的实现没有 1D/1D 那么花里胡哨，就是直接记录 $bp$ ，对于 $d[i, j]$ ，只在 $bp[i, j - 1] \le k \le bp[i + 1, j]$ 的范围枚举 $k$ 维护 $d, bp$ </p><p>时间也很好分析：<br>$$<br>\begin{aligned}<br>&amp; \sum _{i = 1}^{n - 1} \sum <em>{j = i + 1}^{n} (bp[i + 1, j] - bp[i, j - 1] + 1) \\<br>= &amp; \sum</em>{i = 1} ^ {n - 1} (bp[i + 1, n] - bp[1, n - i] + n - i) \\<br>\le &amp; n^2<br>\end{aligned}<br>$$<br>故时间复杂度优化到了 $O(n^2)$ </p><p>你可能觉得似乎没有 1D/1D 优化的厉害，但其实， 1D/1D 状态数是 $O(n)$ 的，四边形不等式把转移从 $O(n)$ 优化到了 $O(\log n)$ （斜率优化在最简单的情况下可以优化到 $O(1)$ ，最麻烦情况下只有 $O(\log^2 n)$ ）；而 2D/1D 状态数是 $O(n^2)$ 的，四边形不等式把转移从 $O(n)$ 直接优化到 $O(1)$ ，作为<strong>对转移的优化</strong>，已经非常优秀了（事实上，如果你不考虑重新设计状态/排除无用状态， $O(n^2)$ 已经是最好复杂度了）</p><p>最后提醒一点：以上的复杂度分析都没有考虑计算 $val$ 的复杂度！（这一点从例题十中也能看出）</p><h2 id="例题十一"><a href="#例题十一" class="headerlink" title="例题十一"></a>例题十一</h2><p><a href="https://www.acwing.com/problem/content/307/">一个古老的石头游戏</a></p><p>题意同“石子合并”，但要求 $O(n^2)$ ，太经典了，就是板子</p><p>话说好像有 $O(n \log n)$ 做法，但那和我们要讲的没关系了……</p><p>艹，好像数据加强了， $O(n^2)$ 过不了了！ shit ！</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>呃呃，还要思路吗？</p><p>写个方程吧：设 $d[i, j]$ 表示“合并区间 $[i, j]$ 的最小代价”，转移有：<br>$$<br>d[i, j] = \min _{i \le k &lt; j} (d[i, k] + d[k + 1, j]) + \sum _{t = i}^j a _t<br>$$<br> $val(i, j)$ 显然可以前缀和做到 $O(1)$ </p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5000</span> + <span class="number">5</span>, INF = <span class="number">1e9</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N], d[N][N], bp[N][N];</span><br><span class="line">LL sum[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n; sum[<span class="number">0</span>] = <span class="number">0</span>, <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, d[<span class="number">1</span>][n]))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]), sum[i] = sum[i - <span class="number">1</span>] + a[i], d[i][i] = <span class="number">0</span>, bp[i][i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; ++len)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j, k; i &lt;= n; ++i)</span><br><span class="line">                <span class="keyword">for</span> (d[i][j = i + len - <span class="number">1</span>] = INF, k = bp[i][j - <span class="number">1</span>]; k &lt;= bp[i + <span class="number">1</span>][j] &amp;&amp; k &lt; j; ++k)</span><br><span class="line">                    <span class="keyword">if</span> (d[i][k] + d[k + <span class="number">1</span>][j] + sum[j] - sum[i - <span class="number">1</span>] &lt; d[i][j]) d[i][j] = d[i][bp[i][j] = k] + d[k + <span class="number">1</span>][j] + sum[j] - sum[i - <span class="number">1</span>];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2D-1D-的另一种形式"><a href="#2D-1D-的另一种形式" class="headerlink" title="2D/1D 的另一种形式?"></a>2D/1D 的另一种形式?</h2><p>如下<br>$$<br>d[i, j] = \min (d[k, j - 1] + val(k + 1, i))<br>$$<br>你会发现其实就是例题十，优化方式也一样，但有些地方把它归类为 2D/1D 优化，可能是因为状态是 $O(n^2)$ 的，但这里还是决定把它归为 1D/1D ，因为外层的 $j$ 我们是当常量的，优化方式也更像（或者说就是） 1D/1D 型</p><h2 id="废话"><a href="#废话" class="headerlink" title="废话"></a>废话</h2><p>解决完四边形不等式，就还剩凸优化一个大点和其它一些小点了，慢慢搞吧</p>]]></content>
    
    
    <summary type="html">&lt;p&gt; 然而我 dp 废的一比（四大皆空）&lt;/p&gt;</summary>
    
    
    
    <category term="比较" scheme="https://dyd-true.github.io/categories/%E6%AF%94%E8%BE%83/"/>
    
    
    <category term="分治" scheme="https://dyd-true.github.io/tags/%E5%88%86%E6%B2%BB/"/>
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="二分" scheme="https://dyd-true.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
    <category term="笔记" scheme="https://dyd-true.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="四边形不等式" scheme="https://dyd-true.github.io/tags/%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>AtCoder AGC015 D</title>
    <link href="https://dyd-true.github.io/2022/02/12/AtCoder-AGC015-D/"/>
    <id>https://dyd-true.github.io/2022/02/12/AtCoder-AGC015-D/</id>
    <published>2022-02-12T05:49:31.000Z</published>
    <updated>2022-02-12T08:07:05.296Z</updated>
    
    <content type="html"><![CDATA[<p> 日本オリジナル輸入問題</p><span id="more"></span><p><a href="https://atcoder.jp/contests/AGC015/tasks/agc015_d">A or…or B Problem</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定 $L, R \le 2^{60}$ ，求在区间 $[L, R]$ 中选若干个或起来有多少种取值</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先 <del>打个表</del> 通过充分的思考，我们可以发现<strong>其实选超过 $2$ 个数和选 $2$ 个数答案是一样的</strong>，简证 <del>口胡</del> 如下：</p><p>对于一种选法，假设我们选了数 $a_1, a_2, …, a_n$ ，且 $a_1 or a_2 or … or a_n = A$ ，我们找到<strong>二进制下最高的一个不全相同的位置</strong>，如图：</p><p><img src="https://s2.loli.net/2022/02/12/NAOJXZrtsoDVuyP.png" alt="高 to 低"></p><p>前面的高位（蓝色）每个 $a_i$ 都相同，后面的低位（橘色）我们不管，绿色框住的就是最高不同位</p><p>我们任取一个 $a_i$ 该位为 $1$ （如图中 $a_1$ ），再取一个 $a_j$ 该位为 $0$ （如图中 $a_2$ ），然后，我们把 $a_i$ 后面的低位（橘色）全赋为 $0$ ，记为 $a_i’$，赋完后 $a_i’$ 该位仍然为 $1$ ，则有 $a_j &lt; a_i’ \le a_i$ ，由于 $a_i, a_j \in [L, R]$ ，故 $a_i’ \in [L, R]$ ；类似的，我们把 $a_j$ 后面的低位（橘色）赋值为和 $A$ 相同（仅橘色部分相同），有 $a_j \le a_j’ &lt; a_i$ ，即 $a_j’ \in [L, R]$ ；最后，我们用 $a_i’ or a_j’ = A$ 来替代这 $n$ 个数</p><p>综上， 选超过 $2$ 个数和选 $2$ 个数答案是一样</p><p>然后考虑从 $[L, R]$ 中选一个或两个数有多少种取值，我们找到 $L, R$ 的二进制下最高的不同位，记为 $bit$ （很明显 $R$ 该位为 $1$ ），再取 $t$ 是前 $bit$ 位都和 $R$ 相同，后面全为 $0$ ，如图</p><p><img src="https://s2.loli.net/2022/02/12/EsG8VkPCoyeMz9n.png" alt="LR"></p><p>绿色是第 $bit$ 位，蓝色部分都相同， $L, R$ 的橙色部分不确定，但 $t$ 的橙色部分全为 $0$ ，显然 $L &lt; t \le R$ ，我们把区间 $[L, R]$ 分成 $[L, t)$ ， $[t, R]$ 两段分类讨论，最后取并集即可，不妨设我们选的数为 $x, y$ 且 $x &lt; y$ （若只选了一个，就设选的为 $x$ ）：</p><h3 id="1）-x-y-in-L-t"><a href="#1）-x-y-in-L-t" class="headerlink" title="1） $x, y \in [L, t)$"></a>1） $x, y \in [L, t)$</h3><p>此时 $x or y$ 一定属于 $[L, t)$ （或运算不会变小，且或后第 $bit$ 一定为 $0$ ），而且，注意到可以只选一个，所以一定可以取遍 $[L, t)$ </p><h3 id="2）-x-y-in-t-R"><a href="#2）-x-y-in-t-R" class="headerlink" title="2） $x, y \in [t, R]$"></a>2） $x, y \in [t, R]$</h3><p>你会发现这个问题就是原问题，只不过 $L$ 变成了 $t$ ，但 $t$ 比 $L$ 多一个关键性质：  $t$ 的 $bit$ 位以后都是 $0$ ，这意味着，若 $R$ 在 $bit$ 位以后最高的 $1$ 在第 $k$ 位，那么 $x or y$ 或者 $x$ 在 $bit$ 位以后最高的 $1$ 在最高也只能在第 $k$ 位，而 $k$ 位以后都可以为 $1$ ，因为区间 $[t, R]$ 是连续的，而 $t$ 的第 $k$ 位即以后都是 $0$ ，每次加 $1$ ，要变到 $R$ ，即第 $k$ 位为 $1$ ，则 $k$ 以下的位置一定是出现过为 $1$ 的情况的，于是，构造 $p$ 如下：</p><p><img src="https://s2.loli.net/2022/02/12/MNpsxZgXv5meQKz.png" alt="p"></p><p>蓝色高位都相同，绿色是第 $bit$ 位，紫色部分都为 $0$ ，红色部分都为 $1$ ，橙色部分任意， $R$ 未被框起来的是第 $k$ 位</p><p>于是 $x or y$ 就取值于 $[t, p]$ （ $x$ 取值为 $[t, R]$ 被包含了）</p><h3 id="3）-x-in-L-t-y-in-t-R"><a href="#3）-x-in-L-t-y-in-t-R" class="headerlink" title="3） $x \in [L, t), y \in [t, R]$"></a>3） $x \in [L, t), y \in [t, R]$</h3><p>此时一定是取了两个数的情况</p><p>下限很好求，就是 $L or t$ ，对于上限，由于前 $bit$ 位最大也只能和 $R$ 一样，而那么最大就是 $bit$ 位以后全为 $1$ ，构造也很简单，就是 $x = t - 1, y = t$ 即可，由于两个区间都是连续的，所以 $x or y \in [L or t, t or (t - 1)]$ </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>不难发现前两个情况可以连起来，记得特判区间长度只有 $1$ 的情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL l, r, t, ans;</span><br><span class="line">    <span class="keyword">int</span> bit;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; <span class="built_in"><span class="keyword">bool</span></span>(r &gt;&gt; i); ++i) <span class="keyword">if</span> (((l &gt;&gt; i) &amp; <span class="number">1</span>) != ((r &gt;&gt; i) &amp; <span class="number">1</span>)) bit = i;</span><br><span class="line">    t = (r &gt;&gt; bit) &lt;&lt; bit;</span><br><span class="line">    LL l1 = l, r1 = t, l2 = l | t, r2 = t | (t - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = bit - <span class="number">1</span>; ~i &amp;&amp; r1 == t; --i) <span class="keyword">if</span> ((r &gt;&gt; i) &amp; <span class="number">1</span>) r1 |= (<span class="number">1ll</span> &lt;&lt; (i + <span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">    ans = r1 &lt; l2 ? r1 - l1 + <span class="number">1</span> + r2 - l2 + <span class="number">1</span> : r2 - l1 + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 日本オリジナル輸入問題&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="数论,数学" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="找规律" scheme="https://dyd-true.github.io/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"/>
    
    <category term="AtCoder" scheme="https://dyd-true.github.io/tags/AtCoder/"/>
    
  </entry>
  
  <entry>
    <title>数列与极限</title>
    <link href="https://dyd-true.github.io/2022/02/10/%E6%95%B0%E5%88%97%E4%B8%8E%E6%9E%81%E9%99%90/"/>
    <id>https://dyd-true.github.io/2022/02/10/%E6%95%B0%E5%88%97%E4%B8%8E%E6%9E%81%E9%99%90/</id>
    <published>2022-02-10T06:53:03.000Z</published>
    <updated>2022-02-13T12:07:03.123Z</updated>
    
    <content type="html"><![CDATA[<p> 然而感觉并无卵用</p><span id="more"></span><h1 id="数列与极限"><a href="#数列与极限" class="headerlink" title="数列与极限"></a>数列与极限</h1><p>稍微学了一下数学，感觉数学过于严谨了</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>一些定义</p><h2 id="数列"><a href="#数列" class="headerlink" title="数列"></a>数列</h2><p>定义一种从自然数（有时候是正整数）到实数（有时候是其它域）的映射 $f : \mathbb{N} \to \mathbb{R}$ ，我们称它为一个<strong>数列</strong>，一般的，设 $a_n = f(n)$ ，则该数列可记为 $\{a_n\}_{n = 0}^{+ \infty}$ </p><p>定义一个数列 $f : \mathbb{N} \to \mathbb{R}$ 的<strong>子数列</strong>为一个数列 $g : L \to \mathbb{R}$ 满足 $L \subseteq  \mathbb{N} \wedge \forall n \in L , g(n) = f(n) \wedge \mid L \mid = + \infty$ </p><h2 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h2><p>对于一个数列 $\{a_n\}_{n = 1}^{+ \infty}$ ，若 $\exists a \in R, s.t. \forall \epsilon &gt; 0, \exists N &gt; 0 \wedge N \in \mathbb{N}^+, s.t. \forall n &gt; N , \mid a_n - a \mid &lt; \epsilon$ ，我们就称 $a$ 为数列的<strong>极限</strong>，记作 $\lim\limits _{n \to + \infty} a_n = a$ ，或者 $a_n \to a(n \to + \infty)$ ，有时候括号内的可以省略（上面的 $s.t$ 指 “使得”）</p><p>对于一个数列，如果它存在极限，我们就称这个数列<strong>收敛</strong>，否则就称其<strong>发散</strong></p><h2 id="柯西列"><a href="#柯西列" class="headerlink" title="柯西列"></a>柯西列</h2><p>对于数列 $\{a_n\} _{n = 1}^{+ \infty}$ ，若 $\forall \epsilon &gt; 0, \exists N &gt; 0, s.t. \forall n, m &gt; N, \mid a_n - a_m \mid &lt; \epsilon$ ，我们即称 $\{a_n\} _{n = 1}^{+ \infty}$ 为<strong>柯西列</strong></p><h2 id="界"><a href="#界" class="headerlink" title="界"></a>界</h2><p>对于一个<strong>数集</strong> $S$ ，若 $\exists M \in \mathbb{R}^+, s.t. \forall a_n \in S, \mid a_n \mid \le M$ ，我们就称 $S$ <strong>有界</strong>，其中 $M$  为<strong>上界</strong>， $-M$ 为<strong>下界</strong></p><p>对于一个有上界的数集 $S$ 我们成使得 $a_n \le M$ 的最小 $M$ 为 $S$ 的<strong>上确界</strong>，记作 $sup(S)$ ；类似的，对于一个有下界的数集 $S$ 我们成使得 $a_n \ge M$ 的最大 $M$ 为 $S$ 的<strong>下确界</strong>，记作 $inf(S)$ ，<strong>可以证明</strong>，一个非空有上下界数集必有上下确界（<strong>确界原理</strong>）</p><h2 id="无穷大量"><a href="#无穷大量" class="headerlink" title="无穷大量"></a>无穷大量</h2><p>对于一个数列 $\{a_n\} _{n = 1}^{+ \infty}$ ，若 $\forall M, \exists N &gt; 0, s.t. \forall n &gt; N, \mid a_n \mid &gt; M$ ，则称 $\{a_n\} _{n = 1}^{+ \infty}$ 为<strong>无穷大量</strong>（注意，这里可能向 $+ \infty$ 也可能向 $- \infty$ 也可能同时向二者）</p><h2 id="无穷小量"><a href="#无穷小量" class="headerlink" title="无穷小量"></a>无穷小量</h2><p>对于一个数列 $\{a_n\} _{n = 1}^{+ \infty}$ ，若 $\lim \limits _{n \to + \infty} a_n = 0$ ，则称 $\{a_n\} _{n = 1}^{+ \infty}$ 为<strong>无穷小量</strong></p><p>不难发现，若 $\{a_n\} _{n = 1}^{+ \infty}$ 为无穷小量，则 $\{\frac{1}{a_n}\} _{n = 1}^{+ \infty}$  为无穷大量，反之亦然</p><h2 id="级数"><a href="#级数" class="headerlink" title="级数"></a>级数</h2><p><strong>级数</strong>是指将数列的项依次用加号连接起来的函数，用 OIer 的话来说就是数列的前缀和，即对于数列 $\{s _n\} _{n = 1}^{+ \infty}$ ，有 $s _n = \sum _{i = 1}^n a _i$ </p><h2 id="数列的和"><a href="#数列的和" class="headerlink" title="数列的和"></a>数列的和</h2><p>对于数列 $\{a _n\} _{n = 1}^{+ \infty}$ ，它的和 $\sum _{n = 1}^{+ \infty} a _n$ 有意义，当且仅当它的级数数列  $\{s _n\} _{n = 1}^{+ \infty}$ 收敛</p><p>正确性显然</p><p>这里补充一个等比数列求和公式（设公比为 $q$ ）： $(1 - q)(1 + q + q^2 + … + q^n) = 1 - q^{n + 1}$ </p><h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><h2 id="收敛数列"><a href="#收敛数列" class="headerlink" title="收敛数列"></a>收敛数列</h2><h3 id="迫敛性（夹逼定理）"><a href="#迫敛性（夹逼定理）" class="headerlink" title="迫敛性（夹逼定理）"></a>迫敛性（夹逼定理）</h3><p>设 $a_n \le b_n \le c_n$ ，且 $\lim \limits _{n \to + \infty} a_n = \lim \limits _{n \to + \infty} c_n = t$ ，则 $\lim \limits _{n \to + \infty} b_n = t$ </p><p>证明：<br>$$<br>\begin{aligned}<br>有:<br>&amp; \mid a_n - t \mid &lt; \epsilon \\<br>即:<br>&amp; t - \epsilon &lt; a_n &lt; t + \epsilon \\<br>同理:<br>&amp; t - \epsilon &lt; c_n &lt; t + \epsilon \\<br>又因为:<br>&amp; a_n \le b_n \le c_n \\<br>得:<br>&amp; t - \epsilon &lt; b_n &lt; t + \epsilon \\<br>即:<br>&amp; \mid b_n - t \mid &lt; \epsilon \\<br>\end{aligned}<br>$$<br>QED</p><h3 id="有界性"><a href="#有界性" class="headerlink" title="有界性"></a>有界性</h3><p>收敛的数列一定有界</p><p>证明：</p><p>任取一个 $\epsilon &gt; 0$ ，一定存在 $N &gt; 0$ 使得 $\forall n &gt; N$ 有 $\mid a_n - a \mid &lt; \epsilon$ （收敛的定义），则 $\forall n &gt; N, \mid a_n \mid &lt; \mid a \mid + \epsilon$  ，又因为 $n \le N$ 的 $a_n$ 只有有限个，记它们的最大值为 $A = \max_{1 \le i \le N} (a_i)$ ，则对于任意 $n$ 有 $\mid a_n \mid \le \max(\mid A \mid, \mid a \mid + \epsilon)$ ，即 $\{a _n\} _{n = 1}^{+ \infty}$ 有界</p><p>QED</p><h3 id="单调有界定理"><a href="#单调有界定理" class="headerlink" title="单调有界定理"></a>单调有界定理</h3><p>若一个数列单调且有界，则这个数列收敛，且收敛到它的确界</p><p>注意只有“一个数列有界”是无法推得“这个数列收敛”的</p><h3 id="柯西收敛准则"><a href="#柯西收敛准则" class="headerlink" title="柯西收敛准则"></a>柯西收敛准则</h3><p>一个数列收敛的<strong>充要条件</strong>为这个数列是柯西列</p><p>必要性显然，充分性不好证明，其实，柯西收敛准则、单调有界定理和确界原理是互相等价的，它们也都等价于<strong>实数的完备性</strong></p><h2 id="极限-1"><a href="#极限-1" class="headerlink" title="极限"></a>极限</h2><h3 id="极限的唯一性"><a href="#极限的唯一性" class="headerlink" title="极限的唯一性"></a>极限的唯一性</h3><p>下面证明极限的唯一性，即：若 $a_n \to b, a_n \to c$ 则 $b = c$ </p><p>有：<br>$$<br>\begin{aligned}<br>\forall \epsilon &gt; 0, \exists N_b &gt; 0, s.t. \forall n &gt; N_b, \mid a_n - b \mid &lt; \epsilon \\<br>\forall \epsilon &gt; 0, \exists N_c &gt; 0, s.t. \forall n &gt; N_c, \mid a_n - c \mid &lt; \epsilon \\<br>\end{aligned}<br>$$<br> 记 $N = \max(N_b, N_c)$ 有：<br>$$<br>\forall n &gt; N, \mid a_n - c \mid + \mid a_n - b \mid &lt; 2 \epsilon<br>$$<br>由三角不等式 $\mid a \mid - \mid b \mid \le \mid a \pm b \mid \le \mid a \mid + \mid b \mid$ 得：<br>$$<br>\mid b - c \mid &lt; 2 \epsilon<br>$$<br>由于 $\epsilon$ 可以无限小，故有 $b = c$ </p><p>QED</p><h3 id="子数列的极限"><a href="#子数列的极限" class="headerlink" title="子数列的极限"></a>子数列的极限</h3><p>对于一个数列 $\{a _n\} _{n = 1}^{+ \infty}$ 的子数列  $\{a _{n _k}\} <em>{k = 1}^{+ \infty}$ ，若 $a_n \to a$ ，则 $a</em>{n_k} \to a$ </p><p>证明：</p><p>对于所有 $k$ ，有 $n_k \ge k$ ，又因为 $\forall \epsilon &gt; 0, \exists N &gt; 0, s.t. \forall n &gt; N, \mid a_n - b \mid &lt; \epsilon$</p><p>故 $\forall \epsilon &gt; 0$ ，取 $K = N$ ，有 $\forall k &gt; K, n_k \ge k &gt; K = N$ ，故 $\mid a_{n_k} - b \mid &lt; \epsilon$ ，即 $a_{n_k} \to a$ </p><p>QED</p><h3 id="极限的线性可加性"><a href="#极限的线性可加性" class="headerlink" title="极限的线性可加性"></a>极限的线性可加性</h3><p>设 $a_n \to a, b_m \to b$ ，则 $\lim \limits _{n \to + \infty} (\alpha a_n + \beta b_n) = \alpha a + \beta b$ </p><p>证明：<br>$$<br>\begin{aligned}<br>&amp; \mid \alpha a _n + \beta b _n  - (\alpha a + \beta b) \mid \\<br>\le &amp; \mid \alpha \mid \mid a _n - a \mid + \mid \beta \mid \mid b _n - b \mid \\<br>&amp; = \mid \alpha \mid \epsilon ‘ + \mid \beta \mid \epsilon ‘<br>\end{aligned}<br>$$</p><p>现在，对于任意的 $\epsilon &gt; 0$ ，一定可得 $\epsilon ‘ = \frac{\epsilon}{\mid \alpha \mid + \mid \beta \mid}$ ，它对应的 $N$ ，使得 $\forall n &gt; N$ ， $\mid \alpha a _n + \beta b _n  - (\alpha a + \beta b) \mid &lt; \epsilon$ </p><p>QED</p><h3 id="极限的可乘性"><a href="#极限的可乘性" class="headerlink" title="极限的可乘性"></a>极限的可乘性</h3><p>设 $a_n \to a, b_m \to b$ ，则 $\lim \limits _{n \to + \infty} (a_n b_n) = a b$ </p><p>证明：</p><p>因为 $a _n \to a, b _n \to b$ ，则 $\{b _n\} _{n = 1}^{+ \infty} $ 一定有界设 $\mid b _n \mid \le B$<br>$$<br>\begin{aligned}<br>&amp; \mid a _n b _n - a b \mid \\<br>= &amp; \mid a _n b _n - a b _n + a b _n - a b \mid \\<br>\le &amp; \mid a _n b _n - a b _n \mid + \mid a b _n - a b \mid \\<br>= &amp; \mid b _n \mid \mid a _n - a \mid + \mid a \mid \mid b _n - b \mid \\<br>\le &amp; B \epsilon + \mid a \mid \epsilon<br>\end{aligned}<br>$$<br>QED</p><h3 id="极限的可除性"><a href="#极限的可除性" class="headerlink" title="极限的可除性"></a>极限的可除性</h3><p>已知 $a_n \to a$ ，  $a_n \ne 0, a \ne 0$ ，则有 $\frac{1}{a _n} \to \frac{1}{a}$ </p><p>证明：</p><p> $\exists N _1 &gt; 0, s.t. \forall n &gt; N _1, \mid a _n - a \mid &lt; \frac{\mid a \mid}{2}$  </p><p>又因为 $\mid a \mid - \mid a _n \mid \le \mid a _n - a \mid$ </p><p> 故： $\mid a \mid - \mid a _n \mid &lt; \frac{\mid a \mid}{2}$ ，即 $\mid a _n \mid &gt;  \frac{\mid a \mid}{2}$ 又即 $\frac{1}{\mid a _n \mid} &lt; \frac{2}{\mid a \mid}$  </p><p> $\forall \epsilon  &gt; 0$ ， $\exists N _2 &gt; 0$ ，使 $\forall n &gt; N _2$ ，   $\mid a _n - a \mid &lt;  \frac{(\mid a \mid)^2 * \epsilon}{2}$ </p><p>取 $N = \max(N _1, N _2)$ ， $\forall n &gt; N$ ，有：<br>$$<br>\begin{aligned}<br>&amp; \mid \frac{1}{a _n} - \frac{1}{a} \mid \\<br>= &amp; \mid \frac{a - a _n}{a _n a} \mid \\<br>\le &amp; \frac{\mid a - a _n \mid}{\mid a _n \mid \mid a \mid} \\<br>= &amp; \frac{\mid a _n - a \mid}{\mid a _n \mid \mid a \mid} \\<br>\le &amp; \frac{2 (\mid a \mid)^2 * \epsilon}{2 \mid a \mid * \mid a \mid} \\<br>= &amp; \epsilon<br>\end{aligned}<br>$$<br>QED</p><h3 id="保号性"><a href="#保号性" class="headerlink" title="保号性"></a>保号性</h3><p>若 $a _n \to a, \forall a’ &lt; a, \exists N &gt; 0, s.t. \forall n &gt; N$ 有 $a ‘ &lt; a _n$  </p><p>证明：</p><p>$a - \epsilon &lt; a _n$ ，对于 $a’$ ，取一个使得 $a - \epsilon &gt; a’$ 即可</p><p>QED</p><h1 id="典例"><a href="#典例" class="headerlink" title="典例"></a>典例</h1><h2 id="T1：求证-lim-limits-n-to-infty-1-frac-1-n-n-存在"><a href="#T1：求证-lim-limits-n-to-infty-1-frac-1-n-n-存在" class="headerlink" title="T1：求证 $\lim \limits _{n \to + \infty} (1 + \frac{1}{n})^n$ 存在"></a>T1：求证 $\lim \limits _{n \to + \infty} (1 + \frac{1}{n})^n$ 存在</h2><p>首先证明 $\{(1 + \frac{1}{n})^n \} _{n = 1}^{+ \infty}$ 有上界：<br>$$<br>\begin{aligned}<br>(1 + \frac{1}{n})^n<br>&amp; = \sum _{k = 0}^n \binom{n}{k} (\frac{1}{n})^k \\<br>&amp; = 1 + n * \frac{1}{n} + \frac{n (n - 1)}{2!} * \frac{1}{n^2} + … + \frac{n (n - 1) (n - 2) … 1}{n!} * \frac{1}{n^n} \\<br>&amp; = 1 + 1 + \frac{1}{2!}(\frac{n - 1}{n}) + … + \frac{1}{n!}(\frac{(n - 1)(n - 2) … 1}{n^{n - 1}}) \\<br>&amp; = 1 + 1 + \frac{1}{2!}(\frac{n - 1}{n}) + … + \frac{1}{n!}(\frac{n - 1}{n} * \frac{n - 2}{n} * … * \frac{1}{n}) \\<br>\end{aligned}<br>$$<br>由于 $\frac{n - 1}{n}, \frac{n - 2}{n} … \frac{1}{n} &lt; 1$ ，我们有：<br>$$<br>\begin{aligned}<br>(1 + \frac{1}{n})^n<br>&amp; = 1 + 1 + \frac{1}{2!}(\frac{n - 1}{n}) + … + \frac{1}{n!}(\frac{(n - 1)(n - 2) … 1}{n^{n - 1}}) \\<br>&amp; &lt; 2 + \frac{1}{2!} + \frac{1}{3!} + … + \frac{1}{n!} \\<br>\end{aligned}<br>$$<br>又因为 $\frac{1}{2!} \le \frac{1}{2}, \frac{1}{3!} \le \frac{1}{2^2} … \frac{1}{n!} \le \frac{1}{2^{n - 1}}$ ，故：<br>$$<br>\begin{aligned}<br>(1 + \frac{1}{n})^n<br>&amp; &lt; 2 + \frac{1}{2!} + \frac{1}{3!} + … + \frac{1}{n!} \\<br>&amp; \le 2 + \frac{1}{2} + … + \frac{1}{2^{n - 1}} \\<br>&amp; = 3 - \frac{1}{2^{n - 1}} \\<br>&amp; &lt; 3<br>\end{aligned}<br>$$<br>综上， $\{(1 + \frac{1}{n})^n\} _{n = 1}^{+ \infty}$ 的上界存在</p><p>然后我们对 $n + 1$ 同上变换，有：<br>$$<br>\begin{aligned}<br>(1 + \frac{1}{n + 1})^{n + 1}<br>&amp; = 1 + 1 + \frac{1}{2!}(\frac{n}{n + 1}) + … + \frac{1}{n!}(\frac{n}{n + 1} * \frac{n - 1}{n + 1} * … * \frac{2}{n + 1}) +  \frac{1}{(n + 1)!}(\frac{n}{n + 1} * \frac{n - 1}{n + 1} * … * \frac{2}{n + 1} * \frac{1}{n + 1})\\<br>\end{aligned}<br>$$<br>不难发现， $n + 1$ 比 $n$ 多一项 $\frac{1}{(n + 1)!}(\frac{n}{n + 1} * \frac{n - 1}{n + 1} * … * \frac{2}{n + 1} * \frac{1}{n + 1}) &gt; 0$ 而其它项逐项对比，有 $\frac{n}{n + 1} \ge \frac{n - 1}{n}, \frac{n - 1}{n + 1} \ge \frac{n - 2}{n} … \frac{2}{n + 1} \ge \frac{1}{n}$ ，故有：<br>$$<br>(1 + \frac{1}{n + 1})^{n + 1} &gt; (1 + \frac{1}{n})^{n}<br>$$<br>因此， $\{(1 + \frac{1}{n})^n\} _{n = 1}^{+ \infty}$ 单调递增且存在下界 $ = (1 + \frac{1}{1})^1 = 2$ </p><p>由单调有界定理， $\{(1 + \frac{1}{n})^n\} _{n = 1}^{+ \infty}$ 收敛，则 $\lim \limits _{n \to + \infty} (1 + \frac{1}{n})^n$ </p><p>QED</p><p>其实 $\lim \limits _{n \to + \infty} (1 + \frac{1}{n})^n = e$ ，这就是自然常数的定义</p><h2 id="T2：求证-lim-limits-x-to-0-frac-sin-x-x-1"><a href="#T2：求证-lim-limits-x-to-0-frac-sin-x-x-1" class="headerlink" title="T2：求证 $\lim \limits _{x \to 0} \frac{\sin x}{x} = 1$"></a>T2：求证 $\lim \limits _{x \to 0} \frac{\sin x}{x} = 1$</h2><p> 首先，有 $\sin x &lt; x &lt; \tan x$ （由三角函数线可证），故 $1 &lt; \frac{x}{\sin x} &lt; \frac{1}{\cos x}$ ，即 $1 &gt; \frac{\sin x}{x} &gt; \cos x$ </p><p>又因为 $\lim \limits _{x \to 0} \cos x = 1$ ，由迫敛性可知 $\lim \limits _{x \to 0} \frac{\sin x}{x} = 1$ </p><p>QED</p><h2 id="T3：求-lim-limits-n-to-infty-sqrt-n-n"><a href="#T3：求-lim-limits-n-to-infty-sqrt-n-n" class="headerlink" title="T3：求 $\lim \limits _{n \to + \infty} \sqrt[n]{n}$"></a>T3：求 $\lim \limits _{n \to + \infty} \sqrt[n]{n}$</h2><p>解：</p><p>因为 $\sqrt[n]{n} \ge 1$ 设 $\sqrt[n]{n} = 1 + r_n, r _n \ge 0$ ，有：<br>$$<br>\begin{aligned}<br>n<br>&amp; = (1 + r _n)^n \\<br>&amp; = \sum _{k = 0}^n \binom{n}{k} r _n^k \\<br>&amp; \ge \binom{n}{2} r _n^2 \\<br>&amp; = \frac{n (n - 1)}{2} r _n^2<br>\end{aligned}<br>$$<br>则有 $0 \le r _n \le \sqrt{\frac{2}{n - 1}}$ </p><p>又因为 $\sqrt{\frac{2}{n - 1}} \to 0$ ，由迫敛性可得 $r_n \to 0$ </p><p>由极限的线性可加性， $\lim \limits _{n \to + \infty} \sqrt[n]{n} = 1$  </p><h2 id="T6：求证：当-a-m-gt-0-时-lim-limits-n-to-infty-a-m-n-m-a-m-1-n-m-1-…-a-1-n-a-0-infty"><a href="#T6：求证：当-a-m-gt-0-时-lim-limits-n-to-infty-a-m-n-m-a-m-1-n-m-1-…-a-1-n-a-0-infty" class="headerlink" title="T6：求证：当 $a _m &gt; 0$ 时 $\lim \limits _{n \to + \infty} a _m n^m + a _{m - 1} n^{m - 1} + … + a _1 n + a _0 = + \infty$"></a>T6：求证：当 $a _m &gt; 0$ 时 $\lim \limits _{n \to + \infty} a _m n^m + a _{m - 1} n^{m - 1} + … + a _1 n + a _0 = + \infty$</h2><p>记 $A = \max(\mid a_i \mid)$<br>$$<br>\begin{aligned}<br>&amp; a _m n^m + a _{m - 1} n^{m - 1} + … + a _1 n + a _0 \\<br>\ge &amp; a _m n^m - A n^{m - 1} * (m - 1) \\<br>= &amp; n^{m - 1} * (a _m * n - A(m - 1))<br>\end{aligned}<br>$$<br>由于 $n^{m - 1} \to + \infty$ ， $a _m n \to + \infty$ ，而 $A(m - 1)$ 为常数，故 $n^{m - 1} * (a _m * n - A(m - 1)) \to + \infty$ </p><p>又因为 $a _m n^m + a _{m - 1} n^{m - 1} + … + a _1 n + a _0 \le A n^m m$ ，且 $A n^m m \to + \infty$ ，由迫敛性可知 $\lim \limits _{n \to + \infty} a _m n^m + a _{m - 1} n^{m - 1} + … + a _1 n + a _0 = + \infty$ </p><p>QED</p><h2 id="T5：求-lim-limits-n-to-infty-frac-b-l-n-l-b-l-1-n-l-1-…-b-1-n-b-0-a-m-n-m-a-m-1-n-m-1-…-a-1-n-a-0"><a href="#T5：求-lim-limits-n-to-infty-frac-b-l-n-l-b-l-1-n-l-1-…-b-1-n-b-0-a-m-n-m-a-m-1-n-m-1-…-a-1-n-a-0" class="headerlink" title="T5：求 $\lim \limits _{n \to + \infty} \frac{b _l n^l + b _{l - 1} n^{l - 1} + … + b _1 n + b _0}{a _m n^m + a _{m - 1} n^{m - 1} + … + a _1 n + a _0}$"></a>T5：求 $\lim \limits _{n \to + \infty} \frac{b _l n^l + b _{l - 1} n^{l - 1} + … + b _1 n + b _0}{a _m n^m + a _{m - 1} n^{m - 1} + … + a _1 n + a _0}$</h2><p>解 ：</p><p>分类讨论：</p><h3 id="1）-l-lt-m-时"><a href="#1）-l-lt-m-时" class="headerlink" title="1） $l &lt; m$ 时"></a>1） $l &lt; m$ 时</h3><p>$$<br>\begin{aligned}<br>原式<br>&amp; = \frac{b _l + b _{l - 1} n^{- 1} + … + b _1 n^{1 - l} + b _0 n^{-l}}{a _m n^{m - l} + a _{m - 1} n^{m - l - 1} + … + a_k n^0 + … + a _1 n^{1 - l} + a _0 n^{-l}}<br>\end{aligned}<br>$$</p><p>又因为当 $k &lt; 0$ 时 $n^k \to 0$ ，由极限的线性可加性和可乘性，有：<br>$$<br>\begin{aligned}<br>&amp;\lim _{n \to + \infty} \frac{b _l n^l + b _{l - 1} n^{l - 1} + … + b _1 n + b _0}{a _m n^m + a _{m - 1} n^{m - 1} + … + a _1 n + a _0} \\<br>= &amp; \lim _{n \to + \infty} \frac{b _l + 0 + … + 0}{a _m n^{m - l} + a _{m - 1} n^{m - l - 1} + … + a _{k + 1} n + 1 + 0 + … + 0} \\<br>= &amp; \lim _{n \to + \infty} \frac{b _l}{a _m n^{m - l} + a _{m - 1} n^{m - l - 1} + … + a _{k + 1} n + 1} \\<br>= &amp; 0<br>\end{aligned}<br>$$<br>故 $l &lt; m$ 时， $\lim \limits _{n \to + \infty} \frac{b _l n^l + b _{l - 1} n^{l - 1} + … + b _1 n + b _0}{a _m n^m + a _{m - 1} n^{m - 1} + … + a _1 n + a _0} = 0$ </p><h3 id="2）-l-gt-m-时"><a href="#2）-l-gt-m-时" class="headerlink" title="2） $l &gt; m$ 时"></a>2） $l &gt; m$ 时</h3><p>由 $1)$ 可知，原式的倒数极限为 $0$ 即为无穷小量，那么原式为无穷大量（其正负由 $b_l$ 决定）</p><h3 id="3）-l-m-时"><a href="#3）-l-m-时" class="headerlink" title="3） $l = m$ 时"></a>3） $l = m$ 时</h3><p>$$<br>\begin{aligned}<br>原式<br>&amp; = \frac{b _l + b _{l - 1} n^{- 1} + … + b _1 n^{1 - l} + b _0 n^{-l}}{a _m + a _{m - 1} n^{-1} + … + a _1 n^{1 - l} + a _0 n^{-l}}<br>\end{aligned}<br>$$</p><p>类似于 $1)$ ，有：<br>$$<br>\begin{aligned}<br>&amp;\lim _{n \to + \infty} \frac{b _l n^l + b _{l - 1} n^{l - 1} + … + b _1 n + b _0}{a _m n^m + a _{m - 1} n^{m - 1} + … + a _1 n + a _0} \\<br>= &amp; \lim _{n \to + \infty} \frac{b _l + 0 + … + 0}{a _m + 0 + … + 0} \\<br>= &amp; \lim _{n \to + \infty} \frac{b _l}{a _m} \\<br>= &amp; \frac{b _l}{a _m}<br>\end{aligned}<br>$$<br>故 $l = m$ 时， $\lim \limits _{n \to + \infty} \frac{b _l n^l + b _{l - 1} n^{l - 1} + … + b _1 n + b _0}{a _m n^m + a _{m - 1} n^{m - 1} + … + a _1 n + a _0} = \frac{b _l}{a _m} $ </p>]]></content>
    
    
    <summary type="html">&lt;p&gt; 然而感觉并无卵用&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数论,数学" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
    <category term="其它" scheme="https://dyd-true.github.io/tags/%E5%85%B6%E5%AE%83/"/>
    
    <category term="笔记" scheme="https://dyd-true.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>优化dp2</title>
    <link href="https://dyd-true.github.io/2022/02/09/%E4%BC%98%E5%8C%96dp2/"/>
    <id>https://dyd-true.github.io/2022/02/09/%E4%BC%98%E5%8C%96dp2/</id>
    <published>2022-02-09T06:50:24.000Z</published>
    <updated>2022-02-13T00:23:15.670Z</updated>
    
    <content type="html"><![CDATA[<p> 然而我 dp 废的一比（三羊开泰）</p><span id="more"></span><h1 id="优化dp2"><a href="#优化dp2" class="headerlink" title="优化dp2"></a>优化dp2</h1><p>上回链接：<a href="https://dyd-true.github.io/2022/02/08/%E4%BC%98%E5%8C%96dp/#more">优化dp</a></p><p>这次目标主要介绍斜率优化，它是利用<strong>单调性</strong>对<strong>转移</strong>进行优化</p><h1 id="斜率优化"><a href="#斜率优化" class="headerlink" title="斜率优化"></a>斜率优化</h1><p>歪果仁喜欢叫凸包/凸壳优化（ convex hull trick ）</p><p>上次我我们说了，对于 1D/1D 模型：<br>$$<br>d[i] = \min_{l(i) \le j \le r(i)} (d[j] + val(i, j))<br>$$<br>如果 $val(i, j)$ 的的每一项仅与 $i, j$ 中一个有关，就可以考虑单调队列，那么，如果 <strong>$val(i, j)$ 包括了 $i, j$ 的乘积（即和它们同时相关的量）</strong>，我们就可以考虑斜率优化</p><p>斜率优化有两种形式，就我个人而言，比较喜欢先把 dp 方程写出来，然后考虑决策 $j$ 优于决策 $k$ 的条件，把条件化成<br>$$<br>\frac{y(j) - y(k)}{x(j) - x(k)} &lt; k<br>$$<br>这里 $&lt;$ 可以换，把外层循环都当常量， $k$ 是常数， $x(t), y(t)$ 是仅和 $t$ 有关的函数，这个就是斜率优化的第一种形式，如果是巨佬，一眼就可以看出（或者带几个点算出）它是上凸/下凸然后打代码了</p><p>但我比较弱，这个只能用来帮助打代码，只好继续化，在得到了形式一后，我们反回去看 dp 方程，把  $\min (\max)$ 去掉，化为斜率优化的第二种形式<br>$$<br>y(j) = k \times x(j) + d[i]’<br>$$<br>这里 $d[i]’$ 是只关于 $d[i]$ 的东西（可以通过它直接得到 $d[i]$ ）， $y(t), x(t), k$ 就和形式一一样（所以我化出形式一的目的其实就是为了指导如何化形式二，因为蒟蒻一般无法一眼看穿如何化形式二），然后我就用形式二来斜率优化</p><p>具体地，把问题化为对一条斜率为 $k$ 的直线尝试去过点 $(x(j), y(j))$ ，最大/小化直线的截距，我们发现只要维护点集的凸包即可，一般用单调队列实现</p><p>实现代码时最好看着这两个形式打（利用它们帮助你明确细节、条件），然后期待自己 rp 够好吧（<del>如果您是巨佬当我没说</del>）</p><p>值得一提的是，对于形式一，巨佬可以直接取几个点就看出上凸/下凸/无法优化，但对于用形式二的蒟蒻来说，只好记结论了：</p><p><strong>可以简单斜率优化的条件是形式二中的 $k$ 和 $x(t)$ 单调，单调递增/递减（或者 $\min$ / $\max$ ）对应下凸/上凸</strong>，这样有一个 $O(n)$ 就可以优化为 $O(1)$ ；而当 $k$ 和 $x(t)$ 有一者不单调时，我们优先考虑改方程（倒着 dp ，重设状态等）来<strong>保证 $x(t)$ 单调</strong>（要保证新决策横坐标大于/小于之前所有决策），并用二分，将 $O(n)$ 优化为 $O(\log n)$ ；最麻烦的是 $k$ 和 $x(t)$ 都不单调，这就只有动态维护，时间和题目要求以及选取的数据结构有关，具体可以看下面的例题</p><h2 id="例题六"><a href="#例题六" class="headerlink" title="例题六"></a>例题六</h2><p><a href="https://codeforces.com/problemset/problem/311/B">Cats Transport</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有 $m \le 10^5$ 只猫分布在 $n \le 10^5$ 座山上，第 $i$ 只猫在山 $h_i$ 且会在 $t_i \le 10^9$ 时间下到山脚，然后一直等着，两个山之间的距离已知且 $\le 10^4$ ，现在在第一座山脚有 $p \le 100$ 个铲屎官，速度为 $1$ ，每个铲屎官在你安排的时间出发（每个人出发时间可以不同，出发时间可以为负数），从山 $1$ 走到山 $n$ ，中通遇到在山脚的猫就带走它，要求你最小化猫的等待时间</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先，什么距离、速度、时间很麻烦，我们先对每只猫计算一个 $a_i = t_i - \sum_{j = 1}^{h_i} d_j$ ，表示“如果一个铲屎官想接走第 $i$ 只猫，它必须在 $a_i$ 时刻之后出发”，不难发现如果出发时间为 $x$ ，猫就会等待 $x - a_i$ 的时间，然后就不管题目中的 $d, t$ 和 $h$  了</p><p>我们先对 $a_i$ 从小到大排序，排完后铲屎官接走的猫一定是连续的，贪心可知，一定存在一种最优解满足每位铲屎官都对应一只刚好接走的猫，即对应一个 $a_i$ （简证 <del>口胡</del> ：若有为铲屎官没有刚好接走的猫，就让它早点出发，使他接的最后一只猫使被刚好接走，这样答案一定不会变差）</p><p>于是考虑第 $x$ 个铲屎官刚好接走猫 $i$ （即在 $a_i$ 出发），上一个人搞好接走猫 $j$ ，那么这个人可以接走猫 $j + 1 \sim i$ ，代价为 $\sum_{k = j + 1}^i a_i - a_k$ ，不妨对 $a_i$ 求个前缀和，然后 $\sum_{k = j + 1}^i a_i - a_k = (i - j)a_i - (sum[i] - sum[j])$ ，设 <code>f[i, j]</code> （ <del>$d$ 又被用了呜呜呜</del>）表示“前 $i$ 个铲屎官带走了前 $j$ 只猫，最小的等待时间”，易得：<br>$$<br>f[i, j] = \min_{0 \le k &lt; j} (f[i - 1, k] + (j - k) * a_j - (sum[j] - sum[k]))<br>$$<br>直接转移是 $O(pm^2)$ 的，外层 $i$ 当常量就是一个 1D/1D ，有 $val(j, k) = (j - k) * a_j - sum[j] + sum[k]$ ，发现存在乘积量 $(j - k) * a_j$ ，考虑斜率优化</p><p>巨佬们可以一眼看穿的就跳过吧，这里是蒻蒟痛苦的推式子：</p><p>考虑决策 $q$ 优于决策 $k$ 的条件（下面省略第一维）：<br>$$<br>\begin{aligned}<br>&amp; f[k] + (j - k) * a_j - sum[j] + sum[k] &gt; f[q] + (j - q) * a_j - sum[j] + sum[q] \\<br>\Rightarrow &amp; f[k] + -k * a_j + sum[k] &gt; f[q] + -q * a_j + sum[q] \\<br>\Rightarrow &amp; a_j &gt; \frac{(f[q] + sum[q]) - (f[k] + sum[k])}{q - k}<br>\end{aligned}<br>$$<br>于是形式一就有了，然后再化方程就简单了：<br>$$<br>\begin{aligned}<br>&amp; f[i, j] = \min_{0 \le k &lt; j} (f[i - 1, k] + (j - k) * a_j - (sum[j] - sum[k])) \\<br>\Rightarrow &amp; f[i, j] = f[i - 1, k] + j * a_j - k * a_j - sum[j] + sum[k] \\<br>\Rightarrow &amp; (f[i - 1, k] + sum[k]) = (a_j) \times (k) + (f[i, j] - a_j * j + sum[j]) \\<br>\end{aligned}<br>$$<br>大家可以对比两个形式和上面给的两个形式的一般式，不难发现它们间的联系</p><p>无论如何，式子是推出来了，现在来看单调性，首先 $a_j$ 是排好序的，显然单调递增，而那个 $k$ 是我们顺序枚举的，单调性也显然，剩下的就是打代码了……时间复杂度 $O(pm)$ </p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ol><li>仔细看看代码是不是有很多地方和形式一/二有点像？这就是我说的“帮助代码实现”</li><li>为了提高精度建议开 <code>double</code> ，也可以化除为乘</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STC static</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, P = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, p, q[N];</span><br><span class="line">LL f[P][N], sum[N], a[N], d[N];</span><br><span class="line"><span class="function">LL <span class="title">Y</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> f[i][x] + sum[x]; &#125;</span><br><span class="line"><span class="function">LL <span class="title">X</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">LL <span class="title">calc</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">Y</span>(i, k) - <span class="built_in">X</span>(a[j]) * k; &#125; <span class="comment">//计算截距i,j,k含义类似形式二</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123; <span class="keyword">return</span> (<span class="built_in">Y</span>(i, b) - <span class="built_in">Y</span>(i, c)) * (<span class="built_in">X</span>(a) - <span class="built_in">X</span>(b)) &gt; (<span class="built_in">Y</span>(i, a) - <span class="built_in">Y</span>(i, b)) * (<span class="built_in">X</span>(b) - <span class="built_in">X</span>(c)); &#125; <span class="comment">//检查a优于b,类似形式一,化乘为除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;p);</span><br><span class="line">    <span class="keyword">if</span> (p &gt;= m) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;d[i]), d[i] += d[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, h, t; i &lt;= m; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;h, &amp;t), a[i] = t - d[h];</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) f[<span class="number">1</span>][i] = a[i] * i - sum[i]; <span class="comment">//先把1算了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j, l, r; i &lt;= p; ++i)</span><br><span class="line">        <span class="keyword">for</span> (q[l = r = <span class="number">1</span>] = <span class="number">0</span>, j = <span class="number">1</span>; j &lt;= m; ++j) <span class="comment">//0也是一个决策点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (; l &lt; r &amp;&amp; <span class="built_in">calc</span>(i - <span class="number">1</span>, j, q[l + <span class="number">1</span>]) &lt; <span class="built_in">calc</span>(i - <span class="number">1</span>, j, q[l]); ++l); <span class="comment">//不优排除，注意至少要保证队列中有一个数,故l&lt;r</span></span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][q[l]] + a[j] * (j - q[l]) - (sum[j] - sum[q[l]]);</span><br><span class="line">            <span class="keyword">for</span> (; l &lt; r &amp;&amp; <span class="built_in">check</span>(i - <span class="number">1</span>, j, q[r], q[r - <span class="number">1</span>]); --r); <span class="comment">//保留斜率更优的</span></span><br><span class="line">            q[++r] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, f[p][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题七"><a href="#例题七" class="headerlink" title="例题七"></a>例题七</h2><p><a href="https://www.acwing.com/problem/content/description/304/">任务安排3</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定 $n \le 3 \times 10^5$ 个任务，要求从时刻 $0$ 开始顺序执行，第 $i$ 个任务耗时 $-512 \le t_i \le 512$ ，有一个机器执行任务，将任务分成若干段，每一段完成耗时就是该段 $t_i$ 之和，而机器开始每段之前要消耗 $S \le 512$ 的启动时间，<strong>一个任务的完成时刻就是所在段的完成时刻</strong>，最后的费用就是每个任务的完成时刻乘一个系数 $c_i \le 512$ 然后求和，现在求最小费用</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>首先求出 $t_i$ ， $c_i$ 的前缀和记为 $sum_t[], sum_c[]$ ，定义 <code>d[i, j]</code> 表示“把前 $i$ 个任务分成 $j$ 段最小费用”，方程显然：<br>$$<br>d[i, j] = \min_{0 \le k &lt; i} (d[k, j - 1] + (S * j + sum_t[i]) * (sum_c[i] - sum_c[k]))<br>$$<br>时间为 $O(n^3)$ ，完全无法接受，考虑到就算把 1D/1D 优化为 $O(1)$ 时间也无法接受，说明要剪去一维状态</p><p>我们发现题目并没有要求分成多少段，我们在状态中记录段数完全是为了计算代价，而每一次启动的代价都会累计到此后所有的任务中，用<strong>费用提前计算</strong>的思想，直接在启动时就把后面的代价累计了，这样就剪去了一维，定义 <code>d[i]</code> 表示“把前 $i$ 个任务分成若干段最小费用”，方程：<br>$$<br>d[i] = \min_{0 \le j &lt; i} (d[j] + sum_t[i] * (sum_c[i] - sum_c[j]) + S * (sum_c[n] - sum_c[j]))<br>$$<br>时间为 $O(n^2)$ ，考虑 1D/1D 优化， $val(i, j) = sum_t[i] * (sum_c[i] - sum_c[j]) + S * (sum_c[n] - sum_c[j])$ 包含 $i, j$ 乘积，考虑斜率优化，设决策 $k$ 优于 $j$ 有：<br>$$<br>\begin{aligned}<br>&amp; d[j] + sum_t[i] * (sum_c[i] - sum_c[j]) + S * (sum_c[n] - sum_c[j]) &gt; d[k] + sum_t[i] * (sum_c[i] - sum_c[k]) + S * (sum_c[n] - sum_c[k]) \\<br>&amp; d[j] - (S + sum_t[i]) *  sum_c[j] &gt; d[k] - (S + sum_t[i]) * sum_c[k] \\<br>&amp; (S + sum_t[i]) &gt; \frac{d[k] - d[j]}{sum_c[k] - sum_c[j]}<br>\end{aligned}<br>$$<br>于是得到形式二为：<br>$$<br>(d[j]) = (S + sum_t[i]) \times (sum_c[j]) + (d[i] - sum_t[i] * sum_c[i] - S * sum_c[n])<br>$$<br>现在来看单调性， $sum_c[j]$ 的单调性显然，但是由于 $t_i$ 可以为负数， $S + sum_t[i]$ <strong>不具有单调性</strong>，完蛋，这就是 $k$ 不单调但 $x(t)$ 单调的情况啊</p><p>但幸好 $x(t)$ 还是单调的，我们来思考 $k$ 不单调的影响：如果 $k$ 是单调的，由形式一可知我们只需保留凸壳上两点连线斜率大于 $k$ 的部分，而最优决策就一定是队头，因为队头的下一个点被删去，说明它的斜率由 $&lt;k$ 变为 $&gt;k$ ，则队头就是变化点，也就是最优决策点；但是 $k$ 不单调了，所以我们不能只保留凸壳上两点连线斜率大于 $k$ 的部分，而要维护整个凸壳，并最优决策点也不在是队头了，需要在队列中二分一个点，使得它和左侧点斜率 $&lt;k$ ，而和右侧点斜率 $&gt;k$ </p><p>时间复杂度 $O(n \log n)$ </p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>注意 <code>long long</code> 相乘要开 <code>int128</code> </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I128 __int128</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line">LL sumc[N], sumt[N], d[N];</span><br><span class="line"><span class="keyword">int</span> q[N], l, r;</span><br><span class="line"><span class="function">LL <span class="title">Y</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> d[x]; &#125;</span><br><span class="line"><span class="function">LL <span class="title">X</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> sumc[x]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, LL k)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">Y</span>(a) - <span class="built_in">Y</span>(b) &gt;= <span class="built_in">I128</span>(k) * (<span class="built_in">X</span>(a) - <span class="built_in">X</span>(b)); &#125; <span class="comment">//判断a,b的斜率大于等于k</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">I128</span>(<span class="built_in">Y</span>(b) - <span class="built_in">Y</span>(a)) * (<span class="built_in">X</span>(c) - <span class="built_in">X</span>(b)) &gt;= <span class="built_in">I128</span>(<span class="built_in">Y</span>(c) - <span class="built_in">Y</span>(b)) * (<span class="built_in">X</span>(b) - <span class="built_in">X</span>(a)); &#125; <span class="comment">//比较斜率,维护凸包</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i, LL k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> q[l];</span><br><span class="line">    <span class="keyword">int</span> ll = l, rr = r, mid, res;</span><br><span class="line">    <span class="keyword">while</span> (ll &lt;= rr)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = ll + rr &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check1</span>(q[mid + <span class="number">1</span>], q[mid], k)) rr = (res = mid) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> ll = mid + <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q[res];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, t, c; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;t, &amp;c);</span><br><span class="line">        sumc[i] = sumc[i - <span class="number">1</span>] + c, sumt[i] = sumt[i - <span class="number">1</span>] + t;</span><br><span class="line">    &#125;</span><br><span class="line">    q[l = r = <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, p; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        d[i] = d[p = <span class="built_in">find</span>(i, s + sumt[i])] - (s + sumt[i]) * sumc[p] + sumt[i] * sumc[i] + s * sumc[n];</span><br><span class="line">        <span class="keyword">for</span> (; l &lt; r &amp;&amp; <span class="built_in">check2</span>(q[r - <span class="number">1</span>], q[r], i); --r);</span><br><span class="line">        q[++r] = i; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, d[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题八"><a href="#例题八" class="headerlink" title="例题八"></a>例题八</h2><p><a href="https://www.luogu.com.cn/problem/P4027">货币兑换</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>有两种金卷 $A, B$ ，已知接下来 $n \le 10^5$ 天每天两种金卷的价格 $A_i, B_i \le 10$ ，用户的账户上有三个<strong>实数</strong>： $a, b, c$ ，分别表示金卷 $A, B$ 的数量和 RMB （软妹币）的数量，用户可以进行两种操作（同一天可以多次操作）：</p><ol><li>提供一个实数 $op \in [0, 100]$ ，然后将 $op\%$ 的 $A, B$ 卷按当天的价格换成 RMB </li><li>提供一个实数 $op$ 表示用 $op$ 元 RMB 买入 $A, B$ 卷，第 $i$ 天买入的 $A, B$ 卷比为 $R_i \in (0, 100]$ </li></ol><p>现在，假设你第一天有 $S \le 10^9$ 元且没有任何金卷，问第 $n$ 天时你账户中最多有多少 RMB ，保证最后答案 $\le 10^9$ 保留 $3$ 位小数 </p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>首先明确一个点：必然存在一种最优的买卖方案，使得每次买进操作使用完所有的人民币，每次卖出操作卖出所有的金券</p><p>证明很简单，如果最优解在某天买入了一部分卷，一定是因为买它最优，而继续买和买入一部分的“优越性”相同（因为参数都没变），所有继续买一定优于其它决策；卖出同理</p><p>然后我们来考虑 dp ，由于实数不好作为状态，定义 <code>d[i]</code> 为“第 $i$ 天最多得到的钱数”，把实数放到转移里，转移分两种：</p><ol><li><p>第 $i$ 天不卖出金卷，则 <code>d[i] = max(d[i], d[i - 1])</code> </p></li><li><p>第 $i$ 天卖出金卷，设上一次买入（一定是花完了所有 RMB 的）是在第 $j$ 天，有：<br>$$<br>d[i] = \max _{1 \le j &lt; i} (\frac{d[j]}{A _j * R _j + B _j} * R _j * A _i + \frac{d[j]}{A _j * R _j + B _j} * B _i)<br>$$</p></li></ol><p>第一种转移很好搞，问题在第二种，发现包含 $i, j$ 的乘积，于是考虑斜率优化</p><p>决策 $k$ 优于决策 $j$ 当且仅当：<br>$$<br>\begin{aligned}<br>&amp; \frac{d[j]}{A _j * R _j + B _j} * R _j * A _i + \frac{d[j]}{A _j * R _j + B _j} * B _i &lt; \frac{d[k]}{A _k * R _k + B _k} * R _k * A _i + \frac{d[k]}{A _k * R _k + B _k} * B _i \\<br>&amp; \frac{d[j] * R _j}{A _j * R _j + B _j} * \frac{A _i}{B _i} + \frac{d[j]}{A _j * R _j + B _j} &lt; \frac{d[k] * R _k}{A _k * R _k + B _k} * \frac{A _i}{B _i} + \frac{d[k]}{A _k * R _k + B _k} \\<br>&amp; \frac{d[j]}{A _j * R _j + B _j} - \frac{d[k]}{A _k * R _k + B _k} &lt; (\frac{d[k] * R _k}{A _k * R _k + B _k} -  \frac{d[j] * R _j}{A _j * R _j + B _j}) * \frac{A _i}{B _i} \\<br>&amp; \frac{\frac{d[j]}{A _j * R _j + B _j} - \frac{d[k]}{A _k * R _k + B _k}}{\frac{d[k] * R _k}{A _k * R _k + B _k} -  \frac{d[j] * R _j}{A _j * R _j + B _j}} &lt; \frac{A _i}{B _i} \\<br>&amp; \frac{\frac{d[k]}{A _k * R _k + B _k} - \frac{d[j]}{A _j * R _j + B _j}}{\frac{d[k] * R _k}{A _k * R _k + B _k} -  \frac{d[j] * R _j}{A _j * R _j + B _j}} &gt; - \frac{A _i}{B _i} \\<br>\end{aligned}<br>$$<br>相信你和我一样看见这个式子就脑壳疼，所以我们设 $Y(t) = \frac{d[t]}{A _t * R _t + B _t}, X(t) = \frac{d[t] * R _t}{A _t * R _t + B _t}$ ，就很明显是形式一了：<br>$$<br>\frac{Y(k) - Y(j)}{X(k) - X(j)} &gt; - \frac{A _i}{B _i}<br>$$<br>于是就推得形式二：<br>$$<br>Y(j) = - \frac{A _i}{B _i} \times X(j) + \frac{d[i]}{B _i}<br>$$<br>奈斯~，似乎维护一个最大截距就结束了（注意本题是维护上凸壳了，上两题都是下凸壳）？来检查一下单调性， what’s up ， $X(j) = \frac{d[j] * R _j}{A _j * R _j + B _j}$ 有个寂寞的单调性，再看 $- \frac{A _i}{B _i}$ ，更没有了，我们遇到了两个都没有单调性的情况</p><p>这下完蛋，  $k = - \frac{A _i}{B _i}$ 不具有单调性还好，可以像例七一样二分决策位置，但 $X(j)$ 没有单调性，这意味着我们凸包上的点不是按照横坐标排好序的，当前点可能不是插在凸包最右（左）边，而是插到凸包的中间已经维护好的部分里，这意味着我们必须动态维护凸包，<strong>对于本题来</strong>，说如果对于点 $j$ 左边的线斜率小于当前 $k$ ，显然用左边的点截距更大（画图一下就看出来了）；如果右边的线斜率大于当前 $k$ ，那么用右边的点更优；最后最优决策点左边直线斜率 $&gt; k$ （在爬升），右边斜率直线斜率 $&lt; k$ （在下降）</p><p>下面介绍三种不同数据结构维护这个凸包，其中前两种比较常用，各有优劣，第三种不太常见，但有些题目用上会有奇效</p><h3 id="平衡树维护"><a href="#平衡树维护" class="headerlink" title="平衡树维护"></a>平衡树维护</h3><p>把凸包上的点维护成一棵按照 $X(j)$ 排序的平衡树，每个点维护其在凸包上左边直线的斜率 $lk$ 和右边的直线斜率 $rk$ 每次插入新点 $x$ 时：</p><ol><li>先将新点旋转到根</li><li>寻找其左边最后一个可以与其构成凸包的点，并把之间的不能构成凸包的点删除（直接把该点旋转到 $x$ 下面，然后删除该点的左/右儿子即可），计算出 $lk$ （如何判断是否构成凸包：对于当前找到的点 $t$ ，如果 $lk(t)$ 大于直线 $t - x$ 的斜率，并且点 $t, x$ 之间有不在凸包内的节点，就说明要找的点在 $t, x$ 之间，就往右走）</li><li>同理维护右边</li><li>如果发现这个点在原来的凸包内，即 $lk(x) &lt; rk(x)$ ，直接删除该点</li></ol><p>平衡树的有点是好想、好理解，且时间好算，缺点当然是码量和常数（但其实三种方法的常数差不多）</p><p>为了方便拓展和迁移，不用常数小的 SBT 而用拓展性强（并且不用打 <code>push_up</code> ）的 splay 打代码前，我又想起蒟蒻我当初打脸的话：<strong>“我的 splay 常数小”</strong></p><p>时间复杂度 $O(n \log n)$ </p><p>代码：</p><p>其实为了卡常可以存下 $X(j), Y(j)$ ，防止每次都算，但我懒</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DB double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> DB eps = <span class="number">1e-9</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">DB d[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Day</span>&#123;</span> DB a, b, r; &#125;day[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(DB x, DB y)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">fabs</span>(x - y) &lt; eps ? <span class="number">0</span> : (x &gt; y ? <span class="number">1</span> : <span class="number">-1</span>); &#125;</span><br><span class="line"><span class="function">DB <span class="title">Y</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> d[x] / (day[x].a * day[x].r + day[x].b); &#125;</span><br><span class="line"><span class="function">DB <span class="title">X</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">Y</span>(x) * day[x].r; &#125;</span><br><span class="line"><span class="function">DB <span class="title">K</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> !<span class="built_in">cmp</span>(<span class="built_in">X</span>(a), <span class="built_in">X</span>(b)) ? -INF : (<span class="built_in">Y</span>(b) - <span class="built_in">Y</span>(a)) / (<span class="built_in">X</span>(b) - <span class="built_in">X</span>(a)); &#125;</span><br><span class="line"><span class="keyword">namespace</span> Splay</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> rt, tot;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> fa, ch[<span class="number">2</span>], id;</span><br><span class="line">        DB lk, rk;</span><br><span class="line">    &#125; tr[N];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> fa(x) tr[(x)].fa</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ch(x) tr[(x)].ch</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lk(x) tr[(x)].lk</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rk(x) tr[(x)].rk</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> id(x) tr[(x)].id</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rot</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="built_in">fa</span>(x), z = <span class="built_in">fa</span>(y), k = <span class="built_in">ch</span>(y)[<span class="number">1</span>] == x;</span><br><span class="line">        <span class="built_in">ch</span>(z)[y == <span class="built_in">ch</span>(z)[<span class="number">1</span>]] = x, <span class="built_in">fa</span>(x) = z;</span><br><span class="line">        <span class="built_in">ch</span>(y)[k] = <span class="built_in">ch</span>(x)[k ^ <span class="number">1</span>], <span class="built_in">fa</span>(<span class="built_in">ch</span>(x)[k ^ <span class="number">1</span>]) = y;</span><br><span class="line">        <span class="built_in">ch</span>(x)[k ^ <span class="number">1</span>] = y, <span class="built_in">fa</span>(y) = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y, z; <span class="built_in">fa</span>(x) != k; <span class="built_in">rot</span>(x)) <span class="keyword">if</span> ((z = <span class="built_in">fa</span>(y = <span class="built_in">fa</span>(x))) != k) (<span class="built_in">ch</span>(y)[<span class="number">1</span>] == x) ^ (<span class="built_in">ch</span>(z)[<span class="number">1</span>] == y) ? <span class="built_in">rot</span>(x) : <span class="built_in">rot</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (!k) rt = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x, DB k)</span> <span class="comment">//寻找最优解,当前斜率为k</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!x || <span class="built_in">cmp</span>(<span class="built_in">lk</span>(x), k) == <span class="number">1</span> &amp;&amp; <span class="built_in">cmp</span>(<span class="built_in">rk</span>(x), k) == <span class="number">-1</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">cmp</span>(<span class="built_in">lk</span>(x), k) == <span class="number">-1</span> ? <span class="built_in">find</span>(<span class="built_in">ch</span>(x)[<span class="number">0</span>], k) :  <span class="built_in">find</span>(<span class="built_in">ch</span>(x)[<span class="number">1</span>], k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y, res;</span><br><span class="line">        <span class="keyword">for</span> (y = <span class="built_in">ch</span>(x)[<span class="number">0</span>], res = y; y; )</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">cmp</span>(<span class="built_in">lk</span>(y), <span class="built_in">K</span>(<span class="built_in">id</span>(y), <span class="built_in">id</span>(x))) &gt;= <span class="number">0</span>) res = y, y = <span class="built_in">ch</span>(y)[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> y = <span class="built_in">ch</span>(y)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">suf</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y, res;</span><br><span class="line">        <span class="keyword">for</span> (y = <span class="built_in">ch</span>(x)[<span class="number">1</span>], res = y; y; )</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">cmp</span>(<span class="built_in">rk</span>(y), <span class="built_in">K</span>(<span class="built_in">id</span>(x), <span class="built_in">id</span>(y))) &lt;= <span class="number">0</span>) res = y, y = <span class="built_in">ch</span>(y)[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span> y = <span class="built_in">ch</span>(y)[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">splay</span>(x, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ch</span>(x)[<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">splay</span>(t = <span class="built_in">pre</span>(x), x), <span class="built_in">ch</span>(t)[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//删去凸包内的</span></span><br><span class="line">            <span class="built_in">lk</span>(x) = <span class="built_in">rk</span>(t) = <span class="built_in">K</span>(<span class="built_in">id</span>(t), <span class="built_in">id</span>(x));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">lk</span>(x) = INF; <span class="comment">//保证不往左,下面同理</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ch</span>(x)[<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">splay</span>(t = <span class="built_in">suf</span>(x), x), <span class="built_in">ch</span>(t)[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">rk</span>(x) = <span class="built_in">lk</span>(t) = <span class="built_in">K</span>(<span class="built_in">id</span>(x), <span class="built_in">id</span>(t));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">rk</span>(x) = -INF;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">cmp</span>(<span class="built_in">lk</span>(x), <span class="built_in">rk</span>(x)) &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            rt = <span class="built_in">ch</span>(x)[<span class="number">0</span>], <span class="built_in">ch</span>(rt)[<span class="number">1</span>] = <span class="built_in">ch</span>(x)[<span class="number">1</span>], <span class="built_in">fa</span>(<span class="built_in">ch</span>(x)[<span class="number">1</span>]) = rt, <span class="built_in">fa</span>(rt) = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">lk</span>(rt) = <span class="built_in">rk</span>(<span class="built_in">ch</span>(rt)[<span class="number">1</span>]) = <span class="built_in">K</span>(<span class="built_in">id</span>(rt), <span class="built_in">id</span>(<span class="built_in">ch</span>(rt)[<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = rt, ff = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (u &amp;&amp; <span class="built_in">id</span>(u) != id) u = <span class="built_in">ch</span>(ff = u)[(<span class="built_in">cmp</span>(<span class="built_in">X</span>(id), <span class="built_in">X</span>(<span class="built_in">id</span>(u))) &lt;= <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">if</span> (u) <span class="keyword">return</span> ;</span><br><span class="line">        u = ++tot;</span><br><span class="line">        <span class="keyword">if</span> (ff) <span class="built_in">ch</span>(ff)[(<span class="built_in">cmp</span>(<span class="built_in">X</span>(id), <span class="built_in">X</span>(<span class="built_in">id</span>(ff))) &lt;= <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>)] = u;</span><br><span class="line">        <span class="built_in">id</span>(u) = id, <span class="built_in">fa</span>(u) = ff, <span class="built_in">ch</span>(u)[<span class="number">0</span>] = <span class="built_in">ch</span>(u)[<span class="number">1</span>] = <span class="number">0</span>, <span class="built_in">check</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %lf&quot;</span>, &amp;n, &amp;d[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j; i &lt;= n; Splay::<span class="built_in">ins</span>(i), ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf %lf&quot;</span>, &amp;day[i].a, &amp;day[i].b, &amp;day[i].r);</span><br><span class="line">        j = Splay::<span class="built_in">find</span>(Splay::rt, -(day[i].a / day[i].b));</span><br><span class="line">        d[i] = <span class="built_in">max</span>(d[i - <span class="number">1</span>], <span class="built_in">X</span>(j) * day[i].a + <span class="built_in">Y</span>(j) * day[i].b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n&quot;</span>, d[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CDQ分治"><a href="#CDQ分治" class="headerlink" title="CDQ分治"></a>CDQ分治</h3><p>直接 CDQ 的话伪代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cdq(l, r)</span><br><span class="line">if (l = r) 用 d[i - 1] 跟新 d[i] </span><br><span class="line">cdq(l, mid)</span><br><span class="line">将 [l, mid] 按 X 排序, 将 [mid + 1, r] 按 k 排序</span><br><span class="line">用正常的斜率优化 O(n) 把左区间转移到右区间</span><br><span class="line">cdq(mid + 1, r)</span><br><span class="line">end dcq</span><br></pre></td></tr></table></figure><p>不难发现这样是 $O(n \log^2 n)$ 的，虽然可过，但这样显得 CDQ 不优于平衡树，其实 CDQ 的归并和归并排序有点像，可以利用它排序</p><p>具体地，我们先在进入 CDQ 前把原序列按 $k$ 排序，并同时记下每个数在原序列中的位置，在区间 $[l, r]$ 中，把在原序列中位置 $&lt; mid$ 的全部放在左边， $&gt; mid$ 的全部放在右边（保证左右仍然按 $k$ 有序） ，然后去归并</p><p>我们希望一个区间归并回来后是按 $X$ 排序的，于是在 CDQ 的最后做归并排序即可</p><p>另外，其实上面的 $k, X$ 可以互换，只要改动分治顺序即可</p><p>不难发现，相比平衡树， CDQ 有码量小，轻便的优点，但缺点是如果要保证时间复杂度的话需要一些冗余操作，且个人觉得思维量比平衡树大，另外 CDQ 是离线的，我也不知道这是优点还是缺点</p><p>时间复杂度 $O(n \log n)$ </p><p>代码：</p><p>中间分两边的步骤可以自己开临时数组做，别用 <code>nth_element</code> （它不稳定），另外，平衡树中说的记录下 $X, Y$ 的卡常在本题中很优秀，但我懒</p><p>（<del>话说 CDQ 是真的短</del>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DB double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STC static</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> DB eps = <span class="number">1e-12</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, p[N];</span><br><span class="line">DB d[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Day</span>&#123;</span> DB a, b, r; &#125;day[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(DB x, DB y)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">fabs</span>(x - y) &lt; eps ? <span class="number">0</span> : (x &gt; y ? <span class="number">1</span> : <span class="number">-1</span>); &#125;</span><br><span class="line"><span class="function">DB <span class="title">Y</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> d[x] / (day[x].a * day[x].r + day[x].b); &#125;</span><br><span class="line"><span class="function">DB <span class="title">X</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">Y</span>(x) * day[x].r; &#125;</span><br><span class="line"><span class="function">DB <span class="title">K</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> !<span class="built_in">cmp</span>(<span class="built_in">X</span>(a), <span class="built_in">X</span>(b)) ? -INF : (<span class="built_in">Y</span>(b) - <span class="built_in">Y</span>(a)) / (<span class="built_in">X</span>(b) - <span class="built_in">X</span>(a)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdq</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    STC <span class="keyword">int</span> q[N], tmp[N];</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(d[l] = <span class="built_in">max</span>(d[l], d[l - <span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>, ll = <span class="number">1</span>, rr = <span class="number">0</span>, lp = l - <span class="number">1</span>, rp = mid, tp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) p[i] &lt;= mid ? tmp[++lp] = p[i] : tmp[++rp] = p[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) p[i] = tmp[i];</span><br><span class="line">    <span class="built_in">cdq</span>(l, mid);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= mid; q[++rr] = i++)</span><br><span class="line">        <span class="keyword">for</span> (; ll &lt; rr &amp;&amp; <span class="built_in">cmp</span>(<span class="built_in">K</span>(p[q[rr]], p[i]), <span class="built_in">K</span>(p[q[rr - <span class="number">1</span>]], p[q[rr]])) == <span class="number">1</span>; --rr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= r; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (; ll &lt; rr &amp;&amp; <span class="built_in">cmp</span>(<span class="built_in">K</span>(p[q[ll]], p[q[ll + <span class="number">1</span>]]), -(day[p[i]].a / day[p[i]].b)) == <span class="number">1</span>; ++ll);</span><br><span class="line">        d[p[i]] = <span class="built_in">max</span>(d[p[i]], <span class="built_in">X</span>(p[q[ll]]) * day[p[i]].a + <span class="built_in">Y</span>(p[q[ll]]) * day[p[i]].b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cdq</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">for</span> (lp = tp = l, rp = mid + <span class="number">1</span>; lp &lt;= mid &amp;&amp; rp &lt;= r; ) tmp[tp++] = (<span class="built_in">cmp</span>(<span class="built_in">X</span>(p[lp]), <span class="built_in">X</span>(p[rp])) == <span class="number">-1</span> ? p[lp++] : p[rp++]);</span><br><span class="line">    <span class="keyword">for</span> (; lp &lt;= mid; tmp[tp++] = p[lp++]); </span><br><span class="line">    <span class="keyword">for</span> (; rp &lt;= r; tmp[tp++] = p[rp++]); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) p[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %lf&quot;</span>, &amp;n, &amp;d[<span class="number">0</span>]); <span class="comment">//都先初始化为s</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; d[i] = d[<span class="number">0</span>], p[i] = i, ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf %lf&quot;</span>, &amp;day[i].a, &amp;day[i].b, &amp;day[i].r);</span><br><span class="line">    <span class="built_in">sort</span>(p + <span class="number">1</span>, p + <span class="number">1</span> + n, [&amp;](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123; <span class="keyword">return</span> -(day[a].a / day[a].b) &gt; -(day[b].a / day[b].b); &#125;);</span><br><span class="line">    <span class="built_in">cdq</span>(<span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n&quot;</span>, d[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="李超线段树"><a href="#李超线段树" class="headerlink" title="李超线段树"></a>李超线段树</h3><p>这个就是邪教了</p><p>看到形式二：<br>$$<br>Y(j) = - \frac{A _i}{B _i} \times X(j) + \frac{d[i]}{B _i}<br>$$<br>我们把它化回去（是的，倒退，但不完全退）：<br>$$<br>\frac{d[i]}{B_i} = \max (X(j) * \frac{A _i}{B _i} + Y(j))<br>$$<br>我们明确一下我们要干嘛：对于一个 $i$ ，我们找到一个最优的 $j$ 使得上式最小</p><p>设 $t = \frac{A _i}{B _i}$ ，不再把每个 $j$ 当作点而是把它当作线段 $y = X(j) * x + Y(j)$ （即 $y = k * x + b$ 的形式），问题转化为对于每个 $t$ ，在一堆直线中找到当 $x = t$ 时，使得 $y$ 最大的一个，这很像李超线段树的板子，只是 $x = t$ 为小数，当然也可以就用小数直接查（动态开点），但这样精度要开很大，常数也很大，更优秀的方法是将 $x$ 离散化，这样也可以保证时间复杂度</p><p>说实话这已经不算斜率优化了，但这种方法可以也解决很大一部分斜率优化题，所以也写这里</p><p>时间复杂度 $O(n \log n)$ </p><p>代码：</p><p>也算短吧（主要数据结构部分长，不好压）？但李超线段树不常打，另外其实这种方法 <code>d[i]</code> 只由 <code>d[i - 1]</code> 转移，可以压掉，但那样就要记录 $X, Y$ ，我懒（艹）</p><p>有一个小点是要注意离散化后下标要从 $1$ 开始，因为建树是建在 $[1, n]$ 上的（这是值域线段树，离散化后值域应该是 $[1, n]$ ）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DB double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> DB eps = <span class="number">1e-9</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">DB d[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Day</span>&#123;</span> DB a, b, r, x; &#125;day[N];</span><br><span class="line">vector&lt;DB&gt; xx;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(DB x, DB y)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">fabs</span>(x - y) &lt; eps ? <span class="number">0</span> : (x &gt; y ? <span class="number">1</span> : <span class="number">-1</span>); &#125;</span><br><span class="line"><span class="function">DB <span class="title">Y</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> d[x] / (day[x].a * day[x].r + day[x].b); &#125;</span><br><span class="line"><span class="function">DB <span class="title">X</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">Y</span>(x) * day[x].r; &#125;</span><br><span class="line"><span class="keyword">namespace</span> LC</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        DB k, b, l, r;</span><br><span class="line">        <span class="function">DB <span class="title">calc</span><span class="params">(<span class="keyword">int</span> xid)</span></span>&#123; <span class="keyword">return</span> ((xid &gt; r || xid &lt; l) ? -INF : xx[xid] * k + b); &#125;</span><br><span class="line">    &#125; li[N];</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> l, r, id;</span><br><span class="line">    &#125; tr[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> l(x) tr[(x)].l</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> r(x) tr[(x)].r</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> id(x) tr[(x)].id</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> Mid (tr[u].l + tr[u].r &gt;&gt; 1)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc (u &lt;&lt; 1)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc (u &lt;&lt; 1 | 1)</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">cmp</span>(li[a].<span class="built_in">calc</span>(x), li[b].<span class="built_in">calc</span>(x)) &lt;= <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        tr[u] = &#123;l, r, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span> mid = Mid;</span><br><span class="line">        <span class="built_in">build</span>(lc, l, mid), <span class="built_in">build</span>(rc, mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = Mid;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= <span class="built_in">l</span>(u) &amp;&amp; r &gt;= <span class="built_in">r</span>(u))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">judge</span>(<span class="built_in">id</span>(u), d, mid)) <span class="built_in">swap</span>(<span class="built_in">id</span>(u), d);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">judge</span>(<span class="built_in">id</span>(u), d, <span class="built_in">l</span>(u))) <span class="built_in">upd</span>(lc, <span class="built_in">l</span>(u), <span class="built_in">r</span>(u), d);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">judge</span>(<span class="built_in">id</span>(u), d, <span class="built_in">r</span>(u))) <span class="built_in">upd</span>(rc, <span class="built_in">l</span>(u), <span class="built_in">r</span>(u), d);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">upd</span>(lc, l, r, d);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) <span class="built_in">upd</span>(lc, l, r, d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(Line x)</span></span>&#123; li[++cnt] = x, <span class="built_in">upd</span>(<span class="number">1</span>, <span class="number">1</span>, n, cnt); &#125;</span><br><span class="line">    <span class="function">DB <span class="title">ask</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">l</span>(u) == <span class="built_in">r</span>(u)) <span class="keyword">return</span> li[<span class="built_in">id</span>(u)].<span class="built_in">calc</span>(x);</span><br><span class="line">        <span class="keyword">int</span> mid = Mid;</span><br><span class="line">        DB res = (x &lt;= mid ? <span class="built_in">ask</span>(lc, x) : <span class="built_in">ask</span>(rc, x));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(res, li[<span class="built_in">id</span>(u)].<span class="built_in">calc</span>(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lsh</span><span class="params">()</span></span>&#123; xx.<span class="built_in">push_back</span>(-INF); <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) xx.<span class="built_in">push_back</span>(day[i].x);<span class="built_in">sort</span>(xx.<span class="built_in">begin</span>(), xx.<span class="built_in">end</span>()); &#125; <span class="comment">//这里就不必去重了,因为是实数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %lf&quot;</span>, &amp;n, &amp;d[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf %lf&quot;</span>, &amp;day[i].a, &amp;day[i].b, &amp;day[i].r), day[i].x = day[i].a / day[i].b;</span><br><span class="line">    <span class="built_in">lsh</span>(), LC::<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, xx.<span class="built_in">size</span>() - <span class="number">1</span>); <span class="comment">//注意是size-1,因为xx多插了一个-INF,多建点会RE</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, t; i &lt;= n; LC::<span class="built_in">ins</span>(&#123;<span class="built_in">X</span>(i), <span class="built_in">Y</span>(i), <span class="number">1</span>, <span class="built_in">DB</span>(n)&#125;), ++i) d[i] = <span class="built_in">max</span>(d[i - <span class="number">1</span>], day[i].b * LC::<span class="built_in">ask</span>(<span class="number">1</span>, <span class="built_in">lower_bound</span>(xx.<span class="built_in">begin</span>(), xx.<span class="built_in">end</span>(), day[i].x) - xx.<span class="built_in">begin</span>()));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.3lf&quot;</span>, d[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h1><p>话说我好懒啊，记录卡常一直懒得打，另外代码有点压行非常抱歉</p><p>其它的下次再写，会挂链接的</p>]]></content>
    
    
    <summary type="html">&lt;p&gt; 然而我 dp 废的一比（三羊开泰）&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="平衡树" scheme="https://dyd-true.github.io/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
    <category term="数据结构" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="斜率优化" scheme="https://dyd-true.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
    <category term="线段树" scheme="https://dyd-true.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    <category term="splay" scheme="https://dyd-true.github.io/tags/splay/"/>
    
    <category term="笔记" scheme="https://dyd-true.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="CDQ" scheme="https://dyd-true.github.io/tags/CDQ/"/>
    
  </entry>
  
  <entry>
    <title>优化dp</title>
    <link href="https://dyd-true.github.io/2022/02/08/%E4%BC%98%E5%8C%96dp/"/>
    <id>https://dyd-true.github.io/2022/02/08/%E4%BC%98%E5%8C%96dp/</id>
    <published>2022-02-08T02:18:27.000Z</published>
    <updated>2022-02-10T14:09:48.397Z</updated>
    
    <content type="html"><![CDATA[<p> 然而我 dp 废的一比（梅开二度）</p><span id="more"></span><h1 id="优化-dp"><a href="#优化-dp" class="headerlink" title="优化 dp"></a>优化 dp</h1><p>作为 dp 废物，这里记录一下（<del>反正我不会的</del>） dp 优化方法</p><p> dp 的关键有：状态、初始化、转移、循环</p><h1 id="倍增优化"><a href="#倍增优化" class="headerlink" title="倍增优化"></a>倍增优化</h1><p>倍增是一种很优美的思想，大部分动态规划的都是采用阶段的线性增长，而在有些题中，可以考虑倍增增长（类似 ST 表的预处理），而这种优化常常会把 $2^k$ 中的 $k$ 记入<strong>状态</strong>中，类似区间 dp ，关于 $k$ 的循环往往在外层</p><p>而倍增优化的 dp 往往是这类问题的第一部分（也是最难的部分），通过 dp 我们得到若干与 $2$ 的整次幂相关的状态；在第二部分，我们会用这些状态<strong>“拼凑”</strong>（一般基于二进制拆分）出最后答案</p><h2 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h2><p><a href="https://www.luogu.com.cn/problem/P1081">开车旅行</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定 $n \le 10^5$ 个不同的数 $\mid h_i \mid \le 10^9$ ，记 $dis(i, j) = \mid h_i - h_j \mid$ ，两种操作<strong>轮流进行</strong>，设当前在 $i$ ，第一种会找到满足 $j &gt; i$ 且使  $dis(i, j)$ 取<strong>次小值</strong>（相等则认为 $h_j$ 小的小，下同）的 $j$ ，并以 $dis(i, j)$ 的代价到达 $j$ ；第二种会找到满足 $j &gt; i$ 且使  $dis(i, j)$ 取<strong>最小值</strong>的 $j$ ，并以 $dis(i, j)$ 的代价到达 $j$ ，但无论如何，总代价不能大于 $X \le 10^9$ ，当操作无法进行下去时就结束，现在有两个问题：</p><ol><li>对于给定的 $X= X_0$ ，求从那个数出发，操作一耗费的代价与操作二耗费的代价比值最小，若有多个答案，输出 $h_i$ 最大的</li><li>给出 $m \le 10^5$ 次询问，每次给定 $X = X_i$ 和出发点 $st_i$ ，分别求两种操作耗费的代价</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先预处理出从每个 $i$ 出发，两种操作会到达的点，记为 $g[0/1, i]$ ，用一个 <code>set</code> 倒序扫描即可</p><p>本题信息有三个：位置、操作次数、代价，如果直接以其为状态，复杂度过高，注意到操作是轮流进行的，考虑倍增优化，设 $d[0/1, i, j, 0/1]$ 表示“对于操作一/二，从 $j$ 出发先做操作一/二，操作 $2^i$ 次后的代价”，初始化和转移比较明显：<br>$$<br>\begin{aligned}<br>&amp; &amp; d[0, 0, j, 0] = dis(j, g[0, i]), d[0, 0, j, 1] = 0 \\<br>&amp; if (i = 1) &amp; d[0, 1, j, k] = d[0, 0, j, k] + d[0, 0, x, k \oplus 1] \\<br>&amp; else &amp; d[0, i, j, k] = d[0, i - 1, j, k] + d[0, i - 1, x, k] \\<br>\end{aligned}<br>$$<br>这里一定要单独考虑 $i = 1$ 的情况，因为只有 $2^0 = 1$ 是奇数， $d[1]$ 类似</p><p>不难发现状态数是 $O(2 * \log n * n * 2) = O(4 n \log n)$ （这里先把常数留一下），所以留给转移的时间最多是 $O(\log n)$ ，而转移的关键在于上面方程中的 $x$ ，它的含义是“前面那步走到的城市”，如在 $i \ne 1$ 时， $x$ 指“从 $j$ 出发先做操作 $k$ ，进行 $2^{i - 1}$ 次操作到达的城市”，这个东西可以 dp 预处理，具体地，设 <code>f[i, j, 0/1]</code> 表示“从 $j$ 出发先做操作一/二，进行 $2^{i}$ 次操作到达的城市”，初始化和转移如下：<br>$$<br>\begin{aligned}<br>&amp; &amp; f[0, j, 0] = g[0, j], f[0, j, 1] = g[1, j] \\<br>&amp; if (i = 1) &amp; f[1, j, k] = f[0, f[0, j, k], k \oplus 1] \\<br>&amp; else &amp; f[i, j, k] = f[i - 1, f[i - 1, j, k], k] \\<br>\end{aligned}<br>$$<br>预处理时间明显 $O(n \log n)$ ，然后 $d$ 的转移可以做到 $O(1)$ </p><p>于是我们在 $O(n \log n)$ 的时间内完成了计算所有操作次数为 $2^i$ 形式的信息，现在，对于问题二，类似 lca 倒序枚举 $i$ 移动即可，时间为 $O(\log n)$ ，而对于问题一，直接枚举起点转化成问题二即可，故总的时间为 $O(n \log n + 4 n \log n + n \log n + m \log n) = O(n \log n)$ 常数在 $10$ 左右，完全可以过</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>马蜂毒牛（ <del>dp 码风重拳出击，数据结构唯唯诺诺</del>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPT set<span class="meta-string">&lt;PII&gt;</span>::iterator</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, D = <span class="number">20</span>, INF = <span class="number">2e9</span> + <span class="number">7</span>; <span class="comment">//这里INF要足够大</span></span><br><span class="line"><span class="keyword">int</span> n, h[N], d[<span class="number">2</span>][D][N][<span class="number">2</span>], f[D][N][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    h[<span class="number">0</span>] = INF, h[n + <span class="number">1</span>] = -INF;</span><br><span class="line">    set&lt;PII&gt; s;</span><br><span class="line">    s.<span class="built_in">insert</span>(&#123;h[<span class="number">0</span>], <span class="number">0</span>&#125;), s.<span class="built_in">insert</span>(&#123;h[<span class="number">0</span>] + <span class="number">1</span>, <span class="number">0</span>&#125;), s.<span class="built_in">insert</span>(&#123;h[n + <span class="number">1</span>], n + <span class="number">1</span>&#125;), s.<span class="built_in">insert</span>(&#123;h[n + <span class="number">1</span>] - <span class="number">1</span>, n + <span class="number">1</span>&#125;); <span class="comment">//set不能插入重复元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n, ga, gb; i; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        s.<span class="built_in">insert</span>(&#123;h[i], i&#125;);</span><br><span class="line">        SPT il = s.<span class="built_in">lower_bound</span>(&#123;h[i], i&#125;), ir = il;</span><br><span class="line">        --il, ++ir;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(h[i] - il-&gt;fi) &lt;= <span class="built_in">abs</span>(h[i] - ir-&gt;fi))</span><br><span class="line">        &#123;</span><br><span class="line">            gb = il-&gt;se, --il;</span><br><span class="line">            ga = (<span class="built_in">abs</span>(h[i] - il-&gt;fi) &lt;= <span class="built_in">abs</span>(h[i] - ir-&gt;fi) ? il-&gt;se : ir -&gt; se);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            gb = ir-&gt;se, ++ir;</span><br><span class="line">            ga = (<span class="built_in">abs</span>(h[i] - il-&gt;fi) &lt;= <span class="built_in">abs</span>(h[i] - ir-&gt;fi) ? il-&gt;se : ir -&gt; se);</span><br><span class="line">        &#125;</span><br><span class="line">        f[<span class="number">0</span>][i][<span class="number">0</span>] = ga, f[<span class="number">0</span>][i][<span class="number">1</span>] = gb;</span><br><span class="line">        d[<span class="number">0</span>][<span class="number">0</span>][i][<span class="number">0</span>] = <span class="built_in">abs</span>(h[i] - h[ga]), d[<span class="number">0</span>][<span class="number">0</span>][i][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        d[<span class="number">1</span>][<span class="number">0</span>][i][<span class="number">1</span>] = <span class="built_in">abs</span>(h[i] - h[gb]), d[<span class="number">1</span>][<span class="number">0</span>][i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; D; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">1</span>; ++k) f[i][j][k] = f[i - <span class="number">1</span>][f[i - <span class="number">1</span>][j][k]][k ^ (i == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>)];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> o = <span class="number">0</span>; o &lt;= <span class="number">1</span>; ++o)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; D; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">1</span>; ++k) d[o][i][j][k] = d[o][i - <span class="number">1</span>][j][k] + d[o][i - <span class="number">1</span>][f[i - <span class="number">1</span>][j][k]][k ^ (i == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">PII <span class="title">work</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> la = <span class="number">0</span>, lb = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = D - <span class="number">1</span>; ~i; --i) <span class="keyword">if</span> (f[i][p][<span class="number">0</span>] &amp;&amp; la + lb + d[<span class="number">0</span>][i][p][<span class="number">0</span>] + d[<span class="number">1</span>][i][p][<span class="number">0</span>] &lt;= x) la += d[<span class="number">0</span>][i][p][<span class="number">0</span>], lb += d[<span class="number">1</span>][i][p][<span class="number">0</span>], p = f[i][p][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> &#123;la, lb&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(PII x, PII y)</span> <span class="comment">//应对分母为0的情况,化除为乘,-1代表相等,1代表x大,0代表y大</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x.se &amp;&amp; !y.se) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!x.se || !y.se) <span class="keyword">return</span> x.se != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (LL)x.fi * y.se == (LL)y.fi * x.se ? <span class="number">-1</span> : (LL)x.fi * y.se &lt; (LL)y.fi * x.se;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, st, ans, m;</span><br><span class="line">    PII as = &#123;INF, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line">    <span class="built_in">dp</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, tt; i &lt;= n; ++i)</span><br><span class="line">    &#123;    </span><br><span class="line">        PII t = <span class="built_in">work</span>(i, x); </span><br><span class="line">        <span class="keyword">if</span> ((tt = <span class="built_in">cmp</span>(t, as)) == <span class="number">1</span> || (tt == <span class="number">-1</span> &amp;&amp; h[i] &gt; h[ans])) ans = i, as = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m); m--; <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, as.fi, as.se)) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;st, &amp;x), as = <span class="built_in">work</span>(st, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h2><p><a href="https://www.acwing.com/problem/content/296/">Count The Repetitions</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>多组数据，定义 <code>conn(s, n)</code> 为 $n$ 个字符串 $s$ 形成的字符串，如 <code>conn(&quot;abc&quot;, 2) = &quot;abcabc&quot;</code> ，每次给定长度 $\le 100$ 的字符串 $s_1, s_2$ 和两个整数 $n_1, n_2 \le 10^6$ ，求一个最大的 $m$ 使得 $conn(conn(s_2, n_2), m)$ 为 $conn(s_1, n_1)$ 的子串</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>首先， $conn(conn(s_2, n_2), m) = conn(s_2, n_2 * m)$ ，现在问题转化为求 $m’ = n_2 * m$ </p><p>注意到 $m’ \le N = \frac{\mid s_1 \mid * n_1}{\mid s_2 \mid}$ ，而  $N \le 10^8$ 过大，不好直接枚举，考虑将 $m’$ 二进制拆分，设 $m’ = 2^{p_0} + 2^{p_1} + … + 2^{p_{t - 1}}$ ，则 $conn(s_2, m’)$ 可看作 $conn(s_2, 2^{p_0}), conn(s_2, 2^{p_1}), …, conn(s_2, 2^{p_{t - 1}})$ 着 $t$ 个串首尾衔接得到，考虑对于每个 $k \in [0, \log N]$ ，求出 $conn(s_1, n_1)$ <strong>从每个位置开始</strong>，最少要多少个字符才能和 $conn(s_2, 2^{k})$ 匹配上（就是含有该子串），这样我们就又可以用类似 lca 的方法拼凑出答案，但 $cons(s_1, n_1)$ 也很长，不妨当成 $conn(s_1, \infty)$ ，但只算从 $s_1$ 的各个位置开始的情况</p><p>综上，定义 <code>d[i, j]</code> 表示“从 $s_1[i]$ 开始，至少要多少个字符，才能匹配 $conn(s_2, 2^j)$ ”，则转移方程为：<br>$$<br>d[i, j] = d[i, j - 1] + d[(i + d[i, j - 1]) \mod \mid s_1 \mid, j - 1]<br>$$<br>初始化 $d[i, 0]$ 可以暴力计算， dp 的总时间复杂度为 $O(\mid s_1 \mid \log N)$ </p><p>然后用得到的状态拼凑答案，类似于 lca ，具体见代码</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>要注意的地方是：</p><ol><li> <code>d</code> 要开 <code>long long</code> </li><li>第 $18$ 行是 <code>x + 1</code> ，因为我下标从 $1$ 开始的</li><li>本题输入非常毒瘤，如果用 <code>cin</code> 一点问题没有，但如果用 <code>scanf</code> 因为数据最后有个换行所以会 TLE ，不过可以利用 <code>scanf</code> 返回值解决</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get(x) (((x) - 1) % l1 + 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">100</span> + <span class="number">5</span>, D = <span class="number">32</span>;</span><br><span class="line"><span class="keyword">char</span> s1[L], s2[L];</span><br><span class="line"><span class="keyword">int</span> n1, n2, l1, l2, ans;</span><br><span class="line">LL d[L][D];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans = <span class="number">0</span>, <span class="built_in">memset</span>(d, <span class="number">0</span> , <span class="keyword">sizeof</span> d);</span><br><span class="line">    l1 = <span class="built_in">strlen</span>(s1 + <span class="number">1</span>), l2 = <span class="built_in">strlen</span>(s2 + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, pos, j, ct; i &lt;= l1; ++i)</span><br><span class="line">        <span class="keyword">for</span> (pos = i, j = <span class="number">1</span>; j &lt;= l2; ++j, pos = <span class="built_in">get</span>(pos + <span class="number">1</span>), d[i][<span class="number">0</span>] += ct + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (ct = <span class="number">0</span>; s1[pos] != s2[j]; pos = <span class="built_in">get</span>(pos + <span class="number">1</span>)) <span class="keyword">if</span> (++ct &gt; l1) <span class="keyword">return</span> ans = <span class="number">0</span>, <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; D; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l1; ++i) d[i][j] = d[i][j - <span class="number">1</span>] + d[<span class="built_in">get</span>(i + d[i][j - <span class="number">1</span>])][j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = D - <span class="number">1</span>, x = <span class="number">0</span>; k &gt;= <span class="number">0</span>; --k) <span class="keyword">if</span> (x + d[<span class="built_in">get</span>(x + <span class="number">1</span>)][k] &lt;= l1 * n1) x += d[<span class="built_in">get</span>(x + <span class="number">1</span>)][k], ans += (<span class="number">1</span> &lt;&lt; k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">scanf</span>(<span class="string">&quot;%s %d %s %d&quot;</span>, s2 + <span class="number">1</span>, &amp;n2, s1 + <span class="number">1</span>, &amp;n1) == <span class="number">4</span>; <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans / n2)) <span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据结构优化"><a href="#数据结构优化" class="headerlink" title="数据结构优化"></a>数据结构优化</h1><p>对于大部分 dp 高效的<strong>转移</strong>非常重要，通过选取适当的数据结构，可以大大提高 dp 效率</p><p>这类问题的难点一般不在数据结构上，它仅仅做一个辅助转移的工具，关于工具的选取还要看题目本身的性质</p><p>当然有时候我们会需要在数据结构上 dp ，这种情况本质上并不是优化 dp 这里就不再做讨论</p><h2 id="例题三"><a href="#例题三" class="headerlink" title="例题三"></a>例题三</h2><p>还是看到题： <a href="https://www.acwing.com/problem/content/299/">赤壁之战</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给定长度为 $n \le 1000$ 的序列 $a_i$ ，求 $a_i$ 有多少个长度为 $m$ 严格递增子序列，多组数据，答案对 $10^9 + 7$ 取模</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p> dp 方程一眼就出来： <code>d[i, j]</code> 表示以 $j$ 结尾的长度为 $i$ 的严格递增子序列的个数，有  $d[i, j] \gets d[i - 1, k] (k &lt; j \wedge a_k &lt; a_j)$ </p><p>仔细一看， $n \le 10^7$ ，直接 dp 是 $O(n^2m)$ 的，这不完蛋，但，先打出来看看</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; j; ++k) <span class="keyword">if</span> (a[k] &lt; a[j]) d[i][j] += d[i - <span class="number">1</span>][k];</span><br></pre></td></tr></table></figure><p>在枚举 $j, k$ 时，可以把最外层的 $i$ 当作定值不管，发现当 $j$ 加 $1$ 后， $k$ 的范围也仅变化了 $1$ ，但决策是变化了不知道多少的，因为条件 <code>a[k] &lt; a[j]</code> 中的 <code>a[j]</code> 变了，考虑用树状数组，把 $a_i$ 离散化，每次查询前缀和并插入一个数，于是第三层循环的 $n$ 变成 $\log n$ ，总时间为 $O(m n \log n)$ </p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000</span> + <span class="number">5</span>, P = <span class="number">1e9</span> + <span class="number">7</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, ans;</span><br><span class="line"><span class="keyword">int</span> d[N][N], a[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; aa;</span><br><span class="line"><span class="keyword">namespace</span> BIT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x) &amp; -(x))</span></span><br><span class="line">    <span class="keyword">int</span> c[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123; <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span> c); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">for</span> (; x &lt;= n; x += <span class="built_in">lowbit</span>(x)) c[x] = (c[x] + y) % P; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; x; x -= <span class="built_in">lowbit</span>(x)) res = (res + c[x]) % P;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lsh</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    aa.<span class="built_in">push_back</span>(- INF - <span class="number">1</span>); <span class="comment">//树状数组不能有下标为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) aa.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">    <span class="built_in">sort</span>(aa.<span class="built_in">begin</span>(), aa.<span class="built_in">end</span>());</span><br><span class="line">    aa.<span class="built_in">erase</span>(<span class="built_in">unique</span>(aa.<span class="built_in">begin</span>(), aa.<span class="built_in">end</span>()), aa.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) a[i] = <span class="built_in">lower_bound</span>(aa.<span class="built_in">begin</span>(), aa.<span class="built_in">end</span>(), a[i]) - aa.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T, t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T); t &lt;= T; aa.<span class="built_in">clear</span>(), <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span> d), ans = <span class="number">0</span>, ++t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        a[<span class="number">0</span>] = -INF;</span><br><span class="line">        <span class="built_in">lsh</span>();</span><br><span class="line">        d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            BIT::<span class="built_in">clear</span>();</span><br><span class="line">            BIT::<span class="built_in">add</span>(a[<span class="number">0</span>], d[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) d[i][j] = BIT::<span class="built_in">ask</span>(a[j] - <span class="number">1</span>), BIT::<span class="built_in">add</span>(a[j], d[i - <span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ans = (ans + d[m][i]) % P;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d\n&quot;</span>, t, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单调队列优化"><a href="#单调队列优化" class="headerlink" title="单调队列优化"></a>单调队列优化</h1><p>从这里开始是对于<strong>转移</strong>的优化</p><p>在 dp 中，我们常常遇到这种方程（有时候不尽相同，但通过把外层变量当定值等方法可以化成这样）：<br>$$<br>d[i] = \min_{l(i) \le j \le r(i)} (d[j] + val(i, j))<br>$$<br>其中 $\min$ 可换成 $\max$ ， $val(i, j)$ 是关于 $i, j$ 的多项式函数（通常<strong>它是决定优化方式的关键</strong>）， $l(i), r(i)$ 限制了 $j$ 的决策范围且保证<strong>上下界变化具有单调性</strong>，上述问题被称作 <strong>1D/1D 动态规划</strong>，因为它的状态和转移都是 $O(n)$ 的</p><p>如果上面方程中，满足 <strong>$val(i, j)$ 中的每一项仅与 $i, j$ 中一个有关</strong>，我们就可以考虑把关于 $i, j$ 的项分开，对于关于 $i$ 的部分，它与 $j$ 无关，可以每次跟新 $i$ 后再计算；对于关于 $j$ 的部分，由于 $l(i), r(i)$ 的单调性，可以用<strong>单调队列优化</strong></p><h2 id="例题四"><a href="#例题四" class="headerlink" title="例题四"></a>例题四</h2><p><a href="https://www.acwing.com/problem/content/301/">Cut the Sequence</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给定长度为 $n \le 10^5$ 的序列 $0 \le a_i \le 10^6$ ，要求把序列分成若干段，在满足“每段的和不超过 $m \le 10^{11}$ ”的前提下，让“每段的最大值之和”最小，求最小值</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>照着题意设方程，定义 <code>d[i]</code> 表示“把前 $i$ 个数分成若干段，在保证每段和不超过 $m$ 的前提下，每段最大值之和的最小值”，转移方程：<br>$$<br>d[i] = \min_{0 \le j &lt; i \wedge \sum_{k = j + 1}^i a_k \le m} (d[j] + \max_{j + 1 \le k \le i} (a_k))<br>$$<br>直接转移明显 $O(n^2)$ ，并且 $val(i, j) = \max_{j + 1 \le k \le i} (a_k)$ 似乎很难用多项式表示，思考转移优化的指导思想：<strong>及时排除不可能的决策，保持候选决策集合的秩序性和有效性</strong>，我们来看看何时决策 $j$ 是必要的</p><p>引理：</p><p>决策 $j(0 \le j &lt; i \wedge \sum_{k = j + 1}^i a_k \le m)$ 是最优策略的必要条件是它至少满足下面两个式子<strong>之一</strong>：</p><ol><li> $a_j = \max_{j \le k \le i} (a_k)$ </li><li> $\sum_{k = j}^i a_k &gt; m$ 或者说 $j$ 是最小的满足 $\sum_{k = j + 1}^i a_k \le m$ 的数</li></ol><p>证明：</p><p>设 $j$ 两个条件都不满足，则由条件 $1$ 有 $\max_{j \le k \le i} (a_k) = \max_{j + 1 \le k \le i} (a_k)$ ，再由条件 $2$ 可知决策 $j - 1$ 合法，又因为明显 $d[j - 1] \le d[j]$ ，有 $d[j - 1] + \max_{j \le k \le i} (a_k) \le d[j] + \max_{j + 1 \le k \le i} (a_k)$ ，即决策 $j - 1$ 优于决策 $j$ </p><p>QED</p><p> 那么，现在来看看引理如何指导 dp ，首先是条件 $2$ ，可以直接对每个 $i$ 预处理出最小的 $j$ ，然后直接进行一次转移即可（然而后面会有更简单的实现方法）；而对于条件 $1$ ，考虑优先队列，当一个新决策 $k$ 入队时，若队尾决策 $j$ 满足 $j &lt; k (这个条件显然) \wedge a_j \le a_k$ 那么 $j$ 一定不优于 $k$ ，这样看来只要维护一个 $a_i$ 单调递减的队列，就可以做到 $O(n)$ 的 dp 了……吗？</p><p>发现我们只能保证<strong>队列中的元素可能为最优决策</strong>，但队头不一定是令 $d[j] + \max_{j + 1 \le k \le i} (a_k)$ 取得最小值的 $j$ ，如果直接扫描队列时间又变回 $O(n^2)$ 了，故我们要快速找到队列中的最优解，考虑数据结构，它要支持查询最小、插入、删除——这不平衡树吗（好像二叉堆 + 懒惰删除也行）？直接维护一个内部元素于单调队列相同的平衡树即可，总时间 $O(n \log n)$ </p><p>最后一个小问题：  $\max_{j + 1 \le k \le i} (a_k)$ 可以用 ST 表做到 $O(1)$ ，但其实仔细思考可以发现，队列中某一项的 $\max_{j + 1 \le k \le i} (a_k)$ 就是它下一项的 $a_i$ </p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><ol><li>特判无解的情况</li><li>关于条件 $2$ 的实现，可以不必预处理，记录一个当前  $sum$ 和对应最小的 $j$ ，即 $L$ 当队列中只有一个元素时就用 $L$ 转移，同时 $L$ 还可以帮助维护队头</li><li> 虽然队列中某一项的 $\max_{j + 1 \le k \le i} (a_k)$ 就是它下一项的 $a_i$ ，但我们的队列（同时对应平衡树）维护的是 $a_i$ ，所以应该是从当前项找到上一项的 $d$ （具体见代码的 <code>calc()</code> 函数），而排除/调用最优时要的是 $d$ ，所以要减 $1$ </li><li>本题一定要先插入再转移，原因同 $3$ ，我们维护的是 $a$ ，而转移时调用的是 $d$ ，它可能刚好是当然插入 $a$ 的前一个（另，关于队列的写法，这边建议都写成先插入再转移的）</li><li>如果你实在觉得这细节来细节去的太麻烦，可以考虑用预处理的方式实现条件 $2$ ，并明确下标，就不必管 $2 \sim 4$ 了（<del>但代码会变长</del>）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N];</span><br><span class="line">LL m, d[N] ,sum;</span><br><span class="line"><span class="keyword">int</span> q[N], l, r, L;</span><br><span class="line">multiset&lt;LL&gt; s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> d[q[x - <span class="number">1</span>]] + a[q[x]]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %lld&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; m) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>), <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    l = L = <span class="number">1</span>, r = sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (; l &lt;= r &amp;&amp; a[i] &gt;= a[q[r]]; --r) <span class="keyword">if</span> (l &lt; r) s.<span class="built_in">erase</span>(s.<span class="built_in">find</span>(<span class="built_in">calc</span>(r)));</span><br><span class="line">        q[++r] = i;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) s.<span class="built_in">insert</span>(<span class="built_in">calc</span>(r));</span><br><span class="line">        sum += a[i];</span><br><span class="line">        <span class="keyword">for</span> (; sum &gt; m; sum -= a[L++]); </span><br><span class="line">        <span class="keyword">for</span> (; l &lt;= r &amp;&amp; q[l] &lt; L; ++l) <span class="keyword">if</span> (l &lt; r) s.<span class="built_in">erase</span>(s.<span class="built_in">find</span>(<span class="built_in">calc</span>(l + <span class="number">1</span>)));</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= r) d[i] = d[L - <span class="number">1</span>] + a[q[l]];</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) d[i] = <span class="built_in">min</span>(d[i], *s.<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, d[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题五"><a href="#例题五" class="headerlink" title="例题五"></a>例题五</h2><p>下面来看一个经典问题，多重背包问题：<a href="https://www.luogu.com.cn/problem/P1782">旅行商的背包</a></p><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>给定 $n \le 10^4$ 种物品，每种物品有 $d_i \le 1000$  个，体积为 $v_i \le 1000$ ，价值为 $w_i \le 1000$ ，又给定 $m \le 5$ 个特殊物品，第 $i$ 个特殊物品的价值 $y_i$ 与取走的体积 $x_i$ 满足 $y_i = a_i x_i^2 + b_i x_i + c_i$  ，其中 $\mid a_i, b_i, c_i \mid \le 1000$ ，现有一个容量为 $c \le 10^4$ 的背包，求最大价值</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>由于 $m \le 5$ 很小，可以完全背包暴力做，问题就转化为多重背包的板子，用二进制拆分法的时间复杂度为 $O(n c \log d )$ 可过，但卡的有点死，实际上，用单调队列可以优化到 $O(nc)$ </p><p>先考虑原来的朴素方程： <code>f[j]</code> （题目已经有 $d$ 了，这里就用 $f$ ）表示“从前 $i$ 个物品中选体积和为 $j$ 的物品的最大价值”（ $i$ 那一维被<strong>倒序循环</strong>压缩掉了），在转移时，考虑第 $i$ 个物品选了 $cnt$ 个：<br>$$<br>f[j] = \max_{1 \le cnt \le d_i} (f[j - cnt * v_i] + cnt * w_i)<br>$$<br>考虑状态 $j$ （注意 $j$ 是状态， $cnt$ 才是决策），它的决策集合就是 $\{j - cnt * v_i \mid 1 \le cnt \le d_i \}$ ，不难发现这个集合相比状态 $j - v_i$ 的决策集合 $\{j - v_i - cnt * v_i \mid 1 \le cnt \le d_i \}$ 只变化了一个数，这启发我们把 $j$ 按照 $\mod v_i$ 的余数分组</p><p>为了简单，我们完全不必枚举 $j$ ，改为枚举余数 $u \in [0, v_i)$ ，再枚举（这里就正序了） $p = 0 \sim \lfloor \frac{c - u}{v_i} \rfloor$ ，这样就可以计算出 $j = u + p * v_i$ ，故 $j$ 的决策集合就是 $\{u + k * p_i \mid p - d_i \le k \le p - 1 \}$ ，于是方程变为：<br>$$<br>f[u + p * v_i] = \max_{p - d_i \le k \le p - 1} (f[u + k * v_i] + (p - k) * w_i)<br>$$<br>这里的 $val(p, k) = (p - k) * w_i$ 明显可以分成两部分 $p * w_i$ 和 $-k * w_i$ ，且当 $p$ 减 $1$ 时，上下界 $p - d_i, p - 1$ 都单调变化，这就是典型的单调队列优化模型，我们建立一个决策点 $k$ 递减， $f[u + k * v_i] - k * w_i$ 递减的单调队列，每次取队头跟新即可，时间复杂度 $O(nc)$ </p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><p>本题卡常，吸氧或者加快读可过（我懒就吸氧了）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIL pair<span class="meta-string">&lt;int, LL&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, C;</span><br><span class="line">LL f[N];</span><br><span class="line">PIL q[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;C);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, v, w, d, u; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;v, &amp;w, &amp;d), u = <span class="number">0</span>; u &lt; v; ++u)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>, p = <span class="number">0</span>, j; (j = p * v + u) &lt;= C; ++p)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (; l &lt;= r &amp;&amp; f[j] - w * p &gt; q[r].se; --r);</span><br><span class="line">                q[++r] = &#123;p, f[j] - w * p&#125;;</span><br><span class="line">                <span class="keyword">for</span> (; l &lt;= r &amp;&amp; q[l].fi &lt; p - d; ++l); <span class="comment">//其实这里if也行,因为每次只有一个数出队</span></span><br><span class="line">                f[j] = q[l].se + w * p;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b, c, j; i &lt;= m; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c), j = C; j; --j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= j; ++k) f[j] = <span class="built_in">max</span>(f[j], f[j - k] + (LL)(a * k + b) * k + c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, f[C]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h1><p>没想到这么长，打算分成三篇写，会挂链接的</p><p><a href="https://dyd-true.github.io/2022/02/09/%E4%BC%98%E5%8C%96dp2/#more">优化dp2</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt; 然而我 dp 废的一比（梅开二度）&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数据结构" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="倍增" scheme="https://dyd-true.github.io/tags/%E5%80%8D%E5%A2%9E/"/>
    
    <category term="单调队列" scheme="https://dyd-true.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
    <category term="笔记" scheme="https://dyd-true.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>luoguP7519 [省选联考 2021 A/B 卷] 滚榜</title>
    <link href="https://dyd-true.github.io/2022/02/08/luoguP7519-%E7%9C%81%E9%80%89%E8%81%94%E8%80%83-2021-A-B-%E5%8D%B7-%E6%BB%9A%E6%A6%9C/"/>
    <id>https://dyd-true.github.io/2022/02/08/luoguP7519-%E7%9C%81%E9%80%89%E8%81%94%E8%80%83-2021-A-B-%E5%8D%B7-%E6%BB%9A%E6%A6%9C/</id>
    <published>2022-02-08T00:38:22.000Z</published>
    <updated>2022-02-08T02:01:50.210Z</updated>
    
    <content type="html"><![CDATA[<p> too difficult for 蒟蒻</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P7519">滚榜</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>已知有 $n \le 13$ 个数 $a_i \le 10^4$ ，按 $1 \sim n$ 编号，每次选一个数给他加上 $b_i$ ，要保证加的 $b_i$ 不小于上次加的，且加完后该数排名第一（大小相同的比编号），已知 $\sum b_i = m \le 500$ ，求最后 $n$ 个数的排名情况有多少种</p><h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><p>看 $n \le 13$ 考虑状态压缩，设 <code>d[s][i][j][k]</code> 表示“已加的数集合为 $s$ ，上一个加的为 $i$ ，当前 $\sum b_i = j$ 且上一个 $b_i = k$ 的方案数”，有 $d[s][i][j][k] \to d[s + \{p\}][p][j + q][q]$ （满足 $a_p + q &gt; / \ge a_i + b_i, j + q &lt; m, q \ge k$ ）时间复杂度为 $O(2^n n^2 m^2)$ 呃呃……</p><p>考虑把状态的维度剪掉，当然是剪一个 $m$ （剪 $n$ 没用啊），发现我们不必要上一个 $b_i$ ，考虑用别的前几维的信息得到 $b_i$ ，发现不是很好表示</p><p>考虑预处理，首先，我们发现数 $a_i$ 要变成最大的， $b_i$ 就要比 $b_j$ 大至少 $a_j - a_i$ （假设 $j$ 先于 $i$ ），不妨设它为 $dt[i][j]$ ，计算它要用 $O(n^2)$ </p><p>其次，由于 $b$ 按出现的顺序单调不降，不妨考虑差分，设差分数组为 $c$ ，有 $b_i = \sum_{j = 1}^i c_i$  （这里假设 $b_i$ 按出现顺序排序了， $b_i$ 的 $i$ 已经不对应 $a_i$ 了），故 $\sum b_i = \sum c_i * (n - i + 1) = m$ ，所以 $c_i$ 对 $m$ 的贡献就要乘 $n - i + 1$ ，只需保证 $c_i \ge 0$ 即可，而 $c_i$ 的最小值就是 $dt[i][j]$ （ $j$ 先于 $i$ 一个）</p><p>再次定义 <code>d[s][i][j]</code> 为“已加的数集合为 $s$ ，上一个加的为 $i$ ，当前 $\sum b_i = j$ 的方案数”，设 $t = s - \{i\}$ ，有 $d[s][i][j] \gets d[t][k][j - dt[i][k] * (n - \mid A \mid)]$ ，时间为 $O(2^n n m)$ ，常数小可过</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">15</span>, NN = (<span class="number">1</span> &lt;&lt; <span class="number">13</span>) + <span class="number">5</span>, M = <span class="number">500</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, nn;</span><br><span class="line">LL ans;</span><br><span class="line"><span class="keyword">int</span> a[N], dt[N][N], d[NN][N][M], si[NN]; <span class="comment">//si[s]:集合s的大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m), nn = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) dt[i][j] = <span class="built_in">max</span>(<span class="number">0</span>, a[j] - a[i] + (i &gt; j)), dt[i][<span class="number">0</span>] = <span class="built_in">max</span>(dt[i][j], dt[i][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nn; ++i) si[i] = si[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>, t, num; s &lt; nn; ++s)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j; i &lt;= n; ++i) <span class="keyword">if</span> (s &gt;&gt; i - <span class="number">1</span> &amp; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (t = s ^ <span class="number">1</span> &lt;&lt; i - <span class="number">1</span>, num = n - si[t], j = si[t] ? <span class="number">1</span> : <span class="number">0</span>; j &lt;= n; ++j) <span class="keyword">if</span> (!j || t &gt;&gt; j - <span class="number">1</span> &amp; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = dt[i][j] * num; k &lt;= m; ++k) d[s][i][k] += d[t][j][k - dt[i][j] * num];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) ans += d[nn - <span class="number">1</span>][i][j];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; too difficult for 蒟蒻&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="状态压缩" scheme="https://dyd-true.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>luoguP4067 [SDOI2016]储能表</title>
    <link href="https://dyd-true.github.io/2022/02/07/luoguP4067-SDOI2016-%E5%82%A8%E8%83%BD%E8%A1%A8/"/>
    <id>https://dyd-true.github.io/2022/02/07/luoguP4067-SDOI2016-%E5%82%A8%E8%83%BD%E8%A1%A8/</id>
    <published>2022-02-07T12:09:58.000Z</published>
    <updated>2022-02-08T00:34:25.749Z</updated>
    
    <content type="html"><![CDATA[<p> 这就是我和巨佬的差距</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P4067">储能表</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p> $T \le 5000$ 组数据，每次给定 $n, m, k \le 10^{18}$ ，求：<br>$$<br>\sum_{i = 0}^{n - 1} \sum_{j = 0}^{m - 1} \max((i \oplus j) - k, 0)<br>$$<br> 答案对 $p \le 10^9$ 取模</p><h2 id="蒻蒟的挣扎"><a href="#蒻蒟的挣扎" class="headerlink" title="蒻蒟的挣扎"></a>蒻蒟的挣扎</h2><p>一看见 $5000, 10^{18}$ 吓了一跳，后来发现是数位 dp</p><p>首先原式里面一个 $\max$ 很不有好（因为它是为了保证非负），不妨考虑只管异或值大于 $k$ 的数对 $(i, j)$ ，就不用管 $\max$ 了，更具体的，我们求出“异或值大于 $k$ 的数对的个数 $A$ ”和“所以异或值大于 $k$ 的数对的异或值之和 $B$ ”，那么 $Ans = B - A * k$ </p><p>考虑分别求 $A, B$ ，定义 <code>d[0/1][i][0/1][0/1][0/1]</code> ，让 $d[0]$ 表示“<strong>从高到低</strong>到了二进制的第 $i$ 位，已经考虑的位数是/否到达 $n$ 的上界，是/否到达 $m$ 的上界，是/否到达 $k$ 的下界，此时的合法个数”， $d[1]$ 类似，但表示的是“异或值之和”</p><p>实现用记忆化搜索，慢一点点但好打的多</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">70</span>;</span><br><span class="line">LL n, m, k;</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">2</span>][N][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>], p, mxl;</span><br><span class="line"><span class="keyword">bool</span> vis[N][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> fn, <span class="keyword">int</span> fm, <span class="keyword">int</span> fk, <span class="keyword">int</span> &amp;as0, <span class="keyword">int</span> &amp;as1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> &amp;f = d[<span class="number">0</span>][len][fn][fm][fk], &amp;g = d[<span class="number">1</span>][len][fn][fm][fk];</span><br><span class="line">    <span class="keyword">if</span> (len &gt; mxl) <span class="keyword">return</span> as0 = <span class="number">1</span>, as1 = <span class="number">0</span>, <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">    <span class="keyword">if</span> (vis[len][fn][fm][fk]) <span class="keyword">return</span> as0 = f, as1 = g, <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">    vis[len][fn][fm][fk] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> pn = (n &gt;&gt; mxl - len) &amp; <span class="number">1</span>, pm = (m &gt;&gt; mxl - len) &amp; <span class="number">1</span>, pk = (k &gt;&gt; mxl - len) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (fn ? pn : <span class="number">1</span>); ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, pf, pg; j &lt;= (fm ? pm : <span class="number">1</span>); ++j) <span class="keyword">if</span> (!fk || (i ^ j) &gt;= pk)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dp</span>(len + <span class="number">1</span>, fn &amp;&amp; (i == pn), fm &amp;&amp; (j == pm), fk &amp;&amp; ((i ^ j) == pk), pf, pg);</span><br><span class="line">            f = (f + pf) % p, g = ((LL)g + (<span class="number">1ll</span> &lt;&lt; mxl - len) * (i ^ j) % p * pf + pg) % p;</span><br><span class="line">        &#125;</span><br><span class="line">    as0 = f, as1 = g;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T, ct, ans[<span class="number">2</span>];</span><br><span class="line">    LL t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T); T--; <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis), <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span> d), mxl = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld %d&quot;</span>, &amp;n, &amp;m, &amp;k, &amp;p), --n, --m;</span><br><span class="line">        <span class="keyword">for</span> (ct = <span class="number">0</span>, t = n; t; ++ct, t &gt;&gt;= <span class="number">1</span>);mxl = <span class="built_in">max</span>(mxl, ct);</span><br><span class="line">        <span class="keyword">for</span> (ct = <span class="number">0</span>, t = m; t; ++ct, t &gt;&gt;= <span class="number">1</span>);mxl = <span class="built_in">max</span>(mxl, ct);</span><br><span class="line">        <span class="keyword">for</span> (ct = <span class="number">0</span>, t = k; t; ++ct, t &gt;&gt;= <span class="number">1</span>);mxl = <span class="built_in">max</span>(mxl, ct);</span><br><span class="line">        <span class="built_in">dp</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, ans[<span class="number">0</span>], ans[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ((LL)ans[<span class="number">1</span>] - k % p * ans[<span class="number">0</span>] % p + p) % p); <span class="comment">//这里太坑了,k是LL,一定要先模一下</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="巨佬的-show-time"><a href="#巨佬的-show-time" class="headerlink" title="巨佬的 show time"></a>巨佬的 show time</h2><p>有巨佬用打表 + 模拟过了……</p><p>思路和<a href="https://www.luogu.com.cn/blog/youxiudezzy/solution-p4067">这位</a>差不多</p><h2 id="巨佬的代码"><a href="#巨佬的代码" class="headerlink" title="巨佬的代码"></a>巨佬的代码</h2><p>懒得打了，直接贴同机房巨佬的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"></span><br><span class="line">ll n, m, k, p, tmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span>((ch = <span class="built_in">getchar</span>()) &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) flag = <span class="literal">true</span>;</span><br><span class="line">x = ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="string">&#x27;0&#x27;</span> &lt;= (ch = <span class="built_in">getchar</span>()) &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) x = x * <span class="number">10</span> + (ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (flag) x = -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(ll x, ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">0</span>) x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (y &lt; <span class="number">0</span>) y = <span class="number">0</span>;</span><br><span class="line">ll res = y - x + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (res &amp; <span class="number">1</span>) <span class="keyword">return</span> (res % p) * ((x + y &gt;&gt; <span class="number">1</span>) % p) % p;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in"><span class="keyword">return</span></span> ((res + <span class="number">1</span> &gt;&gt; <span class="number">1</span>) % p) * ((x + y) % p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getans</span><span class="params">(ll x, ll y, ll z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">max</span>(((n - <span class="number">1</span>) ^ (m - <span class="number">1</span>)) - k, tmp) % p;</span><br><span class="line"><span class="keyword">if</span> (x &lt; y) <span class="built_in">swap</span>(x, y);</span><br><span class="line">ll l =<span class="number">0</span>, t;</span><br><span class="line"><span class="keyword">while</span>((<span class="number">1ll</span> &lt;&lt; l) &lt;= x + <span class="number">1</span>) l++;</span><br><span class="line">l--;</span><br><span class="line">t = (<span class="number">1ll</span> &lt;&lt; l) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (t &lt;= y) <span class="keyword">return</span> ((t + <span class="number">1</span>) % p * <span class="built_in">sum</span>(-z, t - z) % p + (x - t + y - t) % p * <span class="built_in">sum</span>(t + <span class="number">1</span> - z, t * <span class="number">2</span> + <span class="number">1</span> - z) % p + <span class="built_in">getans</span>(x - t - <span class="number">1</span>, y - t - <span class="number">1</span>, z)) % p;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in"><span class="keyword">return</span></span> ((y + <span class="number">1</span>) % p * <span class="built_in">sum</span>(<span class="built_in">max</span>(-z, tmp), <span class="built_in">max</span>(tmp, t - z)) % p + <span class="built_in">getans</span>(x - t - <span class="number">1</span>, y, z - t - <span class="number">1</span>)) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">read</span>(T);</span><br><span class="line"><span class="keyword">while</span>(T--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">read</span>(n), <span class="built_in">read</span>(m), <span class="built_in">read</span>(k), <span class="built_in">read</span>(p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">getans</span>(n - <span class="number">1</span>, m - <span class="number">1</span>, k));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 这就是我和巨佬的差距&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="数论,数学" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="暴力" scheme="https://dyd-true.github.io/tags/%E6%9A%B4%E5%8A%9B/"/>
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="模拟" scheme="https://dyd-true.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="打表" scheme="https://dyd-true.github.io/tags/%E6%89%93%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>luoguP5503 [JSOI2016]灯塔</title>
    <link href="https://dyd-true.github.io/2022/02/07/luoguP5503-JSOI2016-%E7%81%AF%E5%A1%94/"/>
    <id>https://dyd-true.github.io/2022/02/07/luoguP5503-JSOI2016-%E7%81%AF%E5%A1%94/</id>
    <published>2022-02-07T10:28:05.000Z</published>
    <updated>2022-02-07T12:03:25.663Z</updated>
    
    <content type="html"><![CDATA[<p> 明明 $O(n \sqrt{n})$ 可以的……</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P5503">灯塔</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定 $n \le 10^5$ 个数 $0 \le h_i \le 10^9$ ，对于每个数求出一个最小的 $p_i$ 使得 $h_j \le h_i + p_i - \sqrt{\mid i - j \mid}$ 对任意 $h_j$ 成立</p><h2 id="正常做法"><a href="#正常做法" class="headerlink" title="正常做法"></a>正常做法</h2><p>化式子为 $h_j - h_i + \sqrt{\mid i - j \mid} \le p_i$ ，直接暴力是 $n^2$ 的，麻烦点是那个根号，考虑枚举 $k = \sqrt{\mid i - j \mid}$ ，对于枚举到的每个 $k$ ，扫描整个数列，对于当前点 $i$ ，找到满足条件的最大 $h_j$ （用 ST 表可以做到 $O(1)$ ），跟新答案，时间复杂度为 $O(n \sqrt{n})$ </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STC static</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, D = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">namespace</span> ST</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> lg2[N], mx[N][D];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prev</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        lg2[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; ++i) lg2[i] = lg2[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) mx[i][<span class="number">0</span>] = x[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; D; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) mx[i][j] = <span class="built_in">max</span>(mx[i][j - <span class="number">1</span>], mx[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = lg2[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(mx[l][k], mx[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    STC <span class="keyword">int</span> h[N], p[N];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line">    ST::<span class="built_in">prev</span>(h, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>, t = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(n)); k &lt;= t; ++k)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l, r; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            l = (k - <span class="number">1</span>) * (k - <span class="number">1</span>) + i + <span class="number">1</span>, r = <span class="built_in">min</span>(k * k + i, n);</span><br><span class="line">            <span class="keyword">if</span> (l &lt;= r) p[i] = <span class="built_in">max</span>(p[i], ST::<span class="built_in">ask</span>(l, r) - h[i] + k);</span><br><span class="line">            l = <span class="built_in">max</span>(i - k * k, <span class="number">1</span>), r = i - (k - <span class="number">1</span>) * (k - <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (l &lt;= r) p[i] = <span class="built_in">max</span>(p[i], ST::<span class="built_in">ask</span>(l, r) - h[i] + k);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>蒟蒻我到这就结束了，但总有巨佬觉得时间还可以再优</p><h2 id="巨佬的时间"><a href="#巨佬的时间" class="headerlink" title="巨佬的时间"></a>巨佬的时间</h2><p>某位巨佬想出了 $O(n \log n)$ 的做法</p><p>首先去掉绝对值，只考虑 $j &lt; i$ 的情况，设 <code>d[i]</code> 表示“第 $i$ 个数对所有 $j \le i$ 满足条件的最小 $p_i$ ”，然后倒过来再做一遍即可，显然 $d[i] = \max(h_j - h_i + \sqrt{i - j})$ </p><p>然后，考虑根号，注意到这是典型的 $d[i] = \max_{j = 1}^{i - 1} (d[j] + w(j, i))$ 的形式，考虑四边形不等式，那么就要证明 $\forall a &lt; b, w(a, b + 1) + w(a + 1, b) \le w(a, b) + w(a + 1, b + 1)$ （这里因为 $\max$ 所以符号和 $\min$ 相反），对于本题来说 $\sqrt{(b + 1) - a} + \sqrt{b - (a + 1)} \ge \sqrt{b - a} + \sqrt{(b + 1) - (a + 1)}$ 即 $\sqrt{b - a + 1} + \sqrt{b - a - 1} \ge 2\sqrt{b - a}$ 设 $t = b - a$ ，我们要证明 $\sqrt{t + 1} + \sqrt{t - 1} \ge 2 \sqrt{t}$ ，两边平方即可</p><p>因此决策具有单调性，直接用队列 + 二分维护三元组即可，巨佬说因为转移顺序没有要求，所以可以分治，但是我不会，不管如何实现，时间为 $O(n \log n)$ </p><h2 id="贺的巨佬的代码"><a href="#贺的巨佬的代码" class="headerlink" title="贺的巨佬的代码"></a>贺的巨佬的代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DB double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get(i, j) (h[j] + sqrt(i - j))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, h[N];</span><br><span class="line">DB p[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> <span class="keyword">int</span> l, r, x; &#125; stk[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> <span class="comment">//找到i比j更优的最后一个点 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="built_in">max</span>(i, j), r = n, res = <span class="number">-1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">get</span>(mid, i) &gt;= <span class="built_in">get</span>(mid, j)) res = mid, l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    stk[l = r = <span class="number">1</span>] = &#123;<span class="number">1</span>, n ,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; stk[l].r &lt; i) ++l;</span><br><span class="line">        p[i] = <span class="built_in">max</span>(<span class="built_in">get</span>(i, stk[l].x), p[i]);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">get</span>(n, i) &lt;= <span class="built_in">get</span>(n, stk[l].x)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; <span class="built_in">get</span>(stk[r].l, stk[r].x) &lt;= <span class="built_in">get</span>(stk[r].l, i)) --r;</span><br><span class="line">        stk[r].r = <span class="built_in">find</span>(stk[r].x, i), stk[++r] = &#123;stk[r - <span class="number">1</span>].r + <span class="number">1</span>, n, i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line">    <span class="built_in">work</span>();</span><br><span class="line">    <span class="built_in">reverse</span>(h + <span class="number">1</span>, h + <span class="number">1</span> + n), <span class="built_in">reverse</span>(p + <span class="number">1</span>, p + <span class="number">1</span> + n);</span><br><span class="line">    <span class="built_in">work</span>();</span><br><span class="line">    <span class="built_in">reverse</span>(h + <span class="number">1</span>, h + <span class="number">1</span> + n), <span class="built_in">reverse</span>(p + <span class="number">1</span>, p + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">max</span>((<span class="keyword">int</span>)<span class="built_in">ceil</span>(p[i]) - h[i], <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 明明 $O(n \sqrt{n})$ 可以的……&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="ST表" scheme="https://dyd-true.github.io/tags/ST%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>luoguP4072 [SDOI2016]征途</title>
    <link href="https://dyd-true.github.io/2022/02/07/luoguP4072-SDOI2016-%E5%BE%81%E9%80%94/"/>
    <id>https://dyd-true.github.io/2022/02/07/luoguP4072-SDOI2016-%E5%BE%81%E9%80%94/</id>
    <published>2022-02-07T07:48:31.000Z</published>
    <updated>2022-02-07T10:21:30.528Z</updated>
    
    <content type="html"><![CDATA[<p> 被 K-D Tree 虐了一天后继续来 dp 受苦</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P4072">征途</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定 $n$ 个数，分成 $m$ 组，使得每组之和构成的数组方差最小，输出方差 $\times m^2$ ， $n \le 3000$ </p><h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><p>考虑把方差转化推式子：<br>$$<br>\begin{aligned}<br>s^2<br>&amp; = \frac{\sum_{i = 1}^{m} (v_i - \overline{v})^2}{m} \\<br>&amp; = \frac{m (\overline{v})^2 - 2 \overline{v} \sum_{i = 1}^{m} v_i + \sum_{i = 1}^{m} v_i^2}{m} \\<br>又有:\overline{v} &amp; = \frac{\sum_{i = 1}^{m} v_i}{m} \\<br>代入得 s^2<br>&amp; = \frac{m (\frac{\sum_{i = 1}^{m} v_i}{m})^2 - 2 \frac{\sum_{i = 1}^{m} v_i}{m} \sum_{i = 1}^{m} v_i + \sum_{i = 1}^{m} v_i^2}{m} \\<br>&amp; = \frac{\frac{(\sum_{i = 1}^{m} v_i)^2}{m} - 2 \frac{(\sum_{i = 1}^{m} v_i)^2}{m}  + \sum_{i = 1}^{m} v_i^2}{m} \\<br>故 Ans<br>&amp; = s^2 \times m^2 \\<br>&amp; = m \sum_{i = 1}^{m} v_i^2 -(\sum_{i = 1}^{m} v_i)^2 \\<br>&amp; = m \sum_{i = 1}^{m} v_i^2 -(\sum_{i = 1}^{n} x_i)^2 \\<br>\end{aligned}<br>$$<br>发现减号右边的值是恒定的，现在要最小化 $\sum_{i = 1}^{m} v_i^2$ </p><p>考虑 dp ，设 <code>d[i][j]</code> 表示“把前 $i$ 个数分成 $j$ 段的最小平方和”，转移就预处理前缀和， $O(n)$ 枚举最后一段的长度，时间复杂度为 $O(n^2 m)$ ， TLE $80pts$ </p><p>观察 dp 方程： $d[i][j] = min(d[k][j - 1] + (sum[i] - sum[k])^2)$ ，考虑斜率优化，设 $t$ 比 $k$ 优，则：<br>$$<br>\begin{aligned}<br>d[t][j - 1] + (sum[i] - sum[t])^2 &amp; &lt; d[k][j - 1] + (sum[i] - sum[k])^2 \\<br>d[t][j - 1] + sum[t]^2 - d[k][j - 1] - sum[k]^2 &amp; &lt; 2 sum[i] (sum[t] - sum[k]) \\<br>\frac{(d[t][j - 1] + sum[t]^2) - (d[k][j - 1] + sum[k]^2)}{(sum[t] - sum[k])} &amp; &lt; 2 sum[i]<br>\end{aligned}<br>$$<br>换句话说，把二元组 $(sum[x], d[x][j - 1] + sum[x]^2)$ 看作平面上的点，则点 $(sum[t], d[t][j - 1] + sum[t]^2)$ 比 $(sum[k], d[k][j - 1] + sum[k]^2)$ 优的充要条件（因为以上推导显然可以反向）是两点连线（ $k \to t$ ）的斜率小于 $2 sum[i]$ ，则启发我们将式子化为：<br>$$<br>\begin{aligned}<br>(d[k][j - 1] + sum[k]^2) &amp; = (2sum[i]) \times (sum[k]) + (d[i][j] - sum[i]^2) \\<br>y &amp; = k \times x + b<br>\end{aligned}<br>$$<br>要想斜率优化，还要保证 $k, x$ <strong>单调递增</strong>，而它们都是前缀和，单调性显然，于是就可以（<del>痛苦</del>）快乐的用斜率优化，维护一个凸包，把第二维滚动压掉（只会从 $j - 1$ 到 $j$ ），以第二维为最外层循环，枚举第一维，用单调队列维护凸包，转移时直接取队头，时间复杂度为 $O(mn)$ </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DB double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, l, r, o = <span class="number">0</span>;</span><br><span class="line">LL a[N], sum[N], d[N][<span class="number">2</span>], q[N]; </span><br><span class="line"><span class="function">DB <span class="title">get_k</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (DB)((d[y][k] + sum[y] * sum[y]) - (d[x][k] + sum[x] * sum[x])) / (DB)(sum[y] - sum[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]), sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) d[i][o] = sum[i] * sum[i]; <span class="comment">//这里不能初始化为0,所以先把m=1算出来</span></span><br><span class="line">    o ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j; i &lt;= m; ++i, o ^= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (j = i, l = r = <span class="number">1</span>, q[l] = i - <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; <span class="built_in">get_k</span>(q[l], q[l + <span class="number">1</span>], o ^ <span class="number">1</span>) &lt; <span class="number">2</span> * sum[j]) ++l;</span><br><span class="line">            d[j][o] = d[q[l]][o ^ <span class="number">1</span>] + (sum[j] - sum[q[l]]) * (sum[j] - sum[q[l]]);</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; <span class="built_in">get_k</span>(q[r - <span class="number">1</span>], q[r], o ^ <span class="number">1</span>) &gt; <span class="built_in">get_k</span>(q[r], j, o ^ <span class="number">1</span>)) --r;</span><br><span class="line">            q[++r] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, d[n][o ^ <span class="number">1</span>] * m - sum[n] * sum[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 被 K-D Tree 虐了一天后继续来 dp 受苦&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="斜率优化" scheme="https://dyd-true.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>K-D Tree</title>
    <link href="https://dyd-true.github.io/2022/02/06/K-D-Tree/"/>
    <id>https://dyd-true.github.io/2022/02/06/K-D-Tree/</id>
    <published>2022-02-06T12:24:00.000Z</published>
    <updated>2022-02-07T07:42:40.147Z</updated>
    
    <content type="html"><![CDATA[<p> 三维生物瑟瑟发抖</p><span id="more"></span><h1 id="K-D-Tree"><a href="#K-D-Tree" class="headerlink" title="K-D Tree"></a>K-D Tree</h1><p>K-D Tree（k-Dimension Tree，k 维树），是一种<strong>高效处理 $k$ 维空间信息</strong>的（<del>JO级生物</del>）数据结构，在节点数远大于 $2^k$ 时效率很高</p><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>K-D Tree 具有二叉搜索树的形态，通过以下伪代码可以将 $n$ 个 $k$ 维的点建出一棵K-D Tree ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function build (点集 S)</span><br><span class="line">if (S 只有一个点) return 该点</span><br><span class="line">选择一个维度 k ，选择一个切割点 a </span><br><span class="line">以点 a 的第 k 维为标准，所有第 k 维小于 a 的点归入集合 L ，其余归入 R</span><br><span class="line">以点 a 为父节点，用 L 建左子树， R 建右子树</span><br><span class="line">维护一些信息</span><br><span class="line">end function</span><br></pre></td></tr></table></figure><p>可以发现这个树的结构取决于选择的维度和切割点，我们按以下标准选择：</p><ol><li>选择的维度要满足其内部点的分布的差异度最大，即每次选择的切割维度是<strong>方差最大</strong>的维度</li><li>每次在维度上选择切割点时选择该维度上的<strong>中位数</strong>，这样可以保证每次分成的左右子树大小尽量相等</li></ol><p>可以发现这样建出的 K-D Tree 高度最大为 $O(\log n)$ </p><p>考虑建树的时间，每次找中位数时，用 <code>sort</code> 总时间是 $O(n \log^2 n)$ 的，这显然不必要，因为我们不必每次给整个序列排序，只要中位数在正确位置，且左边都小于它，右边大于它即可，在 <code>algorithm</code> 库中的  <code>nth_element()</code> 函数可以支持该操作，它的均摊复杂度为 $O(n)$ 于是建树就变了 $O(n \log n)$ </p><h2 id="插入-删除"><a href="#插入-删除" class="headerlink" title="插入/删除"></a>插入/删除</h2><p>数据结构大部分都要求支持插入和删除，但注意到 K-D Tree 具有二叉搜索树的形态，可它又不支持旋转（或者说很难支持旋转），而 FHQ Treap 的随机优先级思想也不能保证其复杂度，我们考虑用替罪羊树的重构思想</p><p>引入重构常数 $\alpha$ ，对于节点 $x$ 如果它的一个子树的结点数占比大于 $\alpha$ ，或者未删除的结点数在以 $x$ 为根的子树中的占比小于 $\alpha$ 时，我们就重构它</p><p>在插入一个点时，先根据记录的分割维度和分割点判断应该继续插入到左子树还是右子树，如果到达了空结点，新建一个结点代替这个空结点，成功插入结点后回溯插入的过程，维护结点的信息，如果发现当前的子树不平衡，则重构当前子树</p><p>在删除一个点时，先找到它，然后打上懒标记即可</p><p>类似于替罪羊树，带重构的 K-D Tree 的树高仍然是 $O(\log n)$ 的，当然，最好是把操作离线了</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.com.cn/problem/P4148">简单题</a></p><p>$20 MB$ 卡掉树套树，强制在线卡了 CDQ ，于是用 K-D Tree （略微卡常）</p><p>对于修改，直接删除再插入即可，对于询问，记录子树每一维的最大和最小值，可以证明，这样查询 $k$ 维的最坏时间为 $O(n^{1 - \frac{1}{k}})$ ，对于本题，就是 $O(\sqrt{n})$ ，本题可以插入重复元素，然后就不需要删除</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DB double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IL inline</span></span><br><span class="line"><span class="keyword">namespace</span> Fast</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> L = (<span class="number">1</span> &lt;&lt; <span class="number">20</span>) + <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[L], out[L], *iS, *iT;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> gh() (iT == iS ? iT = (iS = buf) + fread(buf, 1, L, stdin), (iT == iS ? EOF : *iS++) : *iS++)</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;class T&gt; </span></span><br><span class="line"><span class="function">    IL <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = <span class="built_in">gh</span>(), t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            t |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">gh</span>();</span><br><span class="line">        <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            x = x * <span class="number">10</span> + (ch ^ <span class="number">48</span>), ch = <span class="built_in">gh</span>();</span><br><span class="line">        <span class="keyword">if</span> (t)</span><br><span class="line">            x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">flus</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">fwrite</span>(out, <span class="number">1</span>, l, stdout);</span><br><span class="line">        l = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">putc</span><span class="params">(<span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        out[l++] = x;</span><br><span class="line">        <span class="keyword">if</span> (l == L - <span class="number">5</span>)</span><br><span class="line">            <span class="built_in">flus</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function">    IL <span class="keyword">void</span> <span class="title">write</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">putc</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">9</span>)</span><br><span class="line">            <span class="built_in">write</span>(x / <span class="number">10</span>);</span><br><span class="line">        out[l++] = x % <span class="number">10</span> + <span class="number">48</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == L - <span class="number">5</span>)</span><br><span class="line">            <span class="built_in">flus</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Fast::flus;</span><br><span class="line"><span class="keyword">using</span> Fast::putc;</span><br><span class="line"><span class="keyword">using</span> Fast::read;</span><br><span class="line"><span class="keyword">using</span> Fast::write;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e5</span> + <span class="number">5</span>, D = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x[D], w;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="keyword">namespace</span> KDT <span class="comment">//K-D Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> DB a = <span class="number">0.725</span>;</span><br><span class="line">    <span class="keyword">int</span> rt, top, rub[M], cur, tot; <span class="comment">//rub:回收空间</span></span><br><span class="line">    Point p[M];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> mn[D], mx[D], sum, lc, rc, si, k;</span><br><span class="line">        Point p;</span><br><span class="line">    &#125; tr[M];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mn(x) tr[(x)].mn</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mx(x) tr[(x)].mx</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sum(x) tr[(x)].sum</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc(x) tr[(x)].lc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc(x) tr[(x)].rc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> si(x) tr[(x)].si</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> k(x) tr[(x)].k</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> p(x) tr[(x)].p</span></span><br><span class="line">    <span class="function">IL <span class="keyword">int</span> <span class="title">newnode</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (top) <span class="keyword">return</span> rub[top--];</span><br><span class="line">        <span class="keyword">return</span> ++cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ls = <span class="built_in">lc</span>(u), rs = <span class="built_in">rc</span>(u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; D; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">mn</span>(u)[i] = <span class="built_in">mx</span>(u)[i] = <span class="built_in">p</span>(u).x[i];</span><br><span class="line">            <span class="keyword">if</span> (ls) <span class="built_in">mn</span>(u)[i] = <span class="built_in">min</span>(<span class="built_in">mn</span>(u)[i], <span class="built_in">mn</span>(ls)[i]), <span class="built_in">mx</span>(u)[i] = <span class="built_in">max</span>(<span class="built_in">mx</span>(u)[i], <span class="built_in">mx</span>(ls)[i]);</span><br><span class="line">            <span class="keyword">if</span> (rs) <span class="built_in">mn</span>(u)[i] = <span class="built_in">min</span>(<span class="built_in">mn</span>(u)[i], <span class="built_in">mn</span>(rs)[i]), <span class="built_in">mx</span>(u)[i] = <span class="built_in">max</span>(<span class="built_in">mx</span>(u)[i], <span class="built_in">mx</span>(rs)[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sum</span>(u) = <span class="built_in">sum</span>(ls) + <span class="built_in">sum</span>(rs) + <span class="built_in">p</span>(u).w, <span class="built_in">si</span>(u) = <span class="built_in">si</span>(ls) + <span class="built_in">si</span>(rs) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>, u = <span class="built_in">newnode</span>();</span><br><span class="line">        <span class="built_in">nth_element</span>(p + l, p + mid, p + r + <span class="number">1</span>, [&amp;](Point a, Point b)&#123; <span class="keyword">return</span> a.x[k] &lt; b.x[k]; &#125;);</span><br><span class="line">        <span class="built_in">k</span>(u) = k, <span class="built_in">p</span>(u) = p[mid], <span class="built_in">lc</span>(u) = <span class="built_in">build</span>(l, mid - <span class="number">1</span>, k ^ <span class="number">1</span>), <span class="built_in">rc</span>(u) = <span class="built_in">build</span>(mid + <span class="number">1</span>, r, k ^ <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">up</span>(u), u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">get_p</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!u) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="built_in">get_p</span>(<span class="built_in">lc</span>(u)), p[++tot] = <span class="built_in">p</span>(u), rub[++top] = u, <span class="built_in">get_p</span>(<span class="built_in">rc</span>(u));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> &amp;u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">si</span>(u) * a &lt; <span class="built_in">max</span>(<span class="built_in">si</span>(<span class="built_in">lc</span>(u)), <span class="built_in">si</span>(<span class="built_in">rc</span>(u)))) tot = <span class="number">0</span>, <span class="built_in">get_p</span>(u), u = <span class="built_in">build</span>(<span class="number">1</span>, tot, <span class="built_in">k</span>(u));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> &amp;u, Point x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!u)</span><br><span class="line">        &#123;</span><br><span class="line">            u = <span class="built_in">newnode</span>();</span><br><span class="line">            <span class="built_in">lc</span>(u) = <span class="built_in">rc</span>(u) = <span class="built_in">k</span>(u) = <span class="number">0</span>, <span class="built_in">p</span>(u) = x;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">up</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x.x[<span class="built_in">k</span>(u)] &lt;= <span class="built_in">p</span>(u).x[<span class="built_in">k</span>(u)]) <span class="built_in">ins</span>(<span class="built_in">lc</span>(u), x);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">ins</span>(<span class="built_in">rc</span>(u), x);</span><br><span class="line">        <span class="built_in">up</span>(u), <span class="built_in">check</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">bool</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> mx[D], <span class="keyword">int</span> mn[D], <span class="keyword">int</span> l[D], <span class="keyword">int</span> r[D])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; D; ++i) <span class="keyword">if</span> (r[i] &lt; mx[i] || l[i] &gt; mn[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">bool</span> <span class="title">out</span><span class="params">(<span class="keyword">int</span> mx[D], <span class="keyword">int</span> mn[D], <span class="keyword">int</span> l[D], <span class="keyword">int</span> r[D])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; D; ++i) <span class="keyword">if</span> (l[i] &gt; mx[i] || r[i] &lt; mn[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l[D], <span class="keyword">int</span> r[D])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!u || <span class="built_in">out</span>(<span class="built_in">mx</span>(u), <span class="built_in">mn</span>(u), l, r)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">in</span>(<span class="built_in">mx</span>(u), <span class="built_in">mn</span>(u), l, r)) <span class="keyword">return</span> <span class="built_in">sum</span>(u);</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">in</span>(<span class="built_in">p</span>(u).x, <span class="built_in">p</span>(u).x, l, r) ? <span class="built_in">p</span>(u).w : <span class="number">0</span>) + <span class="built_in">ask</span>(<span class="built_in">lc</span>(u), l, r) + <span class="built_in">ask</span>(<span class="built_in">rc</span>(u), l, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> op, x[D], y[D], last = <span class="number">0</span>; <span class="built_in">read</span>(op), op != <span class="number">3</span>; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(x[<span class="number">0</span>]), <span class="built_in">read</span>(x[<span class="number">1</span>]), <span class="built_in">read</span>(y[<span class="number">0</span>]), x[<span class="number">0</span>] ^= last, x[<span class="number">1</span>] ^= last, y[<span class="number">0</span>] ^= last;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) KDT::<span class="built_in">ins</span>(KDT::rt, &#123;x[<span class="number">0</span>], x[<span class="number">1</span>], y[<span class="number">0</span>]&#125;);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">read</span>(y[<span class="number">1</span>]), y[<span class="number">1</span>] ^= last, <span class="built_in">write</span>(last = KDT::<span class="built_in">ask</span>(KDT::rt, x, y)), <span class="built_in">putc</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">flus</span>(), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p>个人觉得 K-D Tree 难写、跑得慢且没太大用，不建议打</p>]]></content>
    
    
    <summary type="html">&lt;p&gt; 三维生物瑟瑟发抖&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数据结构" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树" scheme="https://dyd-true.github.io/tags/%E6%A0%91/"/>
    
    <category term="笔记" scheme="https://dyd-true.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="K-D Tree" scheme="https://dyd-true.github.io/tags/K-D-Tree/"/>
    
  </entry>
  
  <entry>
    <title>CF1523F Favorite Game</title>
    <link href="https://dyd-true.github.io/2022/02/06/CF1523F-Favorite-Game/"/>
    <id>https://dyd-true.github.io/2022/02/06/CF1523F-Favorite-Game/</id>
    <published>2022-02-06T09:09:20.000Z</published>
    <updated>2022-02-06T12:02:50.078Z</updated>
    
    <content type="html"><![CDATA[<p> 3300</p><span id="more"></span><p><a href="https://codeforces.com/problemset/problem/1523/F">Favorite Game</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>在平面直角坐标系 $xoy(\mid x, y \mid \le 10^6)$ 玩一个游戏， $0$ 时刻玩家出现在选则的点上，每秒可以走一步或者不动，有 $n \le 14$ 个传送门，初始时未激活，到达一个传送门时此传送门激活，之后可瞬移（不耗时）到这个传送门，有 $m \le 100$ 个任务要求玩家在 $t_i \le 10^9$ 时刻出现在 $(x_i, y_i)$ ，求最多可以完成几个任务</p><h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><p>明显，把传送门的状态压了，任务先按时间排序</p><p>分别考虑传送门和任务，令 <code>g[s][i]</code> 表示“传送门状态为 $s$ 完成了 $i$ 个任务，现在身处某一个传送门的最小时间”，令 <code>f[s][i]</code> 表示“传送门状态为 $s$ 刚完成了任务 $i$ 时可以完成的最大任务数”</p><p>对于每种传送门状态，预处理出它到每个地点（传送门和任务）的最短路程，分四种情况转移：</p><ul><li>传送门到传送门，直接用预处理</li><li>传送门到任务，判断可行后用预处理</li><li>任务到传送门，要么直接走要么用传送</li><li>任务到任务，要么直接走要么用传送，要判断可行</li></ul><p>时间为 $O(2^n m^2)$ </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STC static</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dis(a, b) (abs(a.x - b.x) + abs(a.y - b.y))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">14</span> + <span class="number">5</span>, M = <span class="number">100</span> + <span class="number">5</span>, NN = (<span class="number">1</span> &lt;&lt; <span class="number">14</span>) + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, nn, ans = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Door</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125; d[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Task</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, t;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Task&amp; task) <span class="keyword">const</span> &#123; <span class="keyword">return</span> t &lt; task.t; &#125;</span><br><span class="line">&#125; ta[M];</span><br><span class="line"><span class="keyword">int</span> td[NN][N], tt[NN][M]; <span class="comment">//td:to_door,tt:to_task</span></span><br><span class="line"><span class="keyword">int</span> f[NN][M], g[NN][M], lg2[NN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m), nn = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;d[i].x, &amp;d[i].y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;ta[i].x, &amp;ta[i].y, &amp;ta[i].t);</span><br><span class="line">    <span class="built_in">sort</span>(ta + <span class="number">1</span>, ta + <span class="number">1</span> + m);</span><br><span class="line">    <span class="built_in">memset</span>(td, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> td), <span class="built_in">memset</span>(tt, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> tt);</span><br><span class="line">    lg2[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= nn; ++i) lg2[i] = lg2[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>, j = <span class="built_in">lowbit</span>(s); s &lt; nn; ++s, j = <span class="built_in">lowbit</span>(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) td[s][i] = <span class="built_in">min</span>(td[s ^ j][i], <span class="built_in">dis</span>(d[lg2[j] + <span class="number">1</span>], d[i]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) tt[s][i] = <span class="built_in">min</span>(tt[s ^ j][i], <span class="built_in">dis</span>(d[lg2[j] + <span class="number">1</span>], ta[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0xcf</span>, <span class="keyword">sizeof</span> f), <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) g[<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>)][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) f[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; nn; ++s)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) <span class="keyword">if</span> (!((s &gt;&gt; (j - <span class="number">1</span>)) &amp; <span class="number">1</span>)) g[s ^ (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][i] = <span class="built_in">min</span>(g[s][i] + td[s][j], g[s ^ (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][i]); <span class="comment">//door to door</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) <span class="keyword">if</span> (g[s][i] + tt[s][j] &lt;= ta[j].t) f[s][j] = <span class="built_in">max</span>(i + <span class="number">1</span>, f[s][j]); <span class="comment">//door to task</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) <span class="keyword">if</span> (!((s &gt;&gt; (j - <span class="number">1</span>)) &amp; <span class="number">1</span>) &amp;&amp; f[s][i] &gt; <span class="number">0</span>) g[s ^ (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][f[s][i]] = <span class="built_in">min</span>(ta[i].t + <span class="built_in">min</span>(td[s][j], <span class="built_in">dis</span>(ta[i], d[j])), g[s ^ (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][f[s][i]]); <span class="comment">//task to door</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= m; ++j) <span class="keyword">if</span> (ta[i].t + <span class="built_in">min</span>(<span class="built_in">dis</span>(ta[i], ta[j]), tt[s][j]) &lt;= ta[j].t) f[s][j] = <span class="built_in">max</span>(f[s][j], f[s][i] + <span class="number">1</span>); <span class="comment">//task to task</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, f[s][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 3300&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="状态压缩" scheme="https://dyd-true.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="CF" scheme="https://dyd-true.github.io/tags/CF/"/>
    
  </entry>
  
  <entry>
    <title>CF1530F Bingo</title>
    <link href="https://dyd-true.github.io/2022/02/06/CF1530F-Bingo/"/>
    <id>https://dyd-true.github.io/2022/02/06/CF1530F-Bingo/</id>
    <published>2022-02-06T06:39:00.000Z</published>
    <updated>2022-02-06T09:02:14.564Z</updated>
    
    <content type="html"><![CDATA[<p> 最讨厌期望了</p><span id="more"></span><p><a href="https://codeforces.com/problemset/problem/1530/F">Bingo</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给 $n \times n$ 的矩阵，每个点有 $p_{i, j} \times 10^{-4}$ 的概率为 $1$ ，否则为 $0$ ，求存在某一行或者一列或者一条对角线全为 $1$ 的概率， $n \le 21$ </p><h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><p>先想暴力，设集合 $l_1, l_2, …, l_n$ 表示每一行的点集， $l_{n + 1}, …, l_{2n}$ 表示每一列的点集， $l_{2n + 1}, l_{2n + 2}$ 表示对角线，令 $P(l_i)$ 表示点集 $l_i$ 全为 $1$ 的概率， $P(\overline{l_i})$ 表示点集 $l_i$ 不全为 $1$ 的概率</p><p>明显可以用容斥 $O(2^{2n + 2})$ 暴力统计答案，但当然 TLE</p><p>先来看几条正确性显然的性质：</p><ol><li> $P(l_i) + P(\overline{l_i}) = 1$ </li><li> $P(A \wedge B) = P(B) P(A \mid B)$ ，其中 $A \mid B$ 表示在事件 $B$ 发生的条件下发生事件 $A$ </li><li> $P(\overline{A} \wedge B) + P (A \wedge B) = P(B)$ </li></ol><p>发现我们要求的就是 $P(l_1 \vee l_2 \vee … \vee l_{2n + 2}) = 1 - P(\overline{l_1} \wedge \overline{l_2} \wedge … \wedge \overline{l_{2n + 2}})$ ，然后变形：<br>$$<br>\begin{aligned}<br>&amp; P(\overline{l_1} \wedge \overline{l_2} \wedge … \wedge \overline{l_{2n + 2}}) + P(l_1 \wedge \overline{l_2} \wedge … \wedge \overline{l_{2n + 2}}) = P(\overline{l_2} \wedge … \wedge \overline{l_{2n + 2}}) &amp; (1) \\<br>&amp; P(l_1 \wedge \overline{l_2} \wedge … \wedge \overline{l_{2n + 2}}) = P(l_1) P(\overline{l_2} \wedge … \wedge \overline{l_{2n + 2}}) &amp; (2) \\<br>&amp; 由 (1) (2) 得: \\<br>&amp; P(\overline{l_1} \wedge \overline{l_2} \wedge … \wedge \overline{l_{2n + 2}}) = P(\overline{l_2} \wedge … \wedge \overline{l_{2n + 2}}) - P(l_1) P(\overline{l_2} \wedge … \wedge \overline{l_{2n + 2}}) &amp; (3) \\<br>\end{aligned}<br>$$<br>可以容斥来解释</p><p>考虑 dp ，定义 $d(i, S)$ 表示 $P(\overline{l_i} \wedge … \wedge \overline{l_{2n + 2}} \mid l_{s_1} \wedge … \wedge l_{s_k})$ ，即直线 $s \in S$ 全为 $1$ 而直线 $l_{i \sim 2n + 2}$ 不全为 $1$ 的概率，那么 $(3)$ 式可化为：<br>$$<br>\begin{aligned}<br>&amp; d(i, S) = d(i + 1, S) - d(i + 1, S \vee \{i\}) P(l_i \mid l_{s_1} \wedge … \wedge l_{s_k}) &amp; (4) \\<br>\end{aligned}<br>$$<br>观察这个式子， $P(l_i \mid l_{s_1} \wedge … \wedge l_{s_k})$ 可以 $O(n)$ 求，初始化为 $d(2n + 3, S) = 1$ ，答案就是 $1 - d(1, 0)$ ，时间为 $O(n \times (2n + 2) \times 2^{2n + 2})$ ，这不爆炸，还不如暴力</p><p>看来还得加点容斥，我们暴力枚举行的情况，有 $2^n$ 种（要么 $l_i$ 要么 $\overline{l_i}$ ），然后考虑列（下面的 $i$ 就只代表列了）， $(4)$ 式可化为：<br>$$<br>\begin{aligned}<br>&amp; d(i, S) = d(i + 1, S) - d(i + 1, S) P(l_i \mid l_{s_1} \wedge … \wedge l_{s_k}) \\<br>\end{aligned}<br>$$<br>这是因为我们现在只考虑列，把当前列加入 $S$ 对后面的列没有影响，所有可以干脆不加，则 $S$ 中始终只有我们枚举出的行（要注意此时求出的 $d$ 已经不一样了，因为行我们是枚举的，其概率还没加到 $d$ 中），这样，在枚举了行后，列可以 $O(n^2)$ 计算，这里有一个 $n$ 是求 $P(l_i \mid l_{s_1} \wedge … \wedge l_{s_k})$ 的，这可以预处理成 $O(1)$ ，具体地，设 $mul(i, S)$ 表示“对于第 $i$ 列，行选则情况为 $S$ 的时候，这些行与第 $i$ 列的相交的格子的乘积”，且设 $U$ 为行集合的全集，则有：<br>$$<br>\begin{aligned}<br>&amp; d(i, S) = d(i + 1, S) - d(i + 1, S) \times mul(i, U - S) \\<br>\end{aligned}<br>$$<br>但上面说了，时求出的 $d$ 已经不一样了，为了加上行选择的情况的概率，还要乘一个 $mul(i, S)$ ，同时，发现第一维完全可以省略，即：<br>$$<br>\begin{aligned}<br>&amp; d(S) = (d(S) - d(S) \times mul(i, U - S)) \times nul(i, S) \\<br>&amp; d(S) = (1 - mul(i, U - S)) \times mul(i, S) \times d(S) &amp; (5) \\<br>\end{aligned}<br>$$<br>这样，列的 dp 就是 $O(n)$ 的了</p><p>然后我们再明确一下行的影响，行是枚举的，计算时要用容斥，就是： $1 - d(至少 1 行全为 1) + d(至少 2 行全为 1) - …$ ， dp 贡献时加个系数即可</p><p>最后考虑一下对角线，由于只有两条，可以和行一样枚举它们的情况，把它当成一种特殊的行（具体见代码）</p><p>考虑时间，枚举容斥是 $O(2^{n + 2})$ ， dp 是 $O(n)$ 的，最后就是 $O(n 2^{n + 2})$ </p><p>ps：模数 $31607$ 是质数， $10^4$ 在其意义下的逆元为 $3973$ </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STC static</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x) &amp; -(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">21</span> + <span class="number">5</span>, P = <span class="number">31607</span>, INV = <span class="number">3973</span>, NN = (<span class="number">1</span> &lt;&lt; <span class="number">21</span>) + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, nn, p[N][N], ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> lg2[NN], mul[N][NN];</span><br><span class="line"><span class="keyword">int</span> d[NN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prev</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lg2[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= nn; ++i) lg2[i] = lg2[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, s, j; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (mul[i][<span class="number">0</span>] = <span class="number">1</span>, s = <span class="number">1</span>; s &lt; nn; ++s) mul[i][s] = (LL)mul[i][s ^ (j = <span class="built_in">lowbit</span>(s))] * p[lg2[j] + <span class="number">1</span>][i]% P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cntbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res; </span><br><span class="line">    <span class="keyword">for</span> (res = <span class="number">1</span>; x; x &amp;= (x - <span class="number">1</span>), ++res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), nn = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p[i][j]), p[i][j] = (LL)p[i][j] * INV % P;</span><br><span class="line">    <span class="built_in">prev</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt;= <span class="number">3</span>; ++t) <span class="comment">//t枚举对角线的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; nn; ++s) d[s] = (<span class="built_in">cntbit</span>(s) + <span class="built_in">cntbit</span>(t)) &amp; <span class="number">1</span> ? <span class="number">-1</span> : <span class="number">1</span>; <span class="comment">//容斥系数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>, _s; s &lt; nn; ++s)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//加上对角线</span></span><br><span class="line">                _s = s;</span><br><span class="line">                <span class="keyword">if</span> (t &amp; <span class="number">1</span>) _s |= <span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (t &amp; <span class="number">2</span>) _s |= <span class="number">1</span> &lt;&lt; (n - i);</span><br><span class="line">                d[s] = (LL)d[s] * mul[i][_s] % P * (<span class="number">1</span> - mul[i][(nn - <span class="number">1</span>) ^ _s] + P) % P;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; nn; ++s) ans = (ans + d[s]) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (<span class="number">1</span> - ans + P) % P);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 最讨厌期望了&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="状态压缩" scheme="https://dyd-true.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="CF" scheme="https://dyd-true.github.io/tags/CF/"/>
    
    <category term="容斥" scheme="https://dyd-true.github.io/tags/%E5%AE%B9%E6%96%A5/"/>
    
  </entry>
  
  <entry>
    <title>CF1584F Strange LCS</title>
    <link href="https://dyd-true.github.io/2022/02/06/CF1584F-Strange-LCS/"/>
    <id>https://dyd-true.github.io/2022/02/06/CF1584F-Strange-LCS/</id>
    <published>2022-02-06T02:32:28.000Z</published>
    <updated>2022-02-06T06:38:07.153Z</updated>
    
    <content type="html"><![CDATA[<p> CF来到2600</p><span id="more"></span><p> <a href="https://codeforces.com/problemset/problem/1584/F">Strange LCS</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>$T \le 5$ 组数据，给定 $n \le 10$ 个字符串，字符集为大、小写字母且每个字符在同一个串中最多出现两次，求它们的LCS（最长公共子串）</p><h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><p>暴力做法就类似两个串的LCS，直接 $10$ 维dp，时间……</p><p>发现有信息没用：字符集为大、小写字母且<strong>每个字符在同一个串中最多出现两次</strong></p><p>先考虑如果每个字符只出现一次怎么办，由于字符集不大，可以考虑设计状态为 <code>d[ch]</code> 表示“以**字符 $ch$ **结尾的前缀子串的LCS”，方程明显为 $d[i] = \max(d[j]) + 1$  ，这里要保证在所有串中字符 $j$ 都在字符 $i$ 的前面，关于字符的位置可以预处理</p><p>现在，字符出现了两次，当然可以延续上面的做法，预处理字符的位置，把状态设计为“以字符 $ch$ 结尾的前缀子串的LCS”，但同时我们必须知道这个字符在每个串中是第几次出现，考虑状压，用一个二进制数 $s$ 表示在每个串中是第几次出现，则状态 <code>d[ch][s]</code> 表示“以字符 $ch$ 在第 $i$ 个串中第 $k_i$ 次出现结尾的前缀子串的LCS”，其中 $k_i$  是 $s$ 中压缩的信息， $k_i = 0 / 1$  表示第 $1 / 2$ 次出现</p><p>转移的时候有个贪心：可以从 $k_i = 1$ 转移就不必从 $k_i = 0$ 转移，因为第 $2$ 次出现一定在第 $1$ 次后面，以它结尾的前缀子串一定包含了第 $1$ 次，所以转移时，设当前转移为 $d[ch][s] \gets d[j][t]$ ，直线枚举字符 $j$ ，若在串 $i$ 中字符 $ch$ 前有两个 $j$ 就从 $k_i = 1$ 转移，有一个就从 $k_i = 0$ 转移，换句话说，我们在枚举 $j$ 时就确定了 $t$ </p><p>考虑时间，设字符集大小为 $V$ 状态有 $V \times 2^n$ 个，每次转移要枚举字符 $j$ 并 $O(n)$ 得到 $t$ ，故时间为 $O(V \times 2^n \times V \times n) = O(V^2 2^n n)$ </p><p>由于判断较多，具体实现可以考虑记忆化搜索</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>稍微压了压行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STC static</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span> + <span class="number">5</span>, NN = (<span class="number">1</span> &lt;&lt; <span class="number">10</span>) + <span class="number">5</span>, V = <span class="number">52</span> + <span class="number">5</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, pos[N][V][<span class="number">2</span>], d[V][NN], fr1[V][NN], fr2[V][NN]; <span class="comment">//fr记录来向</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d[ch][s] != <span class="number">-1</span>) <span class="keyword">return</span> d[ch][s];</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j, t; i &lt; V; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>, t = <span class="number">0</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (pos[j][i][<span class="number">0</span>] &gt;= pos[j][ch][(s &gt;&gt; (j - <span class="number">1</span>)) &amp; <span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pos[j][i][<span class="number">1</span>] &lt; pos[j][ch][(s &gt;&gt; (j - <span class="number">1</span>)) &amp; <span class="number">1</span>]) t |= <span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (j &gt; n &amp;&amp; <span class="built_in">dp</span>(i, t) &gt;= mx) mx = d[i][t] + <span class="number">1</span>, fr1[ch][s] = i, fr2[ch][s] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[ch][s] = mx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">(<span class="keyword">int</span> id1, <span class="keyword">int</span> id2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fr1[id1][id2] != <span class="number">-1</span>) <span class="built_in">out</span>(fr1[id1][id2], fr2[id1][id2]);</span><br><span class="line">    <span class="keyword">if</span> (id1 &lt; <span class="number">26</span>) <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, id1 + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, id1 + <span class="string">&#x27;A&#x27;</span> - <span class="number">26</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T, mx, mxid1, mxid2;</span><br><span class="line">    STC <span class="keyword">char</span> s[V &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        mx = <span class="number">0</span>, mxid1 = mxid2 = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//这里要是极大</span></span><br><span class="line">        <span class="built_in">memset</span>(pos, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> pos), <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d), <span class="built_in">memset</span>(fr1, <span class="number">-1</span>, <span class="keyword">sizeof</span> fr1);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j, len; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>), j = <span class="number">1</span>, len = <span class="built_in">strlen</span>(s + <span class="number">1</span>); j &lt;= len; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[j] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; s[j] &lt;= <span class="string">&#x27;z&#x27;</span>) s[j] -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span> s[j] += <span class="number">26</span> - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (pos[i][s[j]][<span class="number">0</span>] &gt;= INF) pos[i][s[j]][<span class="number">0</span>] = j;</span><br><span class="line">                <span class="keyword">else</span> pos[i][s[j]][<span class="number">1</span>] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j, t; i &lt; V; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>, t = <span class="number">0</span>; j &lt;= n; ++j)</span><br><span class="line">                <span class="keyword">if</span> (pos[j][i][<span class="number">0</span>] &gt;= INF) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pos[j][i][<span class="number">1</span>] &lt; INF) t |= <span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (j &gt; n &amp;&amp; <span class="built_in">dp</span>(i, t) &gt;= mx) mx = d[i][t] + <span class="number">1</span>, mxid1 = i, mxid2 = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, mx);</span><br><span class="line">        <span class="keyword">if</span> (mxid1 != <span class="number">-1</span>) <span class="built_in">out</span>(mxid1, mxid2);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; CF来到2600&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="字符串" scheme="https://dyd-true.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="状态压缩" scheme="https://dyd-true.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="CF" scheme="https://dyd-true.github.io/tags/CF/"/>
    
  </entry>
  
  <entry>
    <title>luoguAT2390 [AGC016F] Games on DAG</title>
    <link href="https://dyd-true.github.io/2022/02/06/luoguAT2390-AGC016F-Games-on-DAG/"/>
    <id>https://dyd-true.github.io/2022/02/06/luoguAT2390-AGC016F-Games-on-DAG/</id>
    <published>2022-02-06T00:39:15.000Z</published>
    <updated>2022-02-06T08:50:57.077Z</updated>
    
    <content type="html"><![CDATA[<p> 万能的高橋君</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/AT2390">Games on DAG</a></p><p>明显的博弈论，考虑 SG 函数，结论是当初始局面的 SG 为 $0$ 时先手必败，而初始局面的 $SG = SG(1) \oplus SG(2)$ </p><p>于是考虑计算 $SG(1) = SG(2)$ 的方案数，最后减掉，由于 $n \le 15$ ，可以枚举点集 $S$ ，设 $T$ 是 $S$ 的子集且 $\forall x \in T, SG(x) \ne 0$ （即 $T$ 为必胜点），设 $U = S - T$ （即 $U$ 为必败点， $SG = 0$ ），对于记当前点集 $S$ 满足 $SG(1) = SG(2)$ 的方案数为 $d[S]$ </p><p>由于 SG 函数定义在 mex 上，有：</p><ul><li> $U$ 中的点间互相不连边</li><li> $T$ 中的每个点至少有一条边连向 $U$ </li><li> $U$ 中的点连向 $T$ 是没有限制的</li></ul><p>那么怎么转移呢？考虑 $S$ 的连边方案， $U$ 中的点间没边， $U, T$ 间连边的方案数设为 $tmp$ 可以算，对于 $T$ 间的边，不难发现方案数就是 $d[T]$ （这是因为原来 $d[T]$ 上的每个点都向 $U$ 连边，构成的方案一定合法；而所有点集 $S$ 的合法方案去掉 SG 为 $0$ 的点后也一定会得到一个点集 $T$ 的合法方案），故有 $d[S] \gets d[T] * tmp$  </p><p> 还有一个小知识点：统计一个数的二进制中有多少个 $1$ </p><p>直接统计当然是 $\log n$ 的，但还有一个小技巧，就是每次让 <code>n = n &amp; (n - 1)</code> 不难发现这样操作 $1$ 次后 $n$ 二进制下最低的一个 $1$ 变成了 $0$ ，于是时间为 $O(k)$ ，其中 $k$ 是二进制下 $1$ 的个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STC static</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get(x, o) (((x) &gt;&gt; (o - 1)) &amp; 1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>, M = <span class="number">15</span> * <span class="number">7</span> + <span class="number">5</span>,  NN = (<span class="number">1</span> &lt;&lt; <span class="number">15</span>) + <span class="number">5</span>, P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">for</span> (res = <span class="number">0</span>; x; x &amp;= (x - <span class="number">1</span>), ++res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, nn;</span><br><span class="line">    STC <span class="keyword">int</span> e[N], d[NN], pow2[M];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    nn = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">    d[<span class="number">0</span>] = pow2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="comment">//预处理2^i</span></span><br><span class="line">        pow2[i] = (pow2[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>) % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v), e[u] |= (<span class="number">1</span> &lt;&lt; (v - <span class="number">1</span>)); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>, tmp; s &lt; nn; ++s)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">get</span>(s, <span class="number">1</span>) == <span class="built_in">get</span>(s, <span class="number">2</span>)) <span class="comment">//保证1和2的点的状态相同</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> u = s; u; u = s &amp; (u - <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">get</span>(u, <span class="number">1</span>) == <span class="built_in">get</span>(u, <span class="number">2</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">get</span>(s, i))</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (<span class="built_in">get</span>(u, i))</span><br><span class="line">                                tmp = (LL)tmp * pow2[<span class="built_in">countbit</span>(e[i] &amp; (s ^ u))] % P;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                tmp = (LL)tmp * (pow2[<span class="built_in">countbit</span>(e[i] &amp; u)] - <span class="number">1</span>) % P;</span><br><span class="line">                        &#125;</span><br><span class="line">                    d[s] = (d[s] + (LL)d[s ^ u] * tmp % P) % P;</span><br><span class="line">                &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (pow2[m] - d[nn - <span class="number">1</span>] + P) % P);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 万能的高橋君&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="状态压缩" scheme="https://dyd-true.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="AtCoder" scheme="https://dyd-true.github.io/tags/AtCoder/"/>
    
  </entry>
  
  <entry>
    <title>luoguP5243 [USACO19FEB]Moorio Kart P</title>
    <link href="https://dyd-true.github.io/2022/02/05/luoguP5243-USACO19FEB-Moorio-Kart-P/"/>
    <id>https://dyd-true.github.io/2022/02/05/luoguP5243-USACO19FEB-Moorio-Kart-P/</id>
    <published>2022-02-05T12:40:19.000Z</published>
    <updated>2022-02-06T00:37:19.048Z</updated>
    
    <content type="html"><![CDATA[<p> 过年玩疯了，来做个题</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P5243">Moorio Kart P</a></p><h2 id="简化题意"><a href="#简化题意" class="headerlink" title="简化题意"></a>简化题意</h2><p>给 $n$ 个点 $m$ 条边的森林，边有权，设有 $k$ 棵树，现在要添加 $k$ 条权为 $x$ 的边，使图上形成一个权值和大于 $y$ 的环，且原森林中的每棵树在该环上<strong>至少</strong>有一条边，求方案数，对 $10^9 + 7$ 取模， $n \le 1500, m \le n - 1, x, y \le 2500$ </p><h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><p>由于树上两点间有唯一路径，所以考虑统计出每棵树上所以的路径，然后就转化成了背包</p><p>设 <code>d[i][0/1]</code> 表示“构成权值和为 $i$ 的环的方案数/长度和”， <code>g[i][0/1]</code> 表示“当前小树内长度为 $i$ 的路径数/长度和”，有：<br>$$<br>\begin{aligned}<br>&amp; d[i + j][0] \gets d[i][0] * g[j][0] \\<br>&amp; d[i + j][1] \gets d[i][0] * g[j][1] + d[i][1] * g[j][0]<br>\end{aligned}<br>$$<br>直接dp，时间为……我也不造？卡卡能过</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DB double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STC static</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IL inline</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Fast</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> L = (<span class="number">1</span> &lt;&lt; <span class="number">20</span>) + <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[L], out[L], *iS, *iT;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> gh() (iT == iS ? iT = (iS = buf) + fread(buf, 1, L, stdin), (iT == iS ? EOF : *iS++) : *iS++)</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;class T&gt; </span></span><br><span class="line"><span class="function">    IL <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = <span class="built_in">gh</span>(), t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            t |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">gh</span>();</span><br><span class="line">        <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            x = x * <span class="number">10</span> + (ch ^ <span class="number">48</span>), ch = <span class="built_in">gh</span>();</span><br><span class="line">        <span class="keyword">if</span> (t)</span><br><span class="line">            x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">flus</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">fwrite</span>(out, <span class="number">1</span>, l, stdout);</span><br><span class="line">        l = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">putc</span><span class="params">(<span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        out[l++] = x;</span><br><span class="line">        <span class="keyword">if</span> (l == L - <span class="number">5</span>)</span><br><span class="line">            <span class="built_in">flus</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function">    IL <span class="keyword">void</span> <span class="title">write</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">putc</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">9</span>)</span><br><span class="line">            <span class="built_in">write</span>(x / <span class="number">10</span>);</span><br><span class="line">        out[l++] = x % <span class="number">10</span> + <span class="number">48</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == L - <span class="number">5</span>)</span><br><span class="line">            <span class="built_in">flus</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Fast::flus;</span><br><span class="line"><span class="keyword">using</span> Fast::putc;</span><br><span class="line"><span class="keyword">using</span> Fast::read;</span><br><span class="line"><span class="keyword">using</span> Fast::write;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1500</span> + <span class="number">5</span>, P = <span class="number">1e9</span> + <span class="number">7</span>, V = <span class="number">2500</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, X, Y;</span><br><span class="line"><span class="keyword">int</span> fa[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Egde</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ne, ver, w;</span><br><span class="line">&#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> h[N], idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>, bel[N];</span><br><span class="line"><span class="keyword">int</span> g[N][V][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> d[V][<span class="number">2</span>], last[V][<span class="number">2</span>];</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = &#123;h[x], y, z&#125;, h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">dfscol</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> ff, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bel[x] = col;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">        <span class="keyword">if</span> (e[i].ver != ff)</span><br><span class="line">            <span class="built_in">dfscol</span>(e[i].ver, x, col);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">dfslen</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> ff, <span class="keyword">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ff != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        g[bel[x]][<span class="built_in">min</span>(Y, l)][<span class="number">1</span>] += l;</span><br><span class="line">        g[bel[x]][<span class="built_in">min</span>(Y, l)][<span class="number">1</span>] %= P;</span><br><span class="line">        ++g[bel[x]][<span class="built_in">min</span>(Y, l)][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">        <span class="keyword">if</span> (e[i].ver != ff)</span><br><span class="line">            <span class="built_in">dfslen</span>(e[i].ver, x, l + e[i].w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">int</span> <span class="title">fac</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x; ++i)</span><br><span class="line">        res = (LL)res * i % P;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(m), <span class="built_in">read</span>(X), <span class="built_in">read</span>(Y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        fa[i] = i, h[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, w; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(u), <span class="built_in">read</span>(v), <span class="built_in">read</span>(w);</span><br><span class="line">        <span class="built_in">add</span>(u, v, w), <span class="built_in">add</span>(v, u, w);</span><br><span class="line">        fa[<span class="built_in">find</span>(u)] = <span class="built_in">find</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(i) == i)</span><br><span class="line">            ++cnt, <span class="built_in">dfscol</span>(i, <span class="number">-1</span>, cnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">dfslen</span>(i, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> st = <span class="built_in">min</span>(X * cnt, Y);</span><br><span class="line">    d[st][<span class="number">0</span>] = <span class="number">1</span>, d[st][<span class="number">1</span>] = X * cnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = st; j &lt;= Y; ++j)</span><br><span class="line">            last[j][<span class="number">0</span>] = d[j][<span class="number">0</span>], last[j][<span class="number">1</span>] = d[j][<span class="number">1</span>], d[j][<span class="number">0</span>] = d[j][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= Y; ++j)</span><br><span class="line">            <span class="keyword">if</span> (g[i][j][<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = st; k &lt;= Y; ++k)</span><br><span class="line">                    <span class="keyword">if</span> (last[k][<span class="number">0</span>])</span><br><span class="line">                    &#123;</span><br><span class="line">                        d[<span class="built_in">min</span>(j + k, Y)][<span class="number">0</span>] = (d[<span class="built_in">min</span>(j + k, Y)][<span class="number">0</span>] + (LL)last[k][<span class="number">0</span>] * g[i][j][<span class="number">0</span>]) % P;</span><br><span class="line">                        d[<span class="built_in">min</span>(j + k, Y)][<span class="number">1</span>] = (d[<span class="built_in">min</span>(j + k, Y)][<span class="number">1</span>] + (LL)last[k][<span class="number">0</span>] * g[i][j][<span class="number">1</span>] + (LL)last[k][<span class="number">1</span>] * g[i][j][<span class="number">0</span>]) % P;</span><br><span class="line">                    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (LL)d[Y][<span class="number">1</span>] * <span class="built_in">fac</span>(cnt - <span class="number">1</span>) % P * ((P + <span class="number">1</span>) / <span class="number">2</span>) % P);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">flus</span>(), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 过年玩疯了，来做个题&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="USACO" scheme="https://dyd-true.github.io/tags/USACO/"/>
    
    <category term="暴力" scheme="https://dyd-true.github.io/tags/%E6%9A%B4%E5%8A%9B/"/>
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>gcd</title>
    <link href="https://dyd-true.github.io/2022/02/05/gcd/"/>
    <id>https://dyd-true.github.io/2022/02/05/gcd/</id>
    <published>2022-02-05T12:17:10.000Z</published>
    <updated>2022-02-05T12:20:45.525Z</updated>
    
    <content type="html"><![CDATA[<p> 黑科技？</p><span id="more"></span><h1 id="gcd"><a href="#gcd" class="headerlink" title="gcd"></a>gcd</h1><h2 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法"></a>辗转相除法</h2><p>求 $2$ 个数的gcd时间为 $O(\log{\frac{\min(a, b)}{\gcd(a, b)}})$ </p><p>求 $n$ 个数的gcd时间为 $O(n + \log V)$ </p><h2 id="高精-取模"><a href="#高精-取模" class="headerlink" title="高精+取模"></a>高精+取模</h2><ol><li>若 $2 \mid a \wedge 2 \mid b$ ，则 $\gcd(a, b) = 2 \gcd(\frac{a}{2}, \frac{b}{2})$ </li><li>若 $2 \mid a \wedge 2 \not\mid b(2 \not\mid a \wedge 2 \mid b)$ ，则 $\gcd(a, b) = \gcd(\frac{a}{2}, b)$ </li><li> 若 $2 \not\mid a \wedge 2 \not\mid b$ ，则 $\gcd(a, b) = \gcd(a - b, b)$ </li></ol><p>不难发现时间为 $O(\log n)$ </p><h2 id="正题：预处理法"><a href="#正题：预处理法" class="headerlink" title="正题：预处理法"></a>正题：预处理法</h2><p>$O(n)$ 预处理， $O(1)$ 查询小于等于 $n$ 的gcd</p><h3 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h3><p>对于任意数 $n$ 存在分解 $n = abc$ 满足 $a, b, c$ 要么是质数，要么 $\le \sqrt{n}$ </p><p>证明：</p><ol><li>若 $n$ 存在一个 $&gt; \sqrt{n}$ 的质因数，显然成立</li><li>若 $n$ 的质因数全都 $\le \sqrt{n}$ ，取出 $n$ 的最小质因数 $p$ ：<ul><li>若 $p &gt; \sqrt[4]{n}$ ，显然 $n$ 的其它质因数也 $&gt; \sqrt[4]{n}$ ，那么只要把 $n$ 分解质数即可（ $n$ 决不会有大于 $3$ 个质因数）</li><li>否则我们求出  $\frac{n}{p}$ 的分解 $a’, b’, c’$ ，设其中最小的是 $a’$ （明显它 $\le \sqrt[3]{\frac{n}{p}}$ ），可得 $a’p \le \sqrt[3]{\frac{n}{p}} p = \sqrt[3]{np^2} \le \sqrt[3]{n \sqrt{n}} = \sqrt{n}$ ，则 $n$ 的分解为 $a’p, b’, c’$ </li></ul></li></ol><p>证明同时也给出了分解的求法</p><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>求出 $\le \sqrt{n}$ 的所有数的两两的gcd，具体的， <code>g[a][b] = g[b][a % b]</code> ，可以做到 $O((\sqrt{n})^2) = O(n)$ </p><p>还要求出所有数的分解，这可以先线性筛，然后用证明的方法求</p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>设求 $x = abc, y$ 的gcd，可以把 $a, b, c$ 和 $y$ 合并，以 $a$ 为例：</p><ol><li>若 $a &gt; \sqrt{n}$  ，则 $a$ 为质数，去 $2$ </li><li>若 $a$ 为质数，判 <code>y % a</code> 即可</li><li>否则， $\gcd(y, a) = \gcd(y \mod a, a)$ 直接调用预处理</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><a href="https://darkbzoj.tk/problem/4454">C Language Practice</a></p><p>然而因为卡空间，这份代码并不能过（要把 <code>fen</code> 的下标改成从 $0$  开始）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STC static</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000</span> + <span class="number">5</span>, V = <span class="number">1000000</span> + <span class="number">5</span>, W = <span class="number">1000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> g[W][W], fen[V][<span class="number">4</span>];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; pri;</span><br><span class="line"><span class="keyword">int</span> num[V];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prev</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; W; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j)</span><br><span class="line">            g[i][j] = g[j][i] = ((i &amp;&amp; j) ? g[j][i % j] : (i | j));</span><br><span class="line">    num[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; V; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!num[i])</span><br><span class="line">            pri.<span class="built_in">push_back</span>(i), num[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j : pri)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; num[i] || j * i &gt;= V)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            num[i * j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fen[<span class="number">1</span>][<span class="number">1</span>] = fen[<span class="number">1</span>][<span class="number">2</span>] = fen[<span class="number">1</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; V; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        fen[i][<span class="number">1</span>] = fen[i / num[i]][<span class="number">1</span>];</span><br><span class="line">        fen[i][<span class="number">2</span>] = fen[i / num[i]][<span class="number">2</span>];</span><br><span class="line">        fen[i][<span class="number">3</span>] = fen[i / num[i]][<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">if</span> (fen[i][<span class="number">1</span>] * num[i] &lt; W)</span><br><span class="line">            fen[i][<span class="number">1</span>] *= num[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (fen[i][<span class="number">2</span>] * num[i] &lt; W)</span><br><span class="line">            fen[i][<span class="number">2</span>] *= num[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            fen[i][<span class="number">3</span>] *= num[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> _gcd(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; W &amp;&amp; y &lt; W)</span><br><span class="line">        <span class="keyword">return</span> g[x][y];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!x || !y)</span><br><span class="line">        <span class="keyword">return</span> x | y;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, t; i &lt;= <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fen[x][i] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> ((t = fen[x][i]) == num[t])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (y % t == <span class="number">0</span>)</span><br><span class="line">                y /= t, res *= t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t = g[t][y % t], y /= t, res *= t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">prev</span>();</span><br><span class="line">    <span class="keyword">int</span> T, n, m;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ans;</span><br><span class="line">    STC <span class="keyword">int</span> a[N], b[N];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">                ans += _gcd(a[i], b[j]) ^ (i - <span class="number">1</span>) ^ (j - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 黑科技？&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数论,数学" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
    <category term="笔记" scheme="https://dyd-true.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>松氏基排</title>
    <link href="https://dyd-true.github.io/2022/01/26/%E6%9D%BE%E6%B0%8F%E5%9F%BA%E6%8E%92/"/>
    <id>https://dyd-true.github.io/2022/01/26/%E6%9D%BE%E6%B0%8F%E5%9F%BA%E6%8E%92/</id>
    <published>2022-01-26T03:01:38.000Z</published>
    <updated>2022-01-26T03:27:55.094Z</updated>
    
    <content type="html"><![CDATA[<p> 递归式学习3</p><span id="more"></span><h1 id="松氏基排"><a href="#松氏基排" class="headerlink" title="松氏基排"></a>松氏基排</h1><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序（Radix sort）是一种非比较型的排序算法，它的工作原理是将待排序的元素拆分为 $k$ 个关键字（比较两个元素时，先比较第一关键字，如果相同再比较第二关键字……），然后先对第 $k$ 关键字进行稳定排序，再对第 $k - 1$ 关键字进行稳定排序，再对第 $k - 2$ 关键字进行稳定排序……最后对第一关键字进行稳定排序，这样就完成了对整个待排序序列的稳定排序</p><p><img src="https://s2.loli.net/2022/01/26/FDZeXLCouKpSnWq.png" alt="radix sort"></p><p>如图，要对这些数字排序，我们以百位为第一关键字，十位为第二关键字，个位为第三关键字</p><p>先用第三关键字（个位）稳定排序，再用十位、百位，最后就得出答案</p><p>基数排序需要借助一种<strong>稳定算法</strong>完成内层对关键字的排序，一般是桶排</p><p>当然，一般来说可不会以 $10$ 为基数，因为这样一个 <code>int</code> 要排 $9$ 遍，太麻烦</p><h2 id="松式基排"><a href="#松式基排" class="headerlink" title="松式基排"></a>松式基排</h2><p>那基数取多少好呢？</p><p>一般基排取的是 $65536$ （ $2^{16}$ ），空间开的下，只用排两遍</p><p>可wys大佬说，取 $256$ ，用位运算把一个数拆成四部分，要排四遍，但这样的话 <code>cnt</code> 数组刚好能装进 $L1$ 高速缓存（我也不知道那是啥）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STC static</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> geted(x, d) (((x) &gt;&gt; ((d) * Bit)) &amp; (R - 1))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Bit = <span class="number">8</span>, R = <span class="number">256</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radix_sort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    STC <span class="keyword">int</span> cnt[R], t[N];</span><br><span class="line">    <span class="keyword">int</span> *x = a, *y = t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; ++d)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; ++i)</span><br><span class="line">            cnt[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            ++cnt[<span class="built_in">geted</span>(x[i], d)];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; R; ++i)</span><br><span class="line">            cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">            y[--cnt[<span class="built_in">geted</span>(x[i], d)]] = x[i];</span><br><span class="line">        <span class="built_in">swap</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        a[i] = x[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">radix_sort</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 递归式学习3&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="排序" scheme="https://dyd-true.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>jarvis步进法</title>
    <link href="https://dyd-true.github.io/2022/01/26/jarvis%E6%AD%A5%E8%BF%9B%E6%B3%95/"/>
    <id>https://dyd-true.github.io/2022/01/26/jarvis%E6%AD%A5%E8%BF%9B%E6%B3%95/</id>
    <published>2022-01-26T02:40:17.000Z</published>
    <updated>2022-01-26T03:03:33.806Z</updated>
    
    <content type="html"><![CDATA[<p> 递归式学习2</p><span id="more"></span><h1 id="jarvis步进法"><a href="#jarvis步进法" class="headerlink" title="jarvis步进法"></a>jarvis步进法</h1><p>又名卷包裹法，是一种求凸包的算法，时间为 $O(n H)$ （ $H$ 为凸包上的点数）</p><p>一般来说很不常用，但总有些毒瘤要考</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>卷包裹就行了，从左下角（一定在凸包内的点）开始，想象一条线，线的一端固定在当前点上，把线竖直向凸包外拉使其绷紧（此时线上只有左下角的点），再逆时针旋转直到碰到一个点，这个点就是新的当前点，一直下去直到线包裹整个图形</p><p>代码就咕了，反正也几乎用不到，我要回溯了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt; 递归式学习2&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算几何" scheme="https://dyd-true.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
    <category term="凸包" scheme="https://dyd-true.github.io/tags/%E5%87%B8%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>闵可夫斯基和</title>
    <link href="https://dyd-true.github.io/2022/01/26/%E9%97%B5%E5%8F%AF%E5%A4%AB%E6%96%AF%E5%9F%BA%E5%92%8C/"/>
    <id>https://dyd-true.github.io/2022/01/26/%E9%97%B5%E5%8F%AF%E5%A4%AB%E6%96%AF%E5%9F%BA%E5%92%8C/</id>
    <published>2022-01-25T23:53:25.000Z</published>
    <updated>2022-01-26T02:41:05.566Z</updated>
    
    <content type="html"><![CDATA[<p> 递归式学习</p><span id="more"></span><h1 id="闵可夫斯基和"><a href="#闵可夫斯基和" class="headerlink" title="闵可夫斯基和"></a>闵可夫斯基和</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>比较严谨的定义：两个图形 $A, B$ 的闵可夫斯基和 $C = \{a + b |a \in A, b \in B \}$ </p><p>我的李姐：对于图形 $A$ 中每个点和图形 $B$ 中每个点两两求和（ $(x_a, y_a) + (x_b, y_b) = (x_a + x_b, y_a + y_b)$ ）</p><p>盗张图：<img src="https://s2.loli.net/2022/01/26/LEFlZoq7YCzudve.png" alt="闵可夫斯基和"></p><p>粉色区域是三角形和一个不规则四边形的闵可夫斯基和</p><h2 id="有啥用"><a href="#有啥用" class="headerlink" title="有啥用"></a>有啥用</h2><p>当然说有用我才来递归式学习的了</p><p>一般用在求凸包上，就以我学这个东西的目的为例吧（顺便说说凸包有啥用）</p><p>比如，我们维护了区间和，区间最大后缀和，区间最大前缀和，区间最大子段和分别取名叫 $sum, lmx, rmx, mx$ </p><p>现在我们要区间加 $k$ ，怎么维护？最简单的是 $sum$  就不管了</p><p>较难的是 $lmx, rmx$ ，以 $rmx$ 为例（注意它是区间最大<strong>前缀和</strong>，取名为 $r$ 只是因为它在右子树），我们要维护函数 $y = pre(x) + k * x$ 的最大值，其中 $pre(x)$  代表 $[l, x]$ 的和（前缀和）；考虑斜率优化，我们将函数化为 $pre(x) = kx + y$ ，就是把 $(x, pre(x))$ 看做是一个个点，把斜率为 $k$ 的直线带入这一个个点中，最大化截距，不难发现这就是在凸包上二分切点，因为此时凸包中的所有点都在直线的一侧，自然是在直线上的点代进去之后截距最大</p><p>而最毒瘤的就是 $mx$ 了，仿造上面，写出式子： $y = as(x) + k * x$ ，其中 $as(x)$ 代表长度为 $x$ 的最大子段和，但是，求出 $as(x)$ 是 $n^2$ 的，有救吗？有救</p><p>考虑分治，我们关心的就是 $(x, as(x))$ 这个点集构成的凸包，不妨来看看 $mx$ 的推导式（在线段树上用过无数次的那个）： <code>mx[l][r] = max(mx[l][mid], mx[mid + 1][r], lmx[l][mid] + r[mid + 1][r])</code> ，发现前两个可以直接递归求 $[l, mid]$ 和 $[mid + 1, r]$ 的凸包解决，麻烦的是最后那个求和的式子，不难发现它代表的是“跨过 $mid$ 的区间”</p><p>考虑我们要求的是什么，是 $(x, as(x))$ 的凸包，将，每个跨过 $mid$ 的区间化作一个点 $(x, y)$ ， $x$ 代表区间长度， $y$  代表区间和，就是求这个点集（设为 $C$ ）的凸包</p><p>点集大小是 $O(n^2)$ 的，当然不能直接求，设点集 $A = \{(x, y) | x \in [l, mid], y = suf(x)\}$ ，其中 $suf(x)$ 表示区间 $[l, mid]$  的后缀和；再设 $B = \{(x, y) | x \in [mid + 1, r], y = pre(x)\}$ ，其中 $pre(x)$ 表示区间 $[mid + 1, r]$  的前缀和；那么， $C = \{(x, y) | x = x_A + x_B, y = y_A + y_B\}$ ，这就是闵可夫斯基和呀</p><p>而用闵可夫斯基和，我们可以 $O(n)$  归并出点集 $C$  的凸包</p><h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>那怎么合并呢？再看图（回去翻那张）</p><p>我们（<del>baidu得</del>）发现发现新的凸包就是原来的两个凸包的边重新极角排序一边，证明？咕咕咕</p><p>于是我们得到了一个很有用的结论，求凸包只需要求原来的凸包，然后在一起重新排序就可以了。</p><p>但直接重排有点浪费，由于原来两个凸包都已经求好了，于是可以类似归并排序，重新归并一次</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>例题就不讲了，我要回溯去递归下一条路径了（dfs式学习，艹）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LL x, y;</span><br><span class="line">    <span class="comment">//friend老香了</span></span><br><span class="line">    IL FR Point <span class="keyword">operator</span> + (Point x, Point y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x.x + y.x, x.y + y.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    IL FR Point <span class="keyword">operator</span> - (Point x, Point y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x.x - y.x, x.y - y.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    IL FR <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;= (Point x, Point y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x.y * y.x &lt;= x.x * y.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hull</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Point *st;</span><br><span class="line">    <span class="keyword">int</span> top, now;</span><br><span class="line">    IL Point&amp; <span class="keyword">operator</span> [] (<span class="keyword">const</span> <span class="keyword">int</span>&amp; x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> st[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">const</span> Point&amp; x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        st[x.x].y = <span class="built_in">max</span>(st[x.x].y, x.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> Point&amp; x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        st[++top] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">prev</span><span class="params">(<span class="keyword">int</span> len)</span> <span class="comment">//预处理,长度为x的答案对应其位置,方便ins</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">            st[i] = &#123;i, -INF&#125;;</span><br><span class="line">        top = len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">convex</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (top &lt;= <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>, len = top, top = <span class="number">2</span>; i &lt;= len; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st[i].y == -INF)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; (st[top] - st[top - <span class="number">1</span>]) &lt;= (st[i] - st[top - <span class="number">1</span>]))</span><br><span class="line">                --top;</span><br><span class="line">            st[++top] = st[i];</span><br><span class="line">        &#125;</span><br><span class="line">        now = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL LL <span class="title">maxv</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (now != top &amp;&amp; (-tag) * (st[now + <span class="number">1</span>].x - st[now].x) &lt; (st[now + <span class="number">1</span>].y - st[now].y))</span><br><span class="line">            ++now;</span><br><span class="line">        <span class="keyword">return</span> tag * st[now].x + st[now].y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">minkowski</span><span class="params">(Hull&amp; c, Hull&amp; a, Hull&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line">    c.<span class="built_in">ins</span>(a[i] + b[j]);</span><br><span class="line">    <span class="keyword">while</span> (i != a.top &amp;&amp; j != b.top)</span><br><span class="line">    &#123;</span><br><span class="line">        (a[i + <span class="number">1</span>] - a[i]) &lt;= (b[j + <span class="number">1</span>] - b[j]) ? ++j : ++i;</span><br><span class="line">        c.<span class="built_in">ins</span>(a[i] + b[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i != a.top)</span><br><span class="line">        c.<span class="built_in">ins</span>(a[++i] + b[j]);</span><br><span class="line">    <span class="keyword">while</span> (j != b.top)</span><br><span class="line">        c.<span class="built_in">ins</span>(a[i] + b[++j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个板子优点是快，缺点是指针需要人工分配内存</p>]]></content>
    
    
    <summary type="html">&lt;p&gt; 递归式学习&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算几何" scheme="https://dyd-true.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
    <category term="凸包" scheme="https://dyd-true.github.io/tags/%E5%87%B8%E5%8C%85/"/>
    
  </entry>
  
</feed>
