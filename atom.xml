<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dyd&#39;s Blog</title>
  
  <subtitle>He who has a strong enough why can bear almost any how.</subtitle>
  <link href="https://dyd-true.github.io/atom.xml" rel="self"/>
  
  <link href="https://dyd-true.github.io/"/>
  <updated>2022-02-11T05:37:07.292Z</updated>
  <id>https://dyd-true.github.io/</id>
  
  <author>
    <name>Dyd</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数列与极限</title>
    <link href="https://dyd-true.github.io/2022/02/10/%E6%95%B0%E5%88%97%E4%B8%8E%E6%9E%81%E9%99%90/"/>
    <id>https://dyd-true.github.io/2022/02/10/%E6%95%B0%E5%88%97%E4%B8%8E%E6%9E%81%E9%99%90/</id>
    <published>2022-02-10T06:53:03.000Z</published>
    <updated>2022-02-11T05:37:07.292Z</updated>
    
    <content type="html"><![CDATA[<p> 然而感觉并无卵用</p><span id="more"></span><h1 id="数列与极限"><a href="#数列与极限" class="headerlink" title="数列与极限"></a>数列与极限</h1><p>稍微学了一下数学，感觉数学过于严谨了</p><h2 id="数列"><a href="#数列" class="headerlink" title="数列"></a>数列</h2><p>定义一种从自然数（有时候是正整数）到实数（有时候是其它域）的映射 $f : \mathbb{N} \to \mathbb{R}$ ，我们称它为一个<strong>数列</strong>，一般的，设 $a_n = f(n)$ ，则该数列可记为 $\{a_n\}_{n = 0}^{+ \infty}$ </p><p>定义一个数列 $f : \mathbb{N} \to \mathbb{R}$ 的<strong>子数列</strong>为一个数列 $g : L \to \mathbb{R}$ 满足 $L \subseteq  \mathbb{N} \wedge \forall n \in L , g(n) = f(n) \wedge \mid L \mid = + \infty$ </p><h2 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h2><p>对于一个数列 $\{a_n\}_{n = 1}^{+ \infty}$ ，若 $\exists \delta \in R, s.t. \forall \epsilon &gt; 0, \exists N &gt; 0 \wedge N \in \mathbb{N}^+, s.t. \forall n &gt; N , \mid a_n - \delta \mid &lt; \epsilon$ ，我们就称 $\delta$ 为数列的<strong>极限</strong>，记作 $\lim\limits _{n \to + \infty} a_n = \delta$ ，或者 $a_n \to \delta(n \to + \infty)$ ，有时候括号内的可以省略（上面的 $s.t$ 指 “使得”）</p><p>对于一个数列，如果它存在极限，我们就称这个数列<strong>收敛</strong>，否则就称其<strong>发散</strong></p><h2 id="极限的唯一性"><a href="#极限的唯一性" class="headerlink" title="极限的唯一性"></a>极限的唯一性</h2><p>下面证明极限的唯一性，即：若 $a_n \to b, a_n \to c$ 则 $b = c$ </p><p>有：<br>$$<br>\begin{aligned}<br>\forall \epsilon &gt; 0, \exists N_b &gt; 0, s.t. \forall n &gt; N_b, \mid a_n - b \mid &lt; \epsilon \\<br>\forall \epsilon &gt; 0, \exists N_c &gt; 0, s.t. \forall n &gt; N_c, \mid a_n - c \mid &lt; \epsilon \\<br>\end{aligned}<br>$$<br> 记 $N = \max(N_b, N_c)$ 有：<br>$$<br>\forall n &gt; N, \mid a_n - c \mid + \mid a_n - b \mid &lt; 2 \epsilon<br>$$<br>由三角不等式 $\mid a \mid - \mid b \mid \le \mid a \pm b \mid \le \mid a \mid + \mid b \mid$ 得：<br>$$<br>\mid b - c \mid &lt; 2 \epsilon<br>$$<br>由于 $\epsilon$ 可以无限小，故有 $b = c$ </p><p>QED</p><h2 id="子数列的极限"><a href="#子数列的极限" class="headerlink" title="子数列的极限"></a>子数列的极限</h2><p>对于一个数列  $\{a_n\}<em>{n = 1}^{+ \infty}$ 的子数列  $\{a</em>{n_k}\}<em>{k = 1}^{+ \infty}$ ，若 $a_n \to \delta$ ，则 $a</em>{n_k} \to \delta$ </p><p>证明：</p><p>对于所有 $k$ ，有 $n_k \ge k$ ，又因为 $\forall \epsilon &gt; 0, \exists N &gt; 0, s.t. \forall n &gt; N, \mid a_n - b \mid &lt; \epsilon$</p><p>故 $\forall \epsilon &gt; 0$ ，取 $K = N$ ，有 $\forall k &gt; K, n_k \ge k &gt; K = N$ ，故 $\mid a_{n_k} - b \mid &lt; \epsilon$ ，即 $a_{n_k} \to \delta$ </p><p>QED</p><h2 id="级数"><a href="#级数" class="headerlink" title="级数"></a>级数</h2><p><strong>级数</strong>是指将数列的项依次用加号连接起来的函数，用 IOer 的话来说就是数列的前缀和，即对于数列 $\{s _n\} _{n = 1}^{+ \infty}$ ，有 $s _n = \sum _{i = 1}^n a _i$ </p><h2 id="数列的和"><a href="#数列的和" class="headerlink" title="数列的和"></a>数列的和</h2><p>对于数列 $\{a _n\} _{n = 1}^{+ \infty}$ ，它的和 $\sum _{n = 1}^{+ \infty} a _n$ 有意义，当且仅当它的级数数列  $\{s _n\} _{n = 1}^{+ \infty}$ 收敛</p><p>正确性显然</p><p>这里补充一个等比数列求和公式（设公比为 $q$ ）： $(1 - q)(1 + q + q^2 + … + q^n) = 1 - q^{n + 1}$ </p><h2 id="极限的线性可加性"><a href="#极限的线性可加性" class="headerlink" title="极限的线性可加性"></a>极限的线性可加性</h2><p>设 $a_n \to a, b_m \to b$ ，则 $\lim \limits _{n \to + \infty} (\alpha a_n + \beta b_n) = \alpha a + \beta b$ </p><p>证明：<br>$$<br>\begin{aligned}<br>&amp; \mid \alpha a _n + \beta b _n  - (\alpha a + \beta b) \mid \\<br>\le &amp; \mid \alpha \mid \mid a _n - a \mid + \mid \beta \mid \mid b _n - b \mid \\<br>&amp; = \mid \alpha \mid \epsilon ‘ + \mid \beta \mid \epsilon ‘<br>\end{aligned}<br>$$</p><p>现在，对于任意的 $\epsilon &gt; 0$ ，一定可得 $\epsilon ‘ = \frac{\epsilon}{\mid \alpha \mid + \mid \beta \mid}$ ，它对应的 $N$ ，使得 $\forall n &gt; N$ ， $\mid \alpha a _n + \beta b _n  - (\alpha a + \beta b) \mid &lt; \epsilon$ </p><p>QED</p><h2 id="夹逼定理"><a href="#夹逼定理" class="headerlink" title="夹逼定理"></a>夹逼定理</h2><p>设 $a_n \le b_n \le c_n$ ，且 $\lim \limits _{n \to + \infty} a_n = \lim \limits _{n \to + \infty} c_n = t$ ，则 $\lim \limits _{n \to + \infty} b_n = t$ </p><p>证明：<br>$$<br>\begin{aligned}<br>有:<br>&amp; \mid a_n - t \mid &lt; \epsilon \\<br>即:<br>&amp; t - \epsilon &lt; a_n &lt; t + \epsilon \\<br>同理:<br>&amp; t - \epsilon &lt; c_n &lt; t + \epsilon \\<br>又因为:<br>&amp; a_n \le b_n \le c_n \\<br>得:<br>&amp; t - \epsilon &lt; b_n &lt; t + \epsilon \\<br>即:<br>&amp; \mid b_n - t \mid &lt; \epsilon \\<br>\end{aligned}<br>$$<br>QED</p>]]></content>
    
    
    <summary type="html">&lt;p&gt; 然而感觉并无卵用&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数论,数学" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
    <category term="其它" scheme="https://dyd-true.github.io/tags/%E5%85%B6%E5%AE%83/"/>
    
    <category term="笔记" scheme="https://dyd-true.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>优化dp2</title>
    <link href="https://dyd-true.github.io/2022/02/09/%E4%BC%98%E5%8C%96dp2/"/>
    <id>https://dyd-true.github.io/2022/02/09/%E4%BC%98%E5%8C%96dp2/</id>
    <published>2022-02-09T06:50:24.000Z</published>
    <updated>2022-02-11T05:30:07.939Z</updated>
    
    <content type="html"><![CDATA[<p> 然而我 dp 废的一比（三羊开泰）</p><span id="more"></span><h1 id="优化dp2"><a href="#优化dp2" class="headerlink" title="优化dp2"></a>优化dp2</h1><p>上回链接：<a href="https://dyd-true.github.io/2022/02/08/%E4%BC%98%E5%8C%96dp/#more">优化dp</a></p><p>这次目标主要介绍斜率优化和四边形不等式，它们都是利用<strong>单调性</strong>对<strong>转移</strong>进行优化</p><h1 id="斜率优化"><a href="#斜率优化" class="headerlink" title="斜率优化"></a>斜率优化</h1><p>歪果仁喜欢叫凸包/凸壳优化（ convex hull trick ）</p><p>上次我我们说了，对于 1D/1D 模型：<br>$$<br>d[i] = \min_{l(i) \le j \le r(i)} (d[j] + val(i, j))<br>$$<br>如果 $val(i, j)$ 的的每一项仅与 $i, j$ 中一个有关，就可以考虑单调队列，那么，如果 <strong>$val(i, j)$ 包括了 $i, j$ 的乘积（即和它们同时相关的量）</strong>，我们就可以考虑斜率优化</p><p>斜率优化有两种形式，就我个人而言，比较喜欢先把 dp 方程写出来，然后考虑决策 $j$ 优于决策 $k$ 的条件，把条件化成<br>$$<br>\frac{y(j) - y(k)}{x(j) - x(k)} &lt; k<br>$$<br>这里 $&lt;$ 可以换，把外层循环都当常量， $k$ 是常数， $x(t), y(t)$ 是仅和 $t$ 有关的函数，这个就是斜率优化的第一种形式，如果是巨佬，一眼就可以看出（或者带几个点算出）它是上凸/下凸然后打代码了</p><p>但我比较弱，这个只能用来帮助打代码，只好继续化，在得到了形式一后，我们反回去看 dp 方程，把  $\min (\max)$ 去掉，化为斜率优化的第二种形式<br>$$<br>y(j) = k \times x(j) + d[i]’<br>$$<br>这里 $d[i]’$ 是只关于 $d[i]$ 的东西（可以通过它直接得到 $d[i]$ ）， $y(t), x(t), k$ 就和形式一一样（所以我化出形式一的目的其实就是为了指导如何化形式二，因为蒟蒻一般无法一眼看穿如何化形式二），然后我就用形式二来斜率优化</p><p>具体地，把问题化为对一条斜率为 $k$ 的直线尝试去过点 $(x(j), y(j))$ ，最大/小化直线的截距，我们发现只要维护点集的凸包即可，一般用单调队列实现</p><p>实现代码时最好看着这两个形式打（利用它们帮助你明确细节、条件），然后期待自己 rp 够好吧（<del>如果您是巨佬当我没说</del>）</p><p>值得一提的是，对于形式一，巨佬可以直接取几个点就看出上凸/下凸/无法优化，但对于用形式二的蒟蒻来说，只好记结论了：</p><p><strong>可以简单斜率优化的条件是形式二中的 $k$ 和 $x(t)$ 单调，单调递增/递减（或者 $\min$ / $\max$ ）对应下凸/上凸</strong>，这样有一个 $O(n)$ 就可以优化为 $O(1)$ ；而当 $k$ 和 $x(t)$ 有一者不单调时，我们优先考虑改方程（倒着 dp ，重设状态等）来<strong>保证 $x(t)$ 单调</strong>（要保证新决策横坐标大于/小于之前所有决策），并用二分，将 $O(n)$ 优化为 $O(\log n)$ ；最麻烦的是 $k$ 和 $x(t)$ 都不单调，这就只有动态维护，时间和题目要求以及选取的数据结构有关，具体可以看下面的例题</p><h2 id="例题六"><a href="#例题六" class="headerlink" title="例题六"></a>例题六</h2><p><a href="https://codeforces.com/problemset/problem/311/B">Cats Transport</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有 $m \le 10^5$ 只猫分布在 $n \le 10^5$ 座山上，第 $i$ 只猫在山 $h_i$ 且会在 $t_i \le 10^9$ 时间下到山脚，然后一直等着，两个山之间的距离已知且 $\le 10^4$ ，现在在第一座山脚有 $p \le 100$ 个铲屎官，速度为 $1$ ，每个铲屎官在你安排的时间出发（每个人出发时间可以不同，出发时间可以为负数），从山 $1$ 走到山 $n$ ，中通遇到在山脚的猫就带走它，要求你最小化猫的等待时间</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先，什么距离、速度、时间很麻烦，我们先对每只猫计算一个 $a_i = t_i - \sum_{j = 1}^{h_i} d_j$ ，表示“如果一个铲屎官想接走第 $i$ 只猫，它必须在 $a_i$ 时刻之后出发”，不难发现如果出发时间为 $x$ ，猫就会等待 $x - a_i$ 的时间，然后就不管题目中的 $d, t$ 和 $h$  了</p><p>我们先对 $a_i$ 从小到大排序，排完后铲屎官接走的猫一定是连续的，贪心可知，一定存在一种最优解满足每位铲屎官都对应一只刚好接走的猫，即对应一个 $a_i$ （简证 <del>口胡</del> ：若有为铲屎官没有刚好接走的猫，就让它早点出发，使他接的最后一只猫使被刚好接走，这样答案一定不会变差）</p><p>于是考虑第 $x$ 个铲屎官刚好接走猫 $i$ （即在 $a_i$ 出发），上一个人搞好接走猫 $j$ ，那么这个人可以接走猫 $j + 1 \sim i$ ，代价为 $\sum_{k = j + 1}^i a_i - a_k$ ，不妨对 $a_i$ 求个前缀和，然后 $\sum_{k = j + 1}^i a_i - a_k = (i - j)a_i - (sum[i] - sum[j])$ ，设 <code>f[i, j]</code> （ <del>$d$ 又被用了呜呜呜</del>）表示“前 $i$ 个铲屎官带走了前 $j$ 只猫，最小的等待时间”，易得：<br>$$<br>f[i, j] = \min_{0 \le k &lt; j} (f[i - 1, k] + (j - k) * a_j - (sum[j] - sum[k]))<br>$$<br>直接转移是 $O(pm^2)$ 的，外层 $i$ 当常量就是一个 1D/1D ，有 $val(j, k) = (j - k) * a_j - sum[j] + sum[k]$ ，发现存在乘积量 $(j - k) * a_j$ ，考虑斜率优化</p><p>巨佬们可以一眼看穿的就跳过吧，这里是蒻蒟痛苦的推式子：</p><p>考虑决策 $q$ 优于决策 $k$ 的条件（下面省略第一维）：<br>$$<br>\begin{aligned}<br>&amp; f[k] + (j - k) * a_j - sum[j] + sum[k] &gt; f[q] + (j - q) * a_j - sum[j] + sum[q] \\<br>\Rightarrow &amp; f[k] + -k * a_j + sum[k] &gt; f[q] + -q * a_j + sum[q] \\<br>\Rightarrow &amp; a_j &gt; \frac{(f[q] + sum[q]) - (f[k] + sum[k])}{q - k}<br>\end{aligned}<br>$$<br>于是形式一就有了，然后再化方程就简单了：<br>$$<br>\begin{aligned}<br>&amp; f[i, j] = \min_{0 \le k &lt; j} (f[i - 1, k] + (j - k) * a_j - (sum[j] - sum[k])) \\<br>\Rightarrow &amp; f[i, j] = f[i - 1, k] + j * a_j - k * a_j - sum[j] + sum[k] \\<br>\Rightarrow &amp; (f[i - 1, k] + sum[k]) = (a_j) \times (k) + (f[i, j] - a_j * j + sum[j]) \\<br>\end{aligned}<br>$$<br>大家可以对比两个形式和上面给的两个形式的一般式，不难发现它们间的联系</p><p>无论如何，式子是推出来了，现在来看单调性，首先 $a_j$ 是排好序的，显然单调递增，而那个 $k$ 是我们顺序枚举的，单调性也显然，剩下的就是打代码了……时间复杂度 $O(pm)$ </p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ol><li>仔细看看代码是不是有很多地方和形式一/二有点像？这就是我说的“帮助代码实现”</li><li>为了提高精度建议开 <code>double</code> ，也可以化除为乘</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STC static</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, P = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, p, q[N];</span><br><span class="line">LL f[P][N], sum[N], a[N], d[N];</span><br><span class="line"><span class="function">LL <span class="title">Y</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> f[i][x] + sum[x]; &#125;</span><br><span class="line"><span class="function">LL <span class="title">X</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">LL <span class="title">calc</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">Y</span>(i, k) - <span class="built_in">X</span>(a[j]) * k; &#125; <span class="comment">//计算截距i,j,k含义类似形式二</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123; <span class="keyword">return</span> (<span class="built_in">Y</span>(i, b) - <span class="built_in">Y</span>(i, c)) * (<span class="built_in">X</span>(a) - <span class="built_in">X</span>(b)) &gt; (<span class="built_in">Y</span>(i, a) - <span class="built_in">Y</span>(i, b)) * (<span class="built_in">X</span>(b) - <span class="built_in">X</span>(c)); &#125; <span class="comment">//检查a优于b,类似形式一,化乘为除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;p);</span><br><span class="line">    <span class="keyword">if</span> (p &gt;= m) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;d[i]), d[i] += d[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, h, t; i &lt;= m; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;h, &amp;t), a[i] = t - d[h];</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) f[<span class="number">1</span>][i] = a[i] * i - sum[i]; <span class="comment">//先把1算了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j, l, r; i &lt;= p; ++i)</span><br><span class="line">        <span class="keyword">for</span> (q[l = r = <span class="number">1</span>] = <span class="number">0</span>, j = <span class="number">1</span>; j &lt;= m; ++j) <span class="comment">//0也是一个决策点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (; l &lt; r &amp;&amp; <span class="built_in">calc</span>(i - <span class="number">1</span>, j, q[l + <span class="number">1</span>]) &lt; <span class="built_in">calc</span>(i - <span class="number">1</span>, j, q[l]); ++l); <span class="comment">//不优排除，注意至少要保证队列中有一个数,故l&lt;r</span></span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][q[l]] + a[j] * (j - q[l]) - (sum[j] - sum[q[l]]);</span><br><span class="line">            <span class="keyword">for</span> (; l &lt; r &amp;&amp; <span class="built_in">check</span>(i - <span class="number">1</span>, j, q[r], q[r - <span class="number">1</span>]); --r); <span class="comment">//保留斜率更优的</span></span><br><span class="line">            q[++r] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, f[p][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题七"><a href="#例题七" class="headerlink" title="例题七"></a>例题七</h2><p><a href="https://www.acwing.com/problem/content/description/304/">任务安排3</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定 $n \le 3 \times 10^5$ 个任务，要求从时刻 $0$ 开始顺序执行，第 $i$ 个任务耗时 $-512 \le t_i \le 512$ ，有一个机器执行任务，将任务分成若干段，每一段完成耗时就是该段 $t_i$ 之和，而机器开始每段之前要消耗 $S \le 512$ 的启动时间，<strong>一个任务的完成时刻就是所在段的完成时刻</strong>，最后的费用就是每个任务的完成时刻乘一个系数 $c_i \le 512$ 然后求和，现在求最小费用</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>首先求出 $t_i$ ， $c_i$ 的前缀和记为 $sum_t[], sum_c[]$ ，定义 <code>d[i, j]</code> 表示“把前 $i$ 个任务分成 $j$ 段最小费用”，方程显然：<br>$$<br>d[i, j] = \min_{0 \le k &lt; i} (d[k, j - 1] + (S * j + sum_t[i]) * (sum_c[i] - sum_c[k]))<br>$$<br>时间为 $O(n^3)$ ，完全无法接受，考虑到就算把 1D/1D 优化为 $O(1)$ 时间也无法接受，说明要剪去一维状态</p><p>我们发现题目并没有要求分成多少段，我们在状态中记录段数完全是为了计算代价，而每一次启动的代价都会累计到此后所有的任务中，用<strong>费用提前计算</strong>的思想，直接在启动时就把后面的代价累计了，这样就剪去了一维，定义 <code>d[i]</code> 表示“把前 $i$ 个任务分成若干段最小费用”，方程：<br>$$<br>d[i] = \min_{0 \le j &lt; i} (d[j] + sum_t[i] * (sum_c[i] - sum_c[j]) + S * (sum_c[n] - sum_c[j]))<br>$$<br>时间为 $O(n^2)$ ，考虑 1D/1D 优化， $val(i, j) = sum_t[i] * (sum_c[i] - sum_c[j]) + S * (sum_c[n] - sum_c[j])$ 包含 $i, j$ 乘积，考虑斜率优化，设决策 $k$ 优于 $j$ 有：<br>$$<br>\begin{aligned}<br>&amp; d[j] + sum_t[i] * (sum_c[i] - sum_c[j]) + S * (sum_c[n] - sum_c[j]) &gt; d[k] + sum_t[i] * (sum_c[i] - sum_c[k]) + S * (sum_c[n] - sum_c[k]) \\<br>&amp; d[j] - (S + sum_t[i]) *  sum_c[j] &gt; d[k] - (S + sum_t[i]) * sum_c[k] \\<br>&amp; (S + sum_t[i]) &gt; \frac{d[k] - d[j]}{sum_c[k] - sum_c[j]}<br>\end{aligned}<br>$$<br>于是得到形式二为：<br>$$<br>(d[j]) = (S + sum_t[i]) \times (sum_c[j]) + (d[i] - sum_t[i] * sum_c[i] - S * sum_c[n])<br>$$<br>现在来看单调性， $sum_c[j]$ 的单调性显然，但是由于 $t_i$ 可以为负数， $S + sum_t[i]$ <strong>不具有单调性</strong>，完蛋，这就是 $k$ 不单调但 $x(t)$ 单调的情况啊</p><p>但幸好 $x(t)$ 还是单调的，我们来思考 $k$ 不单调的影响：如果 $k$ 是单调的，由形式一可知我们只需保留凸壳上两点连线斜率大于 $k$ 的部分，而最优决策就一定是队头，因为队头的下一个点被删去，说明它的斜率由 $&lt;k$ 变为 $&gt;k$ ，则队头就是变化点，也就是最优决策点；但是 $k$ 不单调了，所以我们不能只保留凸壳上两点连线斜率大于 $k$ 的部分，而要维护整个凸壳，并最优决策点也不在是队头了，需要在队列中二分一个点，使得它和左侧点斜率 $&lt;k$ ，而和右侧点斜率 $&gt;k$ </p><p>时间复杂度 $O(n \log n)$ </p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>注意 <code>long long</code> 相乘要开 <code>int128</code> </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I128 __int128</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line">LL sumc[N], sumt[N], d[N];</span><br><span class="line"><span class="keyword">int</span> q[N], l, r;</span><br><span class="line"><span class="function">LL <span class="title">Y</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> d[x]; &#125;</span><br><span class="line"><span class="function">LL <span class="title">X</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> sumc[x]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, LL k)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">Y</span>(a) - <span class="built_in">Y</span>(b) &gt;= <span class="built_in">I128</span>(k) * (<span class="built_in">X</span>(a) - <span class="built_in">X</span>(b)); &#125; <span class="comment">//判断a,b的斜率大于等于k</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">I128</span>(<span class="built_in">Y</span>(b) - <span class="built_in">Y</span>(a)) * (<span class="built_in">X</span>(c) - <span class="built_in">X</span>(b)) &gt;= <span class="built_in">I128</span>(<span class="built_in">Y</span>(c) - <span class="built_in">Y</span>(b)) * (<span class="built_in">X</span>(b) - <span class="built_in">X</span>(a)); &#125; <span class="comment">//比较斜率,维护凸包</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i, LL k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> q[l];</span><br><span class="line">    <span class="keyword">int</span> ll = l, rr = r, mid, res;</span><br><span class="line">    <span class="keyword">while</span> (ll &lt;= rr)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = ll + rr &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check1</span>(q[mid + <span class="number">1</span>], q[mid], k)) rr = (res = mid) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> ll = mid + <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q[res];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, t, c; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;t, &amp;c);</span><br><span class="line">        sumc[i] = sumc[i - <span class="number">1</span>] + c, sumt[i] = sumt[i - <span class="number">1</span>] + t;</span><br><span class="line">    &#125;</span><br><span class="line">    q[l = r = <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, p; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        d[i] = d[p = <span class="built_in">find</span>(i, s + sumt[i])] - (s + sumt[i]) * sumc[p] + sumt[i] * sumc[i] + s * sumc[n];</span><br><span class="line">        <span class="keyword">for</span> (; l &lt; r &amp;&amp; <span class="built_in">check2</span>(q[r - <span class="number">1</span>], q[r], i); --r);</span><br><span class="line">        q[++r] = i; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, d[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题八"><a href="#例题八" class="headerlink" title="例题八"></a>例题八</h2><p><a href="https://www.luogu.com.cn/problem/P4027">货币兑换</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>有两种金卷 $A, B$ ，已知接下来 $n \le 10^5$ 天每天两种金卷的价格 $A_i, B_i \le 10$ ，用户的账户上有三个<strong>实数</strong>： $a, b, c$ ，分别表示金卷 $A, B$ 的数量和 RMB （软妹币）的数量，用户可以进行两种操作（同一天可以多次操作）：</p><ol><li>提供一个实数 $op \in [0, 100]$ ，然后将 $op\%$ 的 $A, B$ 卷按当天的价格换成 RMB </li><li>提供一个实数 $op$ 表示用 $op$ 元 RMB 买入 $A, B$ 卷，第 $i$ 天买入的 $A, B$ 卷比为 $R_i \in (0, 100]$ </li></ol><p>现在，假设你第一天有 $S \le 10^9$ 元且没有任何金卷，问第 $n$ 天时你账户中最多有多少 RMB ，保证最后答案 $\le 10^9$ 保留 $3$ 位小数 </p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>首先明确一个点：必然存在一种最优的买卖方案，使得每次买进操作使用完所有的人民币，每次卖出操作卖出所有的金券</p><p>证明很简单，如果最优解在某天买入了一部分卷，一定是因为买它最优，而继续买和买入一部分的“优越性”相同（因为参数都没变），所有继续买一定优于其它决策；卖出同理</p><p>然后我们来考虑 dp ，由于实数不好作为状态，定义 <code>d[i]</code> 为“第 $i$ 天最多得到的钱数”，把实数放到转移里，转移分两种：</p><ol><li><p>第 $i$ 天不卖出金卷，则 <code>d[i] = max(d[i], d[i - 1])</code> </p></li><li><p>第 $i$ 天卖出金卷，设上一次买入（一定是花完了所有 RMB 的）是在第 $j$ 天，有：<br>$$<br>d[i] = \max _{1 \le j &lt; i} (\frac{d[j]}{A _j * R _j + B _j} * R _j * A _i + \frac{d[j]}{A _j * R _j + B _j} * B _i)<br>$$</p></li></ol><p>第一种转移很好搞，问题在第二种，发现包含 $i, j$ 的乘积，于是考虑斜率优化</p><p>决策 $k$ 优于决策 $j$ 当且仅当：<br>$$<br>\begin{aligned}<br>&amp; \frac{d[j]}{A _j * R _j + B _j} * R _j * A _i + \frac{d[j]}{A _j * R _j + B _j} * B _i &lt; \frac{d[k]}{A _k * R _k + B _k} * R _k * A _i + \frac{d[k]}{A _k * R _k + B _k} * B _i \\<br>&amp; \frac{d[j] * R _j}{A _j * R _j + B _j} * \frac{A _i}{B _i} + \frac{d[j]}{A _j * R _j + B _j} &lt; \frac{d[k] * R _k}{A _k * R _k + B _k} * \frac{A _i}{B _i} + \frac{d[k]}{A _k * R _k + B _k} \\<br>&amp; \frac{d[j]}{A _j * R _j + B _j} - \frac{d[k]}{A _k * R _k + B _k} &lt; (\frac{d[k] * R _k}{A _k * R _k + B _k} -  \frac{d[j] * R _j}{A _j * R _j + B _j}) * \frac{A _i}{B _i} \\<br>&amp; \frac{\frac{d[j]}{A _j * R _j + B _j} - \frac{d[k]}{A _k * R _k + B _k}}{\frac{d[k] * R _k}{A _k * R _k + B _k} -  \frac{d[j] * R _j}{A _j * R _j + B _j}} &lt; \frac{A _i}{B _i} \\<br>&amp; \frac{\frac{d[k]}{A _k * R _k + B _k} - \frac{d[j]}{A _j * R _j + B _j}}{\frac{d[k] * R _k}{A _k * R _k + B _k} -  \frac{d[j] * R _j}{A _j * R _j + B _j}} &gt; - \frac{A _i}{B _i} \\<br>\end{aligned}<br>$$<br>相信你和我一样看见这个式子就脑壳疼，所以我们设 $Y(t) = \frac{d[t]}{A _t * R _t + B _t}, X(t) = \frac{d[t] * R _t}{A _t * R _t + B _t}$ ，就很明显是形式一了：<br>$$<br>\frac{Y(k) - Y(j)}{X(k) - X(j)} &gt; - \frac{A _i}{B _i}<br>$$<br>于是就推得形式二：<br>$$<br>Y(j) = - \frac{A _i}{B _i} \times X(j) + \frac{d[i]}{B _i}<br>$$<br>奈斯~，似乎维护一个最大截距就结束了（注意本题是维护上凸壳了，上两题都是下凸壳）？来检查一下单调性， what’s up ， $X(j) = \frac{d[j] * R _j}{A _j * R _j + B _j}$ 有个寂寞的单调性，再看 $- \frac{A _i}{B _i}$ ，更没有了，我们遇到了两个都没有单调性的情况</p><p>这下完蛋，  $k = - \frac{A _i}{B _i}$ 不具有单调性还好，可以像例七一样二分决策位置，但 $X(j)$ 没有单调性，这意味着我们凸包上的点不是按照横坐标排好序的，当前点可能不是插在凸包最右（左）边，而是插到凸包的中间已经维护好的部分里，这意味着我们必须动态维护凸包，<strong>对于本题来</strong>，说如果对于点 $j$ 左边的线斜率小于当前 $k$ ，显然用左边的点截距更大（画图一下就看出来了）；如果右边的线斜率大于当前 $k$ ，那么用右边的点更优；最后最优决策点左边直线斜率 $&gt; k$ （在爬升），右边斜率直线斜率 $&lt; k$ （在下降）</p><p>下面介绍三种不同数据结构维护这个凸包，其中前两种比较常用，各有优劣，第三种不太常见，但有些题目用上会有奇效</p><h3 id="平衡树维护"><a href="#平衡树维护" class="headerlink" title="平衡树维护"></a>平衡树维护</h3><p>把凸包上的点维护成一棵按照 $X(j)$ 排序的平衡树，每个点维护其在凸包上左边直线的斜率 $lk$ 和右边的直线斜率 $rk$ 每次插入新点 $x$ 时：</p><ol><li>先将新点旋转到根</li><li>寻找其左边最后一个可以与其构成凸包的点，并把之间的不能构成凸包的点删除（直接把该点旋转到 $x$ 下面，然后删除该点的左/右儿子即可），计算出 $lk$ （如何判断是否构成凸包：对于当前找到的点 $t$ ，如果 $lk(t)$ 大于直线 $t - x$ 的斜率，并且点 $t, x$ 之间有不在凸包内的节点，就说明要找的点在 $t, x$ 之间，就往右走）</li><li>同理维护右边</li><li>如果发现这个点在原来的凸包内，即 $lk(x) &lt; rk(x)$ ，直接删除该点</li></ol><p>平衡树的有点是好想、好理解，且时间好算，缺点当然是码量和常数（但其实三种方法的常数差不多）</p><p>为了方便拓展和迁移，不用常数小的 SBT 而用拓展性强（并且不用打 <code>push_up</code> ）的 splay 打代码前，我又想起蒟蒻我当初打脸的话：<strong>“我的 splay 常数小”</strong></p><p>代码：</p><p>其实为了卡常可以存下 $X(j), Y(j)$ ，防止每次都算，但我懒</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DB double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> DB eps = <span class="number">1e-9</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">DB d[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Day</span>&#123;</span> DB a, b, r; &#125;day[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(DB x, DB y)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">fabs</span>(x - y) &lt; eps ? <span class="number">0</span> : (x &gt; y ? <span class="number">1</span> : <span class="number">-1</span>); &#125;</span><br><span class="line"><span class="function">DB <span class="title">Y</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> d[x] / (day[x].a * day[x].r + day[x].b); &#125;</span><br><span class="line"><span class="function">DB <span class="title">X</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">Y</span>(x) * day[x].r; &#125;</span><br><span class="line"><span class="function">DB <span class="title">K</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> !<span class="built_in">cmp</span>(<span class="built_in">X</span>(a), <span class="built_in">X</span>(b)) ? -INF : (<span class="built_in">Y</span>(b) - <span class="built_in">Y</span>(a)) / (<span class="built_in">X</span>(b) - <span class="built_in">X</span>(a)); &#125;</span><br><span class="line"><span class="keyword">namespace</span> Splay</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> rt, tot;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> fa, ch[<span class="number">2</span>], id;</span><br><span class="line">        DB lk, rk;</span><br><span class="line">    &#125; tr[N];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> fa(x) tr[(x)].fa</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ch(x) tr[(x)].ch</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lk(x) tr[(x)].lk</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rk(x) tr[(x)].rk</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> id(x) tr[(x)].id</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rot</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="built_in">fa</span>(x), z = <span class="built_in">fa</span>(y), k = <span class="built_in">ch</span>(y)[<span class="number">1</span>] == x;</span><br><span class="line">        <span class="built_in">ch</span>(z)[y == <span class="built_in">ch</span>(z)[<span class="number">1</span>]] = x, <span class="built_in">fa</span>(x) = z;</span><br><span class="line">        <span class="built_in">ch</span>(y)[k] = <span class="built_in">ch</span>(x)[k ^ <span class="number">1</span>], <span class="built_in">fa</span>(<span class="built_in">ch</span>(x)[k ^ <span class="number">1</span>]) = y;</span><br><span class="line">        <span class="built_in">ch</span>(x)[k ^ <span class="number">1</span>] = y, <span class="built_in">fa</span>(y) = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y, z; <span class="built_in">fa</span>(x) != k; <span class="built_in">rot</span>(x)) <span class="keyword">if</span> ((z = <span class="built_in">fa</span>(y = <span class="built_in">fa</span>(x))) != k) (<span class="built_in">ch</span>(y)[<span class="number">1</span>] == x) ^ (<span class="built_in">ch</span>(z)[<span class="number">1</span>] == y) ? <span class="built_in">rot</span>(x) : <span class="built_in">rot</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (!k) rt = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x, DB k)</span> <span class="comment">//寻找最优解,当前斜率为k</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!x || <span class="built_in">cmp</span>(<span class="built_in">lk</span>(x), k) == <span class="number">1</span> &amp;&amp; <span class="built_in">cmp</span>(<span class="built_in">rk</span>(x), k) == <span class="number">-1</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">cmp</span>(<span class="built_in">lk</span>(x), k) == <span class="number">-1</span> ? <span class="built_in">find</span>(<span class="built_in">ch</span>(x)[<span class="number">0</span>], k) :  <span class="built_in">find</span>(<span class="built_in">ch</span>(x)[<span class="number">1</span>], k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y, res;</span><br><span class="line">        <span class="keyword">for</span> (y = <span class="built_in">ch</span>(x)[<span class="number">0</span>], res = y; y; )</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">cmp</span>(<span class="built_in">lk</span>(y), <span class="built_in">K</span>(<span class="built_in">id</span>(y), <span class="built_in">id</span>(x))) &gt;= <span class="number">0</span>) res = y, y = <span class="built_in">ch</span>(y)[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> y = <span class="built_in">ch</span>(y)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">suf</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y, res;</span><br><span class="line">        <span class="keyword">for</span> (y = <span class="built_in">ch</span>(x)[<span class="number">1</span>], res = y; y; )</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">cmp</span>(<span class="built_in">rk</span>(y), <span class="built_in">K</span>(<span class="built_in">id</span>(x), <span class="built_in">id</span>(y))) &lt;= <span class="number">0</span>) res = y, y = <span class="built_in">ch</span>(y)[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span> y = <span class="built_in">ch</span>(y)[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">splay</span>(x, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ch</span>(x)[<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">splay</span>(t = <span class="built_in">pre</span>(x), x), <span class="built_in">ch</span>(t)[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//删去凸包内的</span></span><br><span class="line">            <span class="built_in">lk</span>(x) = <span class="built_in">rk</span>(t) = <span class="built_in">K</span>(<span class="built_in">id</span>(t), <span class="built_in">id</span>(x));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">lk</span>(x) = INF; <span class="comment">//保证不往左,下面同理</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ch</span>(x)[<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">splay</span>(t = <span class="built_in">suf</span>(x), x), <span class="built_in">ch</span>(t)[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">rk</span>(x) = <span class="built_in">lk</span>(t) = <span class="built_in">K</span>(<span class="built_in">id</span>(x), <span class="built_in">id</span>(t));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">rk</span>(x) = -INF;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">cmp</span>(<span class="built_in">lk</span>(x), <span class="built_in">rk</span>(x)) &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            rt = <span class="built_in">ch</span>(x)[<span class="number">0</span>], <span class="built_in">ch</span>(rt)[<span class="number">1</span>] = <span class="built_in">ch</span>(x)[<span class="number">1</span>], <span class="built_in">fa</span>(<span class="built_in">ch</span>(x)[<span class="number">1</span>]) = rt, <span class="built_in">fa</span>(rt) = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">lk</span>(rt) = <span class="built_in">rk</span>(<span class="built_in">ch</span>(rt)[<span class="number">1</span>]) = <span class="built_in">K</span>(<span class="built_in">id</span>(rt), <span class="built_in">id</span>(<span class="built_in">ch</span>(rt)[<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = rt, ff = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (u &amp;&amp; <span class="built_in">id</span>(u) != id) u = <span class="built_in">ch</span>(ff = u)[(<span class="built_in">cmp</span>(<span class="built_in">X</span>(id), <span class="built_in">X</span>(<span class="built_in">id</span>(u))) &lt;= <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">if</span> (u) <span class="keyword">return</span> ;</span><br><span class="line">        u = ++tot;</span><br><span class="line">        <span class="keyword">if</span> (ff) <span class="built_in">ch</span>(ff)[(<span class="built_in">cmp</span>(<span class="built_in">X</span>(id), <span class="built_in">X</span>(<span class="built_in">id</span>(ff))) &lt;= <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>)] = u;</span><br><span class="line">        <span class="built_in">id</span>(u) = id, <span class="built_in">fa</span>(u) = ff, <span class="built_in">ch</span>(u)[<span class="number">0</span>] = <span class="built_in">ch</span>(u)[<span class="number">1</span>] = <span class="number">0</span>, <span class="built_in">check</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %lf&quot;</span>, &amp;n, &amp;d[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j; i &lt;= n; Splay::<span class="built_in">ins</span>(i), ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf %lf&quot;</span>, &amp;day[i].a, &amp;day[i].b, &amp;day[i].r);</span><br><span class="line">        j = Splay::<span class="built_in">find</span>(Splay::rt, -(day[i].a / day[i].b));</span><br><span class="line">        d[i] = <span class="built_in">max</span>(d[i - <span class="number">1</span>], <span class="built_in">X</span>(j) * day[i].a + <span class="built_in">Y</span>(j) * day[i].b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n&quot;</span>, d[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 然而我 dp 废的一比（三羊开泰）&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="斜率优化" scheme="https://dyd-true.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
    <category term="笔记" scheme="https://dyd-true.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>优化dp</title>
    <link href="https://dyd-true.github.io/2022/02/08/%E4%BC%98%E5%8C%96dp/"/>
    <id>https://dyd-true.github.io/2022/02/08/%E4%BC%98%E5%8C%96dp/</id>
    <published>2022-02-08T02:18:27.000Z</published>
    <updated>2022-02-10T14:09:48.397Z</updated>
    
    <content type="html"><![CDATA[<p> 然而我 dp 废的一比（梅开二度）</p><span id="more"></span><h1 id="优化-dp"><a href="#优化-dp" class="headerlink" title="优化 dp"></a>优化 dp</h1><p>作为 dp 废物，这里记录一下（<del>反正我不会的</del>） dp 优化方法</p><p> dp 的关键有：状态、初始化、转移、循环</p><h1 id="倍增优化"><a href="#倍增优化" class="headerlink" title="倍增优化"></a>倍增优化</h1><p>倍增是一种很优美的思想，大部分动态规划的都是采用阶段的线性增长，而在有些题中，可以考虑倍增增长（类似 ST 表的预处理），而这种优化常常会把 $2^k$ 中的 $k$ 记入<strong>状态</strong>中，类似区间 dp ，关于 $k$ 的循环往往在外层</p><p>而倍增优化的 dp 往往是这类问题的第一部分（也是最难的部分），通过 dp 我们得到若干与 $2$ 的整次幂相关的状态；在第二部分，我们会用这些状态<strong>“拼凑”</strong>（一般基于二进制拆分）出最后答案</p><h2 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h2><p><a href="https://www.luogu.com.cn/problem/P1081">开车旅行</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定 $n \le 10^5$ 个不同的数 $\mid h_i \mid \le 10^9$ ，记 $dis(i, j) = \mid h_i - h_j \mid$ ，两种操作<strong>轮流进行</strong>，设当前在 $i$ ，第一种会找到满足 $j &gt; i$ 且使  $dis(i, j)$ 取<strong>次小值</strong>（相等则认为 $h_j$ 小的小，下同）的 $j$ ，并以 $dis(i, j)$ 的代价到达 $j$ ；第二种会找到满足 $j &gt; i$ 且使  $dis(i, j)$ 取<strong>最小值</strong>的 $j$ ，并以 $dis(i, j)$ 的代价到达 $j$ ，但无论如何，总代价不能大于 $X \le 10^9$ ，当操作无法进行下去时就结束，现在有两个问题：</p><ol><li>对于给定的 $X= X_0$ ，求从那个数出发，操作一耗费的代价与操作二耗费的代价比值最小，若有多个答案，输出 $h_i$ 最大的</li><li>给出 $m \le 10^5$ 次询问，每次给定 $X = X_i$ 和出发点 $st_i$ ，分别求两种操作耗费的代价</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先预处理出从每个 $i$ 出发，两种操作会到达的点，记为 $g[0/1, i]$ ，用一个 <code>set</code> 倒序扫描即可</p><p>本题信息有三个：位置、操作次数、代价，如果直接以其为状态，复杂度过高，注意到操作是轮流进行的，考虑倍增优化，设 $d[0/1, i, j, 0/1]$ 表示“对于操作一/二，从 $j$ 出发先做操作一/二，操作 $2^i$ 次后的代价”，初始化和转移比较明显：<br>$$<br>\begin{aligned}<br>&amp; &amp; d[0, 0, j, 0] = dis(j, g[0, i]), d[0, 0, j, 1] = 0 \\<br>&amp; if (i = 1) &amp; d[0, 1, j, k] = d[0, 0, j, k] + d[0, 0, x, k \oplus 1] \\<br>&amp; else &amp; d[0, i, j, k] = d[0, i - 1, j, k] + d[0, i - 1, x, k] \\<br>\end{aligned}<br>$$<br>这里一定要单独考虑 $i = 1$ 的情况，因为只有 $2^0 = 1$ 是奇数， $d[1]$ 类似</p><p>不难发现状态数是 $O(2 * \log n * n * 2) = O(4 n \log n)$ （这里先把常数留一下），所以留给转移的时间最多是 $O(\log n)$ ，而转移的关键在于上面方程中的 $x$ ，它的含义是“前面那步走到的城市”，如在 $i \ne 1$ 时， $x$ 指“从 $j$ 出发先做操作 $k$ ，进行 $2^{i - 1}$ 次操作到达的城市”，这个东西可以 dp 预处理，具体地，设 <code>f[i, j, 0/1]</code> 表示“从 $j$ 出发先做操作一/二，进行 $2^{i}$ 次操作到达的城市”，初始化和转移如下：<br>$$<br>\begin{aligned}<br>&amp; &amp; f[0, j, 0] = g[0, j], f[0, j, 1] = g[1, j] \\<br>&amp; if (i = 1) &amp; f[1, j, k] = f[0, f[0, j, k], k \oplus 1] \\<br>&amp; else &amp; f[i, j, k] = f[i - 1, f[i - 1, j, k], k] \\<br>\end{aligned}<br>$$<br>预处理时间明显 $O(n \log n)$ ，然后 $d$ 的转移可以做到 $O(1)$ </p><p>于是我们在 $O(n \log n)$ 的时间内完成了计算所有操作次数为 $2^i$ 形式的信息，现在，对于问题二，类似 lca 倒序枚举 $i$ 移动即可，时间为 $O(\log n)$ ，而对于问题一，直接枚举起点转化成问题二即可，故总的时间为 $O(n \log n + 4 n \log n + n \log n + m \log n) = O(n \log n)$ 常数在 $10$ 左右，完全可以过</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>马蜂毒牛（ <del>dp 码风重拳出击，数据结构唯唯诺诺</del>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPT set<span class="meta-string">&lt;PII&gt;</span>::iterator</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, D = <span class="number">20</span>, INF = <span class="number">2e9</span> + <span class="number">7</span>; <span class="comment">//这里INF要足够大</span></span><br><span class="line"><span class="keyword">int</span> n, h[N], d[<span class="number">2</span>][D][N][<span class="number">2</span>], f[D][N][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    h[<span class="number">0</span>] = INF, h[n + <span class="number">1</span>] = -INF;</span><br><span class="line">    set&lt;PII&gt; s;</span><br><span class="line">    s.<span class="built_in">insert</span>(&#123;h[<span class="number">0</span>], <span class="number">0</span>&#125;), s.<span class="built_in">insert</span>(&#123;h[<span class="number">0</span>] + <span class="number">1</span>, <span class="number">0</span>&#125;), s.<span class="built_in">insert</span>(&#123;h[n + <span class="number">1</span>], n + <span class="number">1</span>&#125;), s.<span class="built_in">insert</span>(&#123;h[n + <span class="number">1</span>] - <span class="number">1</span>, n + <span class="number">1</span>&#125;); <span class="comment">//set不能插入重复元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n, ga, gb; i; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        s.<span class="built_in">insert</span>(&#123;h[i], i&#125;);</span><br><span class="line">        SPT il = s.<span class="built_in">lower_bound</span>(&#123;h[i], i&#125;), ir = il;</span><br><span class="line">        --il, ++ir;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(h[i] - il-&gt;fi) &lt;= <span class="built_in">abs</span>(h[i] - ir-&gt;fi))</span><br><span class="line">        &#123;</span><br><span class="line">            gb = il-&gt;se, --il;</span><br><span class="line">            ga = (<span class="built_in">abs</span>(h[i] - il-&gt;fi) &lt;= <span class="built_in">abs</span>(h[i] - ir-&gt;fi) ? il-&gt;se : ir -&gt; se);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            gb = ir-&gt;se, ++ir;</span><br><span class="line">            ga = (<span class="built_in">abs</span>(h[i] - il-&gt;fi) &lt;= <span class="built_in">abs</span>(h[i] - ir-&gt;fi) ? il-&gt;se : ir -&gt; se);</span><br><span class="line">        &#125;</span><br><span class="line">        f[<span class="number">0</span>][i][<span class="number">0</span>] = ga, f[<span class="number">0</span>][i][<span class="number">1</span>] = gb;</span><br><span class="line">        d[<span class="number">0</span>][<span class="number">0</span>][i][<span class="number">0</span>] = <span class="built_in">abs</span>(h[i] - h[ga]), d[<span class="number">0</span>][<span class="number">0</span>][i][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        d[<span class="number">1</span>][<span class="number">0</span>][i][<span class="number">1</span>] = <span class="built_in">abs</span>(h[i] - h[gb]), d[<span class="number">1</span>][<span class="number">0</span>][i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; D; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">1</span>; ++k) f[i][j][k] = f[i - <span class="number">1</span>][f[i - <span class="number">1</span>][j][k]][k ^ (i == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>)];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> o = <span class="number">0</span>; o &lt;= <span class="number">1</span>; ++o)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; D; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">1</span>; ++k) d[o][i][j][k] = d[o][i - <span class="number">1</span>][j][k] + d[o][i - <span class="number">1</span>][f[i - <span class="number">1</span>][j][k]][k ^ (i == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">PII <span class="title">work</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> la = <span class="number">0</span>, lb = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = D - <span class="number">1</span>; ~i; --i) <span class="keyword">if</span> (f[i][p][<span class="number">0</span>] &amp;&amp; la + lb + d[<span class="number">0</span>][i][p][<span class="number">0</span>] + d[<span class="number">1</span>][i][p][<span class="number">0</span>] &lt;= x) la += d[<span class="number">0</span>][i][p][<span class="number">0</span>], lb += d[<span class="number">1</span>][i][p][<span class="number">0</span>], p = f[i][p][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> &#123;la, lb&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(PII x, PII y)</span> <span class="comment">//应对分母为0的情况,化除为乘,-1代表相等,1代表x大,0代表y大</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x.se &amp;&amp; !y.se) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!x.se || !y.se) <span class="keyword">return</span> x.se != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (LL)x.fi * y.se == (LL)y.fi * x.se ? <span class="number">-1</span> : (LL)x.fi * y.se &lt; (LL)y.fi * x.se;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, st, ans, m;</span><br><span class="line">    PII as = &#123;INF, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line">    <span class="built_in">dp</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, tt; i &lt;= n; ++i)</span><br><span class="line">    &#123;    </span><br><span class="line">        PII t = <span class="built_in">work</span>(i, x); </span><br><span class="line">        <span class="keyword">if</span> ((tt = <span class="built_in">cmp</span>(t, as)) == <span class="number">1</span> || (tt == <span class="number">-1</span> &amp;&amp; h[i] &gt; h[ans])) ans = i, as = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m); m--; <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, as.fi, as.se)) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;st, &amp;x), as = <span class="built_in">work</span>(st, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h2><p><a href="https://www.acwing.com/problem/content/296/">Count The Repetitions</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>多组数据，定义 <code>conn(s, n)</code> 为 $n$ 个字符串 $s$ 形成的字符串，如 <code>conn(&quot;abc&quot;, 2) = &quot;abcabc&quot;</code> ，每次给定长度 $\le 100$ 的字符串 $s_1, s_2$ 和两个整数 $n_1, n_2 \le 10^6$ ，求一个最大的 $m$ 使得 $conn(conn(s_2, n_2), m)$ 为 $conn(s_1, n_1)$ 的子串</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>首先， $conn(conn(s_2, n_2), m) = conn(s_2, n_2 * m)$ ，现在问题转化为求 $m’ = n_2 * m$ </p><p>注意到 $m’ \le N = \frac{\mid s_1 \mid * n_1}{\mid s_2 \mid}$ ，而  $N \le 10^8$ 过大，不好直接枚举，考虑将 $m’$ 二进制拆分，设 $m’ = 2^{p_0} + 2^{p_1} + … + 2^{p_{t - 1}}$ ，则 $conn(s_2, m’)$ 可看作 $conn(s_2, 2^{p_0}), conn(s_2, 2^{p_1}), …, conn(s_2, 2^{p_{t - 1}})$ 着 $t$ 个串首尾衔接得到，考虑对于每个 $k \in [0, \log N]$ ，求出 $conn(s_1, n_1)$ <strong>从每个位置开始</strong>，最少要多少个字符才能和 $conn(s_2, 2^{k})$ 匹配上（就是含有该子串），这样我们就又可以用类似 lca 的方法拼凑出答案，但 $cons(s_1, n_1)$ 也很长，不妨当成 $conn(s_1, \infty)$ ，但只算从 $s_1$ 的各个位置开始的情况</p><p>综上，定义 <code>d[i, j]</code> 表示“从 $s_1[i]$ 开始，至少要多少个字符，才能匹配 $conn(s_2, 2^j)$ ”，则转移方程为：<br>$$<br>d[i, j] = d[i, j - 1] + d[(i + d[i, j - 1]) \mod \mid s_1 \mid, j - 1]<br>$$<br>初始化 $d[i, 0]$ 可以暴力计算， dp 的总时间复杂度为 $O(\mid s_1 \mid \log N)$ </p><p>然后用得到的状态拼凑答案，类似于 lca ，具体见代码</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>要注意的地方是：</p><ol><li> <code>d</code> 要开 <code>long long</code> </li><li>第 $18$ 行是 <code>x + 1</code> ，因为我下标从 $1$ 开始的</li><li>本题输入非常毒瘤，如果用 <code>cin</code> 一点问题没有，但如果用 <code>scanf</code> 因为数据最后有个换行所以会 TLE ，不过可以利用 <code>scanf</code> 返回值解决</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get(x) (((x) - 1) % l1 + 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">100</span> + <span class="number">5</span>, D = <span class="number">32</span>;</span><br><span class="line"><span class="keyword">char</span> s1[L], s2[L];</span><br><span class="line"><span class="keyword">int</span> n1, n2, l1, l2, ans;</span><br><span class="line">LL d[L][D];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans = <span class="number">0</span>, <span class="built_in">memset</span>(d, <span class="number">0</span> , <span class="keyword">sizeof</span> d);</span><br><span class="line">    l1 = <span class="built_in">strlen</span>(s1 + <span class="number">1</span>), l2 = <span class="built_in">strlen</span>(s2 + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, pos, j, ct; i &lt;= l1; ++i)</span><br><span class="line">        <span class="keyword">for</span> (pos = i, j = <span class="number">1</span>; j &lt;= l2; ++j, pos = <span class="built_in">get</span>(pos + <span class="number">1</span>), d[i][<span class="number">0</span>] += ct + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (ct = <span class="number">0</span>; s1[pos] != s2[j]; pos = <span class="built_in">get</span>(pos + <span class="number">1</span>)) <span class="keyword">if</span> (++ct &gt; l1) <span class="keyword">return</span> ans = <span class="number">0</span>, <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; D; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l1; ++i) d[i][j] = d[i][j - <span class="number">1</span>] + d[<span class="built_in">get</span>(i + d[i][j - <span class="number">1</span>])][j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = D - <span class="number">1</span>, x = <span class="number">0</span>; k &gt;= <span class="number">0</span>; --k) <span class="keyword">if</span> (x + d[<span class="built_in">get</span>(x + <span class="number">1</span>)][k] &lt;= l1 * n1) x += d[<span class="built_in">get</span>(x + <span class="number">1</span>)][k], ans += (<span class="number">1</span> &lt;&lt; k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">scanf</span>(<span class="string">&quot;%s %d %s %d&quot;</span>, s2 + <span class="number">1</span>, &amp;n2, s1 + <span class="number">1</span>, &amp;n1) == <span class="number">4</span>; <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans / n2)) <span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据结构优化"><a href="#数据结构优化" class="headerlink" title="数据结构优化"></a>数据结构优化</h1><p>对于大部分 dp 高效的<strong>转移</strong>非常重要，通过选取适当的数据结构，可以大大提高 dp 效率</p><p>这类问题的难点一般不在数据结构上，它仅仅做一个辅助转移的工具，关于工具的选取还要看题目本身的性质</p><p>当然有时候我们会需要在数据结构上 dp ，这种情况本质上并不是优化 dp 这里就不再做讨论</p><h2 id="例题三"><a href="#例题三" class="headerlink" title="例题三"></a>例题三</h2><p>还是看到题： <a href="https://www.acwing.com/problem/content/299/">赤壁之战</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给定长度为 $n \le 1000$ 的序列 $a_i$ ，求 $a_i$ 有多少个长度为 $m$ 严格递增子序列，多组数据，答案对 $10^9 + 7$ 取模</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p> dp 方程一眼就出来： <code>d[i, j]</code> 表示以 $j$ 结尾的长度为 $i$ 的严格递增子序列的个数，有  $d[i, j] \gets d[i - 1, k] (k &lt; j \wedge a_k &lt; a_j)$ </p><p>仔细一看， $n \le 10^7$ ，直接 dp 是 $O(n^2m)$ 的，这不完蛋，但，先打出来看看</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; j; ++k) <span class="keyword">if</span> (a[k] &lt; a[j]) d[i][j] += d[i - <span class="number">1</span>][k];</span><br></pre></td></tr></table></figure><p>在枚举 $j, k$ 时，可以把最外层的 $i$ 当作定值不管，发现当 $j$ 加 $1$ 后， $k$ 的范围也仅变化了 $1$ ，但决策是变化了不知道多少的，因为条件 <code>a[k] &lt; a[j]</code> 中的 <code>a[j]</code> 变了，考虑用树状数组，把 $a_i$ 离散化，每次查询前缀和并插入一个数，于是第三层循环的 $n$ 变成 $\log n$ ，总时间为 $O(m n \log n)$ </p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000</span> + <span class="number">5</span>, P = <span class="number">1e9</span> + <span class="number">7</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, ans;</span><br><span class="line"><span class="keyword">int</span> d[N][N], a[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; aa;</span><br><span class="line"><span class="keyword">namespace</span> BIT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x) &amp; -(x))</span></span><br><span class="line">    <span class="keyword">int</span> c[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123; <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span> c); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">for</span> (; x &lt;= n; x += <span class="built_in">lowbit</span>(x)) c[x] = (c[x] + y) % P; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; x; x -= <span class="built_in">lowbit</span>(x)) res = (res + c[x]) % P;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lsh</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    aa.<span class="built_in">push_back</span>(- INF - <span class="number">1</span>); <span class="comment">//树状数组不能有下标为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) aa.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">    <span class="built_in">sort</span>(aa.<span class="built_in">begin</span>(), aa.<span class="built_in">end</span>());</span><br><span class="line">    aa.<span class="built_in">erase</span>(<span class="built_in">unique</span>(aa.<span class="built_in">begin</span>(), aa.<span class="built_in">end</span>()), aa.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) a[i] = <span class="built_in">lower_bound</span>(aa.<span class="built_in">begin</span>(), aa.<span class="built_in">end</span>(), a[i]) - aa.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T, t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T); t &lt;= T; aa.<span class="built_in">clear</span>(), <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span> d), ans = <span class="number">0</span>, ++t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        a[<span class="number">0</span>] = -INF;</span><br><span class="line">        <span class="built_in">lsh</span>();</span><br><span class="line">        d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            BIT::<span class="built_in">clear</span>();</span><br><span class="line">            BIT::<span class="built_in">add</span>(a[<span class="number">0</span>], d[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) d[i][j] = BIT::<span class="built_in">ask</span>(a[j] - <span class="number">1</span>), BIT::<span class="built_in">add</span>(a[j], d[i - <span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ans = (ans + d[m][i]) % P;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d\n&quot;</span>, t, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单调队列优化"><a href="#单调队列优化" class="headerlink" title="单调队列优化"></a>单调队列优化</h1><p>从这里开始是对于<strong>转移</strong>的优化</p><p>在 dp 中，我们常常遇到这种方程（有时候不尽相同，但通过把外层变量当定值等方法可以化成这样）：<br>$$<br>d[i] = \min_{l(i) \le j \le r(i)} (d[j] + val(i, j))<br>$$<br>其中 $\min$ 可换成 $\max$ ， $val(i, j)$ 是关于 $i, j$ 的多项式函数（通常<strong>它是决定优化方式的关键</strong>）， $l(i), r(i)$ 限制了 $j$ 的决策范围且保证<strong>上下界变化具有单调性</strong>，上述问题被称作 <strong>1D/1D 动态规划</strong>，因为它的状态和转移都是 $O(n)$ 的</p><p>如果上面方程中，满足 <strong>$val(i, j)$ 中的每一项仅与 $i, j$ 中一个有关</strong>，我们就可以考虑把关于 $i, j$ 的项分开，对于关于 $i$ 的部分，它与 $j$ 无关，可以每次跟新 $i$ 后再计算；对于关于 $j$ 的部分，由于 $l(i), r(i)$ 的单调性，可以用<strong>单调队列优化</strong></p><h2 id="例题四"><a href="#例题四" class="headerlink" title="例题四"></a>例题四</h2><p><a href="https://www.acwing.com/problem/content/301/">Cut the Sequence</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给定长度为 $n \le 10^5$ 的序列 $0 \le a_i \le 10^6$ ，要求把序列分成若干段，在满足“每段的和不超过 $m \le 10^{11}$ ”的前提下，让“每段的最大值之和”最小，求最小值</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>照着题意设方程，定义 <code>d[i]</code> 表示“把前 $i$ 个数分成若干段，在保证每段和不超过 $m$ 的前提下，每段最大值之和的最小值”，转移方程：<br>$$<br>d[i] = \min_{0 \le j &lt; i \wedge \sum_{k = j + 1}^i a_k \le m} (d[j] + \max_{j + 1 \le k \le i} (a_k))<br>$$<br>直接转移明显 $O(n^2)$ ，并且 $val(i, j) = \max_{j + 1 \le k \le i} (a_k)$ 似乎很难用多项式表示，思考转移优化的指导思想：<strong>及时排除不可能的决策，保持候选决策集合的秩序性和有效性</strong>，我们来看看何时决策 $j$ 是必要的</p><p>引理：</p><p>决策 $j(0 \le j &lt; i \wedge \sum_{k = j + 1}^i a_k \le m)$ 是最优策略的必要条件是它至少满足下面两个式子<strong>之一</strong>：</p><ol><li> $a_j = \max_{j \le k \le i} (a_k)$ </li><li> $\sum_{k = j}^i a_k &gt; m$ 或者说 $j$ 是最小的满足 $\sum_{k = j + 1}^i a_k \le m$ 的数</li></ol><p>证明：</p><p>设 $j$ 两个条件都不满足，则由条件 $1$ 有 $\max_{j \le k \le i} (a_k) = \max_{j + 1 \le k \le i} (a_k)$ ，再由条件 $2$ 可知决策 $j - 1$ 合法，又因为明显 $d[j - 1] \le d[j]$ ，有 $d[j - 1] + \max_{j \le k \le i} (a_k) \le d[j] + \max_{j + 1 \le k \le i} (a_k)$ ，即决策 $j - 1$ 优于决策 $j$ </p><p>QED</p><p> 那么，现在来看看引理如何指导 dp ，首先是条件 $2$ ，可以直接对每个 $i$ 预处理出最小的 $j$ ，然后直接进行一次转移即可（然而后面会有更简单的实现方法）；而对于条件 $1$ ，考虑优先队列，当一个新决策 $k$ 入队时，若队尾决策 $j$ 满足 $j &lt; k (这个条件显然) \wedge a_j \le a_k$ 那么 $j$ 一定不优于 $k$ ，这样看来只要维护一个 $a_i$ 单调递减的队列，就可以做到 $O(n)$ 的 dp 了……吗？</p><p>发现我们只能保证<strong>队列中的元素可能为最优决策</strong>，但队头不一定是令 $d[j] + \max_{j + 1 \le k \le i} (a_k)$ 取得最小值的 $j$ ，如果直接扫描队列时间又变回 $O(n^2)$ 了，故我们要快速找到队列中的最优解，考虑数据结构，它要支持查询最小、插入、删除——这不平衡树吗（好像二叉堆 + 懒惰删除也行）？直接维护一个内部元素于单调队列相同的平衡树即可，总时间 $O(n \log n)$ </p><p>最后一个小问题：  $\max_{j + 1 \le k \le i} (a_k)$ 可以用 ST 表做到 $O(1)$ ，但其实仔细思考可以发现，队列中某一项的 $\max_{j + 1 \le k \le i} (a_k)$ 就是它下一项的 $a_i$ </p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><ol><li>特判无解的情况</li><li>关于条件 $2$ 的实现，可以不必预处理，记录一个当前  $sum$ 和对应最小的 $j$ ，即 $L$ 当队列中只有一个元素时就用 $L$ 转移，同时 $L$ 还可以帮助维护队头</li><li> 虽然队列中某一项的 $\max_{j + 1 \le k \le i} (a_k)$ 就是它下一项的 $a_i$ ，但我们的队列（同时对应平衡树）维护的是 $a_i$ ，所以应该是从当前项找到上一项的 $d$ （具体见代码的 <code>calc()</code> 函数），而排除/调用最优时要的是 $d$ ，所以要减 $1$ </li><li>本题一定要先插入再转移，原因同 $3$ ，我们维护的是 $a$ ，而转移时调用的是 $d$ ，它可能刚好是当然插入 $a$ 的前一个（另，关于队列的写法，这边建议都写成先插入再转移的）</li><li>如果你实在觉得这细节来细节去的太麻烦，可以考虑用预处理的方式实现条件 $2$ ，并明确下标，就不必管 $2 \sim 4$ 了（<del>但代码会变长</del>）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N];</span><br><span class="line">LL m, d[N] ,sum;</span><br><span class="line"><span class="keyword">int</span> q[N], l, r, L;</span><br><span class="line">multiset&lt;LL&gt; s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> d[q[x - <span class="number">1</span>]] + a[q[x]]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %lld&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; m) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>), <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    l = L = <span class="number">1</span>, r = sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (; l &lt;= r &amp;&amp; a[i] &gt;= a[q[r]]; --r) <span class="keyword">if</span> (l &lt; r) s.<span class="built_in">erase</span>(s.<span class="built_in">find</span>(<span class="built_in">calc</span>(r)));</span><br><span class="line">        q[++r] = i;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) s.<span class="built_in">insert</span>(<span class="built_in">calc</span>(r));</span><br><span class="line">        sum += a[i];</span><br><span class="line">        <span class="keyword">for</span> (; sum &gt; m; sum -= a[L++]); </span><br><span class="line">        <span class="keyword">for</span> (; l &lt;= r &amp;&amp; q[l] &lt; L; ++l) <span class="keyword">if</span> (l &lt; r) s.<span class="built_in">erase</span>(s.<span class="built_in">find</span>(<span class="built_in">calc</span>(l + <span class="number">1</span>)));</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= r) d[i] = d[L - <span class="number">1</span>] + a[q[l]];</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) d[i] = <span class="built_in">min</span>(d[i], *s.<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, d[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题五"><a href="#例题五" class="headerlink" title="例题五"></a>例题五</h2><p>下面来看一个经典问题，多重背包问题：<a href="https://www.luogu.com.cn/problem/P1782">旅行商的背包</a></p><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>给定 $n \le 10^4$ 种物品，每种物品有 $d_i \le 1000$  个，体积为 $v_i \le 1000$ ，价值为 $w_i \le 1000$ ，又给定 $m \le 5$ 个特殊物品，第 $i$ 个特殊物品的价值 $y_i$ 与取走的体积 $x_i$ 满足 $y_i = a_i x_i^2 + b_i x_i + c_i$  ，其中 $\mid a_i, b_i, c_i \mid \le 1000$ ，现有一个容量为 $c \le 10^4$ 的背包，求最大价值</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>由于 $m \le 5$ 很小，可以完全背包暴力做，问题就转化为多重背包的板子，用二进制拆分法的时间复杂度为 $O(n c \log d )$ 可过，但卡的有点死，实际上，用单调队列可以优化到 $O(nc)$ </p><p>先考虑原来的朴素方程： <code>f[j]</code> （题目已经有 $d$ 了，这里就用 $f$ ）表示“从前 $i$ 个物品中选体积和为 $j$ 的物品的最大价值”（ $i$ 那一维被<strong>倒序循环</strong>压缩掉了），在转移时，考虑第 $i$ 个物品选了 $cnt$ 个：<br>$$<br>f[j] = \max_{1 \le cnt \le d_i} (f[j - cnt * v_i] + cnt * w_i)<br>$$<br>考虑状态 $j$ （注意 $j$ 是状态， $cnt$ 才是决策），它的决策集合就是 $\{j - cnt * v_i \mid 1 \le cnt \le d_i \}$ ，不难发现这个集合相比状态 $j - v_i$ 的决策集合 $\{j - v_i - cnt * v_i \mid 1 \le cnt \le d_i \}$ 只变化了一个数，这启发我们把 $j$ 按照 $\mod v_i$ 的余数分组</p><p>为了简单，我们完全不必枚举 $j$ ，改为枚举余数 $u \in [0, v_i)$ ，再枚举（这里就正序了） $p = 0 \sim \lfloor \frac{c - u}{v_i} \rfloor$ ，这样就可以计算出 $j = u + p * v_i$ ，故 $j$ 的决策集合就是 $\{u + k * p_i \mid p - d_i \le k \le p - 1 \}$ ，于是方程变为：<br>$$<br>f[u + p * v_i] = \max_{p - d_i \le k \le p - 1} (f[u + k * v_i] + (p - k) * w_i)<br>$$<br>这里的 $val(p, k) = (p - k) * w_i$ 明显可以分成两部分 $p * w_i$ 和 $-k * w_i$ ，且当 $p$ 减 $1$ 时，上下界 $p - d_i, p - 1$ 都单调变化，这就是典型的单调队列优化模型，我们建立一个决策点 $k$ 递减， $f[u + k * v_i] - k * w_i$ 递减的单调队列，每次取队头跟新即可，时间复杂度 $O(nc)$ </p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><p>本题卡常，吸氧或者加快读可过（我懒就吸氧了）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIL pair<span class="meta-string">&lt;int, LL&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, C;</span><br><span class="line">LL f[N];</span><br><span class="line">PIL q[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;C);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, v, w, d, u; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;v, &amp;w, &amp;d), u = <span class="number">0</span>; u &lt; v; ++u)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>, p = <span class="number">0</span>, j; (j = p * v + u) &lt;= C; ++p)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (; l &lt;= r &amp;&amp; f[j] - w * p &gt; q[r].se; --r);</span><br><span class="line">                q[++r] = &#123;p, f[j] - w * p&#125;;</span><br><span class="line">                <span class="keyword">for</span> (; l &lt;= r &amp;&amp; q[l].fi &lt; p - d; ++l); <span class="comment">//其实这里if也行,因为每次只有一个数出队</span></span><br><span class="line">                f[j] = q[l].se + w * p;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b, c, j; i &lt;= m; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c), j = C; j; --j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= j; ++k) f[j] = <span class="built_in">max</span>(f[j], f[j - k] + (LL)(a * k + b) * k + c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, f[C]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h1><p>没想到这么长，打算分成三篇写，会挂链接的</p><p><a href="https://dyd-true.github.io/2022/02/09/%E4%BC%98%E5%8C%96dp2/#more">优化dp2</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt; 然而我 dp 废的一比（梅开二度）&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数据结构" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="倍增" scheme="https://dyd-true.github.io/tags/%E5%80%8D%E5%A2%9E/"/>
    
    <category term="单调队列" scheme="https://dyd-true.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
    <category term="笔记" scheme="https://dyd-true.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>luoguP7519 [省选联考 2021 A/B 卷] 滚榜</title>
    <link href="https://dyd-true.github.io/2022/02/08/luoguP7519-%E7%9C%81%E9%80%89%E8%81%94%E8%80%83-2021-A-B-%E5%8D%B7-%E6%BB%9A%E6%A6%9C/"/>
    <id>https://dyd-true.github.io/2022/02/08/luoguP7519-%E7%9C%81%E9%80%89%E8%81%94%E8%80%83-2021-A-B-%E5%8D%B7-%E6%BB%9A%E6%A6%9C/</id>
    <published>2022-02-08T00:38:22.000Z</published>
    <updated>2022-02-08T02:01:50.210Z</updated>
    
    <content type="html"><![CDATA[<p> too difficult for 蒟蒻</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P7519">滚榜</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>已知有 $n \le 13$ 个数 $a_i \le 10^4$ ，按 $1 \sim n$ 编号，每次选一个数给他加上 $b_i$ ，要保证加的 $b_i$ 不小于上次加的，且加完后该数排名第一（大小相同的比编号），已知 $\sum b_i = m \le 500$ ，求最后 $n$ 个数的排名情况有多少种</p><h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><p>看 $n \le 13$ 考虑状态压缩，设 <code>d[s][i][j][k]</code> 表示“已加的数集合为 $s$ ，上一个加的为 $i$ ，当前 $\sum b_i = j$ 且上一个 $b_i = k$ 的方案数”，有 $d[s][i][j][k] \to d[s + \{p\}][p][j + q][q]$ （满足 $a_p + q &gt; / \ge a_i + b_i, j + q &lt; m, q \ge k$ ）时间复杂度为 $O(2^n n^2 m^2)$ 呃呃……</p><p>考虑把状态的维度剪掉，当然是剪一个 $m$ （剪 $n$ 没用啊），发现我们不必要上一个 $b_i$ ，考虑用别的前几维的信息得到 $b_i$ ，发现不是很好表示</p><p>考虑预处理，首先，我们发现数 $a_i$ 要变成最大的， $b_i$ 就要比 $b_j$ 大至少 $a_j - a_i$ （假设 $j$ 先于 $i$ ），不妨设它为 $dt[i][j]$ ，计算它要用 $O(n^2)$ </p><p>其次，由于 $b$ 按出现的顺序单调不降，不妨考虑差分，设差分数组为 $c$ ，有 $b_i = \sum_{j = 1}^i c_i$  （这里假设 $b_i$ 按出现顺序排序了， $b_i$ 的 $i$ 已经不对应 $a_i$ 了），故 $\sum b_i = \sum c_i * (n - i + 1) = m$ ，所以 $c_i$ 对 $m$ 的贡献就要乘 $n - i + 1$ ，只需保证 $c_i \ge 0$ 即可，而 $c_i$ 的最小值就是 $dt[i][j]$ （ $j$ 先于 $i$ 一个）</p><p>再次定义 <code>d[s][i][j]</code> 为“已加的数集合为 $s$ ，上一个加的为 $i$ ，当前 $\sum b_i = j$ 的方案数”，设 $t = s - \{i\}$ ，有 $d[s][i][j] \gets d[t][k][j - dt[i][k] * (n - \mid A \mid)]$ ，时间为 $O(2^n n m)$ ，常数小可过</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">15</span>, NN = (<span class="number">1</span> &lt;&lt; <span class="number">13</span>) + <span class="number">5</span>, M = <span class="number">500</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, nn;</span><br><span class="line">LL ans;</span><br><span class="line"><span class="keyword">int</span> a[N], dt[N][N], d[NN][N][M], si[NN]; <span class="comment">//si[s]:集合s的大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m), nn = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) dt[i][j] = <span class="built_in">max</span>(<span class="number">0</span>, a[j] - a[i] + (i &gt; j)), dt[i][<span class="number">0</span>] = <span class="built_in">max</span>(dt[i][j], dt[i][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nn; ++i) si[i] = si[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>, t, num; s &lt; nn; ++s)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j; i &lt;= n; ++i) <span class="keyword">if</span> (s &gt;&gt; i - <span class="number">1</span> &amp; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (t = s ^ <span class="number">1</span> &lt;&lt; i - <span class="number">1</span>, num = n - si[t], j = si[t] ? <span class="number">1</span> : <span class="number">0</span>; j &lt;= n; ++j) <span class="keyword">if</span> (!j || t &gt;&gt; j - <span class="number">1</span> &amp; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = dt[i][j] * num; k &lt;= m; ++k) d[s][i][k] += d[t][j][k - dt[i][j] * num];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) ans += d[nn - <span class="number">1</span>][i][j];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; too difficult for 蒟蒻&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="状态压缩" scheme="https://dyd-true.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>luoguP4067 [SDOI2016]储能表</title>
    <link href="https://dyd-true.github.io/2022/02/07/luoguP4067-SDOI2016-%E5%82%A8%E8%83%BD%E8%A1%A8/"/>
    <id>https://dyd-true.github.io/2022/02/07/luoguP4067-SDOI2016-%E5%82%A8%E8%83%BD%E8%A1%A8/</id>
    <published>2022-02-07T12:09:58.000Z</published>
    <updated>2022-02-08T00:34:25.749Z</updated>
    
    <content type="html"><![CDATA[<p> 这就是我和巨佬的差距</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P4067">储能表</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p> $T \le 5000$ 组数据，每次给定 $n, m, k \le 10^{18}$ ，求：<br>$$<br>\sum_{i = 0}^{n - 1} \sum_{j = 0}^{m - 1} \max((i \oplus j) - k, 0)<br>$$<br> 答案对 $p \le 10^9$ 取模</p><h2 id="蒻蒟的挣扎"><a href="#蒻蒟的挣扎" class="headerlink" title="蒻蒟的挣扎"></a>蒻蒟的挣扎</h2><p>一看见 $5000, 10^{18}$ 吓了一跳，后来发现是数位 dp</p><p>首先原式里面一个 $\max$ 很不有好（因为它是为了保证非负），不妨考虑只管异或值大于 $k$ 的数对 $(i, j)$ ，就不用管 $\max$ 了，更具体的，我们求出“异或值大于 $k$ 的数对的个数 $A$ ”和“所以异或值大于 $k$ 的数对的异或值之和 $B$ ”，那么 $Ans = B - A * k$ </p><p>考虑分别求 $A, B$ ，定义 <code>d[0/1][i][0/1][0/1][0/1]</code> ，让 $d[0]$ 表示“<strong>从高到低</strong>到了二进制的第 $i$ 位，已经考虑的位数是/否到达 $n$ 的上界，是/否到达 $m$ 的上界，是/否到达 $k$ 的下界，此时的合法个数”， $d[1]$ 类似，但表示的是“异或值之和”</p><p>实现用记忆化搜索，慢一点点但好打的多</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">70</span>;</span><br><span class="line">LL n, m, k;</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">2</span>][N][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>], p, mxl;</span><br><span class="line"><span class="keyword">bool</span> vis[N][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> fn, <span class="keyword">int</span> fm, <span class="keyword">int</span> fk, <span class="keyword">int</span> &amp;as0, <span class="keyword">int</span> &amp;as1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> &amp;f = d[<span class="number">0</span>][len][fn][fm][fk], &amp;g = d[<span class="number">1</span>][len][fn][fm][fk];</span><br><span class="line">    <span class="keyword">if</span> (len &gt; mxl) <span class="keyword">return</span> as0 = <span class="number">1</span>, as1 = <span class="number">0</span>, <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">    <span class="keyword">if</span> (vis[len][fn][fm][fk]) <span class="keyword">return</span> as0 = f, as1 = g, <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">    vis[len][fn][fm][fk] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> pn = (n &gt;&gt; mxl - len) &amp; <span class="number">1</span>, pm = (m &gt;&gt; mxl - len) &amp; <span class="number">1</span>, pk = (k &gt;&gt; mxl - len) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (fn ? pn : <span class="number">1</span>); ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, pf, pg; j &lt;= (fm ? pm : <span class="number">1</span>); ++j) <span class="keyword">if</span> (!fk || (i ^ j) &gt;= pk)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dp</span>(len + <span class="number">1</span>, fn &amp;&amp; (i == pn), fm &amp;&amp; (j == pm), fk &amp;&amp; ((i ^ j) == pk), pf, pg);</span><br><span class="line">            f = (f + pf) % p, g = ((LL)g + (<span class="number">1ll</span> &lt;&lt; mxl - len) * (i ^ j) % p * pf + pg) % p;</span><br><span class="line">        &#125;</span><br><span class="line">    as0 = f, as1 = g;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T, ct, ans[<span class="number">2</span>];</span><br><span class="line">    LL t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T); T--; <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis), <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span> d), mxl = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld %d&quot;</span>, &amp;n, &amp;m, &amp;k, &amp;p), --n, --m;</span><br><span class="line">        <span class="keyword">for</span> (ct = <span class="number">0</span>, t = n; t; ++ct, t &gt;&gt;= <span class="number">1</span>);mxl = <span class="built_in">max</span>(mxl, ct);</span><br><span class="line">        <span class="keyword">for</span> (ct = <span class="number">0</span>, t = m; t; ++ct, t &gt;&gt;= <span class="number">1</span>);mxl = <span class="built_in">max</span>(mxl, ct);</span><br><span class="line">        <span class="keyword">for</span> (ct = <span class="number">0</span>, t = k; t; ++ct, t &gt;&gt;= <span class="number">1</span>);mxl = <span class="built_in">max</span>(mxl, ct);</span><br><span class="line">        <span class="built_in">dp</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, ans[<span class="number">0</span>], ans[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ((LL)ans[<span class="number">1</span>] - k % p * ans[<span class="number">0</span>] % p + p) % p); <span class="comment">//这里太坑了,k是LL,一定要先模一下</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="巨佬的-show-time"><a href="#巨佬的-show-time" class="headerlink" title="巨佬的 show time"></a>巨佬的 show time</h2><p>有巨佬用打表 + 模拟过了……</p><p>思路和<a href="https://www.luogu.com.cn/blog/youxiudezzy/solution-p4067">这位</a>差不多</p><h2 id="巨佬的代码"><a href="#巨佬的代码" class="headerlink" title="巨佬的代码"></a>巨佬的代码</h2><p>懒得打了，直接贴同机房巨佬的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"></span><br><span class="line">ll n, m, k, p, tmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span>((ch = <span class="built_in">getchar</span>()) &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) flag = <span class="literal">true</span>;</span><br><span class="line">x = ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="string">&#x27;0&#x27;</span> &lt;= (ch = <span class="built_in">getchar</span>()) &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) x = x * <span class="number">10</span> + (ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (flag) x = -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(ll x, ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">0</span>) x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (y &lt; <span class="number">0</span>) y = <span class="number">0</span>;</span><br><span class="line">ll res = y - x + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (res &amp; <span class="number">1</span>) <span class="keyword">return</span> (res % p) * ((x + y &gt;&gt; <span class="number">1</span>) % p) % p;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in"><span class="keyword">return</span></span> ((res + <span class="number">1</span> &gt;&gt; <span class="number">1</span>) % p) * ((x + y) % p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getans</span><span class="params">(ll x, ll y, ll z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">max</span>(((n - <span class="number">1</span>) ^ (m - <span class="number">1</span>)) - k, tmp) % p;</span><br><span class="line"><span class="keyword">if</span> (x &lt; y) <span class="built_in">swap</span>(x, y);</span><br><span class="line">ll l =<span class="number">0</span>, t;</span><br><span class="line"><span class="keyword">while</span>((<span class="number">1ll</span> &lt;&lt; l) &lt;= x + <span class="number">1</span>) l++;</span><br><span class="line">l--;</span><br><span class="line">t = (<span class="number">1ll</span> &lt;&lt; l) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (t &lt;= y) <span class="keyword">return</span> ((t + <span class="number">1</span>) % p * <span class="built_in">sum</span>(-z, t - z) % p + (x - t + y - t) % p * <span class="built_in">sum</span>(t + <span class="number">1</span> - z, t * <span class="number">2</span> + <span class="number">1</span> - z) % p + <span class="built_in">getans</span>(x - t - <span class="number">1</span>, y - t - <span class="number">1</span>, z)) % p;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in"><span class="keyword">return</span></span> ((y + <span class="number">1</span>) % p * <span class="built_in">sum</span>(<span class="built_in">max</span>(-z, tmp), <span class="built_in">max</span>(tmp, t - z)) % p + <span class="built_in">getans</span>(x - t - <span class="number">1</span>, y, z - t - <span class="number">1</span>)) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">read</span>(T);</span><br><span class="line"><span class="keyword">while</span>(T--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">read</span>(n), <span class="built_in">read</span>(m), <span class="built_in">read</span>(k), <span class="built_in">read</span>(p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">getans</span>(n - <span class="number">1</span>, m - <span class="number">1</span>, k));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 这就是我和巨佬的差距&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="数论,数学" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="暴力" scheme="https://dyd-true.github.io/tags/%E6%9A%B4%E5%8A%9B/"/>
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="模拟" scheme="https://dyd-true.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="打表" scheme="https://dyd-true.github.io/tags/%E6%89%93%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>luoguP5503 [JSOI2016]灯塔</title>
    <link href="https://dyd-true.github.io/2022/02/07/luoguP5503-JSOI2016-%E7%81%AF%E5%A1%94/"/>
    <id>https://dyd-true.github.io/2022/02/07/luoguP5503-JSOI2016-%E7%81%AF%E5%A1%94/</id>
    <published>2022-02-07T10:28:05.000Z</published>
    <updated>2022-02-07T12:03:25.663Z</updated>
    
    <content type="html"><![CDATA[<p> 明明 $O(n \sqrt{n})$ 可以的……</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P5503">灯塔</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定 $n \le 10^5$ 个数 $0 \le h_i \le 10^9$ ，对于每个数求出一个最小的 $p_i$ 使得 $h_j \le h_i + p_i - \sqrt{\mid i - j \mid}$ 对任意 $h_j$ 成立</p><h2 id="正常做法"><a href="#正常做法" class="headerlink" title="正常做法"></a>正常做法</h2><p>化式子为 $h_j - h_i + \sqrt{\mid i - j \mid} \le p_i$ ，直接暴力是 $n^2$ 的，麻烦点是那个根号，考虑枚举 $k = \sqrt{\mid i - j \mid}$ ，对于枚举到的每个 $k$ ，扫描整个数列，对于当前点 $i$ ，找到满足条件的最大 $h_j$ （用 ST 表可以做到 $O(1)$ ），跟新答案，时间复杂度为 $O(n \sqrt{n})$ </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STC static</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, D = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">namespace</span> ST</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> lg2[N], mx[N][D];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prev</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        lg2[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; ++i) lg2[i] = lg2[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) mx[i][<span class="number">0</span>] = x[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; D; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) mx[i][j] = <span class="built_in">max</span>(mx[i][j - <span class="number">1</span>], mx[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = lg2[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(mx[l][k], mx[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    STC <span class="keyword">int</span> h[N], p[N];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line">    ST::<span class="built_in">prev</span>(h, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>, t = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(n)); k &lt;= t; ++k)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l, r; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            l = (k - <span class="number">1</span>) * (k - <span class="number">1</span>) + i + <span class="number">1</span>, r = <span class="built_in">min</span>(k * k + i, n);</span><br><span class="line">            <span class="keyword">if</span> (l &lt;= r) p[i] = <span class="built_in">max</span>(p[i], ST::<span class="built_in">ask</span>(l, r) - h[i] + k);</span><br><span class="line">            l = <span class="built_in">max</span>(i - k * k, <span class="number">1</span>), r = i - (k - <span class="number">1</span>) * (k - <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (l &lt;= r) p[i] = <span class="built_in">max</span>(p[i], ST::<span class="built_in">ask</span>(l, r) - h[i] + k);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>蒟蒻我到这就结束了，但总有巨佬觉得时间还可以再优</p><h2 id="巨佬的时间"><a href="#巨佬的时间" class="headerlink" title="巨佬的时间"></a>巨佬的时间</h2><p>某位巨佬想出了 $O(n \log n)$ 的做法</p><p>首先去掉绝对值，只考虑 $j &lt; i$ 的情况，设 <code>d[i]</code> 表示“第 $i$ 个数对所有 $j \le i$ 满足条件的最小 $p_i$ ”，然后倒过来再做一遍即可，显然 $d[i] = \max(h_j - h_i + \sqrt{i - j})$ </p><p>然后，考虑根号，注意到这是典型的 $d[i] = \max_{j = 1}^{i - 1} (d[j] + w(j, i))$ 的形式，考虑四边形不等式，那么就要证明 $\forall a &lt; b, w(a, b + 1) + w(a + 1, b) \le w(a, b) + w(a + 1, b + 1)$ （这里因为 $\max$ 所以符号和 $\min$ 相反），对于本题来说 $\sqrt{(b + 1) - a} + \sqrt{b - (a + 1)} \ge \sqrt{b - a} + \sqrt{(b + 1) - (a + 1)}$ 即 $\sqrt{b - a + 1} + \sqrt{b - a - 1} \ge 2\sqrt{b - a}$ 设 $t = b - a$ ，我们要证明 $\sqrt{t + 1} + \sqrt{t - 1} \ge 2 \sqrt{t}$ ，两边平方即可</p><p>因此决策具有单调性，直接用队列 + 二分维护三元组即可，巨佬说因为转移顺序没有要求，所以可以分治，但是我不会，不管如何实现，时间为 $O(n \log n)$ </p><h2 id="贺的巨佬的代码"><a href="#贺的巨佬的代码" class="headerlink" title="贺的巨佬的代码"></a>贺的巨佬的代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DB double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get(i, j) (h[j] + sqrt(i - j))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, h[N];</span><br><span class="line">DB p[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> <span class="keyword">int</span> l, r, x; &#125; stk[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> <span class="comment">//找到i比j更优的最后一个点 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="built_in">max</span>(i, j), r = n, res = <span class="number">-1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">get</span>(mid, i) &gt;= <span class="built_in">get</span>(mid, j)) res = mid, l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    stk[l = r = <span class="number">1</span>] = &#123;<span class="number">1</span>, n ,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; stk[l].r &lt; i) ++l;</span><br><span class="line">        p[i] = <span class="built_in">max</span>(<span class="built_in">get</span>(i, stk[l].x), p[i]);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">get</span>(n, i) &lt;= <span class="built_in">get</span>(n, stk[l].x)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; <span class="built_in">get</span>(stk[r].l, stk[r].x) &lt;= <span class="built_in">get</span>(stk[r].l, i)) --r;</span><br><span class="line">        stk[r].r = <span class="built_in">find</span>(stk[r].x, i), stk[++r] = &#123;stk[r - <span class="number">1</span>].r + <span class="number">1</span>, n, i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line">    <span class="built_in">work</span>();</span><br><span class="line">    <span class="built_in">reverse</span>(h + <span class="number">1</span>, h + <span class="number">1</span> + n), <span class="built_in">reverse</span>(p + <span class="number">1</span>, p + <span class="number">1</span> + n);</span><br><span class="line">    <span class="built_in">work</span>();</span><br><span class="line">    <span class="built_in">reverse</span>(h + <span class="number">1</span>, h + <span class="number">1</span> + n), <span class="built_in">reverse</span>(p + <span class="number">1</span>, p + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">max</span>((<span class="keyword">int</span>)<span class="built_in">ceil</span>(p[i]) - h[i], <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 明明 $O(n \sqrt{n})$ 可以的……&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="ST表" scheme="https://dyd-true.github.io/tags/ST%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>luoguP4072 [SDOI2016]征途</title>
    <link href="https://dyd-true.github.io/2022/02/07/luoguP4072-SDOI2016-%E5%BE%81%E9%80%94/"/>
    <id>https://dyd-true.github.io/2022/02/07/luoguP4072-SDOI2016-%E5%BE%81%E9%80%94/</id>
    <published>2022-02-07T07:48:31.000Z</published>
    <updated>2022-02-07T10:21:30.528Z</updated>
    
    <content type="html"><![CDATA[<p> 被 K-D Tree 虐了一天后继续来 dp 受苦</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P4072">征途</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定 $n$ 个数，分成 $m$ 组，使得每组之和构成的数组方差最小，输出方差 $\times m^2$ ， $n \le 3000$ </p><h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><p>考虑把方差转化推式子：<br>$$<br>\begin{aligned}<br>s^2<br>&amp; = \frac{\sum_{i = 1}^{m} (v_i - \overline{v})^2}{m} \\<br>&amp; = \frac{m (\overline{v})^2 - 2 \overline{v} \sum_{i = 1}^{m} v_i + \sum_{i = 1}^{m} v_i^2}{m} \\<br>又有:\overline{v} &amp; = \frac{\sum_{i = 1}^{m} v_i}{m} \\<br>代入得 s^2<br>&amp; = \frac{m (\frac{\sum_{i = 1}^{m} v_i}{m})^2 - 2 \frac{\sum_{i = 1}^{m} v_i}{m} \sum_{i = 1}^{m} v_i + \sum_{i = 1}^{m} v_i^2}{m} \\<br>&amp; = \frac{\frac{(\sum_{i = 1}^{m} v_i)^2}{m} - 2 \frac{(\sum_{i = 1}^{m} v_i)^2}{m}  + \sum_{i = 1}^{m} v_i^2}{m} \\<br>故 Ans<br>&amp; = s^2 \times m^2 \\<br>&amp; = m \sum_{i = 1}^{m} v_i^2 -(\sum_{i = 1}^{m} v_i)^2 \\<br>&amp; = m \sum_{i = 1}^{m} v_i^2 -(\sum_{i = 1}^{n} x_i)^2 \\<br>\end{aligned}<br>$$<br>发现减号右边的值是恒定的，现在要最小化 $\sum_{i = 1}^{m} v_i^2$ </p><p>考虑 dp ，设 <code>d[i][j]</code> 表示“把前 $i$ 个数分成 $j$ 段的最小平方和”，转移就预处理前缀和， $O(n)$ 枚举最后一段的长度，时间复杂度为 $O(n^2 m)$ ， TLE $80pts$ </p><p>观察 dp 方程： $d[i][j] = min(d[k][j - 1] + (sum[i] - sum[k])^2)$ ，考虑斜率优化，设 $t$ 比 $k$ 优，则：<br>$$<br>\begin{aligned}<br>d[t][j - 1] + (sum[i] - sum[t])^2 &amp; &lt; d[k][j - 1] + (sum[i] - sum[k])^2 \\<br>d[t][j - 1] + sum[t]^2 - d[k][j - 1] - sum[k]^2 &amp; &lt; 2 sum[i] (sum[t] - sum[k]) \\<br>\frac{(d[t][j - 1] + sum[t]^2) - (d[k][j - 1] + sum[k]^2)}{(sum[t] - sum[k])} &amp; &lt; 2 sum[i]<br>\end{aligned}<br>$$<br>换句话说，把二元组 $(sum[x], d[x][j - 1] + sum[x]^2)$ 看作平面上的点，则点 $(sum[t], d[t][j - 1] + sum[t]^2)$ 比 $(sum[k], d[k][j - 1] + sum[k]^2)$ 优的充要条件（因为以上推导显然可以反向）是两点连线（ $k \to t$ ）的斜率小于 $2 sum[i]$ ，则启发我们将式子化为：<br>$$<br>\begin{aligned}<br>(d[k][j - 1] + sum[k]^2) &amp; = (2sum[i]) \times (sum[k]) + (d[i][j] - sum[i]^2) \\<br>y &amp; = k \times x + b<br>\end{aligned}<br>$$<br>要想斜率优化，还要保证 $k, x$ <strong>单调递增</strong>，而它们都是前缀和，单调性显然，于是就可以（<del>痛苦</del>）快乐的用斜率优化，维护一个凸包，把第二维滚动压掉（只会从 $j - 1$ 到 $j$ ），以第二维为最外层循环，枚举第一维，用单调队列维护凸包，转移时直接取队头，时间复杂度为 $O(mn)$ </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DB double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, l, r, o = <span class="number">0</span>;</span><br><span class="line">LL a[N], sum[N], d[N][<span class="number">2</span>], q[N]; </span><br><span class="line"><span class="function">DB <span class="title">get_k</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (DB)((d[y][k] + sum[y] * sum[y]) - (d[x][k] + sum[x] * sum[x])) / (DB)(sum[y] - sum[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]), sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) d[i][o] = sum[i] * sum[i]; <span class="comment">//这里不能初始化为0,所以先把m=1算出来</span></span><br><span class="line">    o ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j; i &lt;= m; ++i, o ^= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (j = i, l = r = <span class="number">1</span>, q[l] = i - <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; <span class="built_in">get_k</span>(q[l], q[l + <span class="number">1</span>], o ^ <span class="number">1</span>) &lt; <span class="number">2</span> * sum[j]) ++l;</span><br><span class="line">            d[j][o] = d[q[l]][o ^ <span class="number">1</span>] + (sum[j] - sum[q[l]]) * (sum[j] - sum[q[l]]);</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; <span class="built_in">get_k</span>(q[r - <span class="number">1</span>], q[r], o ^ <span class="number">1</span>) &gt; <span class="built_in">get_k</span>(q[r], j, o ^ <span class="number">1</span>)) --r;</span><br><span class="line">            q[++r] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, d[n][o ^ <span class="number">1</span>] * m - sum[n] * sum[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 被 K-D Tree 虐了一天后继续来 dp 受苦&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="斜率优化" scheme="https://dyd-true.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>K-D Tree</title>
    <link href="https://dyd-true.github.io/2022/02/06/K-D-Tree/"/>
    <id>https://dyd-true.github.io/2022/02/06/K-D-Tree/</id>
    <published>2022-02-06T12:24:00.000Z</published>
    <updated>2022-02-07T07:42:40.147Z</updated>
    
    <content type="html"><![CDATA[<p> 三维生物瑟瑟发抖</p><span id="more"></span><h1 id="K-D-Tree"><a href="#K-D-Tree" class="headerlink" title="K-D Tree"></a>K-D Tree</h1><p>K-D Tree（k-Dimension Tree，k 维树），是一种<strong>高效处理 $k$ 维空间信息</strong>的（<del>JO级生物</del>）数据结构，在节点数远大于 $2^k$ 时效率很高</p><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>K-D Tree 具有二叉搜索树的形态，通过以下伪代码可以将 $n$ 个 $k$ 维的点建出一棵K-D Tree ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function build (点集 S)</span><br><span class="line">if (S 只有一个点) return 该点</span><br><span class="line">选择一个维度 k ，选择一个切割点 a </span><br><span class="line">以点 a 的第 k 维为标准，所有第 k 维小于 a 的点归入集合 L ，其余归入 R</span><br><span class="line">以点 a 为父节点，用 L 建左子树， R 建右子树</span><br><span class="line">维护一些信息</span><br><span class="line">end function</span><br></pre></td></tr></table></figure><p>可以发现这个树的结构取决于选择的维度和切割点，我们按以下标准选择：</p><ol><li>选择的维度要满足其内部点的分布的差异度最大，即每次选择的切割维度是<strong>方差最大</strong>的维度</li><li>每次在维度上选择切割点时选择该维度上的<strong>中位数</strong>，这样可以保证每次分成的左右子树大小尽量相等</li></ol><p>可以发现这样建出的 K-D Tree 高度最大为 $O(\log n)$ </p><p>考虑建树的时间，每次找中位数时，用 <code>sort</code> 总时间是 $O(n \log^2 n)$ 的，这显然不必要，因为我们不必每次给整个序列排序，只要中位数在正确位置，且左边都小于它，右边大于它即可，在 <code>algorithm</code> 库中的  <code>nth_element()</code> 函数可以支持该操作，它的均摊复杂度为 $O(n)$ 于是建树就变了 $O(n \log n)$ </p><h2 id="插入-删除"><a href="#插入-删除" class="headerlink" title="插入/删除"></a>插入/删除</h2><p>数据结构大部分都要求支持插入和删除，但注意到 K-D Tree 具有二叉搜索树的形态，可它又不支持旋转（或者说很难支持旋转），而 FHQ Treap 的随机优先级思想也不能保证其复杂度，我们考虑用替罪羊树的重构思想</p><p>引入重构常数 $\alpha$ ，对于节点 $x$ 如果它的一个子树的结点数占比大于 $\alpha$ ，或者未删除的结点数在以 $x$ 为根的子树中的占比小于 $\alpha$ 时，我们就重构它</p><p>在插入一个点时，先根据记录的分割维度和分割点判断应该继续插入到左子树还是右子树，如果到达了空结点，新建一个结点代替这个空结点，成功插入结点后回溯插入的过程，维护结点的信息，如果发现当前的子树不平衡，则重构当前子树</p><p>在删除一个点时，先找到它，然后打上懒标记即可</p><p>类似于替罪羊树，带重构的 K-D Tree 的树高仍然是 $O(\log n)$ 的，当然，最好是把操作离线了</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.com.cn/problem/P4148">简单题</a></p><p>$20 MB$ 卡掉树套树，强制在线卡了 CDQ ，于是用 K-D Tree （略微卡常）</p><p>对于修改，直接删除再插入即可，对于询问，记录子树每一维的最大和最小值，可以证明，这样查询 $k$ 维的最坏时间为 $O(n^{1 - \frac{1}{k}})$ ，对于本题，就是 $O(\sqrt{n})$ ，本题可以插入重复元素，然后就不需要删除</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DB double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IL inline</span></span><br><span class="line"><span class="keyword">namespace</span> Fast</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> L = (<span class="number">1</span> &lt;&lt; <span class="number">20</span>) + <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[L], out[L], *iS, *iT;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> gh() (iT == iS ? iT = (iS = buf) + fread(buf, 1, L, stdin), (iT == iS ? EOF : *iS++) : *iS++)</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;class T&gt; </span></span><br><span class="line"><span class="function">    IL <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = <span class="built_in">gh</span>(), t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            t |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">gh</span>();</span><br><span class="line">        <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            x = x * <span class="number">10</span> + (ch ^ <span class="number">48</span>), ch = <span class="built_in">gh</span>();</span><br><span class="line">        <span class="keyword">if</span> (t)</span><br><span class="line">            x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">flus</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">fwrite</span>(out, <span class="number">1</span>, l, stdout);</span><br><span class="line">        l = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">putc</span><span class="params">(<span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        out[l++] = x;</span><br><span class="line">        <span class="keyword">if</span> (l == L - <span class="number">5</span>)</span><br><span class="line">            <span class="built_in">flus</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function">    IL <span class="keyword">void</span> <span class="title">write</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">putc</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">9</span>)</span><br><span class="line">            <span class="built_in">write</span>(x / <span class="number">10</span>);</span><br><span class="line">        out[l++] = x % <span class="number">10</span> + <span class="number">48</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == L - <span class="number">5</span>)</span><br><span class="line">            <span class="built_in">flus</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Fast::flus;</span><br><span class="line"><span class="keyword">using</span> Fast::putc;</span><br><span class="line"><span class="keyword">using</span> Fast::read;</span><br><span class="line"><span class="keyword">using</span> Fast::write;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e5</span> + <span class="number">5</span>, D = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x[D], w;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="keyword">namespace</span> KDT <span class="comment">//K-D Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> DB a = <span class="number">0.725</span>;</span><br><span class="line">    <span class="keyword">int</span> rt, top, rub[M], cur, tot; <span class="comment">//rub:回收空间</span></span><br><span class="line">    Point p[M];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> mn[D], mx[D], sum, lc, rc, si, k;</span><br><span class="line">        Point p;</span><br><span class="line">    &#125; tr[M];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mn(x) tr[(x)].mn</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mx(x) tr[(x)].mx</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sum(x) tr[(x)].sum</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc(x) tr[(x)].lc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc(x) tr[(x)].rc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> si(x) tr[(x)].si</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> k(x) tr[(x)].k</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> p(x) tr[(x)].p</span></span><br><span class="line">    <span class="function">IL <span class="keyword">int</span> <span class="title">newnode</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (top) <span class="keyword">return</span> rub[top--];</span><br><span class="line">        <span class="keyword">return</span> ++cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ls = <span class="built_in">lc</span>(u), rs = <span class="built_in">rc</span>(u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; D; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">mn</span>(u)[i] = <span class="built_in">mx</span>(u)[i] = <span class="built_in">p</span>(u).x[i];</span><br><span class="line">            <span class="keyword">if</span> (ls) <span class="built_in">mn</span>(u)[i] = <span class="built_in">min</span>(<span class="built_in">mn</span>(u)[i], <span class="built_in">mn</span>(ls)[i]), <span class="built_in">mx</span>(u)[i] = <span class="built_in">max</span>(<span class="built_in">mx</span>(u)[i], <span class="built_in">mx</span>(ls)[i]);</span><br><span class="line">            <span class="keyword">if</span> (rs) <span class="built_in">mn</span>(u)[i] = <span class="built_in">min</span>(<span class="built_in">mn</span>(u)[i], <span class="built_in">mn</span>(rs)[i]), <span class="built_in">mx</span>(u)[i] = <span class="built_in">max</span>(<span class="built_in">mx</span>(u)[i], <span class="built_in">mx</span>(rs)[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sum</span>(u) = <span class="built_in">sum</span>(ls) + <span class="built_in">sum</span>(rs) + <span class="built_in">p</span>(u).w, <span class="built_in">si</span>(u) = <span class="built_in">si</span>(ls) + <span class="built_in">si</span>(rs) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>, u = <span class="built_in">newnode</span>();</span><br><span class="line">        <span class="built_in">nth_element</span>(p + l, p + mid, p + r + <span class="number">1</span>, [&amp;](Point a, Point b)&#123; <span class="keyword">return</span> a.x[k] &lt; b.x[k]; &#125;);</span><br><span class="line">        <span class="built_in">k</span>(u) = k, <span class="built_in">p</span>(u) = p[mid], <span class="built_in">lc</span>(u) = <span class="built_in">build</span>(l, mid - <span class="number">1</span>, k ^ <span class="number">1</span>), <span class="built_in">rc</span>(u) = <span class="built_in">build</span>(mid + <span class="number">1</span>, r, k ^ <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">up</span>(u), u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">get_p</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!u) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="built_in">get_p</span>(<span class="built_in">lc</span>(u)), p[++tot] = <span class="built_in">p</span>(u), rub[++top] = u, <span class="built_in">get_p</span>(<span class="built_in">rc</span>(u));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> &amp;u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">si</span>(u) * a &lt; <span class="built_in">max</span>(<span class="built_in">si</span>(<span class="built_in">lc</span>(u)), <span class="built_in">si</span>(<span class="built_in">rc</span>(u)))) tot = <span class="number">0</span>, <span class="built_in">get_p</span>(u), u = <span class="built_in">build</span>(<span class="number">1</span>, tot, <span class="built_in">k</span>(u));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> &amp;u, Point x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!u)</span><br><span class="line">        &#123;</span><br><span class="line">            u = <span class="built_in">newnode</span>();</span><br><span class="line">            <span class="built_in">lc</span>(u) = <span class="built_in">rc</span>(u) = <span class="built_in">k</span>(u) = <span class="number">0</span>, <span class="built_in">p</span>(u) = x;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">up</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x.x[<span class="built_in">k</span>(u)] &lt;= <span class="built_in">p</span>(u).x[<span class="built_in">k</span>(u)]) <span class="built_in">ins</span>(<span class="built_in">lc</span>(u), x);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">ins</span>(<span class="built_in">rc</span>(u), x);</span><br><span class="line">        <span class="built_in">up</span>(u), <span class="built_in">check</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">bool</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> mx[D], <span class="keyword">int</span> mn[D], <span class="keyword">int</span> l[D], <span class="keyword">int</span> r[D])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; D; ++i) <span class="keyword">if</span> (r[i] &lt; mx[i] || l[i] &gt; mn[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">bool</span> <span class="title">out</span><span class="params">(<span class="keyword">int</span> mx[D], <span class="keyword">int</span> mn[D], <span class="keyword">int</span> l[D], <span class="keyword">int</span> r[D])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; D; ++i) <span class="keyword">if</span> (l[i] &gt; mx[i] || r[i] &lt; mn[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l[D], <span class="keyword">int</span> r[D])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!u || <span class="built_in">out</span>(<span class="built_in">mx</span>(u), <span class="built_in">mn</span>(u), l, r)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">in</span>(<span class="built_in">mx</span>(u), <span class="built_in">mn</span>(u), l, r)) <span class="keyword">return</span> <span class="built_in">sum</span>(u);</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">in</span>(<span class="built_in">p</span>(u).x, <span class="built_in">p</span>(u).x, l, r) ? <span class="built_in">p</span>(u).w : <span class="number">0</span>) + <span class="built_in">ask</span>(<span class="built_in">lc</span>(u), l, r) + <span class="built_in">ask</span>(<span class="built_in">rc</span>(u), l, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> op, x[D], y[D], last = <span class="number">0</span>; <span class="built_in">read</span>(op), op != <span class="number">3</span>; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(x[<span class="number">0</span>]), <span class="built_in">read</span>(x[<span class="number">1</span>]), <span class="built_in">read</span>(y[<span class="number">0</span>]), x[<span class="number">0</span>] ^= last, x[<span class="number">1</span>] ^= last, y[<span class="number">0</span>] ^= last;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) KDT::<span class="built_in">ins</span>(KDT::rt, &#123;x[<span class="number">0</span>], x[<span class="number">1</span>], y[<span class="number">0</span>]&#125;);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">read</span>(y[<span class="number">1</span>]), y[<span class="number">1</span>] ^= last, <span class="built_in">write</span>(last = KDT::<span class="built_in">ask</span>(KDT::rt, x, y)), <span class="built_in">putc</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">flus</span>(), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p>个人觉得 K-D Tree 难写、跑得慢且没太大用，不建议打</p>]]></content>
    
    
    <summary type="html">&lt;p&gt; 三维生物瑟瑟发抖&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数据结构" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树" scheme="https://dyd-true.github.io/tags/%E6%A0%91/"/>
    
    <category term="笔记" scheme="https://dyd-true.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="K-D Tree" scheme="https://dyd-true.github.io/tags/K-D-Tree/"/>
    
  </entry>
  
  <entry>
    <title>CF1523F Favorite Game</title>
    <link href="https://dyd-true.github.io/2022/02/06/CF1523F-Favorite-Game/"/>
    <id>https://dyd-true.github.io/2022/02/06/CF1523F-Favorite-Game/</id>
    <published>2022-02-06T09:09:20.000Z</published>
    <updated>2022-02-06T12:02:50.078Z</updated>
    
    <content type="html"><![CDATA[<p> 3300</p><span id="more"></span><p><a href="https://codeforces.com/problemset/problem/1523/F">Favorite Game</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>在平面直角坐标系 $xoy(\mid x, y \mid \le 10^6)$ 玩一个游戏， $0$ 时刻玩家出现在选则的点上，每秒可以走一步或者不动，有 $n \le 14$ 个传送门，初始时未激活，到达一个传送门时此传送门激活，之后可瞬移（不耗时）到这个传送门，有 $m \le 100$ 个任务要求玩家在 $t_i \le 10^9$ 时刻出现在 $(x_i, y_i)$ ，求最多可以完成几个任务</p><h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><p>明显，把传送门的状态压了，任务先按时间排序</p><p>分别考虑传送门和任务，令 <code>g[s][i]</code> 表示“传送门状态为 $s$ 完成了 $i$ 个任务，现在身处某一个传送门的最小时间”，令 <code>f[s][i]</code> 表示“传送门状态为 $s$ 刚完成了任务 $i$ 时可以完成的最大任务数”</p><p>对于每种传送门状态，预处理出它到每个地点（传送门和任务）的最短路程，分四种情况转移：</p><ul><li>传送门到传送门，直接用预处理</li><li>传送门到任务，判断可行后用预处理</li><li>任务到传送门，要么直接走要么用传送</li><li>任务到任务，要么直接走要么用传送，要判断可行</li></ul><p>时间为 $O(2^n m^2)$ </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STC static</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dis(a, b) (abs(a.x - b.x) + abs(a.y - b.y))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">14</span> + <span class="number">5</span>, M = <span class="number">100</span> + <span class="number">5</span>, NN = (<span class="number">1</span> &lt;&lt; <span class="number">14</span>) + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, nn, ans = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Door</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125; d[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Task</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, t;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Task&amp; task) <span class="keyword">const</span> &#123; <span class="keyword">return</span> t &lt; task.t; &#125;</span><br><span class="line">&#125; ta[M];</span><br><span class="line"><span class="keyword">int</span> td[NN][N], tt[NN][M]; <span class="comment">//td:to_door,tt:to_task</span></span><br><span class="line"><span class="keyword">int</span> f[NN][M], g[NN][M], lg2[NN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m), nn = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;d[i].x, &amp;d[i].y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;ta[i].x, &amp;ta[i].y, &amp;ta[i].t);</span><br><span class="line">    <span class="built_in">sort</span>(ta + <span class="number">1</span>, ta + <span class="number">1</span> + m);</span><br><span class="line">    <span class="built_in">memset</span>(td, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> td), <span class="built_in">memset</span>(tt, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> tt);</span><br><span class="line">    lg2[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= nn; ++i) lg2[i] = lg2[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>, j = <span class="built_in">lowbit</span>(s); s &lt; nn; ++s, j = <span class="built_in">lowbit</span>(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) td[s][i] = <span class="built_in">min</span>(td[s ^ j][i], <span class="built_in">dis</span>(d[lg2[j] + <span class="number">1</span>], d[i]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) tt[s][i] = <span class="built_in">min</span>(tt[s ^ j][i], <span class="built_in">dis</span>(d[lg2[j] + <span class="number">1</span>], ta[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0xcf</span>, <span class="keyword">sizeof</span> f), <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) g[<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>)][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) f[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; nn; ++s)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) <span class="keyword">if</span> (!((s &gt;&gt; (j - <span class="number">1</span>)) &amp; <span class="number">1</span>)) g[s ^ (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][i] = <span class="built_in">min</span>(g[s][i] + td[s][j], g[s ^ (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][i]); <span class="comment">//door to door</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) <span class="keyword">if</span> (g[s][i] + tt[s][j] &lt;= ta[j].t) f[s][j] = <span class="built_in">max</span>(i + <span class="number">1</span>, f[s][j]); <span class="comment">//door to task</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) <span class="keyword">if</span> (!((s &gt;&gt; (j - <span class="number">1</span>)) &amp; <span class="number">1</span>) &amp;&amp; f[s][i] &gt; <span class="number">0</span>) g[s ^ (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][f[s][i]] = <span class="built_in">min</span>(ta[i].t + <span class="built_in">min</span>(td[s][j], <span class="built_in">dis</span>(ta[i], d[j])), g[s ^ (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][f[s][i]]); <span class="comment">//task to door</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= m; ++j) <span class="keyword">if</span> (ta[i].t + <span class="built_in">min</span>(<span class="built_in">dis</span>(ta[i], ta[j]), tt[s][j]) &lt;= ta[j].t) f[s][j] = <span class="built_in">max</span>(f[s][j], f[s][i] + <span class="number">1</span>); <span class="comment">//task to task</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, f[s][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 3300&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="状态压缩" scheme="https://dyd-true.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="CF" scheme="https://dyd-true.github.io/tags/CF/"/>
    
  </entry>
  
  <entry>
    <title>CF1530F Bingo</title>
    <link href="https://dyd-true.github.io/2022/02/06/CF1530F-Bingo/"/>
    <id>https://dyd-true.github.io/2022/02/06/CF1530F-Bingo/</id>
    <published>2022-02-06T06:39:00.000Z</published>
    <updated>2022-02-06T09:02:14.564Z</updated>
    
    <content type="html"><![CDATA[<p> 最讨厌期望了</p><span id="more"></span><p><a href="https://codeforces.com/problemset/problem/1530/F">Bingo</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给 $n \times n$ 的矩阵，每个点有 $p_{i, j} \times 10^{-4}$ 的概率为 $1$ ，否则为 $0$ ，求存在某一行或者一列或者一条对角线全为 $1$ 的概率， $n \le 21$ </p><h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><p>先想暴力，设集合 $l_1, l_2, …, l_n$ 表示每一行的点集， $l_{n + 1}, …, l_{2n}$ 表示每一列的点集， $l_{2n + 1}, l_{2n + 2}$ 表示对角线，令 $P(l_i)$ 表示点集 $l_i$ 全为 $1$ 的概率， $P(\overline{l_i})$ 表示点集 $l_i$ 不全为 $1$ 的概率</p><p>明显可以用容斥 $O(2^{2n + 2})$ 暴力统计答案，但当然 TLE</p><p>先来看几条正确性显然的性质：</p><ol><li> $P(l_i) + P(\overline{l_i}) = 1$ </li><li> $P(A \wedge B) = P(B) P(A \mid B)$ ，其中 $A \mid B$ 表示在事件 $B$ 发生的条件下发生事件 $A$ </li><li> $P(\overline{A} \wedge B) + P (A \wedge B) = P(B)$ </li></ol><p>发现我们要求的就是 $P(l_1 \vee l_2 \vee … \vee l_{2n + 2}) = 1 - P(\overline{l_1} \wedge \overline{l_2} \wedge … \wedge \overline{l_{2n + 2}})$ ，然后变形：<br>$$<br>\begin{aligned}<br>&amp; P(\overline{l_1} \wedge \overline{l_2} \wedge … \wedge \overline{l_{2n + 2}}) + P(l_1 \wedge \overline{l_2} \wedge … \wedge \overline{l_{2n + 2}}) = P(\overline{l_2} \wedge … \wedge \overline{l_{2n + 2}}) &amp; (1) \\<br>&amp; P(l_1 \wedge \overline{l_2} \wedge … \wedge \overline{l_{2n + 2}}) = P(l_1) P(\overline{l_2} \wedge … \wedge \overline{l_{2n + 2}}) &amp; (2) \\<br>&amp; 由 (1) (2) 得: \\<br>&amp; P(\overline{l_1} \wedge \overline{l_2} \wedge … \wedge \overline{l_{2n + 2}}) = P(\overline{l_2} \wedge … \wedge \overline{l_{2n + 2}}) - P(l_1) P(\overline{l_2} \wedge … \wedge \overline{l_{2n + 2}}) &amp; (3) \\<br>\end{aligned}<br>$$<br>可以容斥来解释</p><p>考虑 dp ，定义 $d(i, S)$ 表示 $P(\overline{l_i} \wedge … \wedge \overline{l_{2n + 2}} \mid l_{s_1} \wedge … \wedge l_{s_k})$ ，即直线 $s \in S$ 全为 $1$ 而直线 $l_{i \sim 2n + 2}$ 不全为 $1$ 的概率，那么 $(3)$ 式可化为：<br>$$<br>\begin{aligned}<br>&amp; d(i, S) = d(i + 1, S) - d(i + 1, S \vee \{i\}) P(l_i \mid l_{s_1} \wedge … \wedge l_{s_k}) &amp; (4) \\<br>\end{aligned}<br>$$<br>观察这个式子， $P(l_i \mid l_{s_1} \wedge … \wedge l_{s_k})$ 可以 $O(n)$ 求，初始化为 $d(2n + 3, S) = 1$ ，答案就是 $1 - d(1, 0)$ ，时间为 $O(n \times (2n + 2) \times 2^{2n + 2})$ ，这不爆炸，还不如暴力</p><p>看来还得加点容斥，我们暴力枚举行的情况，有 $2^n$ 种（要么 $l_i$ 要么 $\overline{l_i}$ ），然后考虑列（下面的 $i$ 就只代表列了）， $(4)$ 式可化为：<br>$$<br>\begin{aligned}<br>&amp; d(i, S) = d(i + 1, S) - d(i + 1, S) P(l_i \mid l_{s_1} \wedge … \wedge l_{s_k}) \\<br>\end{aligned}<br>$$<br>这是因为我们现在只考虑列，把当前列加入 $S$ 对后面的列没有影响，所有可以干脆不加，则 $S$ 中始终只有我们枚举出的行（要注意此时求出的 $d$ 已经不一样了，因为行我们是枚举的，其概率还没加到 $d$ 中），这样，在枚举了行后，列可以 $O(n^2)$ 计算，这里有一个 $n$ 是求 $P(l_i \mid l_{s_1} \wedge … \wedge l_{s_k})$ 的，这可以预处理成 $O(1)$ ，具体地，设 $mul(i, S)$ 表示“对于第 $i$ 列，行选则情况为 $S$ 的时候，这些行与第 $i$ 列的相交的格子的乘积”，且设 $U$ 为行集合的全集，则有：<br>$$<br>\begin{aligned}<br>&amp; d(i, S) = d(i + 1, S) - d(i + 1, S) \times mul(i, U - S) \\<br>\end{aligned}<br>$$<br>但上面说了，时求出的 $d$ 已经不一样了，为了加上行选择的情况的概率，还要乘一个 $mul(i, S)$ ，同时，发现第一维完全可以省略，即：<br>$$<br>\begin{aligned}<br>&amp; d(S) = (d(S) - d(S) \times mul(i, U - S)) \times nul(i, S) \\<br>&amp; d(S) = (1 - mul(i, U - S)) \times mul(i, S) \times d(S) &amp; (5) \\<br>\end{aligned}<br>$$<br>这样，列的 dp 就是 $O(n)$ 的了</p><p>然后我们再明确一下行的影响，行是枚举的，计算时要用容斥，就是： $1 - d(至少 1 行全为 1) + d(至少 2 行全为 1) - …$ ， dp 贡献时加个系数即可</p><p>最后考虑一下对角线，由于只有两条，可以和行一样枚举它们的情况，把它当成一种特殊的行（具体见代码）</p><p>考虑时间，枚举容斥是 $O(2^{n + 2})$ ， dp 是 $O(n)$ 的，最后就是 $O(n 2^{n + 2})$ </p><p>ps：模数 $31607$ 是质数， $10^4$ 在其意义下的逆元为 $3973$ </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STC static</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x) &amp; -(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">21</span> + <span class="number">5</span>, P = <span class="number">31607</span>, INV = <span class="number">3973</span>, NN = (<span class="number">1</span> &lt;&lt; <span class="number">21</span>) + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, nn, p[N][N], ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> lg2[NN], mul[N][NN];</span><br><span class="line"><span class="keyword">int</span> d[NN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prev</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lg2[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= nn; ++i) lg2[i] = lg2[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, s, j; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (mul[i][<span class="number">0</span>] = <span class="number">1</span>, s = <span class="number">1</span>; s &lt; nn; ++s) mul[i][s] = (LL)mul[i][s ^ (j = <span class="built_in">lowbit</span>(s))] * p[lg2[j] + <span class="number">1</span>][i]% P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cntbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res; </span><br><span class="line">    <span class="keyword">for</span> (res = <span class="number">1</span>; x; x &amp;= (x - <span class="number">1</span>), ++res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), nn = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p[i][j]), p[i][j] = (LL)p[i][j] * INV % P;</span><br><span class="line">    <span class="built_in">prev</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt;= <span class="number">3</span>; ++t) <span class="comment">//t枚举对角线的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; nn; ++s) d[s] = (<span class="built_in">cntbit</span>(s) + <span class="built_in">cntbit</span>(t)) &amp; <span class="number">1</span> ? <span class="number">-1</span> : <span class="number">1</span>; <span class="comment">//容斥系数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>, _s; s &lt; nn; ++s)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//加上对角线</span></span><br><span class="line">                _s = s;</span><br><span class="line">                <span class="keyword">if</span> (t &amp; <span class="number">1</span>) _s |= <span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (t &amp; <span class="number">2</span>) _s |= <span class="number">1</span> &lt;&lt; (n - i);</span><br><span class="line">                d[s] = (LL)d[s] * mul[i][_s] % P * (<span class="number">1</span> - mul[i][(nn - <span class="number">1</span>) ^ _s] + P) % P;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; nn; ++s) ans = (ans + d[s]) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (<span class="number">1</span> - ans + P) % P);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 最讨厌期望了&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="状态压缩" scheme="https://dyd-true.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="CF" scheme="https://dyd-true.github.io/tags/CF/"/>
    
    <category term="容斥" scheme="https://dyd-true.github.io/tags/%E5%AE%B9%E6%96%A5/"/>
    
  </entry>
  
  <entry>
    <title>CF1584F Strange LCS</title>
    <link href="https://dyd-true.github.io/2022/02/06/CF1584F-Strange-LCS/"/>
    <id>https://dyd-true.github.io/2022/02/06/CF1584F-Strange-LCS/</id>
    <published>2022-02-06T02:32:28.000Z</published>
    <updated>2022-02-06T06:38:07.153Z</updated>
    
    <content type="html"><![CDATA[<p> CF来到2600</p><span id="more"></span><p> <a href="https://codeforces.com/problemset/problem/1584/F">Strange LCS</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>$T \le 5$ 组数据，给定 $n \le 10$ 个字符串，字符集为大、小写字母且每个字符在同一个串中最多出现两次，求它们的LCS（最长公共子串）</p><h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><p>暴力做法就类似两个串的LCS，直接 $10$ 维dp，时间……</p><p>发现有信息没用：字符集为大、小写字母且<strong>每个字符在同一个串中最多出现两次</strong></p><p>先考虑如果每个字符只出现一次怎么办，由于字符集不大，可以考虑设计状态为 <code>d[ch]</code> 表示“以**字符 $ch$ **结尾的前缀子串的LCS”，方程明显为 $d[i] = \max(d[j]) + 1$  ，这里要保证在所有串中字符 $j$ 都在字符 $i$ 的前面，关于字符的位置可以预处理</p><p>现在，字符出现了两次，当然可以延续上面的做法，预处理字符的位置，把状态设计为“以字符 $ch$ 结尾的前缀子串的LCS”，但同时我们必须知道这个字符在每个串中是第几次出现，考虑状压，用一个二进制数 $s$ 表示在每个串中是第几次出现，则状态 <code>d[ch][s]</code> 表示“以字符 $ch$ 在第 $i$ 个串中第 $k_i$ 次出现结尾的前缀子串的LCS”，其中 $k_i$  是 $s$ 中压缩的信息， $k_i = 0 / 1$  表示第 $1 / 2$ 次出现</p><p>转移的时候有个贪心：可以从 $k_i = 1$ 转移就不必从 $k_i = 0$ 转移，因为第 $2$ 次出现一定在第 $1$ 次后面，以它结尾的前缀子串一定包含了第 $1$ 次，所以转移时，设当前转移为 $d[ch][s] \gets d[j][t]$ ，直线枚举字符 $j$ ，若在串 $i$ 中字符 $ch$ 前有两个 $j$ 就从 $k_i = 1$ 转移，有一个就从 $k_i = 0$ 转移，换句话说，我们在枚举 $j$ 时就确定了 $t$ </p><p>考虑时间，设字符集大小为 $V$ 状态有 $V \times 2^n$ 个，每次转移要枚举字符 $j$ 并 $O(n)$ 得到 $t$ ，故时间为 $O(V \times 2^n \times V \times n) = O(V^2 2^n n)$ </p><p>由于判断较多，具体实现可以考虑记忆化搜索</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>稍微压了压行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STC static</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span> + <span class="number">5</span>, NN = (<span class="number">1</span> &lt;&lt; <span class="number">10</span>) + <span class="number">5</span>, V = <span class="number">52</span> + <span class="number">5</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, pos[N][V][<span class="number">2</span>], d[V][NN], fr1[V][NN], fr2[V][NN]; <span class="comment">//fr记录来向</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d[ch][s] != <span class="number">-1</span>) <span class="keyword">return</span> d[ch][s];</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j, t; i &lt; V; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>, t = <span class="number">0</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (pos[j][i][<span class="number">0</span>] &gt;= pos[j][ch][(s &gt;&gt; (j - <span class="number">1</span>)) &amp; <span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pos[j][i][<span class="number">1</span>] &lt; pos[j][ch][(s &gt;&gt; (j - <span class="number">1</span>)) &amp; <span class="number">1</span>]) t |= <span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (j &gt; n &amp;&amp; <span class="built_in">dp</span>(i, t) &gt;= mx) mx = d[i][t] + <span class="number">1</span>, fr1[ch][s] = i, fr2[ch][s] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[ch][s] = mx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">(<span class="keyword">int</span> id1, <span class="keyword">int</span> id2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fr1[id1][id2] != <span class="number">-1</span>) <span class="built_in">out</span>(fr1[id1][id2], fr2[id1][id2]);</span><br><span class="line">    <span class="keyword">if</span> (id1 &lt; <span class="number">26</span>) <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, id1 + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, id1 + <span class="string">&#x27;A&#x27;</span> - <span class="number">26</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T, mx, mxid1, mxid2;</span><br><span class="line">    STC <span class="keyword">char</span> s[V &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        mx = <span class="number">0</span>, mxid1 = mxid2 = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//这里要是极大</span></span><br><span class="line">        <span class="built_in">memset</span>(pos, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> pos), <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d), <span class="built_in">memset</span>(fr1, <span class="number">-1</span>, <span class="keyword">sizeof</span> fr1);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j, len; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>), j = <span class="number">1</span>, len = <span class="built_in">strlen</span>(s + <span class="number">1</span>); j &lt;= len; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[j] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; s[j] &lt;= <span class="string">&#x27;z&#x27;</span>) s[j] -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span> s[j] += <span class="number">26</span> - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (pos[i][s[j]][<span class="number">0</span>] &gt;= INF) pos[i][s[j]][<span class="number">0</span>] = j;</span><br><span class="line">                <span class="keyword">else</span> pos[i][s[j]][<span class="number">1</span>] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j, t; i &lt; V; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>, t = <span class="number">0</span>; j &lt;= n; ++j)</span><br><span class="line">                <span class="keyword">if</span> (pos[j][i][<span class="number">0</span>] &gt;= INF) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pos[j][i][<span class="number">1</span>] &lt; INF) t |= <span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (j &gt; n &amp;&amp; <span class="built_in">dp</span>(i, t) &gt;= mx) mx = d[i][t] + <span class="number">1</span>, mxid1 = i, mxid2 = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, mx);</span><br><span class="line">        <span class="keyword">if</span> (mxid1 != <span class="number">-1</span>) <span class="built_in">out</span>(mxid1, mxid2);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; CF来到2600&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="字符串" scheme="https://dyd-true.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="状态压缩" scheme="https://dyd-true.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="CF" scheme="https://dyd-true.github.io/tags/CF/"/>
    
  </entry>
  
  <entry>
    <title>luoguAT2390 [AGC016F] Games on DAG</title>
    <link href="https://dyd-true.github.io/2022/02/06/luoguAT2390-AGC016F-Games-on-DAG/"/>
    <id>https://dyd-true.github.io/2022/02/06/luoguAT2390-AGC016F-Games-on-DAG/</id>
    <published>2022-02-06T00:39:15.000Z</published>
    <updated>2022-02-06T08:50:57.077Z</updated>
    
    <content type="html"><![CDATA[<p> 万能的高橋君</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/AT2390">Games on DAG</a></p><p>明显的博弈论，考虑 SG 函数，结论是当初始局面的 SG 为 $0$ 时先手必败，而初始局面的 $SG = SG(1) \oplus SG(2)$ </p><p>于是考虑计算 $SG(1) = SG(2)$ 的方案数，最后减掉，由于 $n \le 15$ ，可以枚举点集 $S$ ，设 $T$ 是 $S$ 的子集且 $\forall x \in T, SG(x) \ne 0$ （即 $T$ 为必胜点），设 $U = S - T$ （即 $U$ 为必败点， $SG = 0$ ），对于记当前点集 $S$ 满足 $SG(1) = SG(2)$ 的方案数为 $d[S]$ </p><p>由于 SG 函数定义在 mex 上，有：</p><ul><li> $U$ 中的点间互相不连边</li><li> $T$ 中的每个点至少有一条边连向 $U$ </li><li> $U$ 中的点连向 $T$ 是没有限制的</li></ul><p>那么怎么转移呢？考虑 $S$ 的连边方案， $U$ 中的点间没边， $U, T$ 间连边的方案数设为 $tmp$ 可以算，对于 $T$ 间的边，不难发现方案数就是 $d[T]$ （这是因为原来 $d[T]$ 上的每个点都向 $U$ 连边，构成的方案一定合法；而所有点集 $S$ 的合法方案去掉 SG 为 $0$ 的点后也一定会得到一个点集 $T$ 的合法方案），故有 $d[S] \gets d[T] * tmp$  </p><p> 还有一个小知识点：统计一个数的二进制中有多少个 $1$ </p><p>直接统计当然是 $\log n$ 的，但还有一个小技巧，就是每次让 <code>n = n &amp; (n - 1)</code> 不难发现这样操作 $1$ 次后 $n$ 二进制下最低的一个 $1$ 变成了 $0$ ，于是时间为 $O(k)$ ，其中 $k$ 是二进制下 $1$ 的个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STC static</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get(x, o) (((x) &gt;&gt; (o - 1)) &amp; 1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>, M = <span class="number">15</span> * <span class="number">7</span> + <span class="number">5</span>,  NN = (<span class="number">1</span> &lt;&lt; <span class="number">15</span>) + <span class="number">5</span>, P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">for</span> (res = <span class="number">0</span>; x; x &amp;= (x - <span class="number">1</span>), ++res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, nn;</span><br><span class="line">    STC <span class="keyword">int</span> e[N], d[NN], pow2[M];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    nn = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">    d[<span class="number">0</span>] = pow2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="comment">//预处理2^i</span></span><br><span class="line">        pow2[i] = (pow2[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>) % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v), e[u] |= (<span class="number">1</span> &lt;&lt; (v - <span class="number">1</span>)); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>, tmp; s &lt; nn; ++s)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">get</span>(s, <span class="number">1</span>) == <span class="built_in">get</span>(s, <span class="number">2</span>)) <span class="comment">//保证1和2的点的状态相同</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> u = s; u; u = s &amp; (u - <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">get</span>(u, <span class="number">1</span>) == <span class="built_in">get</span>(u, <span class="number">2</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">get</span>(s, i))</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (<span class="built_in">get</span>(u, i))</span><br><span class="line">                                tmp = (LL)tmp * pow2[<span class="built_in">countbit</span>(e[i] &amp; (s ^ u))] % P;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                tmp = (LL)tmp * (pow2[<span class="built_in">countbit</span>(e[i] &amp; u)] - <span class="number">1</span>) % P;</span><br><span class="line">                        &#125;</span><br><span class="line">                    d[s] = (d[s] + (LL)d[s ^ u] * tmp % P) % P;</span><br><span class="line">                &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (pow2[m] - d[nn - <span class="number">1</span>] + P) % P);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 万能的高橋君&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="状态压缩" scheme="https://dyd-true.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="AtCoder" scheme="https://dyd-true.github.io/tags/AtCoder/"/>
    
  </entry>
  
  <entry>
    <title>luoguP5243 [USACO19FEB]Moorio Kart P</title>
    <link href="https://dyd-true.github.io/2022/02/05/luoguP5243-USACO19FEB-Moorio-Kart-P/"/>
    <id>https://dyd-true.github.io/2022/02/05/luoguP5243-USACO19FEB-Moorio-Kart-P/</id>
    <published>2022-02-05T12:40:19.000Z</published>
    <updated>2022-02-06T00:37:19.048Z</updated>
    
    <content type="html"><![CDATA[<p> 过年玩疯了，来做个题</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P5243">Moorio Kart P</a></p><h2 id="简化题意"><a href="#简化题意" class="headerlink" title="简化题意"></a>简化题意</h2><p>给 $n$ 个点 $m$ 条边的森林，边有权，设有 $k$ 棵树，现在要添加 $k$ 条权为 $x$ 的边，使图上形成一个权值和大于 $y$ 的环，且原森林中的每棵树在该环上<strong>至少</strong>有一条边，求方案数，对 $10^9 + 7$ 取模， $n \le 1500, m \le n - 1, x, y \le 2500$ </p><h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><p>由于树上两点间有唯一路径，所以考虑统计出每棵树上所以的路径，然后就转化成了背包</p><p>设 <code>d[i][0/1]</code> 表示“构成权值和为 $i$ 的环的方案数/长度和”， <code>g[i][0/1]</code> 表示“当前小树内长度为 $i$ 的路径数/长度和”，有：<br>$$<br>\begin{aligned}<br>&amp; d[i + j][0] \gets d[i][0] * g[j][0] \\<br>&amp; d[i + j][1] \gets d[i][0] * g[j][1] + d[i][1] * g[j][0]<br>\end{aligned}<br>$$<br>直接dp，时间为……我也不造？卡卡能过</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DB double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STC static</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IL inline</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Fast</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> L = (<span class="number">1</span> &lt;&lt; <span class="number">20</span>) + <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[L], out[L], *iS, *iT;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> gh() (iT == iS ? iT = (iS = buf) + fread(buf, 1, L, stdin), (iT == iS ? EOF : *iS++) : *iS++)</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;class T&gt; </span></span><br><span class="line"><span class="function">    IL <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = <span class="built_in">gh</span>(), t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            t |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">gh</span>();</span><br><span class="line">        <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            x = x * <span class="number">10</span> + (ch ^ <span class="number">48</span>), ch = <span class="built_in">gh</span>();</span><br><span class="line">        <span class="keyword">if</span> (t)</span><br><span class="line">            x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">flus</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">fwrite</span>(out, <span class="number">1</span>, l, stdout);</span><br><span class="line">        l = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">putc</span><span class="params">(<span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        out[l++] = x;</span><br><span class="line">        <span class="keyword">if</span> (l == L - <span class="number">5</span>)</span><br><span class="line">            <span class="built_in">flus</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function">    IL <span class="keyword">void</span> <span class="title">write</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">putc</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">9</span>)</span><br><span class="line">            <span class="built_in">write</span>(x / <span class="number">10</span>);</span><br><span class="line">        out[l++] = x % <span class="number">10</span> + <span class="number">48</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == L - <span class="number">5</span>)</span><br><span class="line">            <span class="built_in">flus</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Fast::flus;</span><br><span class="line"><span class="keyword">using</span> Fast::putc;</span><br><span class="line"><span class="keyword">using</span> Fast::read;</span><br><span class="line"><span class="keyword">using</span> Fast::write;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1500</span> + <span class="number">5</span>, P = <span class="number">1e9</span> + <span class="number">7</span>, V = <span class="number">2500</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, X, Y;</span><br><span class="line"><span class="keyword">int</span> fa[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Egde</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ne, ver, w;</span><br><span class="line">&#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> h[N], idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>, bel[N];</span><br><span class="line"><span class="keyword">int</span> g[N][V][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> d[V][<span class="number">2</span>], last[V][<span class="number">2</span>];</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = &#123;h[x], y, z&#125;, h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">dfscol</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> ff, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bel[x] = col;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">        <span class="keyword">if</span> (e[i].ver != ff)</span><br><span class="line">            <span class="built_in">dfscol</span>(e[i].ver, x, col);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">dfslen</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> ff, <span class="keyword">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ff != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        g[bel[x]][<span class="built_in">min</span>(Y, l)][<span class="number">1</span>] += l;</span><br><span class="line">        g[bel[x]][<span class="built_in">min</span>(Y, l)][<span class="number">1</span>] %= P;</span><br><span class="line">        ++g[bel[x]][<span class="built_in">min</span>(Y, l)][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">        <span class="keyword">if</span> (e[i].ver != ff)</span><br><span class="line">            <span class="built_in">dfslen</span>(e[i].ver, x, l + e[i].w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">int</span> <span class="title">fac</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x; ++i)</span><br><span class="line">        res = (LL)res * i % P;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(m), <span class="built_in">read</span>(X), <span class="built_in">read</span>(Y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        fa[i] = i, h[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, w; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(u), <span class="built_in">read</span>(v), <span class="built_in">read</span>(w);</span><br><span class="line">        <span class="built_in">add</span>(u, v, w), <span class="built_in">add</span>(v, u, w);</span><br><span class="line">        fa[<span class="built_in">find</span>(u)] = <span class="built_in">find</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(i) == i)</span><br><span class="line">            ++cnt, <span class="built_in">dfscol</span>(i, <span class="number">-1</span>, cnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">dfslen</span>(i, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> st = <span class="built_in">min</span>(X * cnt, Y);</span><br><span class="line">    d[st][<span class="number">0</span>] = <span class="number">1</span>, d[st][<span class="number">1</span>] = X * cnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = st; j &lt;= Y; ++j)</span><br><span class="line">            last[j][<span class="number">0</span>] = d[j][<span class="number">0</span>], last[j][<span class="number">1</span>] = d[j][<span class="number">1</span>], d[j][<span class="number">0</span>] = d[j][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= Y; ++j)</span><br><span class="line">            <span class="keyword">if</span> (g[i][j][<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = st; k &lt;= Y; ++k)</span><br><span class="line">                    <span class="keyword">if</span> (last[k][<span class="number">0</span>])</span><br><span class="line">                    &#123;</span><br><span class="line">                        d[<span class="built_in">min</span>(j + k, Y)][<span class="number">0</span>] = (d[<span class="built_in">min</span>(j + k, Y)][<span class="number">0</span>] + (LL)last[k][<span class="number">0</span>] * g[i][j][<span class="number">0</span>]) % P;</span><br><span class="line">                        d[<span class="built_in">min</span>(j + k, Y)][<span class="number">1</span>] = (d[<span class="built_in">min</span>(j + k, Y)][<span class="number">1</span>] + (LL)last[k][<span class="number">0</span>] * g[i][j][<span class="number">1</span>] + (LL)last[k][<span class="number">1</span>] * g[i][j][<span class="number">0</span>]) % P;</span><br><span class="line">                    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (LL)d[Y][<span class="number">1</span>] * <span class="built_in">fac</span>(cnt - <span class="number">1</span>) % P * ((P + <span class="number">1</span>) / <span class="number">2</span>) % P);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">flus</span>(), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 过年玩疯了，来做个题&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="USACO" scheme="https://dyd-true.github.io/tags/USACO/"/>
    
    <category term="暴力" scheme="https://dyd-true.github.io/tags/%E6%9A%B4%E5%8A%9B/"/>
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>gcd</title>
    <link href="https://dyd-true.github.io/2022/02/05/gcd/"/>
    <id>https://dyd-true.github.io/2022/02/05/gcd/</id>
    <published>2022-02-05T12:17:10.000Z</published>
    <updated>2022-02-05T12:20:45.525Z</updated>
    
    <content type="html"><![CDATA[<p> 黑科技？</p><span id="more"></span><h1 id="gcd"><a href="#gcd" class="headerlink" title="gcd"></a>gcd</h1><h2 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法"></a>辗转相除法</h2><p>求 $2$ 个数的gcd时间为 $O(\log{\frac{\min(a, b)}{\gcd(a, b)}})$ </p><p>求 $n$ 个数的gcd时间为 $O(n + \log V)$ </p><h2 id="高精-取模"><a href="#高精-取模" class="headerlink" title="高精+取模"></a>高精+取模</h2><ol><li>若 $2 \mid a \wedge 2 \mid b$ ，则 $\gcd(a, b) = 2 \gcd(\frac{a}{2}, \frac{b}{2})$ </li><li>若 $2 \mid a \wedge 2 \not\mid b(2 \not\mid a \wedge 2 \mid b)$ ，则 $\gcd(a, b) = \gcd(\frac{a}{2}, b)$ </li><li> 若 $2 \not\mid a \wedge 2 \not\mid b$ ，则 $\gcd(a, b) = \gcd(a - b, b)$ </li></ol><p>不难发现时间为 $O(\log n)$ </p><h2 id="正题：预处理法"><a href="#正题：预处理法" class="headerlink" title="正题：预处理法"></a>正题：预处理法</h2><p>$O(n)$ 预处理， $O(1)$ 查询小于等于 $n$ 的gcd</p><h3 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h3><p>对于任意数 $n$ 存在分解 $n = abc$ 满足 $a, b, c$ 要么是质数，要么 $\le \sqrt{n}$ </p><p>证明：</p><ol><li>若 $n$ 存在一个 $&gt; \sqrt{n}$ 的质因数，显然成立</li><li>若 $n$ 的质因数全都 $\le \sqrt{n}$ ，取出 $n$ 的最小质因数 $p$ ：<ul><li>若 $p &gt; \sqrt[4]{n}$ ，显然 $n$ 的其它质因数也 $&gt; \sqrt[4]{n}$ ，那么只要把 $n$ 分解质数即可（ $n$ 决不会有大于 $3$ 个质因数）</li><li>否则我们求出  $\frac{n}{p}$ 的分解 $a’, b’, c’$ ，设其中最小的是 $a’$ （明显它 $\le \sqrt[3]{\frac{n}{p}}$ ），可得 $a’p \le \sqrt[3]{\frac{n}{p}} p = \sqrt[3]{np^2} \le \sqrt[3]{n \sqrt{n}} = \sqrt{n}$ ，则 $n$ 的分解为 $a’p, b’, c’$ </li></ul></li></ol><p>证明同时也给出了分解的求法</p><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>求出 $\le \sqrt{n}$ 的所有数的两两的gcd，具体的， <code>g[a][b] = g[b][a % b]</code> ，可以做到 $O((\sqrt{n})^2) = O(n)$ </p><p>还要求出所有数的分解，这可以先线性筛，然后用证明的方法求</p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>设求 $x = abc, y$ 的gcd，可以把 $a, b, c$ 和 $y$ 合并，以 $a$ 为例：</p><ol><li>若 $a &gt; \sqrt{n}$  ，则 $a$ 为质数，去 $2$ </li><li>若 $a$ 为质数，判 <code>y % a</code> 即可</li><li>否则， $\gcd(y, a) = \gcd(y \mod a, a)$ 直接调用预处理</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><a href="https://darkbzoj.tk/problem/4454">C Language Practice</a></p><p>然而因为卡空间，这份代码并不能过（要把 <code>fen</code> 的下标改成从 $0$  开始）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STC static</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000</span> + <span class="number">5</span>, V = <span class="number">1000000</span> + <span class="number">5</span>, W = <span class="number">1000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> g[W][W], fen[V][<span class="number">4</span>];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; pri;</span><br><span class="line"><span class="keyword">int</span> num[V];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prev</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; W; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j)</span><br><span class="line">            g[i][j] = g[j][i] = ((i &amp;&amp; j) ? g[j][i % j] : (i | j));</span><br><span class="line">    num[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; V; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!num[i])</span><br><span class="line">            pri.<span class="built_in">push_back</span>(i), num[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j : pri)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; num[i] || j * i &gt;= V)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            num[i * j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fen[<span class="number">1</span>][<span class="number">1</span>] = fen[<span class="number">1</span>][<span class="number">2</span>] = fen[<span class="number">1</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; V; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        fen[i][<span class="number">1</span>] = fen[i / num[i]][<span class="number">1</span>];</span><br><span class="line">        fen[i][<span class="number">2</span>] = fen[i / num[i]][<span class="number">2</span>];</span><br><span class="line">        fen[i][<span class="number">3</span>] = fen[i / num[i]][<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">if</span> (fen[i][<span class="number">1</span>] * num[i] &lt; W)</span><br><span class="line">            fen[i][<span class="number">1</span>] *= num[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (fen[i][<span class="number">2</span>] * num[i] &lt; W)</span><br><span class="line">            fen[i][<span class="number">2</span>] *= num[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            fen[i][<span class="number">3</span>] *= num[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> _gcd(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; W &amp;&amp; y &lt; W)</span><br><span class="line">        <span class="keyword">return</span> g[x][y];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!x || !y)</span><br><span class="line">        <span class="keyword">return</span> x | y;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, t; i &lt;= <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fen[x][i] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> ((t = fen[x][i]) == num[t])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (y % t == <span class="number">0</span>)</span><br><span class="line">                y /= t, res *= t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t = g[t][y % t], y /= t, res *= t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">prev</span>();</span><br><span class="line">    <span class="keyword">int</span> T, n, m;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ans;</span><br><span class="line">    STC <span class="keyword">int</span> a[N], b[N];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">                ans += _gcd(a[i], b[j]) ^ (i - <span class="number">1</span>) ^ (j - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 黑科技？&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数论,数学" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
    <category term="笔记" scheme="https://dyd-true.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>松氏基排</title>
    <link href="https://dyd-true.github.io/2022/01/26/%E6%9D%BE%E6%B0%8F%E5%9F%BA%E6%8E%92/"/>
    <id>https://dyd-true.github.io/2022/01/26/%E6%9D%BE%E6%B0%8F%E5%9F%BA%E6%8E%92/</id>
    <published>2022-01-26T03:01:38.000Z</published>
    <updated>2022-01-26T03:27:55.094Z</updated>
    
    <content type="html"><![CDATA[<p> 递归式学习3</p><span id="more"></span><h1 id="松氏基排"><a href="#松氏基排" class="headerlink" title="松氏基排"></a>松氏基排</h1><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序（Radix sort）是一种非比较型的排序算法，它的工作原理是将待排序的元素拆分为 $k$ 个关键字（比较两个元素时，先比较第一关键字，如果相同再比较第二关键字……），然后先对第 $k$ 关键字进行稳定排序，再对第 $k - 1$ 关键字进行稳定排序，再对第 $k - 2$ 关键字进行稳定排序……最后对第一关键字进行稳定排序，这样就完成了对整个待排序序列的稳定排序</p><p><img src="https://s2.loli.net/2022/01/26/FDZeXLCouKpSnWq.png" alt="radix sort"></p><p>如图，要对这些数字排序，我们以百位为第一关键字，十位为第二关键字，个位为第三关键字</p><p>先用第三关键字（个位）稳定排序，再用十位、百位，最后就得出答案</p><p>基数排序需要借助一种<strong>稳定算法</strong>完成内层对关键字的排序，一般是桶排</p><p>当然，一般来说可不会以 $10$ 为基数，因为这样一个 <code>int</code> 要排 $9$ 遍，太麻烦</p><h2 id="松式基排"><a href="#松式基排" class="headerlink" title="松式基排"></a>松式基排</h2><p>那基数取多少好呢？</p><p>一般基排取的是 $65536$ （ $2^{16}$ ），空间开的下，只用排两遍</p><p>可wys大佬说，取 $256$ ，用位运算把一个数拆成四部分，要排四遍，但这样的话 <code>cnt</code> 数组刚好能装进 $L1$ 高速缓存（我也不知道那是啥）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STC static</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> geted(x, d) (((x) &gt;&gt; ((d) * Bit)) &amp; (R - 1))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Bit = <span class="number">8</span>, R = <span class="number">256</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radix_sort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    STC <span class="keyword">int</span> cnt[R], t[N];</span><br><span class="line">    <span class="keyword">int</span> *x = a, *y = t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; ++d)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; ++i)</span><br><span class="line">            cnt[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            ++cnt[<span class="built_in">geted</span>(x[i], d)];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; R; ++i)</span><br><span class="line">            cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">            y[--cnt[<span class="built_in">geted</span>(x[i], d)]] = x[i];</span><br><span class="line">        <span class="built_in">swap</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        a[i] = x[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">radix_sort</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 递归式学习3&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="排序" scheme="https://dyd-true.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>jarvis步进法</title>
    <link href="https://dyd-true.github.io/2022/01/26/jarvis%E6%AD%A5%E8%BF%9B%E6%B3%95/"/>
    <id>https://dyd-true.github.io/2022/01/26/jarvis%E6%AD%A5%E8%BF%9B%E6%B3%95/</id>
    <published>2022-01-26T02:40:17.000Z</published>
    <updated>2022-01-26T03:03:33.806Z</updated>
    
    <content type="html"><![CDATA[<p> 递归式学习2</p><span id="more"></span><h1 id="jarvis步进法"><a href="#jarvis步进法" class="headerlink" title="jarvis步进法"></a>jarvis步进法</h1><p>又名卷包裹法，是一种求凸包的算法，时间为 $O(n H)$ （ $H$ 为凸包上的点数）</p><p>一般来说很不常用，但总有些毒瘤要考</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>卷包裹就行了，从左下角（一定在凸包内的点）开始，想象一条线，线的一端固定在当前点上，把线竖直向凸包外拉使其绷紧（此时线上只有左下角的点），再逆时针旋转直到碰到一个点，这个点就是新的当前点，一直下去直到线包裹整个图形</p><p>代码就咕了，反正也几乎用不到，我要回溯了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt; 递归式学习2&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算几何" scheme="https://dyd-true.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
    <category term="凸包" scheme="https://dyd-true.github.io/tags/%E5%87%B8%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>闵可夫斯基和</title>
    <link href="https://dyd-true.github.io/2022/01/26/%E9%97%B5%E5%8F%AF%E5%A4%AB%E6%96%AF%E5%9F%BA%E5%92%8C/"/>
    <id>https://dyd-true.github.io/2022/01/26/%E9%97%B5%E5%8F%AF%E5%A4%AB%E6%96%AF%E5%9F%BA%E5%92%8C/</id>
    <published>2022-01-25T23:53:25.000Z</published>
    <updated>2022-01-26T02:41:05.566Z</updated>
    
    <content type="html"><![CDATA[<p> 递归式学习</p><span id="more"></span><h1 id="闵可夫斯基和"><a href="#闵可夫斯基和" class="headerlink" title="闵可夫斯基和"></a>闵可夫斯基和</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>比较严谨的定义：两个图形 $A, B$ 的闵可夫斯基和 $C = \{a + b |a \in A, b \in B \}$ </p><p>我的李姐：对于图形 $A$ 中每个点和图形 $B$ 中每个点两两求和（ $(x_a, y_a) + (x_b, y_b) = (x_a + x_b, y_a + y_b)$ ）</p><p>盗张图：<img src="https://s2.loli.net/2022/01/26/LEFlZoq7YCzudve.png" alt="闵可夫斯基和"></p><p>粉色区域是三角形和一个不规则四边形的闵可夫斯基和</p><h2 id="有啥用"><a href="#有啥用" class="headerlink" title="有啥用"></a>有啥用</h2><p>当然说有用我才来递归式学习的了</p><p>一般用在求凸包上，就以我学这个东西的目的为例吧（顺便说说凸包有啥用）</p><p>比如，我们维护了区间和，区间最大后缀和，区间最大前缀和，区间最大子段和分别取名叫 $sum, lmx, rmx, mx$ </p><p>现在我们要区间加 $k$ ，怎么维护？最简单的是 $sum$  就不管了</p><p>较难的是 $lmx, rmx$ ，以 $rmx$ 为例（注意它是区间最大<strong>前缀和</strong>，取名为 $r$ 只是因为它在右子树），我们要维护函数 $y = pre(x) + k * x$ 的最大值，其中 $pre(x)$  代表 $[l, x]$ 的和（前缀和）；考虑斜率优化，我们将函数化为 $pre(x) = kx + y$ ，就是把 $(x, pre(x))$ 看做是一个个点，把斜率为 $k$ 的直线带入这一个个点中，最大化截距，不难发现这就是在凸包上二分切点，因为此时凸包中的所有点都在直线的一侧，自然是在直线上的点代进去之后截距最大</p><p>而最毒瘤的就是 $mx$ 了，仿造上面，写出式子： $y = as(x) + k * x$ ，其中 $as(x)$ 代表长度为 $x$ 的最大子段和，但是，求出 $as(x)$ 是 $n^2$ 的，有救吗？有救</p><p>考虑分治，我们关心的就是 $(x, as(x))$ 这个点集构成的凸包，不妨来看看 $mx$ 的推导式（在线段树上用过无数次的那个）： <code>mx[l][r] = max(mx[l][mid], mx[mid + 1][r], lmx[l][mid] + r[mid + 1][r])</code> ，发现前两个可以直接递归求 $[l, mid]$ 和 $[mid + 1, r]$ 的凸包解决，麻烦的是最后那个求和的式子，不难发现它代表的是“跨过 $mid$ 的区间”</p><p>考虑我们要求的是什么，是 $(x, as(x))$ 的凸包，将，每个跨过 $mid$ 的区间化作一个点 $(x, y)$ ， $x$ 代表区间长度， $y$  代表区间和，就是求这个点集（设为 $C$ ）的凸包</p><p>点集大小是 $O(n^2)$ 的，当然不能直接求，设点集 $A = \{(x, y) | x \in [l, mid], y = suf(x)\}$ ，其中 $suf(x)$ 表示区间 $[l, mid]$  的后缀和；再设 $B = \{(x, y) | x \in [mid + 1, r], y = pre(x)\}$ ，其中 $pre(x)$ 表示区间 $[mid + 1, r]$  的前缀和；那么， $C = \{(x, y) | x = x_A + x_B, y = y_A + y_B\}$ ，这就是闵可夫斯基和呀</p><p>而用闵可夫斯基和，我们可以 $O(n)$  归并出点集 $C$  的凸包</p><h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>那怎么合并呢？再看图（回去翻那张）</p><p>我们（<del>baidu得</del>）发现发现新的凸包就是原来的两个凸包的边重新极角排序一边，证明？咕咕咕</p><p>于是我们得到了一个很有用的结论，求凸包只需要求原来的凸包，然后在一起重新排序就可以了。</p><p>但直接重排有点浪费，由于原来两个凸包都已经求好了，于是可以类似归并排序，重新归并一次</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>例题就不讲了，我要回溯去递归下一条路径了（dfs式学习，艹）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LL x, y;</span><br><span class="line">    <span class="comment">//friend老香了</span></span><br><span class="line">    IL FR Point <span class="keyword">operator</span> + (Point x, Point y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x.x + y.x, x.y + y.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    IL FR Point <span class="keyword">operator</span> - (Point x, Point y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x.x - y.x, x.y - y.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    IL FR <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;= (Point x, Point y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x.y * y.x &lt;= x.x * y.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hull</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Point *st;</span><br><span class="line">    <span class="keyword">int</span> top, now;</span><br><span class="line">    IL Point&amp; <span class="keyword">operator</span> [] (<span class="keyword">const</span> <span class="keyword">int</span>&amp; x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> st[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">const</span> Point&amp; x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        st[x.x].y = <span class="built_in">max</span>(st[x.x].y, x.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> Point&amp; x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        st[++top] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">prev</span><span class="params">(<span class="keyword">int</span> len)</span> <span class="comment">//预处理,长度为x的答案对应其位置,方便ins</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">            st[i] = &#123;i, -INF&#125;;</span><br><span class="line">        top = len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">convex</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (top &lt;= <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>, len = top, top = <span class="number">2</span>; i &lt;= len; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st[i].y == -INF)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; (st[top] - st[top - <span class="number">1</span>]) &lt;= (st[i] - st[top - <span class="number">1</span>]))</span><br><span class="line">                --top;</span><br><span class="line">            st[++top] = st[i];</span><br><span class="line">        &#125;</span><br><span class="line">        now = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL LL <span class="title">maxv</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (now != top &amp;&amp; (-tag) * (st[now + <span class="number">1</span>].x - st[now].x) &lt; (st[now + <span class="number">1</span>].y - st[now].y))</span><br><span class="line">            ++now;</span><br><span class="line">        <span class="keyword">return</span> tag * st[now].x + st[now].y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">minkowski</span><span class="params">(Hull&amp; c, Hull&amp; a, Hull&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line">    c.<span class="built_in">ins</span>(a[i] + b[j]);</span><br><span class="line">    <span class="keyword">while</span> (i != a.top &amp;&amp; j != b.top)</span><br><span class="line">    &#123;</span><br><span class="line">        (a[i + <span class="number">1</span>] - a[i]) &lt;= (b[j + <span class="number">1</span>] - b[j]) ? ++j : ++i;</span><br><span class="line">        c.<span class="built_in">ins</span>(a[i] + b[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i != a.top)</span><br><span class="line">        c.<span class="built_in">ins</span>(a[++i] + b[j]);</span><br><span class="line">    <span class="keyword">while</span> (j != b.top)</span><br><span class="line">        c.<span class="built_in">ins</span>(a[i] + b[++j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个板子优点是快，缺点是指针需要人工分配内存</p>]]></content>
    
    
    <summary type="html">&lt;p&gt; 递归式学习&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算几何" scheme="https://dyd-true.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
    <category term="凸包" scheme="https://dyd-true.github.io/tags/%E5%87%B8%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>大力分块2</title>
    <link href="https://dyd-true.github.io/2022/01/25/%E5%A4%A7%E5%8A%9B%E5%88%86%E5%9D%972/"/>
    <id>https://dyd-true.github.io/2022/01/25/%E5%A4%A7%E5%8A%9B%E5%88%86%E5%9D%972/</id>
    <published>2022-01-25T13:54:00.000Z</published>
    <updated>2022-01-27T03:29:28.300Z</updated>
    
    <content type="html"><![CDATA[<p> 再续前缘</p><span id="more"></span><h1 id="大力分块2"><a href="#大力分块2" class="headerlink" title="大力分块2"></a>大力分块2</h1><p>又来找虐</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>可以见<a href="https://dyd-true.github.io/2022/01/24/%E5%A4%A7%E5%8A%9B%E5%88%86%E5%9D%97/#more">大力分块</a>，这是它的续</p><p>开始之前，大喊一声：我爱lxl！</p><h2 id="第六分块"><a href="#第六分块" class="headerlink" title="第六分块"></a>第六分块</h2><p><strong>「深浅值藏的第六分块」</strong>（<del>让luogu臭名昭著的研究珂学最佳方式</del>）</p><p><a href="https://www.luogu.com.cn/problem/P4118">末日时在做什么？有没有空？可以来拯救吗？</a></p><p>维护一个序列，支持两种操作：把区间 $[l, r]$ 加 $x$ ；查询区间 $[l, r]$ 最大子段和， $n, m \le 10^5$ ，任意时刻 $|a| \le 2 \times 10^9$ ， $1s, 64MB$ </p><p>下面是我脑内的处理过程：</p><h3 id="dfs预处理"><a href="#dfs预处理" class="headerlink" title="dfs预处理"></a>dfs预处理</h3><p>额……前置知识有点多，等我去递归式学习一手</p><p>尴尬了，递归了一会发现自己爆栈了……我太弱了！！！</p><p>但硬着头皮想（he）一（ti）想（jie）吧</p><h3 id="弱化版"><a href="#弱化版" class="headerlink" title="弱化版"></a>弱化版</h3><p>先想一个弱化的问题：没有修改，求区间最大子段和，这就是猫树的板子（线段树也行），不管了</p><p>稍微强一点的：全局修改，求区间最大子段和</p><p>猫树直接爆炸，考虑线段树，线段树上维护 $sum, suf, pre, as$ ，表示区间和、区间最大后缀和、区间最大前缀和、区间最大子段和，在全局加的情况下，我们如何维护这几个数字呢？</p><p> $sum$ 直接加即可</p><p> $pre$ 可以维护一个凸函数 $f(x)$ 表示长度为 $x$ 的前缀和，最大化 $pre = f(x) + d * x$ ，改写为 $f(x) = d * x + pre$ ， $f(x)$ 可以 $O(n)$  求，然后斜率优化，二分凸包最大化截距即可； $suf$ 同理维护 $g(x)$ </p><p> $as$ 也尝试维护一个凸函数 $h(x)$ 表示长度为 $x$ 的大子段和，也去凸包二分……但 $h(x)$ 可没法 $O(n)$ 求啊</p><p>考虑用下一层节点的信息，取子节点的 $g_l, f_r, h_l, h_r$ ，有 $h(x + y) = \max(h_l(x + y), h_r(x + y), g_l(x) + f_r(y))$ ，前两项直接继承，第三项闵可夫斯基和解决，都是线性的</p><p>终于，我们有了 $O(n \log n)$ 建树，求答案时对线段树每一个凸包二分，是 $O(\log^2 n)$ </p><h3 id="TLE版"><a href="#TLE版" class="headerlink" title="TLE版"></a>TLE版</h3><p>好，那区间修改怎么办？我们上面的做法可不支持区间修改呀！</p><p>考虑分块暴力，对每一块建一棵线段树，整块直接修改，散点直接重构，查询时整块在根节点二分凸包，散点就当线段树查询</p><p>设块长为 $B$ ，整块修改 $O(1)$ ，散点重构 $O(B \log B)$ ，整块查询 $O(\log B)$ ，散点查询 $O(\log^2 B)$ ，每次操作最多涉及 $\frac{n}{B}$ 个整块和两个散点，取 $B = \sqrt{n}$ ，时间复杂度为 $O(m \sqrt{n} \log \sqrt{n})$ ，还有个大常数，这不T上天，而且空间也上天了</p><p>空间可以离线逐块处理，时间上，一看是lxl的题，当然选择保留 $\sqrt{n}$ ，优化掉 $\log \sqrt{n}$ ，发现复杂度的 $\log$ 存在于两个地方：散点的重构和整块的查询（散点查询每次操作最多做两次，不是瓶颈）</p><h3 id="散点优化"><a href="#散点优化" class="headerlink" title="散点优化"></a>散点优化</h3><p>重构整棵线段树当然是 $B \log B$ ，但真的需要重构整棵吗？</p><p>我们重构的原因是本题中线段树只支持整体修改，不支持某一段修改，那么，当我们递归到某一段 $[l ,r]$ 已经完全被修改区间包含，为什么不直接打懒标记呢？</p><p>为了让这个懒标记区别于原来的懒标记，我们把它打在凸包上<strong>不下放</strong>，取凸包内节点的时候考虑叠加的正比例函数对点的位置的影响即可，而把原来的不打在树上，开一个变量单独存</p><p>因为每层只有一个节点（最左or最右）没完全被包含，所以每层只有 $O(1)$ 的节点被重构，这层的 $1$ 个节点对应下面的 $2$ 个，再下面 $4$ 个……等比数列求和，总的是 $O(B)$ 的</p><h3 id="整块优化"><a href="#整块优化" class="headerlink" title="整块优化"></a>整块优化</h3><p>首先，整体查询一定是提取线段树根上面那个凸包，而因为整体修改的标记在一个全块共用的变量上，所以根上一定是没有标记的；其次由于我们逐块处理，两个修改间的查询顺序是任意的，综上，我们考虑把所有查询按照查询时整体加标记的值升序排序，然后转换成整体加只加正数（先把标记减了就好）</p><p>这里我不是很李姐，巨佬们说由于区间加的都是正数，可以维护一个当前的最优决策点 $p$ ，决策点只会向右移动，暴力的向右爬一下即可，散点修改重构凸包的时候，直接把指针重置</p><p>这样处理询问的均摊复杂度是 $O(B)$ ，简证（<del>口胡</del>）：</p><p>定义一个块的 $E$ 为根上面的指针距离块右端点的距离，显然最开始的时候，所以块的 $E$ 和 $sum_E = n$ ，每次操作，最多有 $2$ 个散点所在块被重构，导致这两个块指针重置， $sum_E$ 增加 $2B$ ，所以总的 $sum_E$ 在过程中增加最多 $2mB$ ，而让 $sum_E$ 减少的唯一方法就是爬指针，每次减少至少 $1$ ，当 $sum_E = 0$ 时指针显然不会再爬（都到了右端点，不能再往右了），所以指针最多移动 $\frac{n + 2mB}{1}$ 次，时间为 $O(mB)$ ，均摊到每一次操作，就是 $O(B)$ </p><p>一个小点：排序时用基数排序，把总排序时间从 $O(m B \log m)$ 优化到 $O(mB)$ </p><p>到此为止，散点修改 $O(B)$ ，散点查询 $O(\log^2 B)$ ，整块修改 $O(1)$ ，整块查询 $O(B)$ （这里整块查询指一次操作中的所有整块时间和），取  $B = \sqrt{n}$ ，时间复杂度为 $O(m \sqrt{n})$ ，似乎行了？可能吗，这可是lxl啊</p><h3 id="卡常"><a href="#卡常" class="headerlink" title="卡常"></a>卡常</h3><ol><li>快读快输</li><li>基数排序用松氏基排，个数较小时用快排</li><li>维护凸包时别开 <code>vector</code> ，自己分配内存（就像我闵可夫斯基和博客里写的一样）</li><li>由于在块长不变的时候内存分配情况一定不会变，所以只需要在第一个和最后一块分配一下内存，不需要每次都重新分配</li><li>最终优化，调块长吧，多试几次</li></ol><h3 id="受苦"><a href="#受苦" class="headerlink" title="受苦"></a>受苦</h3><p>啊啊啊不想打啊！</p><ul><li> $2022/1/26$ $7:30$ 开始本题</li><li> $2022/1/26$ $1:27$ 开打 </li><li> $2022/1/26$ $16:30$ 打完开调</li><li> $2022/1/26$ $18:17$ 过样例了 </li><li> $2022/1/26$ $18:30$ 第一次提交，TLE + RE $0pts$ </li><li> $2022/1/26$ $19:18$ 改过RE了（二分打挂了），TLE + WA $0pts$ </li><li> $2022/1/26$ $19:33$ 不WA了，TLE  $0pts$ </li><li> $2022/1/26$ $19:33$ 本着宁WA不T的原则卡块长，发现当 $B = 1148$ 时最好（然鹅还是TLE一个点）WA  $0pts$ </li><li> $2022/1/26$ $21:56$ 发现把 $bn$ 打成 $n$ 了，改了后TLE $80pts$ ，啊啊啊，我的打法常数大了！</li><li> $2022/1/27$ $9:45$ 把网上能找到的代码（包括所有的题解）都交了一遍，全TLE（好像lxl加强了），心态爆炸</li><li> $2022/1/27$ $10:00$ 猛然发现一篇分类讨论的 $36pts$ 的代码刚好AC了我TLE的点（他特别猛，就手玩），于是决定高素质……</li><li> $2022/1/27$ $10:37$  高素质过了！决定加点注释，压压行</li><li> $2022/1/27$ $11:08$  搞定</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>超长警告！不压行 $737$ 行，压了后 $649$ 行！lxl太毒瘤了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2022/1/27 11:08</span></span><br><span class="line"><span class="comment">by Dyd</span></span><br><span class="line"><span class="comment">由于代码很长,稍微压了一下行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IL inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Max(x, y) ((x) &gt; (y) ? (x) : (y))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Min(x, y) ((x) &lt; (y) ? (x) : (y))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> got(x, len) (((x) - 1) / (len) + 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LB(x, len) (((x) - 1) * (len) + 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RB(x, len) Min(((x) * (len)), n)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Fast</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> L = (<span class="number">1</span> &lt;&lt; <span class="number">20</span>) + <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[L], out[L], *iS, *iT;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> gh() (iT == iS ? iT = (iS = buf) + fread(buf, 1, L, stdin), (iT == iS ? EOF : *iS++) : *iS++)</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = <span class="built_in">gh</span>(), t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            t |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">gh</span>();</span><br><span class="line">        <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            x = x * <span class="number">10</span> + (ch ^ <span class="number">48</span>), ch = <span class="built_in">gh</span>();</span><br><span class="line">        <span class="keyword">if</span> (t)</span><br><span class="line">            x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">flus</span><span class="params">()</span> </span>&#123; <span class="built_in">fwrite</span>(out, <span class="number">1</span>, l, stdout), l = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">putc</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123; out[l++] = x; &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">write</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">putc</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">9</span>)</span><br><span class="line">            <span class="built_in">write</span>(x / <span class="number">10</span>);</span><br><span class="line">        out[l++] = x % <span class="number">10</span> + <span class="number">48</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Fast::flus;</span><br><span class="line"><span class="keyword">using</span> Fast::putc;</span><br><span class="line"><span class="keyword">using</span> Fast::read;</span><br><span class="line"><span class="keyword">using</span> Fast::write;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">1148</span>, N = <span class="number">1e5</span> + B + <span class="number">5</span>, R = <span class="number">256</span>, Bit = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">const</span> LL MINF = <span class="number">-0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Question</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> op = <span class="number">0</span>, l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    LL v = <span class="number">0</span>;</span><br><span class="line">&#125; que[N];</span><br><span class="line"><span class="comment">//我的程序(80pts,最后一个点会TLE)</span></span><br><span class="line"><span class="keyword">namespace</span> My</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//bl,br,pos卡常,记录LB,RB,got;tot:分配空间</span></span><br><span class="line">    <span class="keyword">int</span> bl[N / B + <span class="number">5</span>], br[N / B + <span class="number">5</span>], pos[N], tot;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        LL x, y;</span><br><span class="line">        IL Point <span class="keyword">operator</span> + (<span class="keyword">const</span> Point &amp;b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> &#123;x + b.x, y + b.y&#125;; &#125;</span><br><span class="line">        IL Point <span class="keyword">operator</span> - (<span class="keyword">const</span> Point &amp;b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> &#123;x - b.x, y - b.y&#125;; &#125;</span><br><span class="line">        IL <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;= (<span class="keyword">const</span> Point &amp;b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> x * b.y &gt;= y * b.x; &#125;</span><br><span class="line">    &#125; pool[N];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Hull</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        Point *vc;</span><br><span class="line">        <span class="keyword">int</span> si, mxid;</span><br><span class="line">        LL tag;</span><br><span class="line">        IL Point <span class="keyword">operator</span> [] (<span class="keyword">const</span> <span class="keyword">int</span> x) &#123; <span class="keyword">return</span> &#123;vc[x].x, vc[x].y + tag * vc[x].x&#125;; &#125;</span><br><span class="line">        <span class="function">IL <span class="keyword">void</span> <span class="title">ins</span><span class="params">(Point x)</span> </span>&#123; vc[x.x].y = <span class="built_in">Max</span>(vc[x.x].y, x.y); &#125;</span><br><span class="line">        <span class="function">IL <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(Point x)</span> </span>&#123; vc[si++] = x; &#125;</span><br><span class="line">        <span class="function">IL <span class="keyword">void</span> <span class="title">prev</span><span class="params">(<span class="keyword">int</span> len)</span> <span class="comment">//预留len的空间(赋为MINF以待跟新)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            vc[<span class="number">0</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;, si = len + <span class="number">1</span>, tag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) vc[i] = &#123;i, MINF&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">IL <span class="keyword">void</span> <span class="title">jarvis</span><span class="params">()</span> <span class="comment">//求凸包</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (si &lt;= <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">int</span> top = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; si; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (vc[i].y == MINF) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">while</span> (top &gt;= <span class="number">1</span> &amp;&amp; (vc[top] - vc[top - <span class="number">1</span>]) &lt;= (vc[i] - vc[top - <span class="number">1</span>])) --top;</span><br><span class="line">                vc[++top] = vc[i];</span><br><span class="line">            &#125;</span><br><span class="line">            si = top + <span class="number">1</span>, tag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">IL <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x, LL addv)</span> </span>&#123; <span class="keyword">return</span> (vc[x + <span class="number">1</span>].x - vc[x].x) * (tag + addv) + vc[x + <span class="number">1</span>].y - vc[x].y &gt; <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="function">IL LL <span class="title">maxv</span><span class="params">(LL addv)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (mxid &lt; si - <span class="number">1</span> &amp;&amp; <span class="built_in">check</span>(mxid, addv)) ++mxid;</span><br><span class="line">            <span class="keyword">return</span> vc[mxid].x * (tag + addv) + vc[mxid].y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">IL LL <span class="title">bs</span><span class="params">(LL addv)</span> <span class="comment">//凸包上二分</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">-1</span>, r = si - <span class="number">1</span>, mid;</span><br><span class="line">            <span class="keyword">for</span> (mid = l + r &gt;&gt; <span class="number">1</span>; l &lt; r - <span class="number">1</span>; mid = l + r &gt;&gt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">check</span>(mid, addv)) l = mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid;</span><br><span class="line">            mxid = r;</span><br><span class="line">            <span class="keyword">return</span> vc[mxid].x * (tag + addv) + vc[mxid].y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Ans</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        LL pre, suf, as, sum;</span><br><span class="line">        IL Ans <span class="keyword">operator</span> + (<span class="keyword">const</span> Ans &amp;b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> &#123;<span class="built_in">Max</span>(pre, sum + b.pre), <span class="built_in">Max</span>(suf + b.sum, b.suf), <span class="built_in">Max</span>(<span class="built_in">Max</span>(as, b.as), suf + b.pre), sum + b.sum&#125;; &#125;</span><br><span class="line">    &#125; ans[N];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LineTree</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        Hull pre[B &lt;&lt; <span class="number">2</span>], suf[B &lt;&lt; <span class="number">2</span>], as[B &lt;&lt; <span class="number">2</span>];</span><br><span class="line">        LL sum[B &lt;&lt; <span class="number">2</span>], tag[B &lt;&lt; <span class="number">2</span>];</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> lc (u &lt;&lt; 1)</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> rc (u &lt;&lt; 1 | 1)</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> Mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line">        <span class="function">IL <span class="keyword">void</span> <span class="title">prev</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> <span class="comment">//预分配空间</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            pre[u].vc = pool + tot, tot += r - l + <span class="number">3</span>;</span><br><span class="line">            suf[u].vc = pool + tot, tot += r - l + <span class="number">3</span>;</span><br><span class="line">            as[u].vc = pool + tot, tot += r - l + <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">int</span> mid = Mid;</span><br><span class="line">            <span class="built_in">prev</span>(lc, l, mid), <span class="built_in">prev</span>(rc, mid + <span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">IL <span class="keyword">void</span> <span class="title">pre_suf_merge</span><span class="params">(Hull &amp;c, Hull &amp;a, Hull &amp;b, Point addb)</span> <span class="comment">//普通合并</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t = a.si; i &lt; t; ++i) c.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t = b.si; i &lt; t; ++i) c.<span class="built_in">push_back</span>(addb + b[i]);</span><br><span class="line">            c.<span class="built_in">jarvis</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">IL <span class="keyword">void</span> <span class="title">minkowski</span><span class="params">(Hull &amp;c, Hull &amp;a, Hull &amp;b)</span> <span class="comment">//闵可夫斯基和</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, sa = a.si - <span class="number">1</span>, sb = b.si - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (c.<span class="built_in">ins</span>(a[i] + b[j]); i &lt; sa &amp;&amp; j &lt; sb; c.<span class="built_in">ins</span>(a[i] + b[j])) a[i + <span class="number">1</span>] - a[i] &lt;= b[j + <span class="number">1</span>] - b[j] ? ++j : ++i;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; sa) c.<span class="built_in">ins</span>(a[++i] + b[j]);</span><br><span class="line">            <span class="keyword">while</span> (j &lt; sb) c.<span class="built_in">ins</span>(a[i] + b[++j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">IL <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = Mid;</span><br><span class="line">            <span class="built_in">pre_suf_merge</span>(pre[u], pre[lc], pre[rc], &#123;mid - l + <span class="number">1</span>, sum[lc]&#125;);</span><br><span class="line">            <span class="built_in">pre_suf_merge</span>(suf[u], suf[rc], suf[lc], &#123;r - mid, sum[rc]&#125;);</span><br><span class="line">            as[u].<span class="built_in">prev</span>(r - l + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t = as[lc].si; i &lt; t; ++i) as[u].<span class="built_in">ins</span>(as[lc][i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t = as[rc].si; i &lt; t; ++i) as[u].<span class="built_in">ins</span>(as[rc][i]);</span><br><span class="line">            <span class="built_in">minkowski</span>(as[u], suf[lc], pre[rc]);</span><br><span class="line">            as[u].<span class="built_in">jarvis</span>();</span><br><span class="line">            pre[u].mxid = suf[u].mxid = as[u].mxid = <span class="number">0</span>;</span><br><span class="line">            sum[u] = sum[lc] + sum[rc];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加标记,同时修改</span></span><br><span class="line">        <span class="function">IL <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, LL d)</span> </span>&#123; tag[u] += d, pre[u].tag += d, suf[u].tag += d, as[u].tag += d, sum[u] += d * (r - l + <span class="number">1</span>); &#125;</span><br><span class="line">        <span class="function">IL <span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (l == r || !tag[u]) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">int</span> mid = Mid;</span><br><span class="line">            <span class="built_in">add</span>(lc, l, mid, tag[u]), <span class="built_in">add</span>(rc, mid + <span class="number">1</span>, r, tag[u]);</span><br><span class="line">            tag[u] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">IL <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> bid)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (l == r)</span><br><span class="line">            &#123;</span><br><span class="line">                sum[u] = a[l + bl[bid] - <span class="number">1</span>];</span><br><span class="line">                pre[u].<span class="built_in">push_back</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;), pre[u].<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, sum[u]&#125;);</span><br><span class="line">                suf[u].<span class="built_in">push_back</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;), suf[u].<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, sum[u]&#125;);</span><br><span class="line">                as[u].<span class="built_in">push_back</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;), as[u].<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, sum[u]&#125;);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> mid = Mid;</span><br><span class="line">            <span class="built_in">build</span>(lc, l, mid, bid), <span class="built_in">build</span>(rc, mid + <span class="number">1</span>, r, bid);</span><br><span class="line">            <span class="built_in">up</span>(u, l, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">IL <span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            pre[u].si = suf[u].si = as[u].si = <span class="number">0</span>;</span><br><span class="line">            pre[u].mxid = suf[u].mxid = as[u].mxid = <span class="number">0</span>;</span><br><span class="line">            pre[u].tag = suf[u].tag = as[u].tag = <span class="number">0</span>;</span><br><span class="line">            tag[u] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">int</span> mid = Mid;</span><br><span class="line">            <span class="built_in">clear</span>(lc, l, mid), <span class="built_in">clear</span>(rc, mid + <span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">IL <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr, LL d)</span> <span class="comment">//散点修改</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (l == ql &amp;&amp; r == qr) <span class="keyword">return</span> <span class="built_in">add</span>(u, l, r, d);</span><br><span class="line">            <span class="built_in">down</span>(u, l, r);</span><br><span class="line">            <span class="keyword">int</span> mid = Mid;</span><br><span class="line">            <span class="keyword">if</span> (qr &lt;= mid) <span class="built_in">change</span>(lc, l, mid, ql, qr, d);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ql &gt; mid) <span class="built_in">change</span>(rc, mid + <span class="number">1</span>, r, ql, qr, d);</span><br><span class="line">            <span class="comment">//注意这里ql,qr改变了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">change</span>(lc, l, mid, ql, mid, d), <span class="built_in">change</span>(rc, mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, qr, d);</span><br><span class="line">            pre[u].si = suf[u].si = as[u].si = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">up</span>(u, l, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//整块询问</span></span><br><span class="line">        <span class="function">IL Ans <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, LL addv)</span> </span>&#123; <span class="keyword">return</span> &#123;pre[<span class="number">1</span>].<span class="built_in">maxv</span>(addv), suf[<span class="number">1</span>].<span class="built_in">maxv</span>(addv), as[<span class="number">1</span>].<span class="built_in">maxv</span>(addv), sum[<span class="number">1</span>] + (r - l + <span class="number">1</span>) * addv&#125;; &#125;</span><br><span class="line">        <span class="function">IL Ans <span class="title">ask</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr, LL addv)</span> <span class="comment">//散点询问</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (l == ql &amp;&amp; r == qr) <span class="keyword">return</span> u == <span class="number">1</span> ? <span class="built_in">query</span>(ql, qr, addv) : (Ans)&#123;pre[u].<span class="built_in">bs</span>(addv), suf[u].<span class="built_in">bs</span>(addv), as[u].<span class="built_in">bs</span>(addv), sum[u] + (qr - ql + <span class="number">1</span>) * addv&#125;;</span><br><span class="line">            <span class="built_in">down</span>(u, l, r);</span><br><span class="line">            <span class="keyword">int</span> mid = Mid;</span><br><span class="line">            <span class="keyword">if</span> (qr &lt;= mid) <span class="keyword">return</span> <span class="built_in">ask</span>(lc, l, mid, ql, qr, addv);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ql &gt; mid) <span class="keyword">return</span> <span class="built_in">ask</span>(rc, mid + <span class="number">1</span>, r, ql, qr, addv);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">ask</span>(lc, l, mid, ql, mid, addv) + <span class="built_in">ask</span>(rc, mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, qr, addv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QuestionForBlock</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, id = <span class="number">0</span>;</span><br><span class="line">        LL v = <span class="number">0</span>, typ = <span class="number">0</span>;</span><br><span class="line">        IL <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> QuestionForBlock &amp;b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> v &lt; b.v; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Block</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        LineTree lt;</span><br><span class="line">        <span class="comment">//cnt,tmp,val,valt都是基数排序用的,为了卡常在这里定</span></span><br><span class="line">        <span class="keyword">int</span> bid, bn, bm, cnt[R];</span><br><span class="line">        QuestionForBlock bq[N], tmp[N];</span><br><span class="line">        LL tag, valt[N], val[N];</span><br><span class="line">        <span class="comment">//整体修改</span></span><br><span class="line">        <span class="function">IL <span class="keyword">void</span> <span class="title">modify</span><span class="params">(LL d)</span> </span>&#123; tag += d; &#125;</span><br><span class="line">        <span class="function">IL <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, LL d)</span> <span class="comment">//散点修改</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (d == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (l == <span class="number">1</span> &amp;&amp; r == bn) <span class="keyword">return</span> tag += d, <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">            bq[bm++] = &#123;l, r, <span class="number">0</span>, tag, d&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//整体查询</span></span><br><span class="line">        <span class="function">IL <span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> id)</span> </span>&#123; bq[bm++] = &#123;l, r, id, tag, <span class="number">0</span>&#125;; &#125;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> geted(x, d) (((x) &gt;&gt; ((d)*Bit)) &amp; (R - 1))</span></span><br><span class="line">        <span class="function">IL <span class="keyword">void</span> <span class="title">radix_sort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> <span class="comment">//松氏基排</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (r - l &lt;= <span class="number">1500</span>) <span class="keyword">return</span> <span class="built_in">sort</span>(bq + l, bq + r); <span class="comment">//小优化</span></span><br><span class="line">            LL *x = val, *y = valt;</span><br><span class="line">            <span class="keyword">int</span> tt = r - l;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; ++i) x[i - l] = y[i - l] = bq[i].v | ((<span class="number">1ll</span> * i) &lt;&lt; <span class="number">35</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; ++d)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; ++i) cnt[i] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tt; ++i) ++cnt[<span class="built_in">geted</span>(x[i], d)];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; R; ++i) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = tt - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) y[--cnt[<span class="built_in">geted</span>(x[i], d)]] = x[i];</span><br><span class="line">                <span class="built_in">swap</span>(x, y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; ++i) tmp[i - l] = bq[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; ++i) bq[i] = tmp[(x[i - l] &gt;&gt; <span class="number">35</span>) - l];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">IL <span class="keyword">void</span> <span class="title">prev</span><span class="params">()</span> <span class="comment">//预处理(修改化为正数,建树,排序)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            LL mintag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bm; ++i) mintag = <span class="built_in">Min</span>(mintag, bq[i].v);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bm; ++i) bq[i].v -= mintag;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = bl[bid], t = br[bid]; i &lt;= t; ++i) a[i] += mintag;</span><br><span class="line">            lt.<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, bn, bid);</span><br><span class="line">            <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bm; ++i) <span class="keyword">if</span> (bq[i].typ)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != last) <span class="built_in">radix_sort</span>(last, i);</span><br><span class="line">                last = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (last != bm) <span class="built_in">radix_sort</span>(last, bm);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">IL <span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bm; ++i)</span><br><span class="line">                <span class="keyword">if</span> (!bq[i].typ)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &amp;&amp; bq[i - <span class="number">1</span>].typ) lt.pre[<span class="number">1</span>].<span class="built_in">bs</span>(bq[i].v), lt.suf[<span class="number">1</span>].<span class="built_in">bs</span>(bq[i].v), lt.as[<span class="number">1</span>].<span class="built_in">bs</span>(bq[i].v);</span><br><span class="line">                    ans[bq[i].id] = ans[bq[i].id] + lt.<span class="built_in">ask</span>(<span class="number">1</span>, <span class="number">1</span>, bn, bq[i].l, bq[i].r, bq[i].v);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> lt.<span class="built_in">change</span>(<span class="number">1</span>, <span class="number">1</span>, bn, bq[i].l, bq[i].r, bq[i].typ);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">IL <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; bm = tag = <span class="number">0</span>, lt.<span class="built_in">clear</span>(<span class="number">1</span>, <span class="number">1</span>, bn); &#125;</span><br><span class="line">    &#125; blk;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="keyword">int</span> qcnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) pos[i] = <span class="built_in">got</span>(i, B);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= pos[n]; ++i) bl[i] = <span class="built_in">LB</span>(i, B), br[i] = <span class="built_in">RB</span>(i, B);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= pos[n]; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            qcnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//这里一定要先加了在判continue,否则输出会不够</span></span><br><span class="line">                <span class="keyword">if</span> (que[j].op == <span class="number">2</span>) ++qcnt;</span><br><span class="line">                <span class="keyword">if</span> (que[j].l &gt; br[i] || que[j].r &lt; bl[i]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (que[j].op == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (que[j].l &lt;= bl[i] &amp;&amp; que[j].r &gt;= br[i]) blk.<span class="built_in">modify</span>(que[j].v);</span><br><span class="line">                    <span class="keyword">else</span> blk.<span class="built_in">change</span>(<span class="built_in">Max</span>(que[j].l, bl[i]) - bl[i] + <span class="number">1</span>, <span class="built_in">Min</span>(que[j].r, br[i]) - bl[i] + <span class="number">1</span>, que[j].v);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> blk.<span class="built_in">query</span>(<span class="built_in">Max</span>(que[j].l, bl[i]) - bl[i] + <span class="number">1</span>, <span class="built_in">Min</span>(que[j].r, br[i]) - bl[i] + <span class="number">1</span>, qcnt);</span><br><span class="line">            &#125;</span><br><span class="line">            blk.bid = i, blk.bn = br[i] - bl[i] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span> || i == pos[n]) tot = <span class="number">0</span>, blk.lt.<span class="built_in">prev</span>(<span class="number">1</span>, <span class="number">1</span>, blk.bn);</span><br><span class="line">            blk.<span class="built_in">prev</span>(), blk.<span class="built_in">solve</span>(), blk.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= qcnt; ++i) <span class="built_in">write</span>(ans[i].as), <span class="built_in">putc</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//高素质嫖别人的(36pts,但最后一个点AC了)</span></span><br><span class="line"><span class="keyword">namespace</span> GaoSuZhi</span><br><span class="line">&#123;</span><br><span class="line">    LL check[<span class="number">5000005</span>], nowu, cnt1, cnt2, c[<span class="number">1000005</span>], qf[<span class="number">1000005</span>];</span><br><span class="line">    <span class="keyword">bool</span> check1, hmz;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">add</span><span class="params">(LL now, LL v)</span></span>&#123; <span class="keyword">for</span> (; now &lt;= n; now += now &amp; -now) c[now] += v; &#125;</span><br><span class="line">    <span class="function">IL LL <span class="title">sum</span><span class="params">(LL tmp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LL s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; tmp &gt; <span class="number">0</span>; tmp -= tmp &amp; -tmp) s += c[tmp];</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">getmid</span><span class="params">(LL pos, LL l, LL r, <span class="keyword">bool</span> vis)</span></span>;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">getmid1</span><span class="params">(LL pos, LL l, LL r, <span class="keyword">bool</span> vis)</span></span>;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">getmid2</span><span class="params">(LL pos, LL l, LL r, <span class="keyword">bool</span> vis)</span></span>;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">getmn</span><span class="params">(LL pos, LL l, LL r)</span></span>;</span><br><span class="line">    <span class="keyword">namespace</span> work1</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            LL l, r, mid, sum, maxx, minn, tag;</span><br><span class="line">            <span class="keyword">bool</span> need;</span><br><span class="line">            <span class="built_in">node</span>() &#123;&#125;</span><br><span class="line">            <span class="built_in">node</span>(LL _l, LL _r, LL _mid, LL _sum, LL _maxx, LL _minn, LL _tag) &#123; l = _l, r = _r, mid = _mid, sum = _sum, maxx = _maxx, minn = _minn, tag = _tag, need = <span class="number">0</span>; &#125;</span><br><span class="line">        &#125; tree[<span class="number">5000005</span>];</span><br><span class="line">        <span class="function">IL node <span class="title">merge</span><span class="params">(node x, node y)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">node</span>(<span class="built_in">Max</span>(x.l, x.sum + y.l), <span class="built_in">Max</span>(y.r, y.sum + x.r), <span class="built_in">Max</span>(<span class="built_in">Max</span>(x.mid, y.mid), x.r + y.l), x.sum + y.sum, <span class="built_in">Max</span>(x.maxx, y.maxx), <span class="built_in">min</span>(x.minn, y.minn), <span class="number">0ll</span>); &#125;</span><br><span class="line">        <span class="function">IL <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(LL now, LL l, LL r)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            LL mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (tree[now].tag != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                LL mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                tree[now &lt;&lt; <span class="number">1</span>].sum += (mid - l + <span class="number">1</span>) * tree[now].tag, tree[now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum += (r - mid) * tree[now].tag;</span><br><span class="line">                tree[now &lt;&lt; <span class="number">1</span>].tag += tree[now].tag, tree[now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].tag += tree[now].tag;</span><br><span class="line">                tree[now &lt;&lt; <span class="number">1</span>].maxx += tree[now].tag, tree[now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].maxx += tree[now].tag;</span><br><span class="line">                tree[now &lt;&lt; <span class="number">1</span>].minn += tree[now].tag, tree[now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].minn += tree[now].tag;</span><br><span class="line">                tree[now &lt;&lt; <span class="number">1</span>].l = tree[now &lt;&lt; <span class="number">1</span>].r = tree[now &lt;&lt; <span class="number">1</span>].mid = <span class="built_in">Max</span>(tree[now &lt;&lt; <span class="number">1</span>].sum, <span class="number">0ll</span>), tree[now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].l = tree[now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].r = tree[now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mid = <span class="built_in">Max</span>(tree[now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum, <span class="number">0ll</span>);</span><br><span class="line">                tree[now].tag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tree[now].need &amp;&amp; l != r)</span><br><span class="line">            &#123;</span><br><span class="line">                tree[now &lt;&lt; <span class="number">1</span>].need = <span class="literal">true</span>, tree[now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].need = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">getmid</span>(now &lt;&lt; <span class="number">1</span>, l, mid, <span class="literal">true</span>), <span class="built_in">getmid</span>(now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, <span class="literal">true</span>);</span><br><span class="line">                tree[now].need = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">IL <span class="keyword">void</span> <span class="title">build</span><span class="params">(LL now, LL l, LL r)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (l == r)</span><br><span class="line">            &#123;</span><br><span class="line">                tree[now].need = <span class="literal">false</span>;</span><br><span class="line">                tree[now].l = tree[now].r = tree[now].mid = <span class="built_in">Max</span>(a[l], <span class="number">0ll</span>);</span><br><span class="line">                tree[now].sum = tree[now].minn = tree[now].maxx = a[l];</span><br><span class="line">                tree[now].tag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tree[now].need = <span class="literal">false</span>;</span><br><span class="line">            LL mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">build</span>(now &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">            tree[now] = <span class="built_in">merge</span>(tree[now &lt;&lt; <span class="number">1</span>], tree[now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">IL <span class="keyword">void</span> <span class="title">update</span><span class="params">(LL now, LL l, LL r, LL x, LL y, LL w)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (l &gt; y || r &lt; x) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (tree[now].maxx + w &lt;= <span class="number">0</span> || tree[now].minn + w &gt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    tree[now].sum += (r - l + <span class="number">1</span>) * w;</span><br><span class="line">                    tree[now].tag += w, tree[now].maxx += w, tree[now].minn += w;</span><br><span class="line">                    tree[now].l = tree[now].r = tree[now].mid = <span class="built_in">Max</span>(tree[now].sum, <span class="number">0ll</span>);</span><br><span class="line">                    tree[now].need = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((!check1 &amp;&amp; r - l + <span class="number">1</span> &lt;= <span class="number">500</span>) || (check1 &amp;&amp; r - l + <span class="number">1</span> &lt;= <span class="number">5000</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    tree[now].sum += (r - l + <span class="number">1</span>) * w;</span><br><span class="line">                    tree[now].tag += w, tree[now].maxx += w, tree[now].minn += w;</span><br><span class="line">                    tree[now].need = <span class="literal">true</span>;</span><br><span class="line">                    <span class="built_in">getmid</span>(now, l, r, <span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (r - l + <span class="number">1</span> &lt;= <span class="number">500</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">getmn</span>(now, l, r);</span><br><span class="line">                <span class="keyword">if</span> (tree[now].maxx &lt;= <span class="number">0</span> || tree[now].minn &gt;= <span class="number">0</span>) tree[now].mid = tree[now].l = tree[now].r = <span class="built_in">Max</span>(<span class="number">0ll</span>, tree[now].sum);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">getmid</span>(now, l, r, <span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">push_down</span>(now, l, r);</span><br><span class="line">            LL mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">update</span>(now &lt;&lt; <span class="number">1</span>, l, mid, x, y, w), <span class="built_in">update</span>(now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x, y, w);</span><br><span class="line">            tree[now] = <span class="built_in">merge</span>(tree[now &lt;&lt; <span class="number">1</span>], tree[now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">IL node <span class="title">query</span><span class="params">(LL now, LL l, LL r, LL x, LL y)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) <span class="keyword">return</span> tree[now];</span><br><span class="line">            <span class="keyword">if</span> (l &lt;= x &amp;&amp; r &lt;= y &amp;&amp; (r - x + <span class="number">1</span>) &lt;= <span class="number">700</span> &amp;&amp; (tree[now].need || r - x &lt;= <span class="number">500</span>)) <span class="keyword">return</span> <span class="built_in">getmid</span>(<span class="number">0</span>, x, r, <span class="literal">true</span>), tree[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &gt;= y &amp;&amp; (y - l + <span class="number">1</span>) &lt;= <span class="number">700</span> &amp;&amp; (tree[now].need || y - l &lt;= <span class="number">500</span>)) <span class="keyword">return</span> <span class="built_in">getmid</span>(<span class="number">0</span>, l, y, <span class="literal">true</span>), tree[<span class="number">0</span>];</span><br><span class="line">            LL mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">push_down</span>(now, l, r);</span><br><span class="line">            node ans;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; mid) ans = <span class="built_in">query</span>(now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x, y);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (y &lt;= mid) ans = <span class="built_in">query</span>(now &lt;&lt; <span class="number">1</span>, l, mid, x, y);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                node resa = <span class="built_in">query</span>(now &lt;&lt; <span class="number">1</span>, l, mid, x, y), resb = <span class="built_in">query</span>(now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x, y);</span><br><span class="line">                ans = <span class="built_in">node</span>(<span class="built_in">Max</span>(resa.l, resa.sum + resb.l), <span class="built_in">Max</span>(resb.r, resb.sum + resa.r), <span class="built_in">Max</span>(resa.mid, <span class="built_in">Max</span>(resb.mid, resa.r + resb.l)), resa.sum + resb.sum, <span class="number">0ll</span>, <span class="number">0ll</span>, <span class="number">0ll</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            tree[now] = <span class="built_in">merge</span>(tree[now &lt;&lt; <span class="number">1</span>], tree[now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">namespace</span> work2 <span class="comment">//实测用不到,但为了保持他代码的完整性,方便我以后理解他的思路,还是留下</span></span><br><span class="line">    &#123;</span><br><span class="line">        LL eps;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            LL l, r, mid, sum, maxx, minn, tag;</span><br><span class="line">            <span class="keyword">bool</span> check;</span><br><span class="line">        &#125; tree[<span class="number">1000005</span>];</span><br><span class="line">        <span class="function">IL <span class="keyword">bool</span> <span class="title">get</span><span class="params">(node now, LL len)</span></span>&#123; <span class="keyword">return</span> (now.maxx &lt;= <span class="number">0</span> || now.minn &gt;= <span class="number">0</span>); &#125;</span><br><span class="line">        <span class="function">IL <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(LL now, LL l, LL r)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            LL mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            tree[now &lt;&lt; <span class="number">1</span>].sum += (mid - l + <span class="number">1</span>) * tree[now].tag, tree[now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum += (r - mid) * tree[now].tag;</span><br><span class="line">            tree[now &lt;&lt; <span class="number">1</span>].tag += tree[now].tag, tree[now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].tag += tree[now].tag;</span><br><span class="line">            tree[now &lt;&lt; <span class="number">1</span>].maxx += tree[now].tag, tree[now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].maxx += tree[now].tag;</span><br><span class="line">            tree[now &lt;&lt; <span class="number">1</span>].minn += tree[now].tag, tree[now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].minn += tree[now].tag;</span><br><span class="line">            tree[now &lt;&lt; <span class="number">1</span>].check = <span class="built_in">get</span>(tree[now &lt;&lt; <span class="number">1</span>], mid - l + <span class="number">1</span>), tree[now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].check = <span class="built_in">get</span>(tree[now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>], r - mid);</span><br><span class="line">            tree[now].tag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">node <span class="title">merge</span><span class="params">(node x, node y, LL len)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            node ans = &#123;<span class="built_in">Max</span>(x.l, x.sum + y.l), <span class="built_in">Max</span>(y.r, y.sum + x.r), <span class="built_in">Max</span>(<span class="built_in">Max</span>(x.mid, y.mid), x.r + y.l), x.sum + y.sum, <span class="built_in">Max</span>(x.maxx, y.maxx), <span class="built_in">min</span>(x.minn, y.minn)&#125;;</span><br><span class="line">            <span class="keyword">if</span> (x.check || y.check) ans.check = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> ans.check = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(LL now, LL l, LL r)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            tree[now].tag = <span class="number">0</span>, tree[now].check = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (l == r)</span><br><span class="line">            &#123;</span><br><span class="line">                tree[now].maxx = tree[now].minn = tree[now].sum = a[l];</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            LL mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">build</span>(now &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">            tree[now] = <span class="built_in">merge</span>(tree[now &lt;&lt; <span class="number">1</span>], tree[now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>], r - l + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(LL now, LL l, LL r, LL x, LL y, LL w)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (l &gt; y || r &lt; x) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y)</span><br><span class="line">            &#123;</span><br><span class="line">                tree[now].sum += (r - l + <span class="number">1</span>) * w;</span><br><span class="line">                tree[now].maxx += w, tree[now].minn += w, tree[now].tag += w;</span><br><span class="line">                <span class="keyword">if</span> ((tree[now].maxx &lt;= <span class="number">0</span> || tree[now].minn &gt;= <span class="number">0</span>) &amp;&amp; r - l + <span class="number">1</span> &gt;= eps) tree[now].check = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> tree[now].check = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">push_down</span>(now, l, r);</span><br><span class="line">            LL mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">update</span>(now &lt;&lt; <span class="number">1</span>, l, mid, x, y, w), <span class="built_in">update</span>(now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x, y, w);</span><br><span class="line">            tree[now] = <span class="built_in">merge</span>(tree[now &lt;&lt; <span class="number">1</span>], tree[now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>], r - l + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">node <span class="title">query</span><span class="params">(LL now, LL l, LL r, LL x, LL y)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            tree[now].check = <span class="built_in">get</span>(tree[now], r - l + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (l &gt; y || r &lt; x) <span class="keyword">return</span> node&#123;<span class="number">-10000000</span>, <span class="number">-10000000</span>, <span class="number">-10000000</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (tree[now].maxx &lt;= <span class="number">0</span> || tree[now].minn &gt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    tree[now].l = tree[now].r = tree[now].mid = <span class="built_in">Max</span>(tree[now].sum, <span class="number">0ll</span>);</span><br><span class="line">                    <span class="keyword">return</span> tree[now];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (r - l + <span class="number">1</span> &lt;= <span class="number">300</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">getmid</span>(now, l, r, <span class="literal">false</span>);</span><br><span class="line">                    <span class="keyword">return</span> tree[now];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            node ans;</span><br><span class="line">            <span class="built_in">push_down</span>(now, l, r);</span><br><span class="line">            LL mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (l &gt; mid) ans = <span class="built_in">query</span>(now &lt;&lt; <span class="number">1</span>, l, mid, x, y);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (r &lt;= mid) ans = <span class="built_in">query</span>(now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x, y);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                node a = <span class="built_in">query</span>(now &lt;&lt; <span class="number">1</span>, l, mid, x, y), b = <span class="built_in">query</span>(now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x, y);</span><br><span class="line">                ans = &#123;<span class="built_in">Max</span>(a.l, a.sum + b.l), <span class="built_in">Max</span>(b.r, b.sum + a.r), <span class="built_in">Max</span>(<span class="built_in">Max</span>(a.mid, b.mid), a.r + b.l), a.sum + b.sum, <span class="built_in">Max</span>(a.maxx, b.maxx), <span class="built_in">min</span>(a.minn, b.minn)&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            tree[now] = <span class="built_in">merge</span>(tree[now &lt;&lt; <span class="number">1</span>], tree[now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>], r - l + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LL l, r, w;</span><br><span class="line">        <span class="keyword">double</span> p = cnt1 * <span class="number">1.0</span> / <span class="number">1e10</span>;</span><br><span class="line">        check1 = (p &lt; <span class="number">0.8</span> &amp;&amp; p &gt;= <span class="number">0.7</span>);</span><br><span class="line">        work2::eps = n / <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> LL i = <span class="number">1</span>; i &lt;= n; ++i) qf[i] = a[i] - a[i - <span class="number">1</span>], <span class="built_in">add</span>(i, qf[i]);</span><br><span class="line">        <span class="keyword">bool</span> hmz = (cnt1 &lt;= <span class="number">2e9</span>);</span><br><span class="line">        work1::<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">for</span> (LL k = <span class="number">1</span>; k &lt;= m; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            l = que[k].l, r = que[k].r, w = que[k].v;</span><br><span class="line">            <span class="keyword">if</span> (!l) ++l;</span><br><span class="line">            nowu = l;</span><br><span class="line">            <span class="keyword">if</span> (!hmz)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (que[k].op == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    qf[l] += w, qf[r + <span class="number">1</span>] -= w;</span><br><span class="line">                    <span class="built_in">add</span>(l, w), <span class="built_in">add</span>(r + <span class="number">1</span>, -w);</span><br><span class="line">                    work1::<span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, que[k].l, que[k].r, que[k].v);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (r - l + <span class="number">1</span> &lt;= <span class="number">50000</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        LL ans = <span class="number">0</span>, now = <span class="number">0</span>, ql = <span class="built_in">sum</span>(l), i;</span><br><span class="line">                        <span class="keyword">for</span> (i = l; i &lt;= r - <span class="number">11</span>; i += <span class="number">12</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            now = (now &lt; <span class="number">0</span> ? <span class="number">0</span> : now) + ql, ans = (ans &gt; now ? ans : now), ql += qf[i + <span class="number">1</span>],</span><br><span class="line">                            now = (now &lt; <span class="number">0</span> ? <span class="number">0</span> : now) + ql, ans = (ans &gt; now ? ans : now), ql += qf[i + <span class="number">2</span>],</span><br><span class="line">                            now = (now &lt; <span class="number">0</span> ? <span class="number">0</span> : now) + ql, ans = (ans &gt; now ? ans : now), ql += qf[i + <span class="number">3</span>],</span><br><span class="line">                            now = (now &lt; <span class="number">0</span> ? <span class="number">0</span> : now) + ql, ans = (ans &gt; now ? ans : now), ql += qf[i + <span class="number">4</span>],</span><br><span class="line">                            now = (now &lt; <span class="number">0</span> ? <span class="number">0</span> : now) + ql, ans = (ans &gt; now ? ans : now), ql += qf[i + <span class="number">5</span>],</span><br><span class="line">                            now = (now &lt; <span class="number">0</span> ? <span class="number">0</span> : now) + ql, ans = (ans &gt; now ? ans : now), ql += qf[i + <span class="number">6</span>],</span><br><span class="line">                            now = (now &lt; <span class="number">0</span> ? <span class="number">0</span> : now) + ql, ans = (ans &gt; now ? ans : now), ql += qf[i + <span class="number">7</span>],</span><br><span class="line">                            now = (now &lt; <span class="number">0</span> ? <span class="number">0</span> : now) + ql, ans = (ans &gt; now ? ans : now), ql += qf[i + <span class="number">8</span>],</span><br><span class="line">                            now = (now &lt; <span class="number">0</span> ? <span class="number">0</span> : now) + ql, ans = (ans &gt; now ? ans : now), ql += qf[i + <span class="number">9</span>],</span><br><span class="line">                            now = (now &lt; <span class="number">0</span> ? <span class="number">0</span> : now) + ql, ans = (ans &gt; now ? ans : now), ql += qf[i + <span class="number">10</span>],</span><br><span class="line">                            now = (now &lt; <span class="number">0</span> ? <span class="number">0</span> : now) + ql, ans = (ans &gt; now ? ans : now), ql += qf[i + <span class="number">11</span>],</span><br><span class="line">                            now = (now &lt; <span class="number">0</span> ? <span class="number">0</span> : now) + ql, ans = (ans &gt; now ? ans : now), ql += qf[i + <span class="number">12</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">while</span> (i &lt;= r) now = (now &lt; <span class="number">0</span> ? <span class="number">0</span> : now) + ql, ans = (ans &gt; now ? ans : now), ql += qf[++i];</span><br><span class="line">                        <span class="built_in">write</span>(ans), <span class="built_in">putc</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="built_in">write</span>(work1::<span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, que[k].l, que[k].r).mid), <span class="built_in">putc</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里本来还有一个else但用不到,为了代码简洁就不放了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">getmid</span><span class="params">(LL pos, LL l, LL r, <span class="keyword">bool</span> vis)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!pos || !vis || !check1 || (l != nowu &amp;&amp; work1::tree[pos].maxx &gt;= <span class="number">1e8</span> + <span class="number">1e5</span>)) <span class="built_in">getmid1</span>(pos, l, r, vis);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">getmid2</span>(pos, l, r, vis);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">getmid1</span><span class="params">(LL pos, LL l, LL r, <span class="keyword">bool</span> vis)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LL ans[<span class="number">3</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, now[<span class="number">3</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, ql = <span class="built_in">sum</span>(l), i;</span><br><span class="line">        <span class="keyword">for</span> (i = l; i &lt;= r - <span class="number">3</span>; i += <span class="number">4</span>)</span><br><span class="line">            now[<span class="number">1</span>] += ql, ans[<span class="number">1</span>] = (ans[<span class="number">1</span>] &gt; now[<span class="number">1</span>] ? ans[<span class="number">1</span>] : now[<span class="number">1</span>]),</span><br><span class="line">                          now[<span class="number">2</span>] = (now[<span class="number">2</span>] &lt; <span class="number">0</span> ? <span class="number">0</span> : now[<span class="number">2</span>]) + ql, ql += qf[i + <span class="number">1</span>], ans[<span class="number">2</span>] = (ans[<span class="number">2</span>] &gt; now[<span class="number">2</span>] ? ans[<span class="number">2</span>] : now[<span class="number">2</span>]),</span><br><span class="line">                          now[<span class="number">1</span>] += ql, ans[<span class="number">1</span>] = (ans[<span class="number">1</span>] &gt; now[<span class="number">1</span>] ? ans[<span class="number">1</span>] : now[<span class="number">1</span>]),</span><br><span class="line">                          now[<span class="number">2</span>] = (now[<span class="number">2</span>] &lt; <span class="number">0</span> ? <span class="number">0</span> : now[<span class="number">2</span>]) + ql, ql += qf[i + <span class="number">2</span>], ans[<span class="number">2</span>] = (ans[<span class="number">2</span>] &gt; now[<span class="number">2</span>] ? ans[<span class="number">2</span>] : now[<span class="number">2</span>]),</span><br><span class="line">                          now[<span class="number">1</span>] += ql, ans[<span class="number">1</span>] = (ans[<span class="number">1</span>] &gt; now[<span class="number">1</span>] ? ans[<span class="number">1</span>] : now[<span class="number">1</span>]),</span><br><span class="line">                          now[<span class="number">2</span>] = (now[<span class="number">2</span>] &lt; <span class="number">0</span> ? <span class="number">0</span> : now[<span class="number">2</span>]) + ql, ql += qf[i + <span class="number">3</span>], ans[<span class="number">2</span>] = (ans[<span class="number">2</span>] &gt; now[<span class="number">2</span>] ? ans[<span class="number">2</span>] : now[<span class="number">2</span>]),</span><br><span class="line">                          now[<span class="number">1</span>] += ql, ans[<span class="number">1</span>] = (ans[<span class="number">1</span>] &gt; now[<span class="number">1</span>] ? ans[<span class="number">1</span>] : now[<span class="number">1</span>]),</span><br><span class="line">                          now[<span class="number">2</span>] = (now[<span class="number">2</span>] &lt; <span class="number">0</span> ? <span class="number">0</span> : now[<span class="number">2</span>]) + ql, ql += qf[i + <span class="number">4</span>], ans[<span class="number">2</span>] = (ans[<span class="number">2</span>] &gt; now[<span class="number">2</span>] ? ans[<span class="number">2</span>] : now[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= r)</span><br><span class="line">            now[<span class="number">1</span>] += ql, ans[<span class="number">1</span>] = (ans[<span class="number">1</span>] &gt; now[<span class="number">1</span>] ? ans[<span class="number">1</span>] : now[<span class="number">1</span>]),</span><br><span class="line">                          now[<span class="number">2</span>] = (now[<span class="number">2</span>] &lt; <span class="number">0</span> ? <span class="number">0</span> : now[<span class="number">2</span>]) + ql, ql += qf[i + <span class="number">1</span>], ans[<span class="number">2</span>] = (ans[<span class="number">2</span>] &gt; now[<span class="number">2</span>] ? ans[<span class="number">2</span>] : now[<span class="number">2</span>]),</span><br><span class="line">                          ++i;</span><br><span class="line">        <span class="keyword">if</span> (vis) work1::tree[pos].l = ans[<span class="number">1</span>], work1::tree[pos].r = now[<span class="number">2</span>], work1::tree[pos].mid = ans[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">else</span> work2::tree[pos].l = ans[<span class="number">1</span>], work2::tree[pos].r = now[<span class="number">2</span>], work2::tree[pos].mid = ans[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">getmid2</span><span class="params">(LL pos, LL l, LL r, <span class="keyword">bool</span> vis)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LL now[<span class="number">3</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, ql = <span class="built_in">sum</span>(l), i, ans[<span class="number">3</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (i = l; i &lt;= r - <span class="number">12</span>; i += <span class="number">13</span>)</span><br><span class="line">            now[<span class="number">2</span>] = (now[<span class="number">2</span>] &lt; <span class="number">0</span> ? <span class="number">0</span> : now[<span class="number">2</span>]) + ql, ql += qf[i + <span class="number">1</span>], ans[<span class="number">2</span>] = (ans[<span class="number">2</span>] &gt; now[<span class="number">2</span>] ? ans[<span class="number">2</span>] : now[<span class="number">2</span>]),</span><br><span class="line">            now[<span class="number">2</span>] = (now[<span class="number">2</span>] &lt; <span class="number">0</span> ? <span class="number">0</span> : now[<span class="number">2</span>]) + ql, ql += qf[i + <span class="number">2</span>], ans[<span class="number">2</span>] = (ans[<span class="number">2</span>] &gt; now[<span class="number">2</span>] ? ans[<span class="number">2</span>] : now[<span class="number">2</span>]),</span><br><span class="line">            now[<span class="number">2</span>] = (now[<span class="number">2</span>] &lt; <span class="number">0</span> ? <span class="number">0</span> : now[<span class="number">2</span>]) + ql, ql += qf[i + <span class="number">3</span>], ans[<span class="number">2</span>] = (ans[<span class="number">2</span>] &gt; now[<span class="number">2</span>] ? ans[<span class="number">2</span>] : now[<span class="number">2</span>]),</span><br><span class="line">            now[<span class="number">2</span>] = (now[<span class="number">2</span>] &lt; <span class="number">0</span> ? <span class="number">0</span> : now[<span class="number">2</span>]) + ql, ql += qf[i + <span class="number">4</span>], ans[<span class="number">2</span>] = (ans[<span class="number">2</span>] &gt; now[<span class="number">2</span>] ? ans[<span class="number">2</span>] : now[<span class="number">2</span>]),</span><br><span class="line">            now[<span class="number">2</span>] = (now[<span class="number">2</span>] &lt; <span class="number">0</span> ? <span class="number">0</span> : now[<span class="number">2</span>]) + ql, ql += qf[i + <span class="number">5</span>], ans[<span class="number">2</span>] = (ans[<span class="number">2</span>] &gt; now[<span class="number">2</span>] ? ans[<span class="number">2</span>] : now[<span class="number">2</span>]),</span><br><span class="line">            now[<span class="number">2</span>] = (now[<span class="number">2</span>] &lt; <span class="number">0</span> ? <span class="number">0</span> : now[<span class="number">2</span>]) + ql, ql += qf[i + <span class="number">6</span>], ans[<span class="number">2</span>] = (ans[<span class="number">2</span>] &gt; now[<span class="number">2</span>] ? ans[<span class="number">2</span>] : now[<span class="number">2</span>]),</span><br><span class="line">            now[<span class="number">2</span>] = (now[<span class="number">2</span>] &lt; <span class="number">0</span> ? <span class="number">0</span> : now[<span class="number">2</span>]) + ql, ql += qf[i + <span class="number">7</span>], ans[<span class="number">2</span>] = (ans[<span class="number">2</span>] &gt; now[<span class="number">2</span>] ? ans[<span class="number">2</span>] : now[<span class="number">2</span>]),</span><br><span class="line">            now[<span class="number">2</span>] = (now[<span class="number">2</span>] &lt; <span class="number">0</span> ? <span class="number">0</span> : now[<span class="number">2</span>]) + ql, ql += qf[i + <span class="number">8</span>], ans[<span class="number">2</span>] = (ans[<span class="number">2</span>] &gt; now[<span class="number">2</span>] ? ans[<span class="number">2</span>] : now[<span class="number">2</span>]),</span><br><span class="line">            now[<span class="number">2</span>] = (now[<span class="number">2</span>] &lt; <span class="number">0</span> ? <span class="number">0</span> : now[<span class="number">2</span>]) + ql, ql += qf[i + <span class="number">9</span>], ans[<span class="number">2</span>] = (ans[<span class="number">2</span>] &gt; now[<span class="number">2</span>] ? ans[<span class="number">2</span>] : now[<span class="number">2</span>]),</span><br><span class="line">            now[<span class="number">2</span>] = (now[<span class="number">2</span>] &lt; <span class="number">0</span> ? <span class="number">0</span> : now[<span class="number">2</span>]) + ql, ql += qf[i + <span class="number">10</span>], ans[<span class="number">2</span>] = (ans[<span class="number">2</span>] &gt; now[<span class="number">2</span>] ? ans[<span class="number">2</span>] : now[<span class="number">2</span>]),</span><br><span class="line">            now[<span class="number">2</span>] = (now[<span class="number">2</span>] &lt; <span class="number">0</span> ? <span class="number">0</span> : now[<span class="number">2</span>]) + ql, ql += qf[i + <span class="number">11</span>], ans[<span class="number">2</span>] = (ans[<span class="number">2</span>] &gt; now[<span class="number">2</span>] ? ans[<span class="number">2</span>] : now[<span class="number">2</span>]),</span><br><span class="line">            now[<span class="number">2</span>] = (now[<span class="number">2</span>] &lt; <span class="number">0</span> ? <span class="number">0</span> : now[<span class="number">2</span>]) + ql, ql += qf[i + <span class="number">12</span>], ans[<span class="number">2</span>] = (ans[<span class="number">2</span>] &gt; now[<span class="number">2</span>] ? ans[<span class="number">2</span>] : now[<span class="number">2</span>]),</span><br><span class="line">            now[<span class="number">2</span>] = (now[<span class="number">2</span>] &lt; <span class="number">0</span> ? <span class="number">0</span> : now[<span class="number">2</span>]) + ql, ql += qf[i + <span class="number">13</span>], ans[<span class="number">2</span>] = (ans[<span class="number">2</span>] &gt; now[<span class="number">2</span>] ? ans[<span class="number">2</span>] : now[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= r)</span><br><span class="line">            now[<span class="number">2</span>] = (now[<span class="number">2</span>] &lt; <span class="number">0</span> ? <span class="number">0</span> : now[<span class="number">2</span>]) + ql, ql += qf[i + <span class="number">1</span>], ans[<span class="number">2</span>] = (ans[<span class="number">2</span>] &gt; now[<span class="number">2</span>] ? ans[<span class="number">2</span>] : now[<span class="number">2</span>]),</span><br><span class="line">            ++i;</span><br><span class="line">        <span class="keyword">if</span> (vis) work1::tree[pos].l = ans[<span class="number">1</span>], work1::tree[pos].r = now[<span class="number">2</span>], work1::tree[pos].mid = ans[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">else</span> work2::tree[pos].l = ans[<span class="number">1</span>], work2::tree[pos].r = now[<span class="number">2</span>], work2::tree[pos].mid = ans[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">getmn</span><span class="params">(LL pos, LL l, LL r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LL i, su = <span class="number">0</span>, maxx = <span class="number">-1e10</span>, minn = <span class="number">1e10</span>, ql = <span class="built_in">sum</span>(l);</span><br><span class="line">        <span class="keyword">for</span> (i = l; i &lt;= r - <span class="number">11</span>; i += <span class="number">12</span>)</span><br><span class="line">            su += ql, maxx = (maxx &lt; ql ? ql : maxx), minn = (minn &lt; ql ? minn : ql), ql += qf[i + <span class="number">1</span>],</span><br><span class="line">                      su += ql, maxx = (maxx &lt; ql ? ql : maxx), minn = (minn &lt; ql ? minn : ql), ql += qf[i + <span class="number">2</span>],</span><br><span class="line">                      su += ql, maxx = (maxx &lt; ql ? ql : maxx), minn = (minn &lt; ql ? minn : ql), ql += qf[i + <span class="number">3</span>],</span><br><span class="line">                      su += ql, maxx = (maxx &lt; ql ? ql : maxx), minn = (minn &lt; ql ? minn : ql), ql += qf[i + <span class="number">4</span>],</span><br><span class="line">                      su += ql, maxx = (maxx &lt; ql ? ql : maxx), minn = (minn &lt; ql ? minn : ql), ql += qf[i + <span class="number">5</span>],</span><br><span class="line">                      su += ql, maxx = (maxx &lt; ql ? ql : maxx), minn = (minn &lt; ql ? minn : ql), ql += qf[i + <span class="number">6</span>],</span><br><span class="line">                      su += ql, maxx = (maxx &lt; ql ? ql : maxx), minn = (minn &lt; ql ? minn : ql), ql += qf[i + <span class="number">7</span>],</span><br><span class="line">                      su += ql, maxx = (maxx &lt; ql ? ql : maxx), minn = (minn &lt; ql ? minn : ql), ql += qf[i + <span class="number">8</span>],</span><br><span class="line">                      su += ql, maxx = (maxx &lt; ql ? ql : maxx), minn = (minn &lt; ql ? minn : ql), ql += qf[i + <span class="number">9</span>],</span><br><span class="line">                      su += ql, maxx = (maxx &lt; ql ? ql : maxx), minn = (minn &lt; ql ? minn : ql), ql += qf[i + <span class="number">10</span>],</span><br><span class="line">                      su += ql, maxx = (maxx &lt; ql ? ql : maxx), minn = (minn &lt; ql ? minn : ql), ql += qf[i + <span class="number">11</span>],</span><br><span class="line">                      su += ql, maxx = (maxx &lt; ql ? ql : maxx), minn = (minn &lt; ql ? minn : ql), ql += qf[i + <span class="number">12</span>];</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= r)</span><br><span class="line">            su += ql, maxx = (maxx &lt; ql ? ql : maxx), minn = (minn &lt; ql ? minn : ql), ql += qf[++i];</span><br><span class="line">        work1::tree[pos].sum = su, work1::tree[pos].maxx = maxx, work1::tree[pos].minn = minn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(que[i].op), <span class="built_in">read</span>(que[i].l), <span class="built_in">read</span>(que[i].r);</span><br><span class="line">        <span class="keyword">if</span> (que[i].op == <span class="number">1</span>) <span class="built_in">read</span>(que[i].v);</span><br><span class="line">        <span class="keyword">else</span> GaoSuZhi::cnt1 += que[i].r - que[i].l + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> p = GaoSuZhi::cnt1 * <span class="number">1.0</span> / <span class="number">1e10</span>;</span><br><span class="line">    GaoSuZhi::check1 = (p &lt; <span class="number">0.8</span> &amp;&amp; p &gt;= <span class="number">0.7</span>);</span><br><span class="line">    GaoSuZhi::hmz = (GaoSuZhi::cnt1 &lt;= <span class="number">2e9</span>);</span><br><span class="line">    <span class="comment">//不要问我是怎么知道最后一个点a[1]=-1的</span></span><br><span class="line">    <span class="keyword">if</span> (!GaoSuZhi::hmz &amp;&amp; a[<span class="number">1</span>] == <span class="number">-1</span>) GaoSuZhi::<span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">else</span> My::<span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">flus</span>(), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>其实我对末日三问不是很感冒，感觉就是一般般的感动吧，当然确实挺好看的，但有点带入不了男女的立场，可能是我的理解有点不同吧</p><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2><p>上次三道题才 $7000$ 字，这一道题就 $7000$ 了！</p><p>学校马上要放假了，以后再更吧，还是一样，会挂链接的</p><p>最后首尾呼应一下：lxl太可爱了，我爱lxl！！！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt; 再续前缘&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="数据结构" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="分块" scheme="https://dyd-true.github.io/tags/%E5%88%86%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>猫树</title>
    <link href="https://dyd-true.github.io/2022/01/25/%E7%8C%AB%E6%A0%91/"/>
    <id>https://dyd-true.github.io/2022/01/25/%E7%8C%AB%E6%A0%91/</id>
    <published>2022-01-25T11:06:36.000Z</published>
    <updated>2022-01-25T13:26:43.659Z</updated>
    
    <content type="html"><![CDATA[<p> 喵~</p><span id="more"></span><h1 id="猫树"><a href="#猫树" class="headerlink" title="猫树"></a>猫树</h1><p>你肯定想知道它为什么要叫猫树（Cat Tree），其实就像珂朵莉树（Old Driver Tree）一样，只是创造的人喜欢罢了</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>先看猫树用来解决什么问题，一句话说，就是不带修改的线段树</p><p>线段树的时间为 $O(n) + O(\log n)$ （预处理 + 单次询问），而猫树可以做到 $O(n \log n) + O(1)$ ，但是<strong>不带修改</strong>（感觉好没用啊），一般用于优化dp之类的</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路非常简单：由于不带修改，可以线段树上每一段信息统计出来，直接调用</p><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>先看预处理，类似线段树的 <code>build</code> ，我们用递归的方式预处理</p><p>设处理到区间 $[l, r]$ ，就维护好其信息（这个信息不同于线段树的整体，而是更细致的信息，且一般以 $mid$ 为界，比如线段树维护“区间和”，猫树这里就应统计 $[l, mid]$ 的后缀和与 $[mid + 1, r]$ 的前缀和），然后进入左右段，时空明显 $O(n \log n)$ （假设统计信息是 $O(n)$ 的）</p><h2 id="询问"><a href="#询问" class="headerlink" title="询问"></a>询问</h2><p>这才是精髓，看看它是如何做到 $O(1)$ 的</p><p>如果只是预处理了，它的询问还是要递归，这不还是 $O(\log n)$ ？这可不行</p><p>我们逆向思考，如果是从叶节点 $[x, x]$ 和 $[y, y]$ 向上走，那它们第一次相遇于LCA处时，对应的区间就是唯一一个满足 $l \le x \le mid \le y \le r$ 的区间，而我们在这个区间统计的信息就足以回答询问了（比如“区间和”，我们统计的前后缀足以回答 $[x, y]$ 的和）</p><p>那么问题变成树上LCA，而且是完全二叉树，倍增是 $O(\log \log n)$ ，ST表可以做到 $O(1)$ ，但如果只是这样，似乎略显麻烦，体现不出猫树的优势啊</p><p>注意到，猫树它和线段树一样，采用“父子二倍”标号，而 $(110101)_2$ 和 $(110011)_2$ 的LCA就是最长公共前缀 $(110)_2$ ，大家可以手玩验证一下</p><p>那么怎么快速求出两个数的二进制的最长公共前缀？</p><p>求法是有的，但都不是很简单（太麻烦了还不如用ST表），我们退而求其次</p><p>设两个数的二进制的最长公共前缀长度为 $len$ （二进制下），发现两个数异或之后，最高位右移了 $len$ 位，而一个数的二进制长度就是 $\log n + 1$ ，可以预处理出 $\log$ $O(1)$ 得LCA的二进制长度</p><p>那长度有啥用呢？别忘了，在“父子二倍”标号下，长度就是层数啊！我们求得了LCA在树上是第几层</p><p>那有什么用呢？别忘了我们还知道查询的端点 $x, y$ ，考虑在预处理时把同一层的信息直接存在同一个数组里，如让 <code>sum[x][i]</code> 代表第 $x$ 层的前缀（ $i &gt; mid$ ）/后缀（ $i \le mid$ ）和，由于一层的节点没有重复覆盖，这是可以做到的</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>还是给道题：<a href="https://www.luogu.com.cn/problem/SP2916">GSS5</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STC static</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>, D = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">int</span> log_2[N &lt;&lt; <span class="number">2</span>], a[N], len;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CatTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//记录对应叶节点</span></span><br><span class="line">    <span class="keyword">int</span> pos[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//sum前/后缀和,mmx端点为mid最大子段和,mx最大子段和,imx端点为i的最大子段段和</span></span><br><span class="line">    <span class="keyword">int</span> sum[D][N &lt;&lt; <span class="number">1</span>], mmx[D][N &lt;&lt; <span class="number">1</span>], mx[D][N &lt;&lt; <span class="number">1</span>], imx[D][N &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r)</span><br><span class="line">            <span class="keyword">return</span> pos[l] = u, <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">        <span class="keyword">int</span> t, tt, mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        sum[d][mid] = mmx[d][mid] = mx[d][mid] = imx[d][mid] = t = tt = a[mid], tt = <span class="built_in">max</span>(tt, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mid - <span class="number">1</span>; i &gt;= l; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            t += a[i], tt += a[i];</span><br><span class="line">            sum[d][i] = t, imx[d][i] = tt;</span><br><span class="line">            mmx[d][i] = <span class="built_in">max</span>(mmx[d][i + <span class="number">1</span>], t);</span><br><span class="line">            mx[d][i] = <span class="built_in">max</span>(mx[d][i + <span class="number">1</span>], tt);</span><br><span class="line">            tt = <span class="built_in">max</span>(tt, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sum[d][mid + <span class="number">1</span>] = mmx[d][mid + <span class="number">1</span>] = mx[d][mid + <span class="number">1</span>] = imx[d][mid + <span class="number">1</span>] = t = tt = a[mid + <span class="number">1</span>], tt = <span class="built_in">max</span>(tt, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">2</span>; i &lt;= r; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            t += a[i], tt += a[i];</span><br><span class="line">            sum[d][i] = t, imx[d][i] = tt;</span><br><span class="line">            mmx[d][i] = <span class="built_in">max</span>(mmx[d][i - <span class="number">1</span>], t);</span><br><span class="line">            mx[d][i] = <span class="built_in">max</span>(mx[d][i - <span class="number">1</span>], tt);</span><br><span class="line">            tt = <span class="built_in">max</span>(tt, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid, d + <span class="number">1</span>), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, d + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//typ:1sum 2pre 3suf 4mid</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> typ)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == r)</span><br><span class="line">            <span class="keyword">return</span> a[l];</span><br><span class="line">        <span class="keyword">int</span> d = log_2[pos[l]] - log_2[pos[l] ^ pos[r]];</span><br><span class="line">        <span class="keyword">if</span> (typ == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> sum[d][l] + sum[d][r];</span><br><span class="line">        <span class="keyword">if</span> (typ == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(sum[d][l] + mmx[d][r], imx[d][l]);</span><br><span class="line">        <span class="keyword">if</span> (typ == <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(mmx[d][l] + sum[d][r], imx[d][r]);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">max</span>(mx[d][l], mx[d][r]), mmx[d][l] + mmx[d][r]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ct;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prev</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    log_2[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, t = N &lt;&lt; <span class="number">2</span>; i &lt; t; ++i)</span><br><span class="line">        log_2[i] = log_2[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l1, <span class="keyword">int</span> r1, <span class="keyword">int</span> l2, <span class="keyword">int</span> r2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (r1 &lt; l2)</span><br><span class="line">        <span class="keyword">return</span> ct.<span class="built_in">ask</span>(l1, r1, <span class="number">3</span>) + ct.<span class="built_in">ask</span>(r1 + <span class="number">1</span>, l2 - <span class="number">1</span>, <span class="number">1</span>) + ct.<span class="built_in">ask</span>(l2, r2, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    res = <span class="built_in">max</span>(ct.<span class="built_in">ask</span>(l2, r1, <span class="number">4</span>), ct.<span class="built_in">ask</span>(l1, l2, <span class="number">3</span>) + ct.<span class="built_in">ask</span>(l2, r2, <span class="number">2</span>) - a[l2]);</span><br><span class="line">    res = <span class="built_in">max</span>(res, ct.<span class="built_in">ask</span>(l1, r1, <span class="number">3</span>) + ct.<span class="built_in">ask</span>(r1, r2, <span class="number">2</span>) - a[r1]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T, n, m, l1, r1, l2, r2;</span><br><span class="line">    <span class="built_in">prev</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="comment">//要保证满二叉树</span></span><br><span class="line">        <span class="keyword">for</span> (len = <span class="number">2</span>; len &lt; n; len &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">        ct.<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, len, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">        <span class="keyword">while</span> (m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;l1, &amp;r1, &amp;l2, &amp;r2);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">ask</span>(l1, r1, l2, r2));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 喵~&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数据结构" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树" scheme="https://dyd-true.github.io/tags/%E6%A0%91/"/>
    
    <category term="笔记" scheme="https://dyd-true.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>大力分块</title>
    <link href="https://dyd-true.github.io/2022/01/24/%E5%A4%A7%E5%8A%9B%E5%88%86%E5%9D%97/"/>
    <id>https://dyd-true.github.io/2022/01/24/%E5%A4%A7%E5%8A%9B%E5%88%86%E5%9D%97/</id>
    <published>2022-01-24T06:13:12.000Z</published>
    <updated>2022-01-25T14:04:44.788Z</updated>
    
    <content type="html"><![CDATA[<p> lxl是yyds</p><span id="more"></span><h1 id="大力分块"><a href="#大力分块" class="headerlink" title="大力分块"></a>大力分块</h1><p>我估计会长的一比</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>众所周知，lxl喜欢数据结构</p><p>众所周知，lxl很毒瘤</p><p>众所周知，lxl有点中二+宅</p><p>于是lxl出了Yn（由乃）oi的大分块题目，把以上三者结合了起来</p><p>然后，就让我们来大力分块吧！</p><h2 id="最初分块"><a href="#最初分块" class="headerlink" title="最初分块"></a>最初分块</h2><p><strong>「望月悲叹的最初分块」</strong></p><p><a href="https://www.luogu.com.cn/problem/P4119">未来日记</a></p><p>维护一个序列，支持区间修改（把所有的 $x$ 变成 $y$ ）和区间第 $k$ 小， $n, m, a \le 10^5$ </p><h3 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h3><p>当然考虑分块</p><p>先设块长为 $B = \sqrt{n}$ ，考虑询问，先找到询问的区间，这个区间必定是由整块+散点组成，而这步寻找可以 $O(1)$ 找到</p><p>注意到 $a \le 10^5$ ，值域与 $n$ 同级，考虑对值域也分块（为区分称其为值块），设块长为 $V = \sqrt{n}$ ，记 <code>cnt[i][j]</code> 表示第 $i$ 块内的数值在第 $j$ 值块内的有几个</p><p>但是这个区间最多有 $\sqrt{n}$ 个块，又最多要枚举 $\sqrt{n}$ 个值块，这显然不可接受，由于对于单次询问，包括的块不变，考虑对块进行<strong>前缀和</strong>，设 <code>cnt[i][j]</code> 表示前 $i$ 块内的数值在第 $j$ 值块内的有几个，再开一个临时数组 <code>tcnt[j]</code> 表示散点中数值在第 $j$ 值块内的有几个，枚举可得答案所在值块，我们发现同理可得答案，具体的，设 <code>rel[i][j]</code> 表示前 $i$ 块内的数值是 $j$ 的有几个， <code>trel[j]</code> 同理，枚举可得答案，注意到枚举 <code>cnt[i][j]</code> 的时间是 $O(\sqrt{n})$ 的（只用枚举 $j$ ），枚举 <code>rel[i][j]</code> 也是 $O(\sqrt{n})$ 的，于是，我们用单次 $O(\sqrt{n})$ 的时间（目前看来）， $O(n \sqrt{n})$ 的空间（ <code>rel</code> 数组）解决了询问</p><p>考虑修改，先看散点，明显暴力就行了，修改的区间也可以 $O(1)$ 找到，对于整块每次修改需要一并修改 <code>cnt</code> 和 <code>rel</code> ，并且由于他们是“前缀和”，必须要把后面的每个块都改了，时间是 $O(\sqrt{n})$ （注意这里不要每个块都去修改后面，那样是 $O(n)$ 的，应该记一个修改量的前缀和），就……行了？</p><p>行个鬼啊！区间在修改完后一定要打上懒标记，不然下一次单点修改时查到的就是错误的值啊！</p><p>发现区间修改有一个优美的性质：值相等的点无论如何一定相等，这启发我们打<strong>并查集</strong>（对每一块开一个），把相等的点直接并到一起，这样，区间的标记可以 $O(\log \sqrt{n})$ 解决，但是，副作用是：单点修改的时候怎么办？不能直接更改这个点的 $fa$ ，因为它下面可能还有点，直接重构其实是可以的办法（因为每次散点只在两个块，最多 $2\sqrt{n}$ 个点），但我们还有别的办法</p><p>考虑建一些<strong>辅助点</strong>，设点 <code>nd[i][j]</code> 代表第 $i$ 块值为 $j$ ，对于一个块里的点，把他们全都并到 $nd$ 上去（换句话说，只有 $nd$ 有儿子），这样，散点就直接改就行了，而整块可以让 <code>nd[i][x]</code> 的 $fa$ 改为 <code>nd[i][y]</code> ，并让 <code>nd[i][x] = 0</code> （这代表这个区间没有值为 $x$ 的点），特殊情况是 <code>nd[i][y] == 0</code> ，这个时候就新建一个节点（<del>浪费空间ing</del>）</p><p>考虑空间， $nd$ 数组大小为 $O(n \sqrt{n})$ ，因为最初有 $n$ 个点（它们不做父亲），每一块最多有 $\sqrt{n}$ 个值，每次操作最多加 $\sqrt{n}$ 个辅助点（每块一个），并查集的节点数最多是 $n + \sqrt{n} * \sqrt{n} + m * \sqrt{n}$ 可以看作 $O(n \sqrt{n})$ 的空间；而对于时间，并查集的修改都是 $O(1)$ 的，单点的查询是 $O(\log \sqrt{n})$ （这个 $\log \sqrt{n}$ 非常解决于 $1$ ，因为并查集的深度只有辅助点个数，加上有路径压缩），散点是 $O(\sqrt{n})$ 个，块是 $O(\sqrt{n})$ 个，而修改那两个数组要用 $O(\sqrt{n})$ ，单次修改的总时间为 $O(\sqrt{n} \log \sqrt{n})$ ，而由于单点的查询是 $O(\log \sqrt{n})$ ，上面的单次询问也变成了 $O(\sqrt{n} \log \sqrt{n})$ </p><p>额……先打出来</p><p>（受苦了一下午以后……）</p><p>好，TLE $0pts$ ，<del>wtm**lxl！！！</del>，我只能望月悲叹</p><p>吃了个饭，回来尝试卡块长，发现 $B = 500, V = 317$ 是既不会TLE，也不会MLE，只是WA了，貌似有戏……？</p><p>开始调试<del>受苦</del>（这记着是为了防止我忘了，可以跳过不看） ：</p><ul><li><p> $2022/1/24$ $18:00 \sim 20:50$ 自以为操作 $2$ 基本调试完毕</p></li><li><p> $2022/1/24$ $20:55$ 自以为调完然后交（<del>谁给我的自信</del>），WA  $10pts$ ，WA的点都是输出了负数，不知为何（疑似炸 <code>int</code> ？）</p></li><li><p>  $2022/1/24$ $21:00$ 发现负数是我调试的时候把范围改了没改回去，修正后手造大样例，结果WA了（幸好没交） </p></li><li><p> $2022/1/24$ $21:20$ 发现我的make date不够严谨，而且在大数据下操作 $2$ 也挂了</p></li><li><p> $2022/1/24$ $21:30$ 发现操作 $2$ 挂在没特判同块</p></li><li><p> $2022/1/24$ $21:51$ 同机房<strong>wfy</strong>巨佬帮我调出了一个很难的RE，这次应该是真的吧操作 $2$ 调好了</p></li><li><p> $2022/1/24$ $22:00$  $73pts$ 该睡觉了</p></li><li><p>话说我昨晚睡觉时想到，并查集上加一个按秩合并，可以优化到单次 $O(\sqrt{n} \alpha(n))$ </p></li><li><p> $2022/1/25$ $8:00$ AC了！！！</p></li></ul><p>做法如果还有不懂的可以看<a href="https://dydbenren.blog.luogu.org/solution-p4119">这个</a></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STC static</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IL inline</span></span><br><span class="line"><span class="comment">//求块号</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get(x, len) (((x) - 1) / (len) + 1)</span></span><br><span class="line"><span class="comment">//块左端点</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LB(x, len) (((x) - 1) * (len) + 1)</span></span><br><span class="line"><span class="comment">//块右端点</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RB(x, len) ((x) * (len))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Fast <span class="comment">//长的和shit一样的快读</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[L], out[L], *iS, *iT;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> gh() (iT == iS ? iT = (iS = buf) + fread(buf, 1, L, stdin), (iT == iS ? EOF : *iS++) : *iS++)</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;class T&gt; </span></span><br><span class="line"><span class="function">    IL <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = <span class="built_in">gh</span>(), t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            t |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">gh</span>();</span><br><span class="line">        <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            x = x * <span class="number">10</span> + (ch ^ <span class="number">48</span>), ch = <span class="built_in">gh</span>();</span><br><span class="line">        <span class="keyword">if</span> (t)</span><br><span class="line">            x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">flus</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">fwrite</span>(out, <span class="number">1</span>, l, stdout);</span><br><span class="line">        l = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">putc</span><span class="params">(<span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        out[l++] = x;</span><br><span class="line">        <span class="keyword">if</span> (l == L - <span class="number">5</span>)</span><br><span class="line">            <span class="built_in">flus</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function">    IL <span class="keyword">void</span> <span class="title">write</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">putc</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">9</span>)</span><br><span class="line">            <span class="built_in">write</span>(x / <span class="number">10</span>);</span><br><span class="line">        out[l++] = x % <span class="number">10</span> + <span class="number">48</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == L - <span class="number">5</span>)</span><br><span class="line">            <span class="built_in">flus</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Fast::flus;</span><br><span class="line"><span class="keyword">using</span> Fast::putc;</span><br><span class="line"><span class="keyword">using</span> Fast::read;</span><br><span class="line"><span class="keyword">using</span> Fast::write;</span><br><span class="line"><span class="comment">//B:点块长,N:注意要多开一个B的大小,V:值块长,NB:开空间用</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>  B = <span class="number">500</span>, N = <span class="number">1e5</span> + B + <span class="number">1</span>, V = <span class="number">317</span>, NB = B + <span class="number">5</span>;</span><br><span class="line"><span class="comment">//num:块数,wi:最大值</span></span><br><span class="line"><span class="keyword">int</span> num, wi;</span><br><span class="line"><span class="comment">//如题</span></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//cnt:块值前缀和,rel:真实值前缀和</span></span><br><span class="line">    <span class="keyword">int</span> cnt[NB], rel[N];</span><br><span class="line">    <span class="comment">//b[i].nd[j]:第i块值为j的并查集根</span></span><br><span class="line">    <span class="keyword">int</span> nd[N];</span><br><span class="line">&#125; b[NB];</span><br><span class="line"><span class="comment">//并查集:父亲,大小,值(仅当为根时有意义)</span></span><br><span class="line"><span class="keyword">int</span> fa[N * NB + N * <span class="number">2</span>], si[N * NB + N * <span class="number">2</span>], val[N * NB + N * <span class="number">2</span>], tot = <span class="number">0</span>;</span><br><span class="line"><span class="function">IL <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//路径压缩</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">newnd</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> v)</span> <span class="comment">//新建并查集根节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = ++tot, fa[x] = x, si[x] = <span class="number">0</span>, val[x] = v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span> <span class="comment">//按秩合并,把x并给y</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (si[x] &gt; si[y])</span><br><span class="line">    &#123;</span><br><span class="line">        val[x] = val[y];</span><br><span class="line">        <span class="built_in">swap</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    fa[x] = y, si[y] += si[x], x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">int</span> <span class="title">va</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//返回点x的真实值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val[<span class="built_in">find</span>(x)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//栈用于还原tcnt和trel</span></span><br><span class="line">    STC <span class="keyword">int</span> tcnt[NB], trel[N], stk[NB &lt;&lt; <span class="number">1</span>], top;</span><br><span class="line">    STC <span class="keyword">int</span> t, tt, x;</span><br><span class="line">    <span class="comment">//特判同块</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">get</span>(l, B) == <span class="built_in">get</span>(r, B))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (; l &lt;= r; ++l)</span><br><span class="line">        &#123;</span><br><span class="line">            x = <span class="built_in">va</span>(l);</span><br><span class="line">            ++tcnt[<span class="built_in">get</span>(x, V)], ++trel[x];</span><br><span class="line">            stk[++top] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (x = <span class="number">0</span>, t = <span class="number">1</span>, tt = <span class="built_in">get</span>(wi, V); t &lt;= tt; ++t)</span><br><span class="line">            <span class="keyword">if</span> ((x += tcnt[t]) &gt;= k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (tt = <span class="built_in">RB</span>(t, V); ; --tt)</span><br><span class="line">                    <span class="keyword">if</span> ((x -= trel[tt]) &lt; k)</span><br><span class="line">                    &#123;</span><br><span class="line">                        t = tt;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//处理散点</span></span><br><span class="line">        top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">get</span>(l - <span class="number">1</span>, B) == (t = <span class="built_in">get</span>(l, B))) <span class="comment">//这里虽然第一块多了个点0但不影响答案</span></span><br><span class="line">            <span class="keyword">for</span> (; <span class="built_in">get</span>(l, B) == t; ++l)</span><br><span class="line">            &#123;</span><br><span class="line">                x = <span class="built_in">va</span>(l);</span><br><span class="line">                ++tcnt[<span class="built_in">get</span>(x, V)], ++trel[x];</span><br><span class="line">                stk[++top] = x;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">get</span>(r + <span class="number">1</span>, B) == (t = <span class="built_in">get</span>(r, B)))</span><br><span class="line">            <span class="keyword">for</span> (; <span class="built_in">get</span>(r, B) == t; --r)</span><br><span class="line">            &#123;</span><br><span class="line">                x = <span class="built_in">va</span>(r);</span><br><span class="line">                ++tcnt[<span class="built_in">get</span>(x, V)], ++trel[x];</span><br><span class="line">                stk[++top] = x;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//找到答案(这里假设答案一定存在)</span></span><br><span class="line">        <span class="keyword">for</span> (x = <span class="number">0</span>, t = <span class="number">1</span>, l = <span class="built_in">get</span>(l, B), r = <span class="built_in">get</span>(r, B), tt = <span class="built_in">get</span>(wi, V); t &lt;= tt; ++t)</span><br><span class="line">            <span class="keyword">if</span> ((x += tcnt[t] + b[r].cnt[t] - b[l - <span class="number">1</span>].cnt[t]) &gt;= k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (tt = <span class="built_in">RB</span>(t, V); ; --tt)</span><br><span class="line">                    <span class="keyword">if</span> ((x -= trel[tt] + b[r].rel[tt] - b[l - <span class="number">1</span>].rel[tt]) &lt; k)</span><br><span class="line">                    &#123;</span><br><span class="line">                        t = tt;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//还原</span></span><br><span class="line">    <span class="keyword">while</span> (top)</span><br><span class="line">    &#123;</span><br><span class="line">        x = stk[top--];</span><br><span class="line">        --tcnt[<span class="built_in">get</span>(x, V)], --trel[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == y)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    wi = <span class="built_in">max</span>(wi, y);</span><br><span class="line">    STC <span class="keyword">int</span> t, tt, xx, yy, ll;</span><br><span class="line">    <span class="comment">//记录l用于还原</span></span><br><span class="line">    ll = l;</span><br><span class="line">    xx = <span class="built_in">get</span>(x, V), yy = <span class="built_in">get</span>(y, V);</span><br><span class="line">    <span class="comment">//还原前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (t = num, tt = <span class="built_in">get</span>(ll, B); t &gt;= tt; --t)</span><br><span class="line">    &#123;</span><br><span class="line">        b[t].cnt[xx] -= b[t - <span class="number">1</span>].cnt[xx];</span><br><span class="line">        b[t].rel[x] -= b[t - <span class="number">1</span>].rel[x];</span><br><span class="line">        b[t].cnt[yy] -= b[t - <span class="number">1</span>].cnt[yy];</span><br><span class="line">        b[t].rel[y] -= b[t - <span class="number">1</span>].rel[y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//特判同块</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">get</span>(l, B) == (t = <span class="built_in">get</span>(r, B)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[t].rel[x] &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!b[t].nd[y])</span><br><span class="line">                <span class="built_in">newnd</span>(b[t].nd[y], y);</span><br><span class="line">            <span class="keyword">for</span> (; l &lt;= r; ++l)</span><br><span class="line">                <span class="keyword">if</span> ((tt = <span class="built_in">va</span>(l)) == x)</span><br><span class="line">                &#123;</span><br><span class="line">                    fa[l] = b[t].nd[y];</span><br><span class="line">                    <span class="comment">//注意同时跟新大小</span></span><br><span class="line">                    ++si[b[t].nd[y]];</span><br><span class="line">                    --si[b[t].nd[x]];</span><br><span class="line">                    --b[t].cnt[xx], --b[t].rel[x];</span><br><span class="line">                    ++b[t].cnt[yy], ++b[t].rel[y];</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//处理散点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">get</span>(l - <span class="number">1</span>, B) == (t = <span class="built_in">get</span>(l, B)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (b[t].rel[x] &lt;= <span class="number">0</span>)</span><br><span class="line">                l = <span class="built_in">LB</span>(t + <span class="number">1</span>, B); </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!b[t].nd[y])</span><br><span class="line">                    <span class="built_in">newnd</span>(b[t].nd[y], y);</span><br><span class="line">                <span class="keyword">for</span> (; <span class="built_in">get</span>(l, B) == t; ++l)</span><br><span class="line">                    <span class="keyword">if</span> ((tt = <span class="built_in">va</span>(l)) == x)</span><br><span class="line">                    &#123;</span><br><span class="line">                        fa[l] = b[t].nd[y];</span><br><span class="line">                        ++si[b[t].nd[y]];</span><br><span class="line">                        --si[b[t].nd[x]];</span><br><span class="line">                        --b[t].cnt[xx], --b[t].rel[x];</span><br><span class="line">                        ++b[t].cnt[yy], ++b[t].rel[y];</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">get</span>(r + <span class="number">1</span>, B) == (t = <span class="built_in">get</span>(r, B)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (b[t].rel[x] &lt;= <span class="number">0</span>)</span><br><span class="line">                r = <span class="built_in">RB</span>(t - <span class="number">1</span>, B); </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!b[t].nd[y])</span><br><span class="line">                    <span class="built_in">newnd</span>(b[t].nd[y], y);</span><br><span class="line">                <span class="keyword">for</span> (; <span class="built_in">get</span>(r, B) == t; --r)</span><br><span class="line">                    <span class="keyword">if</span> ((tt = <span class="built_in">va</span>(r)) == x)</span><br><span class="line">                    &#123;</span><br><span class="line">                        fa[r] = b[t].nd[y];</span><br><span class="line">                        ++si[b[t].nd[y]];</span><br><span class="line">                        --si[b[t].nd[x]];</span><br><span class="line">                        --b[t].cnt[xx], --b[t].rel[x];</span><br><span class="line">                        ++b[t].cnt[yy], ++b[t].rel[y];</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理整块</span></span><br><span class="line">        <span class="keyword">for</span> (l = <span class="built_in">get</span>(l, B), r = <span class="built_in">get</span>(r, B); l &lt;= r; ++l)</span><br><span class="line">            <span class="keyword">if</span> (b[l].rel[x] &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!b[l].nd[y])</span><br><span class="line">                    <span class="built_in">newnd</span>(b[l].nd[y], y);</span><br><span class="line">                <span class="built_in">merge</span>(b[l].nd[x], b[l].nd[y]);</span><br><span class="line">                b[l].cnt[yy] += b[l].rel[x];</span><br><span class="line">                b[l].rel[y] += b[l].rel[x];</span><br><span class="line">                b[l].cnt[xx] -= b[l].rel[x];</span><br><span class="line">                b[l].rel[x] -= b[l].rel[x];</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再求前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (t = <span class="built_in">get</span>(ll, B); t &lt;= num; ++t)</span><br><span class="line">    &#123;</span><br><span class="line">        b[t].cnt[xx] += b[t - <span class="number">1</span>].cnt[xx];</span><br><span class="line">        b[t].rel[x] += b[t - <span class="number">1</span>].rel[x];</span><br><span class="line">        b[t].cnt[yy] += b[t - <span class="number">1</span>].cnt[yy];</span><br><span class="line">        b[t].rel[y] += b[t - <span class="number">1</span>].rel[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(m);</span><br><span class="line">    num = <span class="built_in">get</span>(n, B), wi = <span class="number">0</span>;</span><br><span class="line">    tot = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(a);</span><br><span class="line">        wi = <span class="built_in">max</span>(wi, a);</span><br><span class="line">        <span class="keyword">auto</span> &amp;t = b[<span class="built_in">get</span>(i, B)];</span><br><span class="line">        <span class="keyword">if</span> (!t.nd[a])</span><br><span class="line">            <span class="built_in">newnd</span>(t.nd[a], a);</span><br><span class="line">        fa[i] = t.nd[a];</span><br><span class="line">        ++si[t.nd[a]];</span><br><span class="line">        ++t.cnt[<span class="built_in">get</span>(a, V)], ++t.rel[a];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, t = <span class="built_in">get</span>(wi, V); j &lt;= t; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++i)</span><br><span class="line">            b[i].cnt[j] += b[i - <span class="number">1</span>].cnt[j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= wi; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++i)</span><br><span class="line">            b[i].rel[j] += b[i - <span class="number">1</span>].rel[j];</span><br><span class="line">    <span class="keyword">int</span> op, l, r, x, y;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(op), <span class="built_in">read</span>(l), <span class="built_in">read</span>(r), <span class="built_in">read</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">read</span>(y), <span class="built_in">modify</span>(l, r, x, y);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">write</span>(<span class="built_in">ask</span>(l, r, x)), <span class="built_in">putc</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">flus</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>我用于喜欢我妻由乃！</p><h2 id="第二分块"><a href="#第二分块" class="headerlink" title="第二分块"></a>第二分块</h2><p><strong>「突刺贯穿的第二分块」</strong></p><p>好，我们乘胜追击！</p><p><a href="https://www.luogu.com.cn/problem/P4117">五彩斑斓的世界</a></p><p>维护一个序列，支持区间修改（把所有大于 $x$ 的数减去 $x$ ）和查询区间中 $x$ 的出现次数， $n \le 10^5, m \le 5 \times 10^5, a \le 10^5 + 1$  ，时限 $7.5s$ ，空间 $64MB$ </p><h3 id="做题-1"><a href="#做题-1" class="headerlink" title="做题"></a>做题</h3><p>不难发现，如果不是那<del>sm</del>的空间，可以用最初分块解决，但这空间，  $O(n \sqrt{n})$ 都开不出来</p><p>那看看着题和最初分块的不同呢？发现询问是出现次数，而不是排名，这个显然可以直接记录，就不必要前缀和了，注意，这意味着分块后<strong>每个块之间的信息毫无关联</strong>，并且答案就是<strong>区间包含的所有答案的累加</strong>于是有一个控制空间的方法：</p><p>把操作离线下来，对每个块都按顺序处理一遍所有的操作，然后把询问的答案累加即可，空间是 $O(n + m)$ 的了（也许开 <code>short</code>  也行，没试过）</p><p>那么该如何修改呢？注意到由于我们离线了，所以要枚举 $\sqrt{n}$ 块，每一块又要枚举 $m$ 个操作，所以对于每个操作我们要做到 $O(1)$ ，或者所有操作加起来共用 $O(n)$ </p><p>这……直接瞟一眼<a href="https://olddrivertree.blog.uoj.ac/blog/4715">出题人的题解</a>，发现可以这样懒标记+并查集维护，具体的，设当前块最大值为 $mx$ ：</p><ul><li>若 $mx \le 2x$ ，就直接枚举大于 $x$ 的数，让它们减去 $x$ </li><li>若 $mx &gt; 2x$ ，就直接枚举小于 $x$ 的数，让它们加上 $x$ ，然后区间打上减 $x$ 的标记</li></ul><p>设后面的“枚举……”时间复杂度为 $O(t)$ ，发现 $mx$ 的真实值（算上懒标记）是单调下降的，由于 $mx$ 初始最大为 $10^5 + 1$ ，所以所有操作时间加起来是 $O(a) * O(t)$ 的，由于总共只能用 $O(n)$ ，所以必须保证 $O(t) = O(1)$ </p><p>还是可以开并查集（但这里可不能像最初分块一样开辅助点，空间不够），对每个值开一个并查集，然后记录这个并查集的 $si$ ，整块修改的时候直接合并两个值的并查集，查询的时候直接输出这个并查集的 $si$ ，都是 $O(1)$ 的；如果是散点修改，就直接重构；散点查询，就通过并查集找到范围内每个数的值，暴力统计即可</p><p>但对于散点的时间，我们还得从另一个角度分析才能得出结论：假设我们没有离线，空间就开那么大，则 $m$ 次操作最多重构 $2m$  个块，每个块 $\sqrt{n}$ 个点，同时怼上路径压缩，由于每次会遍历每个叶子，路径压缩的效果极好，散点均摊每个点可以当作 $O(1)$ ，则时间复杂度为 $O(m \sqrt{n})$ ，均摊到每个块和每个操作，就是 $O(1)$ 了（好像严格的 $O(1)$ 应该是用链表代替并查集，重构更快，但不太好打）</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STC static</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IL inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get(x, len) (((x) - 1) / (len) + 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LB(x, len) (((x) - 1) * (len) + 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RB(x, len) ((x) * (len))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Fast</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[L], out[L], *iS, *iT;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> gh() (iT == iS ? iT = (iS = buf) + fread(buf, 1, L, stdin), (iT == iS ? EOF : *iS++) : *iS++)</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;class T&gt; </span></span><br><span class="line"><span class="function">    IL <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = <span class="built_in">gh</span>(), t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            t |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">gh</span>();</span><br><span class="line">        <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            x = x * <span class="number">10</span> + (ch ^ <span class="number">48</span>), ch = <span class="built_in">gh</span>();</span><br><span class="line">        <span class="keyword">if</span> (t)</span><br><span class="line">            x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">flus</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">fwrite</span>(out, <span class="number">1</span>, l, stdout);</span><br><span class="line">        l = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">putc</span><span class="params">(<span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        out[l++] = x;</span><br><span class="line">        <span class="keyword">if</span> (l == L - <span class="number">5</span>)</span><br><span class="line">            <span class="built_in">flus</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function">    IL <span class="keyword">void</span> <span class="title">write</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">putc</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">9</span>)</span><br><span class="line">            <span class="built_in">write</span>(x / <span class="number">10</span>);</span><br><span class="line">        out[l++] = x % <span class="number">10</span> + <span class="number">48</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == L - <span class="number">5</span>)</span><br><span class="line">            <span class="built_in">flus</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Fast::flus;</span><br><span class="line"><span class="keyword">using</span> Fast::putc;</span><br><span class="line"><span class="keyword">using</span> Fast::read;</span><br><span class="line"><span class="keyword">using</span> Fast::write;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">5e5</span> + <span class="number">5</span>, A = <span class="number">1e5</span> + <span class="number">5</span>, B = <span class="number">1000</span>, NB = B + <span class="number">5</span>, N = <span class="number">1e6</span> + B + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Question</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> op, l, r, x, ans;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fa[N], si[N], val[N], rt[A];</span><br><span class="line">    <span class="keyword">int</span> mx, tag, l, r;</span><br><span class="line">    <span class="function">IL <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">int</span> <span class="title">va</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val[<span class="built_in">find</span>(x)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rt[y])</span><br><span class="line">            fa[rt[x]] = rt[y];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rt[y] = rt[x], val[rt[y]] = y;</span><br><span class="line">        si[y] += si[x];</span><br><span class="line">        rt[x] = si[x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ++si[x[i]];</span><br><span class="line">            <span class="keyword">if</span> (!rt[x[i]])</span><br><span class="line">            &#123;</span><br><span class="line">                mx = <span class="built_in">max</span>(mx, x[i]);</span><br><span class="line">                rt[x[i]] = i;</span><br><span class="line">                fa[i] = i, val[i] = x[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                fa[i] = rt[x[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(<span class="keyword">int</span> x[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//一定在摧毁前找到真实值</span></span><br><span class="line">            x[i] = <span class="built_in">va</span>(i);</span><br><span class="line">            rt[x[i]] = si[x[i]] = <span class="number">0</span>;</span><br><span class="line">            x[i] -= tag;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i)</span><br><span class="line">            fa[i] = <span class="number">0</span>;</span><br><span class="line">        tag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mx - tag &lt; (d &lt;&lt; <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = mx; i &gt; d + tag; --i)</span><br><span class="line">                <span class="keyword">if</span> (rt[i])</span><br><span class="line">                    <span class="built_in">merge</span>(i, i - d);</span><br><span class="line">            <span class="comment">//这里最大值不一定要保证存在,反正上面判了rt的,但一定要不多不少</span></span><br><span class="line">            mx = <span class="built_in">min</span>(mx, d + tag);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> + tag; i &lt;= d + tag; ++i)</span><br><span class="line">                <span class="keyword">if</span> (rt[i])</span><br><span class="line">                    <span class="built_in">merge</span>(i, i + d);</span><br><span class="line">            tag += d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> ll ,<span class="keyword">int</span> rr, <span class="keyword">int</span> x[], <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ll &gt; rr)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="built_in">destroy</span>(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = ll; i &lt;= rr; ++i)</span><br><span class="line">            <span class="keyword">if</span> (x[i] &gt; d)</span><br><span class="line">                x[i] -= d;</span><br><span class="line">        <span class="built_in">build</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (d + tag &gt; A)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> si[d + tag];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> ll, <span class="keyword">int</span> rr, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = ll; i &lt;= rr; ++i)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">va</span>(i) - tag == d)</span><br><span class="line">                ++res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; blk;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    STC <span class="keyword">int</span> a[N];</span><br><span class="line">    STC Question q[M];</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)    </span><br><span class="line">        <span class="built_in">read</span>(q[i].op), <span class="built_in">read</span>(q[i].l), <span class="built_in">read</span>(q[i].r), <span class="built_in">read</span>(q[i].x), q[i].ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">get</span>(n, B); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        blk.l = <span class="built_in">LB</span>(i, B);</span><br><span class="line">        blk.r = <span class="built_in">RB</span>(i, B);</span><br><span class="line">        blk.<span class="built_in">build</span>(a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (q[j].op == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (q[j].l &lt;= blk.l &amp;&amp; q[j].r &gt;= blk.r)</span><br><span class="line">                    blk.<span class="built_in">modify</span>(q[j].x);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    blk.<span class="built_in">change</span>(<span class="built_in">max</span>(q[j].l, blk.l), <span class="built_in">min</span>(q[j].r, blk.r), a, q[j].x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (q[j].l &lt;= blk.l &amp;&amp; q[j].r &gt;= blk.r)</span><br><span class="line">                    q[j].ans += blk.<span class="built_in">query</span>(q[j].x);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    q[j].ans += blk.<span class="built_in">ask</span>(<span class="built_in">max</span>(q[j].l, blk.l), <span class="built_in">min</span>(q[j].r, blk.r), q[j].x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        blk.<span class="built_in">destroy</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="keyword">if</span> (q[i].op == <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">write</span>(q[i].ans), <span class="built_in">putc</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="built_in">flus</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其它-1"><a href="#其它-1" class="headerlink" title="其它"></a>其它</h3><p>这是个galgame吗？我好像没玩过……</p><h2 id="第三分块"><a href="#第三分块" class="headerlink" title="第三分块"></a>第三分块</h2><p>由于lxl觉得它过于简单，被开除块籍了，后面数字断了的就是开除块籍了，不再提</p><h2 id="第四分块"><a href="#第四分块" class="headerlink" title="第四分块"></a>第四分块</h2><p><strong>「弑尽破净的第四分块」</strong></p><p><a href="https://www.luogu.com.cn/problem/P5397">天降之物</a></p><p>维护一个序列，支持两种操作：</p><ol><li>区间修改，把序列中所有的 $x$ 变成 $y$ </li><li>在整个序列中找出一组 $i, j$ 满足 $a_i = x, a_j = y$ ，使 $|i - j|$ 最小，并输出 $i - j$ ，不存在输出Ikaros</li></ol><p>强制在线， $n, m, a \le 10^5$ ， $500ms, 256MB$ </p><h3 id="做题-2"><a href="#做题-2" class="headerlink" title="做题"></a>做题</h3><p>额……操作全都是对<strong>序列中</strong>进行，分个鬼的块啊！但是毕竟这是“第四分块”，加上出题人lxl，估计还得分，就硬分！</p><p>还是考虑对序列分块，同时记录每一块内每一个数的个数，对于询问，如果有一个块同时包含两个数，直接暴力，时间 $O(B)$ ；否则吧每个块当成一个点，点上只有 $x, y, 0$ 三种信息，找到最近的 $x, y$ ，整块直接加，散点暴力，时间为 $O(2B + \frac{n}{B})$ ，修改就并查集维护即可，考虑到每次修改是对于整个序列，可以所有数共用一个并查集，不存在散点的情况，块长取 $B = \sqrt{n}$ 时，时空复杂度为均为 $O(n \sqrt{n})$ ，希望它别卡常……</p><p>艹，打到一半意识到这是完全假的，因为可能会有多个块同时包含两个数，而且还有可能出现两个相邻块最优，或者多个跨块最优……总之就是完全假掉了</p><p>臭不要脸的康康题解~</p><p>原来正解是根号分治（那为啥要叫第四分块啊！不过好像有人分块卡过了），不过既然是学习，当然学更稳当的根号分治了（就是平衡时间复杂度）</p><p>在讲正解前，先明确一些东西：</p><p>先考虑暴力的做法，当然是对每个数维护一个<strong>有序</strong>的位置集合，合并时归并排序，查询类似归并用双指针，但不合并，据说这样有 $60pts$ （夭寿了！lxl出的题有暴力分了！）</p><p>设 <code>si[x]</code> 表示 $x$ 在序列中出现的次数，当 <code>si[x] &gt; lim</code> （ $lim$ 是阈值）时称其为<strong>大点</strong>，否则是<strong>小点</strong>；定义数组 <code>as[x][y]</code> 有意义当且仅当 $x$ 是大点，其意义为“大点 $x$ 到值 $y$ 的最小距离”；定义<strong>附属集合</strong> <code>v[x]</code> 表示“自上一次重构以来，新出现的 $x$ 的位置”</p><p>我们要保证所有附属集合的大小不超过 $lim$ ，具体的，每当一个点 $x$ 的附属集合的大小超过 $lim$ ，我们就暴力跟新 <code>as[x][]</code> （此时 $x$ 必为大点），暴力可以做到 $O(n)$ ，我们称这个操作为<strong>重构</strong></p><p>另外，在修改操作把 $x$ 变成 $y$ 时，可以开一个数组 <code>val[x]</code> 代表值 $x$ 的真实值，这样我们就可以交换 $x, y$ 了，只要记得只要修改一下 $val$ 即可</p><p>好，现在来看根号分治：</p><p>因为 $x, y$ 可以交换，所以只考虑 <code>si[x] &lt;= si[y]</code> 的情况 </p><p>对于修改，设把 $x$ 变成 $y$ </p><ul><li>若 $x$ 是小点，暴力归并二者的附属集合（把 $x$ 并入 $y$ ）；如果合并后（这是预判，不必真的合并） $y$ 的附属集合大小超过 $lim$ 就重构 $y$ </li><li>若 $x$ 为大点（此时 $y$ 必为大点），显然把 $x$ 当成 $y$ 直接暴力重构（为啥不合并呢？因为 $x$ 是大点，它的一部分答案信息已经在 <code>as[x][]</code> 里了，附属集合记录信息不完全）</li></ul><p>重构发生会把至少 $lim$ 个数从附属集合里除去，它们的信息被记在了 $as$ 中，且它们<strong>不会在出现在任何附属集合内</strong>了，而当所有附属集合都为空时，显然不会再发生重构，所以重构最多发生 $\frac{n}{lim}$ 次</p><p>合并附属集合显然是 $O(lim)$ ，不重构只修改 <code>as[][y]</code> 是 $O(\frac{n}{lim})$ 所以修改的时间复杂度为 $O(m * \max(lim, \frac{n}{lim}) + n * \frac{n}{lim})$ </p><p>对于查询 $x, y$ </p><p>先暴力“归并”（不合并）二者附属集合，再与两个数中大点的 $as$ 取 $\min$ </p><p>查询的时间为 $O(m * lim)$ </p><p>最后关于空间，最多有 $\frac{n}{lim}$ 个大点，而每个点的附属集合最多有 $lim$ 个数，所以空间为 $O(\frac{n}{lim} * a + n * lim)$ ，另外一定注意 <code>vector</code> 的 <code>clear</code> <strong>不释放空间</strong>，具体写法见代码</p><p>明显，因为 $n, m, a$ 同级， $lim = \sqrt{n}$ 时时空都达到最优（然而实际上一般出题人都会卡 $\sqrt{n}$ 的，开大点可能好些，但本题不必）</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STC static</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IL inline</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Fast</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[L], out[L], *iS, *iT;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> gh() (iT == iS ? iT = (iS = buf) + fread(buf, 1, L, stdin), (iT == iS ? EOF : *iS++) : *iS++)</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;class T&gt; </span></span><br><span class="line"><span class="function">    IL <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = <span class="built_in">gh</span>(), t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            t |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">gh</span>();</span><br><span class="line">        <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            x = x * <span class="number">10</span> + (ch ^ <span class="number">48</span>), ch = <span class="built_in">gh</span>();</span><br><span class="line">        <span class="keyword">if</span> (t)</span><br><span class="line">            x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">flus</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">fwrite</span>(out, <span class="number">1</span>, l, stdout);</span><br><span class="line">        l = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">putc</span><span class="params">(<span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        out[l++] = x;</span><br><span class="line">        <span class="keyword">if</span> (l == L - <span class="number">5</span>)</span><br><span class="line">            <span class="built_in">flus</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function">    IL <span class="keyword">void</span> <span class="title">write</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">putc</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">9</span>)</span><br><span class="line">            <span class="built_in">write</span>(x / <span class="number">10</span>);</span><br><span class="line">        out[l++] = x % <span class="number">10</span> + <span class="number">48</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == L - <span class="number">5</span>)</span><br><span class="line">            <span class="built_in">flus</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Fast::flus;</span><br><span class="line"><span class="keyword">using</span> Fast::putc;</span><br><span class="line"><span class="keyword">using</span> Fast::read;</span><br><span class="line"><span class="keyword">using</span> Fast::write;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">317</span>, NL = L + <span class="number">5</span>, N = <span class="number">1e5</span> + L + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[N];</span><br><span class="line"><span class="comment">//id记录大点编号</span></span><br><span class="line"><span class="keyword">int</span> lim, si[N], as[NL][N], id[N], val[N], tot = <span class="number">0</span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v[N];</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">write_Ikaros</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">putc</span>(<span class="string">&#x27;I&#x27;</span>), <span class="built_in">putc</span>(<span class="string">&#x27;k&#x27;</span>), <span class="built_in">putc</span>(<span class="string">&#x27;a&#x27;</span>), <span class="built_in">putc</span>(<span class="string">&#x27;r&#x27;</span>), <span class="built_in">putc</span>(<span class="string">&#x27;o&#x27;</span>), <span class="built_in">putc</span>(<span class="string">&#x27;s&#x27;</span>), <span class="built_in">putc</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//重构</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!id[x])</span><br><span class="line">        id[x] = ++tot;</span><br><span class="line">    <span class="keyword">int</span> t = id[x];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line">        as[t][i] = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = INF; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (a[i] == x)</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            as[t][a[i]] = <span class="built_in">min</span>(as[t][a[i]], ++j);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n, j = INF; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> (a[i] == x)</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            as[t][a[i]] = <span class="built_in">min</span>(as[t][a[i]], ++j);</span><br><span class="line">    as[t][x] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//把v和一个空vector交换,开在函数里的会被释放</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; l18qAKIOI;</span><br><span class="line">    v[x].<span class="built_in">swap</span>(l18qAKIOI);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">//合并</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, sx = v[x].<span class="built_in">size</span>(), sy = v[y].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; sx &amp;&amp; j &lt; sy)</span><br><span class="line">        t.<span class="built_in">push_back</span>(v[x][i] &lt; v[y][j] ? v[x][i++] : v[y][j++]);</span><br><span class="line">    <span class="keyword">while</span> (i &lt; sx)</span><br><span class="line">        t.<span class="built_in">push_back</span>(v[x][i++]);</span><br><span class="line">    <span class="keyword">while</span> (j &lt; sy)</span><br><span class="line">        t.<span class="built_in">push_back</span>(v[y][j++]);</span><br><span class="line">    v[y] = t;</span><br><span class="line">&#125;</span><br><span class="line">IL <span class="keyword">int</span> _merge(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, sx = v[x].<span class="built_in">size</span>(), sy = v[y].<span class="built_in">size</span>(), res = INF;</span><br><span class="line">    <span class="keyword">if</span> (!sx || !sy)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; sx &amp;&amp; j &lt; sy)</span><br><span class="line">        res = <span class="built_in">min</span>(res, v[x][i] &lt; v[y][j] ? v[y][j] - v[x][i++] : v[x][i] - v[y][j++]);</span><br><span class="line">    <span class="keyword">while</span> (i &lt; sx)</span><br><span class="line">        res = <span class="built_in">min</span>(res, <span class="built_in">abs</span>(v[x][i++] - v[y][sy - <span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">while</span> (j &lt; sy)</span><br><span class="line">        res = <span class="built_in">min</span>(res, <span class="built_in">abs</span>(v[x][sx - <span class="number">1</span>] - v[y][j++]));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _x = val[x], _y = val[y];</span><br><span class="line">    <span class="keyword">if</span> (!si[_x] || _x == _y)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (si[_x] &gt; si[_y])</span><br><span class="line">        val[y] = _x, <span class="built_in">swap</span>(_x, _y);</span><br><span class="line">    val[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!_x || !_y)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    x = _x, y = _y;</span><br><span class="line">    <span class="keyword">if</span> (si[x] &gt; lim)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (a[i] == x)</span><br><span class="line">                a[i] = y;</span><br><span class="line">        <span class="built_in">build</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : v[x])</span><br><span class="line">            a[i] = y;</span><br><span class="line">        <span class="keyword">if</span> (si[x] + v[y].<span class="built_in">size</span>() &lt;= lim)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//重构y就不必进行这个跟新了,反正as[y][]是准确的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i)</span><br><span class="line">                as[i][y] = <span class="built_in">min</span>(as[i][y], as[i][x]);</span><br><span class="line">            <span class="built_in">merge</span>(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">build</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    si[y] += si[x], si[x] = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; wfyAKNOI;</span><br><span class="line">    v[x].<span class="built_in">swap</span>(wfyAKNOI);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IL <span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = val[x], y = val[y];</span><br><span class="line">    <span class="keyword">if</span> (!si[x] || !si[y])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == y)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = _merge(x, y);</span><br><span class="line">    <span class="keyword">if</span> (si[y] &gt; lim)</span><br><span class="line">        res = <span class="built_in">min</span>(res, as[id[y]][x]);</span><br><span class="line">    <span class="keyword">if</span> (si[x] &gt; lim)</span><br><span class="line">        res = <span class="built_in">min</span>(res, as[id[x]][y]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last = <span class="number">0</span>, op, x, y;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(m);</span><br><span class="line">    lim = <span class="built_in">sqrt</span>(n) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">read</span>(a[i]), ++si[a[i]], v[a[i]].<span class="built_in">push_back</span>(i), val[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (si[i] &gt; lim)</span><br><span class="line">            <span class="built_in">build</span>(i);</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(op), <span class="built_in">read</span>(x), <span class="built_in">read</span>(y);</span><br><span class="line">        x ^= last, y ^= last;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">modify</span>(x, y);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((last = <span class="built_in">ask</span>(x, y)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">write_Ikaros</span>(), last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">write</span>(last), <span class="built_in">putc</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">flus</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其它-2"><a href="#其它-2" class="headerlink" title="其它"></a>其它</h3><p>天降之物也挺好看的，但可惜 $09$ 年是钢炼的天下</p><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2><p>在写到这里时，已经 $7000$ 字了，才完成 $\frac{1}{3}$ ，觉定分成几部分（目前想的是三篇，到时候看吧）</p><p>已经打了两天的分块了，我都要吐了，缓缓再战，下一篇写好会在这里挂链接的</p><p>update：<a href="https://dyd-true.github.io/2022/01/25/%E5%A4%A7%E5%8A%9B%E5%88%86%E5%9D%972/#more">大力分块2</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt; lxl是yyds&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="数据结构" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="分块" scheme="https://dyd-true.github.io/tags/%E5%88%86%E5%9D%97/"/>
    
  </entry>
  
</feed>
