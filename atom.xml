<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dyd&#39;s Blog</title>
  
  <subtitle>He who has a strong enough why can bear almost any how.</subtitle>
  <link href="https://dyd-true.github.io/atom.xml" rel="self"/>
  
  <link href="https://dyd-true.github.io/"/>
  <updated>2022-06-05T08:41:56.135Z</updated>
  <id>https://dyd-true.github.io/</id>
  
  <author>
    <name>Dyd</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>luoguP2155 [SDOI2008] 沙拉公主的困惑</title>
    <link href="https://dyd-true.github.io/2022/06/05/luoguP2155-SDOI2008-%E6%B2%99%E6%8B%89%E5%85%AC%E4%B8%BB%E7%9A%84%E5%9B%B0%E6%83%91/"/>
    <id>https://dyd-true.github.io/2022/06/05/luoguP2155-SDOI2008-%E6%B2%99%E6%8B%89%E5%85%AC%E4%B8%BB%E7%9A%84%E5%9B%B0%E6%83%91/</id>
    <published>2022-06-05T08:28:42.000Z</published>
    <updated>2022-06-05T08:41:56.135Z</updated>
    
    <content type="html"><![CDATA[<p> 感觉式子很有用</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P2155">沙拉公主的困惑</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先给式子： $Ans = \frac{n!}{m!} * \varphi(m!)$ ，打开就是 $n!\frac{\prod(p - 1)}{\prod p},其中p是m!的约数$ </p><p>直接预处理即可，注意当 $n!$ 里包含模数而且分母没有约掉的话直接输出 $0$ </p><p>看起来很简单，但式子不好推，比较简单的推法是写成 $\gcd(x, y) == 1$ 然后上欧拉反演即得</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, P, ans;</span><br><span class="line"><span class="keyword">int</span> fac[N], pr[N], cnt, imp[N], mp[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = <span class="built_in">LL</span>(x) * x % P) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = <span class="built_in">LL</span>(res) * x % P;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prev</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fac[<span class="number">0</span>] = fac[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i) fac[i] = <span class="built_in">LL</span>(fac[i - <span class="number">1</span>]) * i % P;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[i]) pr[++cnt] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; <span class="built_in">LL</span>(pr[j]) * i &lt; N; ++j)</span><br><span class="line">&#123;</span><br><span class="line">vis[pr[j] * i] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i % pr[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>, sum = <span class="number">1</span>, is = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pr[j] == P) ++j;</span><br><span class="line"><span class="keyword">if</span> (j &lt;= cnt &amp;&amp; pr[j] &lt;= i) sum = <span class="built_in">LL</span>(pr[j++]) * sum % P, is = <span class="built_in">qpow</span>(sum, P - <span class="number">2</span>);</span><br><span class="line">imp[i] = is;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>, sum = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j &lt;= cnt &amp;&amp; pr[j] &lt;= i) sum = <span class="built_in">LL</span>(pr[j++] - <span class="number">1</span>) * sum % P;</span><br><span class="line">mp[i] = sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;T, &amp;P);</span><br><span class="line"><span class="built_in">prev</span>();</span><br><span class="line"><span class="keyword">while</span> (T--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">if</span> (n &gt;= P &amp;&amp; m &lt; P) <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ans = <span class="built_in">LL</span>(fac[n]) * imp[m] % P * mp[m] % P;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 感觉式子很有用&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="数论,数学" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
    <category term="欧拉函数" scheme="https://dyd-true.github.io/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>优化dp4</title>
    <link href="https://dyd-true.github.io/2022/06/04/%E4%BC%98%E5%8C%96dp4/"/>
    <id>https://dyd-true.github.io/2022/06/04/%E4%BC%98%E5%8C%96dp4/</id>
    <published>2022-06-04T06:54:52.000Z</published>
    <updated>2022-06-05T14:00:35.779Z</updated>
    
    <content type="html"><![CDATA[<p> 然而我 dp 废的一比</p><span id="more"></span><h1 id="优化dp4"><a href="#优化dp4" class="headerlink" title="优化dp4"></a>优化dp4</h1><p>才发现这个还没写……</p><p>上一篇：<a href="https://dyd-true.github.io/2022/02/12/%E4%BC%98%E5%8C%96dp3/">优化dp3</a></p><h1 id="wqs-二分"><a href="#wqs-二分" class="headerlink" title="wqs 二分"></a>wqs 二分</h1><h2 id="（并不保证真确性的）定义"><a href="#（并不保证真确性的）定义" class="headerlink" title="（并不保证真确性的）定义"></a>（并不保证真确性的）定义</h2><p>以下全是自己的理解：感觉就是用来求一个“选 $m$ 个，最优化”的问题，更具体的，设选 $x$ 个的最大权值为 $f(x)$ ，wqs 二分要求 $f(x)-x$ 图像是这样（就是先随着可选个数增多变优，后来因为必须要选 $x$ 个导致变坏），形式化的，其实是要求它是个凸函数：<img src="https://s2.loli.net/2022/06/04/1LgZziuFHh7BPTb.png" alt="f(x)-x"></p><p>如图，设绿色直线为 $y = kx + b$ ，由切点 $D(x_D, f(x_D))$ 得 $b = f(x_D) - kx_D$ ，考虑到这是切线，显然对于一个确定的 $k$ ， $x_D$ 是使 $b$ 最大的点，那么可以二分一个 $k$ ，把每个物品的价值 $-k$ （如果是代价就 $+k$ ），然后做<strong>没有个数限制</strong>的 dp 求出最大的价值和就是 $b$ ，此时对应的 $x$ （如绿线对应的 $x_D$ ）若比 $m$ 大，说明 $k$ 应继续变大；若比 $m$ 小，$k$ 应该变小；若相等，则用 $k, x/m$ 计算得到 $f(m)$ </p><p>值得一提的是，很多时候如果 $x, f(x)$ 都是整数，那么 $k$ 也可以只在整数范围二分：考虑求导，有 $f’(x) = k$ ，大部分情况下 $f(x)$ 的导函数 $f’(x)$ 都是“比较好看的”，加上 $x$ 是整数，那么 $k$  一半也是整数</p><p>但是，整数又会遇到一个问题：如果一条切线过了几个点（包括 $m$ ）怎么办（更具体的，当斜率为 $k$ 时 $x = m - 1$ ，斜率变化 $1$ 时 $x = m + 1$ ）？其实此时我们不也是算出了 $m$ 的斜率吗，直接就用此时的 $k$ 就好了（优先用小的那个算，即 $x = m - 1$ 那个）</p><p>带权二分的好处在于，对于要求“选则恰好 $k$ 个“，我们 dp 时几乎不可避免的要给 $k$ 一维，这让状态数（和时间复杂度）直接乘了个 $n$ （个数），而 wqs 二分可以避免加一维，把 $n$ 优化至 $\log v$ （权值）</p><p>另外，一个细节是，向下取整（ ）</p><h2 id="例题十二"><a href="#例题十二" class="headerlink" title="例题十二"></a>例题十二</h2><p>经典题：<a href="https://www.luogu.com.cn/problem/P2619">Tree I</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二分一个 $k$ ，对于每条白边，把权值改为 $c - k$ ，直接做最小生成树即可，时间 $O(m \log m \log k \alpha(n))$ （ $k$ 是边权），可以黑白边分开排序，每次合并，时间 $O(m \alpha(n) \log k + m \log m)$ </p><p>细节是一条切线过几个点的情况，此时明显白边权值与黑边权值相等，我们优先选白边，还有 $k$ 可以为负数</p><p>（所以这和 dp 有啥关系啊）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> PII = std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span>+ <span class="number">100</span>, M = <span class="number">1e5</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, num, ans, cta = <span class="number">0</span>, ctb = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span> <span class="keyword">int</span> u, v, w, c; &#125; e[M], a[M], b[M];</span><br><span class="line"><span class="keyword">int</span> fa[N], rk[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">get</span>(fa[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (rk[x] &gt; rk[y]) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">fa[x] = y, rk[y] += rk[x] == rk[y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">PII <span class="title">chk</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>, ct = <span class="number">0</span>, x, y;</span><br><span class="line">PII res = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= cta &amp;&amp; j &lt;= ctb)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i].w - k &lt; b[j].w) e[++ct] = a[i++], e[ct].w -= k;</span><br><span class="line"><span class="keyword">else</span> e[++ct] = b[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= cta) e[++ct] = a[i++], e[ct].w -= k;</span><br><span class="line"><span class="keyword">while</span> (j &lt;= ctb) e[++ct] = b[j++];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) fa[i] = i, rk[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= ct; ++i)</span><br><span class="line">&#123;</span><br><span class="line">x = <span class="built_in">get</span>(e[i].u), y = <span class="built_in">get</span>(e[i].v);</span><br><span class="line"><span class="keyword">if</span> (x == y) <span class="keyword">continue</span>;</span><br><span class="line">res.fi += e[i].w;</span><br><span class="line">res.se += e[i].c == <span class="number">0</span>;</span><br><span class="line"><span class="built_in">merge</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;num);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;e[i].u, &amp;e[i].v, &amp;e[i].w, &amp;e[i].c);</span><br><span class="line">++e[i].u, ++e[i].v;</span><br><span class="line"><span class="keyword">if</span> (e[i].c == <span class="number">0</span>) a[++cta] = e[i];</span><br><span class="line"><span class="keyword">else</span> b[++ctb] = e[i];</span><br><span class="line">&#125;</span><br><span class="line">std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + cta + <span class="number">1</span>, [&amp;](Edge x, Edge y)&#123; <span class="keyword">return</span> x.w &lt; y.w; &#125;);</span><br><span class="line">std::<span class="built_in">sort</span>(b + <span class="number">1</span>, b + ctb + <span class="number">1</span>, [&amp;](Edge x, Edge y)&#123; <span class="keyword">return</span> x.w &lt; y.w; &#125;);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">-101</span>, r = <span class="number">101</span>, mid;</span><br><span class="line">PII t;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line">mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">t = <span class="built_in">chk</span>(mid);</span><br><span class="line"><span class="keyword">if</span> (t.se &lt;= num)</span><br><span class="line">&#123;</span><br><span class="line">ans = t.fi + mid * num;</span><br><span class="line">l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题十三"><a href="#例题十三" class="headerlink" title="例题十三"></a>例题十三</h2><p>看看真正的 dp 题（不难发现大部分时候 dp 都是套在 wqs 二分内部的）：<a href="https://www.luogu.com.cn/problem/P4383">林克卡特树</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>为了方便记题目中的 $k$ 为 $num$ 显然切断 $num$ 条边后原树变成 $num + 1$ 个联通块（更进一步，它们都是树），我们求出每棵树的直径（最长链，可以是点），用 $num$ 条权为 $0$ 的边连起来就是最优解</p><p>考虑树形 dp ，套路的设 $d[i, j]$ 表示”点 $i$ 的子树中有 $j$ 条链的最大值”，然后发现没法转移，没法转移的关键问题是，当考虑合并 $u, v$ 两个点代表的联通块集合时，会出现两个链合并成一条链/链数不变/链数加 $1$ 三个情况，我们当前信息无法指导我们如何转移</p><p>考虑加一维，不难发现在最后选的链中每个点的度数只有 $0/1/2$ ，于是令 $d[i, j, k](k = 0/1/2)$ 表示”点 $i$ 的子树中有 $j$ 条链，且 $i$ 的度数为 $k$ 的最大值“，那么转移就分讨设 $v$  为 $u$ 的儿子：</p><ol><li>不选 $(u, v)$ ： $d[u, j_1, k_1] + d[v, j_2, k_2] \to d[u, j_1 + j_2, k_1]$ </li><li>选则 $(u, v)$ ： $d[u, j_1, k_1] + d[v, j_2, k_2] \to d[u, j_1 + j_2 + dt, k_1 + 1]$ ，其中 $k_1, k_2 \ne 2$ ， $dt = [k_1 == 0 \wedge k_2 == 0] - [k_1 == 1 \wedge k_2 == 1]$ </li></ol><p>那么边界显然就是 $d[i, 0, 0] = 0$ 其它都是 $-\infty$ ，吗？发现如果是以一个点作为链，那就是 $d[i, 1, ?] = 0$ ，但 $?$ （也就是这个点的度）该是多少呢？显然我们不能让这个点与其它任何点相连，所以是 $2$ ，即 $d[i, 1, 2] = d[i, 0, 0] = 0$ 其它都是 $-\infty$ ，于是 dp ，答案就是 $\max(d[root, num, 0/1/2])$ ，直接 dp 时间为 $O(n * num * 3)$ ，我们发现很难优化，因为转移已经是 $O(1)$ 了，时间瓶颈在状态数，现在我们要么减少计算的状态数（即只计算一部分状态），要么减少状态数（即修改状态的定义）</p><p>此时不难发现 <del>这篇 blog 讲的是 wqs 二分</del> 此题也是”选 $num$ 个“的形式，我们把 $num = 0 \sim 100$ 的答案依次求一下，发现这是一个凸函数（不会证，具体做题时靠感觉 + 打表 + 猜想），上 wqs 二分，把第二维直接去掉，转移时发现边数减少就加一个 $k$ ，否则减一个 $k$ （这个 $k$ 是二分的）</p><p>最后是 wqs 二分的经典问题：凸包上多点共线怎么解决；我们打个结构体 dp 时优先转移边数少的即可，注意去掉第二维后出现自己转移到自己的情况，用临时数组避免多次转移</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p> $l, r$ 初始值一定要够大，注意是 $num + 1$ 个联通块</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">100</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">int</span> n, num, l, r, mid, h[N], idx = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span> <span class="keyword">int</span> ne, ver, w; &#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DP</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">LL v; <span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (DP x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> v == x.v ? num &gt; x.num : v &lt; x.v; &#125;</span><br><span class="line">DP <span class="keyword">operator</span> + (DP x)&#123; <span class="keyword">return</span> &#123;v + x.v, num + x.num&#125;; &#125;</span><br><span class="line">&#125; d[N][<span class="number">3</span>], as, td[<span class="number">3</span>];</span><br><span class="line">LL ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>&#123; e[idx] = &#123;h[x], y, z&#125;, h[x] = idx++; &#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmx</span><span class="params">(T &amp;x, T y)</span></span>&#123; <span class="keyword">return</span> x &lt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne) <span class="keyword">if</span> ((y = e[i].ver) != fa)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">dp</span>(y, x);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; ++j) td[j] = &#123;-INF, inf&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; ++j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span>; ++k) <span class="built_in">cmx</span>(td[j], d[x][j] + d[y][k]);</span><br><span class="line"><span class="built_in">cmx</span>(td[<span class="number">1</span>], d[x][<span class="number">0</span>] + d[y][<span class="number">0</span>] + DP&#123;e[i].w - mid, <span class="number">1</span>&#125;);</span><br><span class="line"><span class="built_in">cmx</span>(td[<span class="number">1</span>], d[x][<span class="number">0</span>] + d[y][<span class="number">1</span>] + DP&#123;e[i].w, <span class="number">0</span>&#125;);</span><br><span class="line"><span class="built_in">cmx</span>(td[<span class="number">2</span>], d[x][<span class="number">1</span>] + d[y][<span class="number">0</span>] + DP&#123;e[i].w, <span class="number">0</span>&#125;);</span><br><span class="line"><span class="built_in">cmx</span>(td[<span class="number">2</span>], d[x][<span class="number">1</span>] + d[y][<span class="number">1</span>] + DP&#123;e[i].w + mid, <span class="number">-1</span>&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; ++j) d[x][j] = td[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;num);</span><br><span class="line"><span class="built_in">memset</span>(h + <span class="number">1</span>, <span class="number">-1</span>, n &lt;&lt; <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, w; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line"><span class="built_in">add</span>(u, v, w), <span class="built_in">add</span>(v, u, w);</span><br><span class="line">&#125;</span><br><span class="line">l = <span class="number">-1e12</span>, r = <span class="number">1e12</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line">mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">d[i][<span class="number">0</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">d[i][<span class="number">1</span>] = &#123;-INF, inf&#125;;</span><br><span class="line">d[i][<span class="number">2</span>] = &#123;-mid, <span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dp</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">as = d[<span class="number">1</span>][<span class="number">0</span>], <span class="built_in">cmx</span>(as, d[<span class="number">1</span>][<span class="number">1</span>]), <span class="built_in">cmx</span>(as, d[<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">if</span> (as.num &lt;= num + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">ans = as.v + <span class="built_in">LL</span>(mid) * (num + <span class="number">1</span>);</span><br><span class="line">r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="未完待续？"><a href="#未完待续？" class="headerlink" title="未完待续？"></a>未完待续？</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt; 然而我 dp 废的一比&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="笔记" scheme="https://dyd-true.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="优化" scheme="https://dyd-true.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
    <category term="wqs二分" scheme="https://dyd-true.github.io/tags/wqs%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>模板汇总</title>
    <link href="https://dyd-true.github.io/2022/05/29/%E6%A8%A1%E6%9D%BF%E6%B1%87%E6%80%BB/"/>
    <id>https://dyd-true.github.io/2022/05/29/%E6%A8%A1%E6%9D%BF%E6%B1%87%E6%80%BB/</id>
    <published>2022-05-29T02:56:18.000Z</published>
    <updated>2022-06-05T06:36:12.295Z</updated>
    
    <content type="html"><![CDATA[<p> rt</p><span id="more"></span><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>总结一下板子；顺序没有意义；尽量不会压行（但有时候略微压）；限于本人水平，有概率会错；有些东西的运用要视情况而定，会给出类似伪代码的东西，还有些之间用文字给出流程</p><p>关于编译选项，默认是 <code>-O2 -std=c++11 -Wl,--stack=1145141919</code></p><p>关于头文件，默认是万能头 <code>#include &lt;bits/stdc++.h&gt;</code> </p><p>关于宏（包括 <code>using</code> ），默认包含以下宏</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STC static</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> DB = <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> LDB = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="keyword">using</span> PR = std::pair&lt;T1, T2&gt;;</span><br><span class="line"><span class="keyword">using</span> PII = std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">std</span>:</span>:<span class="keyword">size_t</span> num&gt;</span><br><span class="line"><span class="keyword">using</span> AR = std::array&lt;T, num&gt;;</span><br></pre></td></tr></table></figure><p>大部分情况默认数据范围是 <code>int</code> </p><p>大部分情况默认 $P$ 为模数， $INF$ 为正无穷</p><p>如未特殊说明，那些写在外面的语句就是主函数里的</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span> <span class="keyword">int</span> ne, ver, w; &#125; e[M];</span><br><span class="line"><span class="keyword">int</span> h[N], idx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="built_in">memset</span>(h, <span class="number">-1</span>, (n + <span class="number">1</span>) * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)), idx = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>&#123; e[idx] = &#123;h[x], y, z&#125;, h[x] = idx++; &#125;</span><br></pre></td></tr></table></figure><p>使用前要初始化（如何使用： <code>for (int i = h[x]; ~i; i = e[i].ne)</code> ）</p><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">get</span>(fa[x]); &#125; <span class="comment">//路径压缩</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = <span class="built_in">get</span>(x), y = <span class="built_in">get</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (rk[x] &gt; rk[y]) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">    fa[x] = y, rk[y] += rk[x] == rk[y]; <span class="comment">//按秩合并</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>STL （大根堆）： <code>std::priority_queue&lt;int&gt; q;</code> </p><p>手打（小根堆）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Hp <span class="comment">//Heap</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> hp[N], tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">for</span> (; x &gt; <span class="number">1</span> &amp;&amp; hp[x] &lt; hp[x &gt;&gt; <span class="number">1</span>]; x &gt;&gt;= <span class="number">1</span>) std::<span class="built_in">swap</span>(hp[x], hp[x &gt;&gt; <span class="number">1</span>]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dw</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = x &lt;&lt; <span class="number">1</span>; y &lt;= tot; y = x &lt;&lt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (y &lt; tot &amp;&amp; hp[y + <span class="number">1</span>] &lt; hp[y]) ++y;</span><br><span class="line"><span class="keyword">if</span> (hp[y] &lt; hp[x])</span><br><span class="line">&#123;</span><br><span class="line">std::<span class="built_in">swap</span>(hp[y], hp[x]);</span><br><span class="line">x = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; hp[++tot] = x, <span class="built_in">up</span>(tot); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x = <span class="number">1</span>)</span></span>&#123; hp[x] = hp[tot--], <span class="built_in">up</span>(x), <span class="built_in">dw</span>(x); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>左偏树（小根堆）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> LH <span class="comment">//Left Heap</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> fa[N], tot; <span class="comment">//并查集维护根</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> <span class="keyword">int</span> lc, rc, v, dis; &#125; lh[N];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc lh[x].lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc lh[x].rc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> v(x) lh[(x)].v</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ds(x) lh[(x)].dis</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//新建一个只有值x的堆</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">lh[++tot] = &#123;<span class="number">0</span>, <span class="number">0</span>, x, <span class="number">0</span>&#125;;</span><br><span class="line">fa[tot] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> _merge(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">v</span>(x) &gt; <span class="built_in">v</span>(y)) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">rc = _merge(rc, y);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ds</span>(rc) &gt; <span class="built_in">ds</span>(lc)) std::<span class="built_in">swap</span>(rc, lc);</span><br><span class="line"><span class="built_in">ds</span>(x) = <span class="built_in">ds</span>(rc) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">get</span>(fa[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">v</span>(x) == <span class="number">-1</span> || <span class="built_in">v</span>(y) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">x = <span class="built_in">get</span>(x), y = <span class="built_in">get</span>(y);</span><br><span class="line"><span class="keyword">if</span> (x != y) <span class="keyword">return</span> fa[x] = fa[y] = _merge(x, y);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="built_in">v</span>(x) = <span class="number">-1</span>, fa[lc] = lc, fa[rc] = rc, fa[x] = <span class="built_in">merge</span>(lc, rc); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">v</span>(x) == <span class="number">-1</span> ? <span class="number">-1</span> : <span class="built_in">v</span>(<span class="built_in">get</span>(x)); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> v</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> ds</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树状树组"><a href="#树状树组" class="headerlink" title="树状树组"></a>树状树组</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> BIT</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(x) ((x) &amp; (-(x)))</span></span><br><span class="line"><span class="keyword">int</span> c[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span></span>&#123; <span class="keyword">for</span> (; x &lt;= n; x += <span class="built_in">lb</span>(x)) c[x] += d; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; x; x ^= <span class="built_in">lb</span>(x)) res += c[x];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> lb</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意下标必须从 $1$ 开始，否则会死循环</p><h2 id="ST-表"><a href="#ST-表" class="headerlink" title="ST 表"></a>ST 表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> ST</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mx[N][D], lg2[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prev</span><span class="params">(<span class="keyword">int</span> x[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) mx[i][<span class="number">0</span>] = x[i];</span><br><span class="line">lg2[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) lg2[i] = lg2[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> t = lg2[n] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; t; ++j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - (<span class="number">1</span> &lt;&lt; j) + <span class="number">1</span>; ++i) mx[i][j] = std::<span class="built_in">max</span>(mx[i][j - <span class="number">1</span>], mx[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = lg2[r - l + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">max</span>(mx[l][t], mx[r - (<span class="number">1</span> &lt;&lt; t) + <span class="number">1</span>][t]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四毛子"><a href="#四毛子" class="headerlink" title="四毛子"></a>四毛子</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> FR <span class="comment">//Four Russians</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> L = N &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span> <span class="keyword">int</span> lc, rc, dat; &#125; tr[N];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Block</span>&#123;</span> <span class="keyword">int</span> l, r, tp; &#125; b[N];</span><br><span class="line">    <span class="keyword">int</span> dfn[N], bid[L], cnt = <span class="number">0</span>, rt, num = <span class="number">0</span>, B, bk[L];</span><br><span class="line">    PII dat[L];</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">bool</span> <span class="title">cmn</span><span class="params">(T &amp;x, T y)</span></span>&#123; <span class="keyword">return</span> y &lt; x ? x = y, <span class="literal">true</span> : <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="keyword">namespace</span> ST</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> D = <span class="number">18</span>;</span><br><span class="line">        <span class="keyword">int</span> lg2[L];</span><br><span class="line">        PII mn[L][D];</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            lg2[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= num; ++i) lg2[i] = lg2[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++i) mn[i][<span class="number">0</span>] = dat[b[i].l + bk[b[i].tp] - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, t = lg2[num]; j &lt;= t; ++j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num - (<span class="number">1</span> &lt;&lt; j) + <span class="number">1</span>; ++i) mn[i][j] = std::<span class="built_in">min</span>(mn[i][j - <span class="number">1</span>], mn[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">PII <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> &#123;INF, INF&#125;;</span><br><span class="line">            <span class="keyword">int</span> t = lg2[r - l + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">min</span>(mn[l][t], mn[r - (<span class="number">1</span> &lt;&lt; t) + <span class="number">1</span>][t]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> x[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        FF&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>[])&gt; bct = [&amp;](<span class="keyword">int</span> len, <span class="keyword">int</span> x[])</span><br><span class="line">        &#123;</span><br><span class="line">            STC <span class="keyword">int</span> stk[N];</span><br><span class="line">            <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) tr[i].dat = x[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, k; i &lt;= len; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (k = top; k &amp;&amp; tr[stk[k]].dat &lt; tr[i].dat; --k);</span><br><span class="line">                <span class="keyword">if</span> (k) tr[stk[k]].rc = i;</span><br><span class="line">                <span class="keyword">if</span> (k &lt; top) tr[i].lc = stk[k + <span class="number">1</span>];</span><br><span class="line">                stk[top = k + <span class="number">1</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            rt = stk[<span class="number">1</span>];</span><br><span class="line">        &#125; ; </span><br><span class="line">        <span class="built_in">bct</span>(len, x);</span><br><span class="line">        FF&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> dep)</span><br><span class="line">        &#123;</span><br><span class="line">            dfn[x] = ++cnt, dat[cnt] = &#123;dep, x&#125;;</span><br><span class="line">            <span class="keyword">if</span> (tr[x].lc) <span class="built_in">dfs</span>(tr[x].lc, dep + <span class="number">1</span>), dat[++cnt] = &#123;dep, x&#125;;</span><br><span class="line">            <span class="keyword">if</span> (tr[x].rc) <span class="built_in">dfs</span>(tr[x].rc, dep + <span class="number">1</span>), dat[++cnt] = &#123;dep, x&#125;;</span><br><span class="line">        &#125; ;</span><br><span class="line">        <span class="built_in">dfs</span>(rt, <span class="number">1</span>);</span><br><span class="line">        B = <span class="built_in">log2</span>(cnt) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i += B) b[++num].l = i, b[num].r = i + B - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = cnt + <span class="number">1</span>; i &lt;= b[num].r; ++i) dat[i] = &#123;INF, INF&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = b[i].l; j &lt;= b[i].r; ++j) bid[j] = i;</span><br><span class="line">        FF&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>)&gt; calc = [&amp;](<span class="keyword">int</span> x)</span><br><span class="line">        &#123;</span><br><span class="line">            bk[x] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, mn = <span class="number">0</span>, sum = <span class="number">0</span>; i &lt;= B; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ((x &gt;&gt; (i - <span class="number">1</span>)) &amp; <span class="number">1</span>) ++sum;</span><br><span class="line">                <span class="keyword">else</span> --sum;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">cmn</span>(mn, sum)) bk[x] = i; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; ;</span><br><span class="line">        FF&lt;<span class="built_in"><span class="keyword">int</span></span>(Block)&gt; get_tp = [&amp;](Block x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = x.l + <span class="number">1</span>; i &lt;= x.r; ++i) res |= (dat[i].fi - dat[i - <span class="number">1</span>].fi &gt;= <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>) &lt;&lt; (i - x.l);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; ; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="number">1</span> &lt;&lt; B) - <span class="number">1</span>; ~i; --i) <span class="built_in">calc</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++i) b[i].tp = <span class="built_in">get_tp</span>(b[i]);</span><br><span class="line">        ST::<span class="built_in">init</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">PII <span class="title">to_ask</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="built_in">to_ask</span>(r, l);</span><br><span class="line">        FF&lt;<span class="built_in">PII</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; bask = [&amp;](<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span><br><span class="line">        &#123;</span><br><span class="line">            Block &amp;x = b[bid[l]];</span><br><span class="line">            <span class="keyword">int</span> t = x.tp, ll = l - x.l + <span class="number">1</span>, rr = r - x.l + <span class="number">1</span>;</span><br><span class="line">            t &gt;&gt;= ll - <span class="number">1</span>;</span><br><span class="line">            t |= ((<span class="number">1</span> &lt;&lt; (rr - ll + <span class="number">1</span>)) - <span class="number">1</span>) ^ ((<span class="number">1</span> &lt;&lt; B) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> dat[l + bk[t] - <span class="number">1</span>];</span><br><span class="line">        &#125; ;</span><br><span class="line">        <span class="keyword">if</span> (bid[l] == bid[r]) <span class="keyword">return</span> <span class="built_in">bask</span>(l, r); </span><br><span class="line">        PII res = std::<span class="built_in">min</span>(<span class="built_in">bask</span>(l, b[bid[l]].r), <span class="built_in">bask</span>(b[bid[r]].l, r));</span><br><span class="line">        <span class="keyword">if</span> (bid[r] - bid[l] &gt; <span class="number">1</span>) <span class="built_in">cmn</span>(res, ST::<span class="built_in">ask</span>(bid[l] + <span class="number">1</span>, bid[r] - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123; <span class="keyword">return</span> tr[<span class="built_in">to_ask</span>(dfn[l], dfn[r]).se].dat; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> LT</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> ... &#125; tr[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc (u &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc ((u &lt;&lt; 1) | 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adt</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> d)</span></span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dw</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">tg</span>(u))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">adt</span>(lc, <span class="built_in">tg</span>(u)), <span class="built_in">adt</span>(rc, <span class="built_in">tg</span>(u));</span><br><span class="line"><span class="built_in">tg</span>(u) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">(<span class="keyword">int</span> u = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tr[u] = &#123;<span class="number">0</span>, ...&#125;;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line"><span class="built_in">bd</span>(lc, l, mid), <span class="built_in">bd</span>(rc, mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="built_in">up</span>(u); <span class="comment">//有时候可以不要</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cg</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> d, <span class="keyword">int</span> u = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="built_in">adt</span>(u, d);</span><br><span class="line"><span class="built_in">dw</span>(u);</span><br><span class="line">pos &lt;= mid ? <span class="built_in">cg</span>(pos, d, lc, l, mid) : <span class="built_in">cg</span>(pos, d, rc, mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="built_in">up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mdf</span><span class="params">(<span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> d, <span class="keyword">int</span> u = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) <span class="built_in">adt</span>(u, d);</span><br><span class="line"><span class="built_in">dw</span>(u);</span><br><span class="line"><span class="keyword">if</span> (ql &lt;= mid) <span class="built_in">mdf</span>(ql, qr, d, lc, l, mid);</span><br><span class="line"><span class="keyword">if</span> (qr &gt; mid) <span class="built_in">mdf</span>(ql, qr, d, rc, mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="built_in">up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> u = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> ...;</span><br><span class="line"><span class="built_in">dw</span>(u);</span><br><span class="line"><span class="keyword">return</span> pos &lt;= mid ? <span class="built_in">ask</span>(pos, lc, l, mid) : <span class="built_in">ask</span>(pos, rc, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> u = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) <span class="keyword">return</span> ...;</span><br><span class="line"><span class="built_in">dw</span>(u);</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (ql &lt;= mid) res ? <span class="built_in">qry</span>(ql, qr, lc, l, mid); <span class="comment">//?表示某种运算</span></span><br><span class="line"><span class="keyword">if</span> (qr &gt; mid) res ? <span class="built_in">qry</span>(ql, qr, rc, mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> mid</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意空间开 $4$ 倍</p><h2 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">读入</span><br><span class="line">将询问按照(l所在块号，r)双关键字排序</span><br><span class="line">依次处理每一个询问:</span><br><span class="line">移动指针</span><br><span class="line">    维护答案</span><br><span class="line">输出</span><br></pre></td></tr></table></figure><h2 id="莫队二次离线"><a href="#莫队二次离线" class="headerlink" title="莫队二次离线"></a>莫队二次离线</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> TOF <span class="comment">//Twice Offline</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">320</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Tag</span>&#123;</span> <span class="keyword">int</span> l, r, id, pos; &#125; tg1[N], tg2[N]; <span class="comment">//用vector可以不必排序,但慢一些,且有时候不好优化</span></span><br><span class="line">    <span class="keyword">int</span> tp1 = <span class="number">0</span>, tp2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> bid[N], f[<span class="number">2</span>][N]; <span class="comment">//f[0/1][i]:f(i,[1,i-1/i+1])</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prev</span><span class="params">()</span> <span class="comment">//处理块号并排序询问</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) bid[i] = (i - <span class="number">1</span>) / B + <span class="number">1</span>;</span><br><span class="line">        std::<span class="built_in">sort</span>(q + <span class="number">1</span>, q + m + <span class="number">1</span>, [&amp;](Q x, Q y)&#123; <span class="keyword">return</span> bid[x.l] == bid[y.l] ? x.r &lt; y.r : x.l &lt; y.l; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_tag</span><span class="params">()</span> <span class="comment">//打上离线标记</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, il = q[<span class="number">1</span>].r + <span class="number">1</span>, ir = q[<span class="number">1</span>].r; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (il &gt; q[i].l) tg1[++tp1] = &#123;q[i].l, il - <span class="number">1</span>, -i, ir&#125;;</span><br><span class="line">            <span class="keyword">else</span>  <span class="keyword">if</span> (il &lt; q[i].l) tg1[++tp1] = &#123;il, q[i].l - <span class="number">1</span>, i, ir&#125;; </span><br><span class="line">            il = q[i].l; <span class="comment">//一定要记得移动指针</span></span><br><span class="line">            <span class="keyword">if</span> (ir &lt; q[i].r) tg2[++tp2] = &#123;ir + <span class="number">1</span>, q[i].r, -i, il - <span class="number">1</span>&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ir &gt; q[i].r) tg2[++tp2] = &#123;q[i].r + <span class="number">1</span>, ir, i, il - <span class="number">1</span>&#125;;</span><br><span class="line">            ir = q[i].r;</span><br><span class="line">        &#125;</span><br><span class="line">        std::<span class="built_in">sort</span>(tg1 + <span class="number">1</span>, tg1 + tp1 + <span class="number">1</span>, [&amp;](Tag x, Tag y)&#123; <span class="keyword">return</span> x.pos &lt; y.pos; &#125;); <span class="comment">//标记排序</span></span><br><span class="line">        std::<span class="built_in">sort</span>(tg2 + <span class="number">1</span>, tg2 + tp2 + <span class="number">1</span>, [&amp;](Tag x, Tag y)&#123; <span class="keyword">return</span> x.pos &lt; y.pos; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">offline</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tp2; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (p &lt; tg2[i].pos &amp;&amp; ++p)</span><br><span class="line">            &#123;</span><br><span class="line">计算f[<span class="number">0</span>][p]</span><br><span class="line">完成a[p]的修改</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = tg2[i].l, r = tg2[i].r, k = (tg2[i].id &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>), id = tg2[i].id * k; l &lt;= r; ++l) q[id].ans += (计算贡献) * k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p &lt; n &amp;&amp; ++p)</span><br><span class="line">        &#123;</span><br><span class="line">            计算f[<span class="number">0</span>][p]</span><br><span class="line">完成a[p]的修改</span><br><span class="line">        &#125;</span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tp1; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (p &lt; tg1[i].pos &amp;&amp; ++p)</span><br><span class="line">            &#123;</span><br><span class="line">完成a[p]的修改</span><br><span class="line">                计算f[<span class="number">1</span>][p]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = tg1[i].l, r = tg1[i].r, k = (tg1[i].id &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>), id = tg1[i].id * k; l &lt;= r; ++l) q[id].ans += (计算贡献) * k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p &lt; n &amp;&amp; ++p)</span><br><span class="line">        &#123;</span><br><span class="line">            完成a[p]的修改</span><br><span class="line">            计算f[<span class="number">1</span>][p]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modui</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, il = q[<span class="number">1</span>].r + <span class="number">1</span>, ir = q[<span class="number">1</span>].r; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (il != q[i].l) q[i].ans += f[<span class="number">1</span>][il - <span class="number">1</span>] - f[<span class="number">1</span>][q[i].l - <span class="number">1</span>];</span><br><span class="line">            il = q[i].l;</span><br><span class="line">            <span class="keyword">if</span> (ir != q[i].r) q[i].ans += f[<span class="number">0</span>][q[i].r] - f[<span class="number">0</span>][ir];</span><br><span class="line">            ir = q[i].r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) q[i].ans += q[i - <span class="number">1</span>].ans; <span class="comment">//前缀和后才是答案</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) ans[q[i].id] = q[i].ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123; <span class="built_in">prev</span>(), <span class="built_in">add_tag</span>(), <span class="built_in">offline</span>(), <span class="built_in">modui</span>(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h2><p>额……，略</p><h2 id="点分治"><a href="#点分治" class="headerlink" title="点分治"></a>点分治</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_si</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = e[i].ne) <span class="keyword">if</span> (e[i].ver != fa) res += <span class="built_in">get_si</span>(e[i].ver, x);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_wc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> si, <span class="keyword">int</span> &amp;wc)</span> <span class="comment">//求重心(其实是一个保证删去后子树大小小于n/2的点,不一定是重心)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">1</span>, mx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y, t; ~i; i = e[i].ne) <span class="keyword">if</span> ((y = e[i].ver) != fa)</span><br><span class="line">&#123;</span><br><span class="line">t = <span class="built_in">get_wc</span>(y, x, si, wc);</span><br><span class="line">mx = <span class="built_in">max</span>(mx, t);</span><br><span class="line">sum += t;</span><br><span class="line">&#125;</span><br><span class="line">mx = <span class="built_in">max</span>(mx, si - sum);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">LL</span>(mx &lt;&lt; <span class="number">1</span>) &lt;= si) wc = x;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//cp,cq是p[],q[]的计数器</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del[x]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">get_wc</span>(x, <span class="number">-1</span>, <span class="built_in">get_si</span>(x, <span class="number">-1</span>), x);</span><br><span class="line">del[x] = <span class="literal">true</span>;</span><br><span class="line">cp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line">cq = <span class="number">0</span>;</span><br><span class="line">得到y子树的,记录在q[]中</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cq; ++j)</span><br><span class="line">&#123;</span><br><span class="line">利用q[j]计算答案</span><br><span class="line">将q[j]的信息记录在p[]中</span><br><span class="line">&#125;</span><br><span class="line">可能需要修正一些偏差量(比如多算的减掉)</span><br><span class="line">&#125;</span><br><span class="line">用p[]还原q[]计算时的修改</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = e[i].ne) res += <span class="built_in">calc</span>(e[i].ver);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h2><p>STL1 ： <code>std::set&lt;int&gt; s;</code> </p><p>STL2  ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ext/pb_ds/assoc_container.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ext/pb_ds/tree_policy.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_pbds;</span><br><span class="line">tree&lt;LL, null_type, less&lt;LL&gt;, rb_tree_tag,tree_order_statistics_node_update&gt; tr;</span><br><span class="line">函数为:</span><br><span class="line">tr.<span class="built_in">insert</span>(val);</span><br><span class="line">tr.<span class="built_in">erase</span>(tr.<span class="built_in">lower_bound</span>(val));</span><br><span class="line">tr.<span class="built_in">order_of_key</span>(val);</span><br><span class="line">tr.<span class="built_in">find_by_order</span>(rank);</span><br><span class="line">tr.<span class="built_in">lower_bound</span>(val)</span><br><span class="line">tr.<span class="built_in">upper_bound</span>(val)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Splay ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Splay</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> rt, tot;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> <span class="keyword">int</span> ch[<span class="number">2</span>], fa, val, size, tag, cnt; &#125; tr[N];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ch(x, y) tr[(x)].ch[(y)]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fa(x) tr[(x)].fa</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> v(x) tr[(x)].val</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> si(x) tr[(x)].size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> tg(x) tr[(x)].tag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> c(x) tr[(x)].cnt</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="built_in">si</span>(x) = <span class="built_in">si</span>(<span class="built_in">ch</span>(x, <span class="number">0</span>)) + <span class="built_in">si</span>(<span class="built_in">ch</span>(x, <span class="number">1</span>)) + <span class="built_in">c</span>(x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dw</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//文艺平衡树的交换</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">tg</span>(x))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">tg</span>(<span class="built_in">ch</span>(x, <span class="number">0</span>)) ^= <span class="number">1</span>, <span class="built_in">tg</span>(<span class="built_in">ch</span>(x, <span class="number">1</span>)) ^= <span class="number">1</span>;</span><br><span class="line"><span class="built_in">tg</span>(x) = <span class="number">0</span>;</span><br><span class="line">std::<span class="built_in">swap</span>(<span class="built_in">ch</span>(x, <span class="number">0</span>), <span class="built_in">ch</span>(x, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rot</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> y = <span class="built_in">fa</span>(x), z = <span class="built_in">fa</span>(y);</span><br><span class="line"><span class="keyword">int</span> k = <span class="built_in">ch</span>(y, <span class="number">1</span>) == x;</span><br><span class="line"><span class="built_in">ch</span>(z, <span class="built_in">ch</span>(z, <span class="number">1</span>) == y) = x, <span class="built_in">fa</span>(x) = z;</span><br><span class="line"><span class="built_in">ch</span>(y, k) = <span class="built_in">ch</span>(x, k ^ <span class="number">1</span>), <span class="built_in">fa</span>(<span class="built_in">ch</span>(x, k ^ <span class="number">1</span>)) = y;</span><br><span class="line"><span class="built_in">ch</span>(x, k ^ <span class="number">1</span>) = y, <span class="built_in">fa</span>(y) = x;</span><br><span class="line"><span class="built_in">up</span>(y), <span class="built_in">up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">fa</span>(x) != f)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> y = <span class="built_in">fa</span>(x), z = <span class="built_in">fa</span>(y);</span><br><span class="line"><span class="keyword">if</span> (z != f) (<span class="built_in">ch</span>(y, <span class="number">1</span>) == x) ^ (<span class="built_in">ch</span>(z, <span class="number">1</span>) == y) ? <span class="built_in">rot</span>(x) : <span class="built_in">rot</span>(y);</span><br><span class="line"><span class="built_in">rot</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!f) rt = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> u = rt;</span><br><span class="line"><span class="keyword">if</span> (!u) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">while</span> (x != <span class="built_in">v</span>(u) &amp;&amp; <span class="built_in">ch</span>(u, x &gt; <span class="built_in">v</span>(u)) ) u = <span class="built_in">ch</span>(u, x &gt; <span class="built_in">v</span>(u));</span><br><span class="line"><span class="built_in">splay</span>(u, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">near</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> dir)</span> <span class="comment">//查询前驱(0)后继(1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">find</span>(x);</span><br><span class="line"><span class="keyword">int</span> u = rt;</span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">v</span>(u) &gt; x &amp;&amp; dir) || (<span class="built_in">v</span>(u) &lt; x &amp;&amp; !dir)) <span class="keyword">return</span> u;</span><br><span class="line">u = <span class="built_in">ch</span>(u, dir);</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">ch</span>(u, dir ^ <span class="number">1</span>)) u = <span class="built_in">ch</span>(u, dir ^ <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> last = <span class="built_in">near</span>(x, <span class="number">0</span>), next = <span class="built_in">near</span>(x, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">splay</span>(last, <span class="number">0</span>), <span class="built_in">splay</span>(next, last);</span><br><span class="line"><span class="keyword">int</span> t = <span class="built_in">ch</span>(next, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">c</span>(t) &gt; <span class="number">1</span>) --<span class="built_in">c</span>(t), <span class="built_in">splay</span>(t, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">ch</span>(next, <span class="number">0</span>) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> u = rt, f = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (u &amp;&amp; <span class="built_in">v</span>(u) != x) f = u, u = <span class="built_in">ch</span>(u, x &gt; <span class="built_in">v</span>(u));</span><br><span class="line"><span class="keyword">if</span> (u) ++<span class="built_in">c</span>(u);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">u = ++tot;</span><br><span class="line"><span class="keyword">if</span> (f) <span class="built_in">ch</span>(f, x &gt; <span class="built_in">v</span>(f)) = u;</span><br><span class="line">tr[u] = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, f, x, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">splay</span>(u, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_k</span><span class="params">(<span class="keyword">int</span> k)</span> <span class="comment">//查询排名为k的数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> u = rt;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">si</span>(u) &lt; k) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">dw</span>(u);</span><br><span class="line"><span class="keyword">int</span> y = <span class="built_in">ch</span>(u, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (k &gt; <span class="built_in">si</span>(y) + <span class="built_in">c</span>(u)) k -= <span class="built_in">si</span>(y) + <span class="built_in">c</span>(u), u = <span class="built_in">ch</span>(u, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">si</span>(y) &gt;= k) u = y;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">v</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> ch</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> fa</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> v</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> si</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> tg</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点是可拓展性强，缺点是慢（被卡的化可以试试多转几下）</p><p>FHQ Treap ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> FHQ</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> <span class="keyword">int</span> priority, size, val, left_child, right_child; &#125; tr[N];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> p(x) tr[(x)].priority</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> si(x) tr[(x)].size</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> v(x) tr[(x)].val</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc(x) tr[(x)].left_child</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc(x) tr[(x)].right_child</span></span><br><span class="line">    <span class="keyword">int</span> rub[N], top = <span class="number">0</span>, num = <span class="number">0</span>, rt;</span><br><span class="line">    <span class="function">std::mt19937 <span class="title">rud</span><span class="params">(<span class="number">114514</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="built_in">si</span>(x) = <span class="built_in">si</span>(<span class="built_in">lc</span>(x)) + <span class="built_in">si</span>(<span class="built_in">rc</span>(x)) + <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnd</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = (top ? rub[top--] : ++num);</span><br><span class="line">        tr[res] = &#123;(<span class="keyword">int</span>)<span class="built_in">rud</span>(), <span class="number">1</span>, val, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">//合并以x,y为根的树,返回合并后的根(要保证x的val都小于y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">p</span>(x) &gt; <span class="built_in">p</span>(y))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">rc</span>(x) = <span class="built_in">merge</span>(<span class="built_in">rc</span>(x), y);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">up</span>(x), x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">lc</span>(y) = <span class="built_in">merge</span>(x, <span class="built_in">lc</span>(y));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">up</span>(y), y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> val, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span> <span class="comment">//把以u为根的树分裂为x,y</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!u) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(x = y = <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">v</span>(u) &lt;= val) <span class="built_in">split</span>(<span class="built_in">rc</span>(x = u), val, <span class="built_in">rc</span>(u), y);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">split</span>(<span class="built_in">lc</span>(y = u), val, x, <span class="built_in">lc</span>(u));</span><br><span class="line">        <span class="built_in">up</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tx, ty;</span><br><span class="line">        <span class="built_in">split</span>(rt, val, tx, ty), rt = <span class="built_in">merge</span>(<span class="built_in">merge</span>(tx, <span class="built_in">newnd</span>(val)), ty);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tx, ty, tz;</span><br><span class="line">        <span class="built_in">split</span>(rt, val, tx, ty);</span><br><span class="line">        <span class="built_in">split</span>(tx, val - <span class="number">1</span>, tx, tz);</span><br><span class="line">        rub[++top] = tz;</span><br><span class="line">        tz = <span class="built_in">merge</span>(<span class="built_in">lc</span>(tz), <span class="built_in">rc</span>(tz));</span><br><span class="line">        rt = <span class="built_in">merge</span>(<span class="built_in">merge</span>(tx, tz), ty);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rank</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tx, ty, res;</span><br><span class="line">        <span class="built_in">split</span>(rt, val - <span class="number">1</span>, tx, ty);</span><br><span class="line">        res = <span class="built_in">si</span>(tx) + <span class="number">1</span>;</span><br><span class="line">        rt = <span class="built_in">merge</span>(tx, ty);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getk</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t; u; )</span><br><span class="line">            <span class="keyword">if</span> ((t = <span class="built_in">si</span>(<span class="built_in">lc</span>(u)) + <span class="number">1</span>) == k) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t &gt; k) u = <span class="built_in">lc</span>(u);</span><br><span class="line">            <span class="keyword">else</span> k -= t, u = <span class="built_in">rc</span>(u);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">v</span>(u); <span class="comment">//可视题目改</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getk</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">getk</span>(rt, k); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tx, ty, res;</span><br><span class="line">        <span class="built_in">split</span>(rt, val - <span class="number">1</span>, tx, ty);</span><br><span class="line">        res = <span class="built_in">getk</span>(tx, <span class="built_in">si</span>(tx));</span><br><span class="line">        rt = <span class="built_in">merge</span>(tx, ty);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">suc</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tx, ty, res;</span><br><span class="line">        <span class="built_in">split</span>(rt, val, tx, ty);</span><br><span class="line">        res = <span class="built_in">getk</span>(ty, <span class="number">1</span>);</span><br><span class="line">        rt = <span class="built_in">merge</span>(tx, ty);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> p</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> si</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> v</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点是好打且较快</p><p>SBT ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> SBT</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SBT</span>&#123;</span> <span class="keyword">int</span> size, lc, rc, val; &#125; tr[N];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> si(x) tr[(x)].size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc(x) tr[(x)].rc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc(x) tr[(x)].lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> v(x) tr[(x)].val</span></span><br><span class="line"><span class="keyword">int</span> rt, tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r_r</span><span class="params">(<span class="keyword">int</span> &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = <span class="built_in">lc</span>(t);</span><br><span class="line"><span class="built_in">lc</span>(t) = <span class="built_in">rc</span>(k), <span class="built_in">rc</span>(k) = t;</span><br><span class="line"><span class="built_in">si</span>(k) = <span class="built_in">si</span>(t), <span class="built_in">si</span>(t) = <span class="built_in">si</span>(<span class="built_in">rc</span>(t)) + <span class="built_in">si</span>(<span class="built_in">lc</span>(t)) + <span class="number">1</span>;</span><br><span class="line">t = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">l_r</span><span class="params">(<span class="keyword">int</span> &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = <span class="built_in">rc</span>(t);</span><br><span class="line"><span class="built_in">rc</span>(t) = <span class="built_in">lc</span>(k), <span class="built_in">lc</span>(k) = t;</span><br><span class="line"><span class="built_in">si</span>(k) = <span class="built_in">si</span>(t), <span class="built_in">si</span>(t) = <span class="built_in">si</span>(<span class="built_in">rc</span>(t)) + <span class="built_in">si</span>(<span class="built_in">lc</span>(t)) + <span class="number">1</span>;</span><br><span class="line">t = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mt</span><span class="params">(<span class="keyword">int</span> &amp;t, <span class="keyword">bool</span> f)</span> <span class="comment">//maintain</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!f)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">si</span>(<span class="built_in">lc</span>(<span class="built_in">lc</span>(t))) &gt; <span class="built_in">si</span>(<span class="built_in">rc</span>(t))) <span class="built_in">r_r</span>(t);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">si</span>(<span class="built_in">rc</span>(<span class="built_in">lc</span>(t))) &gt; <span class="built_in">si</span>(<span class="built_in">rc</span>(t))) <span class="built_in">l_r</span>(<span class="built_in">lc</span>(t)), <span class="built_in">r_r</span>(t);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">si</span>(<span class="built_in">rc</span>(<span class="built_in">rc</span>(t))) &gt; <span class="built_in">si</span>(<span class="built_in">lc</span>(t))) <span class="built_in">l_r</span>(t);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">si</span>(<span class="built_in">lc</span>(<span class="built_in">rc</span>(t))) &gt; <span class="built_in">si</span>(<span class="built_in">lc</span>(t))) <span class="built_in">r_r</span>(<span class="built_in">rc</span>(t)), <span class="built_in">l_r</span>(t);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">mt</span>(<span class="built_in">lc</span>(t), <span class="literal">false</span>), <span class="built_in">mt</span>(<span class="built_in">rc</span>(t), <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">mt</span>(t, <span class="literal">false</span>), <span class="built_in">mt</span>(t, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> &amp;t, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!t) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(tr[t = ++tot] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, x&#125;);</span><br><span class="line">++<span class="built_in">si</span>(t);</span><br><span class="line">x &lt;= <span class="built_in">v</span>(t) ? <span class="built_in">ins</span>(<span class="built_in">lc</span>(t), x) : <span class="built_in">ins</span>(<span class="built_in">rc</span>(t), x);</span><br><span class="line"><span class="built_in">mt</span>(t, x &gt; <span class="built_in">v</span>(t));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> &amp;t, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">--<span class="built_in">si</span>(t);</span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">v</span>(t) == x) || (<span class="built_in">v</span>(t) &gt; x &amp;&amp; !<span class="built_in">lc</span>(t)) || (<span class="built_in">v</span>(t) &lt; x &amp;&amp; !<span class="built_in">rc</span>(t)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="built_in">v</span>(t);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">lc</span>(t) || !<span class="built_in">rc</span>(t)) t = <span class="built_in">lc</span>(t) + <span class="built_in">rc</span>(t);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">v</span>(t) = <span class="built_in">del</span>(<span class="built_in">lc</span>(t), <span class="built_in">v</span>(t) + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">v</span>(t) &gt; x ? <span class="built_in">del</span>(<span class="built_in">lc</span>(t), x) : <span class="built_in">del</span>(<span class="built_in">rc</span>(t), x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rk</span><span class="params">(<span class="keyword">int</span> &amp;t, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">v</span>(t) &gt;= x ? <span class="built_in">rk</span>(<span class="built_in">lc</span>(t), x) : <span class="built_in">si</span>(<span class="built_in">lc</span>(t)) + <span class="number">1</span> + <span class="built_in">rk</span>(<span class="built_in">rc</span>(t), x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_k</span><span class="params">(<span class="keyword">int</span> &amp;t, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="built_in">si</span>(<span class="built_in">lc</span>(t)) + <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">v</span>(t);</span><br><span class="line"><span class="keyword">return</span> x &lt;= <span class="built_in">si</span>(<span class="built_in">lc</span>(t)) ? <span class="built_in">get_k</span>(<span class="built_in">lc</span>(t), x) : <span class="built_in">get_k</span>(<span class="built_in">rc</span>(t), x - <span class="number">1</span> - <span class="built_in">si</span>(<span class="built_in">lc</span>(t)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pred</span><span class="params">(<span class="keyword">int</span> &amp;t, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!t) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">if</span> (x &lt;= <span class="built_in">v</span>(t)) <span class="keyword">return</span> <span class="built_in">pred</span>(<span class="built_in">lc</span>(t), x);</span><br><span class="line"><span class="keyword">int</span> res = <span class="built_in">pred</span>(<span class="built_in">rc</span>(t), x);</span><br><span class="line"><span class="keyword">if</span> (res == x) res = <span class="built_in">v</span>(t);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">succ</span><span class="params">(<span class="keyword">int</span> &amp;t, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!t) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= <span class="built_in">v</span>(t)) <span class="keyword">return</span> <span class="built_in">succ</span>(<span class="built_in">rc</span>(t), x);</span><br><span class="line"><span class="keyword">int</span> res = <span class="built_in">succ</span>(<span class="built_in">lc</span>(t), x);</span><br><span class="line"><span class="keyword">if</span> (res == x) res = <span class="built_in">v</span>(t);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> si</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> v</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点是快</p><h2 id="CDQ-分治"><a href="#CDQ-分治" class="headerlink" title="CDQ 分治"></a>CDQ 分治</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdq</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cdq</span>(l, mid);</span><br><span class="line">    计算[l, mid]对[mid + <span class="number">1</span>, r]的影响/计算跨过mid的贡献</span><br><span class="line">    <span class="built_in">cdq</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个顺序不是严格的，可以先左右都递归了再计算中间</p><h2 id="李超线段树"><a href="#李超线段树" class="headerlink" title="李超线段树"></a>李超线段树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> k; LL b;</span><br><span class="line">    <span class="function">LL <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> dis[bid[x]] * k + b; &#125;</span><br><span class="line">&#125; li[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">namespace</span> LC</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> std::max;</span><br><span class="line">    <span class="keyword">using</span> std::min;</span><br><span class="line">    <span class="keyword">int</span> id[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    LL mn[N &lt;&lt; <span class="number">4</span>];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mid (l + r &gt;&gt; 1)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc (u &lt;&lt; 1)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc (u &lt;&lt; 1 | 1)</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> li[a].<span class="built_in">calc</span>(x) &gt; li[b].<span class="built_in">calc</span>(x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mn[u] = <span class="built_in">min</span>(mn[u], <span class="built_in">min</span>(li[id[u]].<span class="built_in">calc</span>(l), li[id[u]].<span class="built_in">calc</span>(r)));</span><br><span class="line">mn[u] = <span class="built_in">min</span>(mn[u], <span class="built_in">min</span>(mn[lc], mn[rc])); </span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">judge</span>(id[u], d, mid)) std::<span class="built_in">swap</span>(id[u], d);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">judge</span>(id[u], d, l)) <span class="built_in">upd</span>(lc, l, mid, ql, qr, d);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">judge</span>(id[u], d, r)) <span class="built_in">upd</span>(rc, mid + <span class="number">1</span>, r, ql, qr, d);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">up</span>(u, l, r); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= mid) <span class="built_in">upd</span>(lc, l, mid, ql, qr, d);</span><br><span class="line">        <span class="keyword">if</span> (qr &gt; mid) <span class="built_in">upd</span>(rc, mid + <span class="number">1</span>, r, ql, qr, d);</span><br><span class="line">        <span class="built_in">up</span>(u, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">LL <span class="title">ask</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) <span class="keyword">return</span> mn[u];</span><br><span class="line">        LL res = <span class="built_in">min</span>(li[id[u]].<span class="built_in">calc</span>(<span class="built_in">max</span>(l, ql)), li[id[u]].<span class="built_in">calc</span>(<span class="built_in">min</span>(r, qr)));</span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= mid) res = <span class="built_in">min</span>(res, <span class="built_in">ask</span>(lc, l, mid, ql, qr));</span><br><span class="line">        <span class="keyword">if</span> (qr &gt; mid) res = <span class="built_in">min</span>(res, <span class="built_in">ask</span>(rc, mid + <span class="number">1</span>, r, ql, qr));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> mid</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主席树"><a href="#主席树" class="headerlink" title="主席树"></a>主席树</h2><p>普通：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> CT <span class="comment">//Chairman Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> NN = <span class="number">5e6</span> + <span class="number">100</span>; <span class="comment">//点一定要开够</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> <span class="keyword">int</span> lc, rc, dat; &#125; tr[NN];</span><br><span class="line">    <span class="keyword">int</span> rt[N], tot = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc(x) tr[(x)].lc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc(x) tr[(x)].rc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> dat(x) tr[(x)].dat</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">(<span class="keyword">int</span> &amp;u, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        u = ++tot;</span><br><span class="line">        tr[u] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) <span class="built_in">bd</span>(<span class="built_in">lc</span>(u), l, mid), <span class="built_in">bd</span>(<span class="built_in">rc</span>(u), mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cg</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> d, <span class="keyword">int</span> &amp;u, <span class="keyword">int</span> la, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        u = ++tot;</span><br><span class="line">        tr[u] = tr[la];</span><br><span class="line">        <span class="built_in">dat</span>(u) += d;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line">        (pos &lt;= mid) ? <span class="built_in">cg</span>(pos, d, <span class="built_in">lc</span>(u), <span class="built_in">lc</span>(la), l, mid) : <span class="built_in">cg</span>(pos, d, <span class="built_in">rc</span>(u), <span class="built_in">rc</span>(la), mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> ul, <span class="keyword">int</span> ur, <span class="keyword">int</span> k, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="built_in">dat</span>(<span class="built_in">lc</span>(ur)) - <span class="built_in">dat</span>(<span class="built_in">lc</span>(ul));</span><br><span class="line">        <span class="keyword">return</span> (t &gt;= k) ? <span class="built_in">ask</span>(<span class="built_in">lc</span>(ul), <span class="built_in">lc</span>(ur), k, l, mid) : <span class="built_in">ask</span>(<span class="built_in">rc</span>(ul), <span class="built_in">rc</span>(ur), k - t, mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> dat</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> mid </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>带修：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> BIT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> NN = <span class="number">6e7</span> + <span class="number">100</span>, D = <span class="number">20</span>; <span class="comment">//任然是空间要开够</span></span><br><span class="line">    <span class="keyword">int</span> rts[<span class="number">2</span>][D];</span><br><span class="line">    <span class="keyword">namespace</span> CT</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> <span class="keyword">int</span> lc, rc, cnt; &#125; tr[NN];</span><br><span class="line">        <span class="keyword">int</span> rt[N], tot = <span class="number">0</span>;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> lc(x) tr[(x)].lc</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> rc(x) tr[(x)].rc</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> ct(x) tr[(x)].cnt</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">cg</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> d, <span class="keyword">int</span> &amp;u, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = num)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!u) u = ++tot;</span><br><span class="line">            <span class="built_in">ct</span>(u) += d;</span><br><span class="line">            <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line">            (pos &lt;= mid) ? <span class="built_in">cg</span>(pos, d, <span class="built_in">lc</span>(u), l, mid) : <span class="built_in">cg</span>(pos, d, <span class="built_in">rc</span>(u), mid + <span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = num)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = rts[<span class="number">1</span>][<span class="number">0</span>]; i; --i) sum += <span class="built_in">ct</span>(<span class="built_in">lc</span>(rts[<span class="number">1</span>][i]));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = rts[<span class="number">0</span>][<span class="number">0</span>]; i; --i) sum -= <span class="built_in">ct</span>(<span class="built_in">lc</span>(rts[<span class="number">0</span>][i]));</span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = rts[<span class="number">1</span>][<span class="number">0</span>]; i; --i) rts[<span class="number">1</span>][i] = <span class="built_in">lc</span>(rts[<span class="number">1</span>][i]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = rts[<span class="number">0</span>][<span class="number">0</span>]; i; --i) rts[<span class="number">0</span>][i] = <span class="built_in">lc</span>(rts[<span class="number">0</span>][i]);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">ask</span>(k, l, mid);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = rts[<span class="number">1</span>][<span class="number">0</span>]; i; --i) rts[<span class="number">1</span>][i] = <span class="built_in">rc</span>(rts[<span class="number">1</span>][i]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = rts[<span class="number">0</span>][<span class="number">0</span>]; i; --i) rts[<span class="number">0</span>][i] = <span class="built_in">rc</span>(rts[<span class="number">0</span>][i]);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">ask</span>(k - sum, mid + <span class="number">1</span>, r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">undef</span> ct</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">undef</span> mid</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">using</span> CT::rt;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lb(x) ((x) &amp; (-(x)))</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cg</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span></span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += <span class="built_in">lb</span>(i)) CT::<span class="built_in">cg</span>(a[x], d, rt[i]); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        rts[<span class="number">0</span>][<span class="number">0</span>] = rts[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i; i ^= <span class="built_in">lb</span>(i)) rts[<span class="number">1</span>][++rts[<span class="number">1</span>][<span class="number">0</span>]] = rt[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l - <span class="number">1</span>; i; i ^= <span class="built_in">lb</span>(i)) rts[<span class="number">0</span>][++rts[<span class="number">0</span>][<span class="number">0</span>]] = rt[i];</span><br><span class="line">        <span class="keyword">return</span> CT::<span class="built_in">ask</span>(k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> lb</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="K-D-Tree"><a href="#K-D-Tree" class="headerlink" title="K-D Tree"></a>K-D Tree</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span> <span class="keyword">int</span> x[D], w; &#125;;</span><br><span class="line"><span class="keyword">namespace</span> KDT <span class="comment">//K-D Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> DB a = <span class="number">0.725</span>;</span><br><span class="line">    <span class="keyword">int</span> rt, top, rub[M], cur, tot; <span class="comment">//rub:回收空间</span></span><br><span class="line">    Point p[M];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> mn[D], mx[D], sum, lc, rc, si, k;</span><br><span class="line">        Point p;</span><br><span class="line">    &#125; tr[M];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mn(x) tr[(x)].mn</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mx(x) tr[(x)].mx</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sum(x) tr[(x)].sum</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc(x) tr[(x)].lc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc(x) tr[(x)].rc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> si(x) tr[(x)].si</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> k(x) tr[(x)].k</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> p(x) tr[(x)].p</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> top ? rub[top--] : ++cur; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ls = <span class="built_in">lc</span>(u), rs = <span class="built_in">rc</span>(u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; D; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">mn</span>(u)[i] = <span class="built_in">mx</span>(u)[i] = <span class="built_in">p</span>(u).x[i];</span><br><span class="line">            <span class="keyword">if</span> (ls) <span class="built_in">mn</span>(u)[i] = <span class="built_in">min</span>(<span class="built_in">mn</span>(u)[i], <span class="built_in">mn</span>(ls)[i]), <span class="built_in">mx</span>(u)[i] = <span class="built_in">max</span>(<span class="built_in">mx</span>(u)[i], <span class="built_in">mx</span>(ls)[i]);</span><br><span class="line">            <span class="keyword">if</span> (rs) <span class="built_in">mn</span>(u)[i] = <span class="built_in">min</span>(<span class="built_in">mn</span>(u)[i], <span class="built_in">mn</span>(rs)[i]), <span class="built_in">mx</span>(u)[i] = <span class="built_in">max</span>(<span class="built_in">mx</span>(u)[i], <span class="built_in">mx</span>(rs)[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sum</span>(u) = <span class="built_in">sum</span>(ls) + <span class="built_in">sum</span>(rs) + <span class="built_in">p</span>(u).w, <span class="built_in">si</span>(u) = <span class="built_in">si</span>(ls) + <span class="built_in">si</span>(rs) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>, u = <span class="built_in">newnode</span>();</span><br><span class="line">        <span class="built_in">nth_element</span>(p + l, p + mid, p + r + <span class="number">1</span>, [&amp;](Point a, Point b)&#123; <span class="keyword">return</span> a.x[k] &lt; b.x[k]; &#125;);</span><br><span class="line">        <span class="built_in">k</span>(u) = k, <span class="built_in">p</span>(u) = p[mid], <span class="built_in">lc</span>(u) = <span class="built_in">build</span>(l, mid - <span class="number">1</span>, k ^ <span class="number">1</span>), <span class="built_in">rc</span>(u) = <span class="built_in">build</span>(mid + <span class="number">1</span>, r, k ^ <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">up</span>(u), u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get_p</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123; <span class="keyword">if</span> (u) <span class="built_in">get_p</span>(<span class="built_in">lc</span>(u)), p[++tot] = <span class="built_in">p</span>(u), rub[++top] = u, <span class="built_in">get_p</span>(<span class="built_in">rc</span>(u)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> &amp;u)</span></span>&#123; <span class="keyword">if</span> (<span class="built_in">si</span>(u) * a &lt; <span class="built_in">max</span>(<span class="built_in">si</span>(<span class="built_in">lc</span>(u)), <span class="built_in">si</span>(<span class="built_in">rc</span>(u)))) tot = <span class="number">0</span>, <span class="built_in">get_p</span>(u), u = <span class="built_in">build</span>(<span class="number">1</span>, tot, <span class="built_in">k</span>(u)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> &amp;u, Point x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!u)</span><br><span class="line">        &#123;</span><br><span class="line">            u = <span class="built_in">newnode</span>();</span><br><span class="line">            <span class="built_in">lc</span>(u) = <span class="built_in">rc</span>(u) = <span class="built_in">k</span>(u) = <span class="number">0</span>, <span class="built_in">p</span>(u) = x;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">up</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x.x[<span class="built_in">k</span>(u)] &lt;= <span class="built_in">p</span>(u).x[<span class="built_in">k</span>(u)]) <span class="built_in">ins</span>(<span class="built_in">lc</span>(u), x);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">ins</span>(<span class="built_in">rc</span>(u), x);</span><br><span class="line">        <span class="built_in">up</span>(u), <span class="built_in">chk</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> mx[D], <span class="keyword">int</span> mn[D], <span class="keyword">int</span> l[D], <span class="keyword">int</span> r[D])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; D; ++i) <span class="keyword">if</span> (r[i] &lt; mx[i] || l[i] &gt; mn[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">out</span><span class="params">(<span class="keyword">int</span> mx[D], <span class="keyword">int</span> mn[D], <span class="keyword">int</span> l[D], <span class="keyword">int</span> r[D])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; D; ++i) <span class="keyword">if</span> (l[i] &gt; mx[i] || r[i] &lt; mn[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l[D], <span class="keyword">int</span> r[D])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!u || <span class="built_in">out</span>(<span class="built_in">mx</span>(u), <span class="built_in">mn</span>(u), l, r)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">in</span>(<span class="built_in">mx</span>(u), <span class="built_in">mn</span>(u), l, r)) <span class="keyword">return</span> <span class="built_in">sum</span>(u);</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">in</span>(<span class="built_in">p</span>(u).x, <span class="built_in">p</span>(u).x, l, r) ? <span class="built_in">p</span>(u).w : <span class="number">0</span>) + <span class="built_in">ask</span>(<span class="built_in">lc</span>(u), l, r) + <span class="built_in">ask</span>(<span class="built_in">rc</span>(u), l, r);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> mn</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> mx</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> si</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> k</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> p</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="笛卡尔树"><a href="#笛卡尔树" class="headerlink" title="笛卡尔树"></a>笛卡尔树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) tr[i].dat = a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, k; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">k = top;</span><br><span class="line"><span class="comment">//找到最下面的一个比当前小的,满足小根堆</span></span><br><span class="line"><span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; tr[stk[k]].dat &gt; tr[i].dat) --k;</span><br><span class="line"><span class="keyword">if</span> (k) tr[stk[k]].rc = i;</span><br><span class="line"><span class="keyword">if</span> (k &lt; top) tr[i].lc = stk[k + <span class="number">1</span>];</span><br><span class="line">top = k;</span><br><span class="line">stk[++top] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>二叉：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">建立小根堆q,把所有点放入</span><br><span class="line"><span class="keyword">while</span> (堆中元素个数 &gt;= <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">int</span> y = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">    ans += x + y;</span><br><span class="line">    q.<span class="built_in">push</span>(x + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多叉：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">用权值为<span class="number">0</span>的点补足点数,使(n - <span class="number">1</span>) % (k - <span class="number">1</span>) == <span class="number">0</span></span><br><span class="line">建立小根堆q,把所有点放入</span><br><span class="line"><span class="keyword">while</span> (堆中元素个数 &gt;= k)</span><br><span class="line">&#123;</span><br><span class="line">    取出前k个元素</span><br><span class="line">    ans += 前k个元素和;</span><br><span class="line">    q.<span class="built_in">push</span>(前k个元素和);</span><br><span class="line">&#125;</span><br><span class="line">把堆中剩下元素取出,计算贡献</span><br></pre></td></tr></table></figure><h2 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> father, <span class="keyword">int</span> depth)</span> <span class="comment">//求每个的重儿子</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dep[x] = depth, fa[x] = father, si[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne) <span class="keyword">if</span> ((y = e[i].ver) != father)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">dfs1</span>(y, x, depth + <span class="number">1</span>);</span><br><span class="line">si[x] += si[y];</span><br><span class="line"><span class="keyword">if</span> (si[son[x]] &lt; si[y]) son[x] = y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> t)</span> <span class="comment">//求dfs序,t:当前节点所在重链的顶点</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">id[x] = ++cnt, nw[cnt] = w[x], top[x] = t;</span><br><span class="line"><span class="keyword">if</span> (!son[x]) <span class="keyword">return</span>; <span class="comment">//若是叶节点,直接返回</span></span><br><span class="line"><span class="built_in">dfs2</span>(son[x], t);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (y == fa[x] || y == son[x]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(y, y); <span class="comment">//轻儿子一定是其所在重链的顶点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">path</span><span class="params">(<span class="keyword">int</span> )</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> <span class="comment">//路径操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (top[u] != top[v]) <span class="comment">//当这两个点不在同一重链</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">if</span> (dep[top[u]] &lt; dep[top[v]]) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line"><span class="built_in">work</span>(id[top[u]], id[u]); <span class="comment">//注意在dfs序中top[u]在u前面</span></span><br><span class="line">u = fa[top[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dep[u] &lt; dep[v]) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line"><span class="built_in">work</span>(id[v], id[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123; <span class="built_in">work</span>(id[u], id[u] + si[u] - <span class="number">1</span>); &#125; <span class="comment">//子树操作</span></span><br></pre></td></tr></table></figure><h2 id="动态树"><a href="#动态树" class="headerlink" title="动态树"></a>动态树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> LCT</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> stk[N]; <span class="comment">//中间要用的栈</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node_of_Slpay</span>&#123;</span> <span class="keyword">int</span> ch[<span class="number">2</span>], fa, v, sum, rev; &#125; tr[N];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ch(x, y) tr[(x)].ch[(y)]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fa(x) tr[(x)].fa</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> v(x) tr[(x)].v</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) tr[(x)].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rev(x) tr[(x)].rev</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adt</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="built_in">swap</span>(<span class="built_in">ch</span>(x, <span class="number">0</span>),<span class="built_in">ch</span>(x, <span class="number">1</span>)), <span class="built_in">rev</span>(x) ^= <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="built_in">sum</span>(x) = <span class="built_in">sum</span>(<span class="built_in">ch</span>(x, <span class="number">0</span>)) ^ <span class="built_in">sum</span>(<span class="built_in">ch</span>(x, <span class="number">1</span>)) ^ <span class="built_in">v</span>(x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dw</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">rev</span>(x))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">adt</span>(<span class="built_in">ch</span>(x, <span class="number">0</span>)), <span class="built_in">adt</span>(<span class="built_in">ch</span>(x, <span class="number">1</span>));</span><br><span class="line"><span class="built_in">rev</span>(x) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_rt</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">ch</span>(<span class="built_in">fa</span>(x), <span class="number">0</span>) != x &amp;&amp; <span class="built_in">ch</span>(<span class="built_in">fa</span>(x), <span class="number">1</span>) != x; &#125; <span class="comment">//判断x是否是所在splay的根</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rot</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> y = <span class="built_in">fa</span>(x), z = <span class="built_in">fa</span>(y);</span><br><span class="line"><span class="keyword">int</span> k = <span class="built_in">ch</span>(y, <span class="number">1</span>) == x;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">is_rt</span>(y)) <span class="built_in">ch</span>(z, <span class="built_in">ch</span>(z, <span class="number">1</span>) == y) = x;</span><br><span class="line"><span class="built_in">fa</span>(x) = z;</span><br><span class="line"><span class="built_in">ch</span>(y, k) = <span class="built_in">ch</span>(x, k ^ <span class="number">1</span>), <span class="built_in">fa</span>(<span class="built_in">ch</span>(x, k ^ <span class="number">1</span>)) = y;</span><br><span class="line"><span class="built_in">ch</span>(x, k ^ <span class="number">1</span>) = y, <span class="built_in">fa</span>(y) = x;</span><br><span class="line"><span class="built_in">up</span>(y), <span class="built_in">up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>, t = x, y, z;</span><br><span class="line">stk[++top] = t;</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">is_rt</span>(t)) stk[++top] = t = <span class="built_in">fa</span>(t);</span><br><span class="line"><span class="keyword">while</span> (top) <span class="built_in">dw</span>(stk[top--]);</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">is_rt</span>(x))</span><br><span class="line">&#123;</span><br><span class="line">y = <span class="built_in">fa</span>(x), z = <span class="built_in">fa</span>(y);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">is_rt</span>(y)) (<span class="built_in">ch</span>(y, <span class="number">1</span>) == x) ^ (<span class="built_in">ch</span>(z, <span class="number">1</span>) == y) ? <span class="built_in">rot</span>(x) : <span class="built_in">rot</span>(y);</span><br><span class="line"><span class="built_in">rot</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//将根到x之间的路径变成实边</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> z = x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; x; y = x, x = <span class="built_in">fa</span>(x))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">splay</span>(x);</span><br><span class="line"><span class="built_in">ch</span>(x, <span class="number">1</span>) = y;</span><br><span class="line"><span class="built_in">up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">splay</span>(z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_rt</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="built_in">access</span>(x), <span class="built_in">adt</span>(x); &#125; <span class="comment">//将x变成树根</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_rt</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//找到x所在树的根并将其转到splay的根节点上</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">access</span>(x);</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">ch</span>(x, <span class="number">0</span>)) <span class="built_in">dw</span>(x), x = <span class="built_in">ch</span>(x, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">splay</span>(x);</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="built_in">make_rt</span>(x), <span class="built_in">access</span>(y); &#125; <span class="comment">//将x到y的路径变成实边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">//加边(x, y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">make_rt</span>(x);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">find_rt</span>(y) != x) <span class="built_in">fa</span>(x) = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">//断边(x, y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">make_rt</span>(x);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">find_rt</span>(y) == x &amp;&amp; <span class="built_in">fa</span>(y) == x &amp;&amp; !<span class="built_in">ch</span>(y, <span class="number">0</span>)) <span class="built_in">ch</span>(x, <span class="number">1</span>) = <span class="built_in">fa</span>(y) = <span class="number">0</span>, <span class="built_in">up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ne[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= s_len; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; s[i] != s[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (s[i] == s[j + <span class="number">1</span>]) ++j;</span><br><span class="line">    ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= t_len; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; (t[i] != s[j + <span class="number">1</span>] || j == s_len)) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (t[i] == s[j + <span class="number">1</span>]) ++j;</span><br><span class="line">    <span class="keyword">if</span> (j == s_len); <span class="comment">// 此时t[i - s_len + 1, i] = s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下标均从 $1$ 开始</p><h2 id="Z函数"><a href="#Z函数" class="headerlink" title="Z函数"></a>Z函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Z[<span class="number">1</span>] = s_len;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, l = <span class="number">0</span>, r = <span class="number">0</span>; i &lt;= s_len; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= r) Z[i] = std::<span class="built_in">min</span>(Z[i - l + <span class="number">1</span>], r - i + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (Z[i] + i &lt;= s_len &amp;&amp; s[Z[i] + i] == s[Z[i] + <span class="number">1</span>]) ++Z[i];</span><br><span class="line">    <span class="keyword">if</span> (i + Z[i] - <span class="number">1</span> &gt; r) r = i + Z[i] - <span class="number">1</span>, l = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l = <span class="number">0</span>, r = <span class="number">0</span>, as; i &lt;= t_len; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    as = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= r) as = std::<span class="built_in">min</span>(Z[i - l + <span class="number">1</span>], r - i + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (as + i &lt;= t_len &amp;&amp; s[as + <span class="number">1</span>] == t[as + i]) ++as;</span><br><span class="line">    <span class="keyword">if</span> (i + as - <span class="number">1</span> &gt; r) r = i + as - <span class="number">1</span>, l = i;</span><br><span class="line">    <span class="comment">//此时的as就是t[i, s_len]与s的LCP长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下标从 $1$ 开始</p><h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><p>普通：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Trie</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ch[N][<span class="number">26</span>], ed[N], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; *s != <span class="string">&#x27;\0&#x27;</span>; ++s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!ch[p][*s - <span class="string">&#x27;a&#x27;</span>]) ch[p][*s - <span class="string">&#x27;a&#x27;</span>] = ++tot;</span><br><span class="line">p = ch[p][*s - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line">++ed[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; *s != <span class="string">&#x27;\0&#x27;</span>; ++s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!ch[p][*s - <span class="string">&#x27;a&#x27;</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">p = ch[p][*s - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ed[p]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Trie 的根是 $1$ ；注意空间要开够</p><p>可持久化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Trie</span><br><span class="line">&#123;</span><br><span class="line">AR&lt;<span class="keyword">int</span>, <span class="number">26</span>&gt; ch[N];</span><br><span class="line"><span class="keyword">int</span> rt[M], cid, tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = rt[cid], q = rt[++cid] = ++tot;</span><br><span class="line"><span class="keyword">for</span> (; *s != <span class="string">&#x27;\0&#x27;</span>; ++s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p) ch[q] = ch[p];</span><br><span class="line">ch[q][*s - <span class="string">&#x27;a&#x27;</span>] = ++tot;</span><br><span class="line">p = ch[p][*s - <span class="string">&#x27;a&#x27;</span>], q = ch[q][*s - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = rt[id];</span><br><span class="line"><span class="keyword">for</span> (; *s != <span class="string">&#x27;\0&#x27;</span>; ++s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!ch[p][*s - <span class="string">&#x27;a&#x27;</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">p = ch[p][*s - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任然是要注意空间</p><h2 id="最小表示法"><a href="#最小表示法" class="headerlink" title="最小表示法"></a>最小表示法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_min</span><span class="params">(<span class="keyword">char</span> *s)</span> <span class="comment">//求串s的最小表示,完成后答案存在s[k...k + len - 1]中</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) s[i + len] = s[i];</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">2</span>, k;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= len &amp;&amp; j &lt;= len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt;= len &amp;&amp; s[i + k] == s[j + k]; ++k);</span><br><span class="line"><span class="keyword">if</span> (k &gt; len) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (s[i + k] &gt; s[j + k]) i += k + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> j += k + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i == j) ++j;</span><br><span class="line">&#125;</span><br><span class="line">k = std::<span class="built_in">min</span>(i, j);</span><br><span class="line">s[k + len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意空间要开两倍</p><h2 id="Manacher"><a href="#Manacher" class="headerlink" title="Manacher"></a>Manacher</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">manacher</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">STC <span class="keyword">char</span> t[N &lt;&lt; <span class="number">1</span>]; <span class="comment">//临时字符串要两倍</span></span><br><span class="line">STC <span class="keyword">int</span> p[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s + <span class="number">1</span>), mr = <span class="number">0</span>, mid, res = <span class="number">0</span>;</span><br><span class="line">t[++mr] = <span class="string">&#x27;$&#x27;</span>, t[++mr] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) t[++mr] = s[i], t[++mr] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">t[++mr] = <span class="string">&#x27;^&#x27;</span>;</span><br><span class="line">len = mr, mr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; ++i)</span><br><span class="line">&#123;</span><br><span class="line">p[i] = i &lt; mr ? std::<span class="built_in">min</span>(p[mid * <span class="number">2</span> - i], mr - i) : <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (t[i - p[i]] == t[i + p[i]]) ++p[i];</span><br><span class="line"><span class="keyword">if</span> (i + p[i] &gt; mr) mr = i + p[i], mid = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) res = std::<span class="built_in">max</span>(res, p[i]);</span><br><span class="line"><span class="keyword">return</span> res - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AC-自动机"><a href="#AC-自动机" class="headerlink" title="AC 自动机"></a>AC 自动机</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> AC</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ch[N][<span class="number">26</span>], tot, in[N], as[N], fail[N];</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; ed[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; *s != <span class="string">&#x27;\0&#x27;</span>; ++s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!ch[p][*s - <span class="string">&#x27;a&#x27;</span>]) ch[p][*s - <span class="string">&#x27;a&#x27;</span>] = ++tot;</span><br><span class="line">p = ch[p][*s - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line">ed[p].<span class="built_in">pb</span>(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_fail</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">fail[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) <span class="keyword">if</span> (ch[<span class="number">0</span>][i])</span><br><span class="line">&#123;</span><br><span class="line">fail[ch[<span class="number">0</span>][i]] = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push</span>(ch[<span class="number">0</span>][i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line"><span class="keyword">if</span> (v = ch[u][i])</span><br><span class="line">&#123;</span><br><span class="line">fail[v] = ch[fail[u]][i];</span><br><span class="line">++in[fail[v]];</span><br><span class="line">q.<span class="built_in">push</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> ch[u][i] = ch[fail[u]][i]; <span class="comment">//优化</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> ans[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">std::queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> ct = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; *s != <span class="string">&#x27;\0&#x27;</span>; ++s)</span><br><span class="line">&#123;</span><br><span class="line">++ct;</span><br><span class="line">p = ch[p][*s - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">++as[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) <span class="keyword">if</span> (!in[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u = q.<span class="built_in">front</span>(), v; q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : ed[u]) ans[i] = as[u];</span><br><span class="line">v = fail[u];</span><br><span class="line">as[v] += as[u];</span><br><span class="line"><span class="keyword">if</span> (!(--in[v])) q.<span class="built_in">push</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SAM"><a href="#SAM" class="headerlink" title="SAM"></a>SAM</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> SAM</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1为空节点</span></span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">1</span>, last = <span class="number">1</span>; <span class="comment">//last:未加入此字符前最长的前缀所属的节点的编号</span></span><br><span class="line"><span class="comment">//这里的节点只维护了最长的串,因为所有长度小于它但同结尾的串一定被它的祖先维护了</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> len, fa; <span class="comment">//最长长度,父节点</span></span><br><span class="line"><span class="keyword">int</span> ch[<span class="number">26</span>]; <span class="comment">//类似于Trie</span></span><br><span class="line">&#125; nd[N &lt;&lt; <span class="number">1</span>]; <span class="comment">//开2倍</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = last, np = last = ++tot;</span><br><span class="line">nd[np].len = nd[p].len + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; p &amp;&amp; !nd[p].ch[x]; p = nd[p].fa) nd[p].ch[x] = np; <span class="comment">//遍历所有长度小于它但同结尾的串,加字符</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果最后形成的新字符串没有旧串里出现过,</span></span><br><span class="line"><span class="comment">说明x实际上是一个在旧串中没有出现过的字符</span></span><br><span class="line"><span class="comment">因此不可能存在除节点1以外的祖先</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (!p) nd[np].fa = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> q = nd[p].ch[x];</span><br><span class="line"><span class="keyword">if</span> (nd[q].len == nd[p].len + <span class="number">1</span>) nd[np].fa = q; <span class="comment">//判断np是否为q的子节点</span></span><br><span class="line"><span class="keyword">else</span> <span class="comment">//不是就说明q含了不该含的子串,直接新建节点为np的父节点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nq = ++tot;</span><br><span class="line">nd[nq] = nd[q], nd[nq].len = nd[p].len + <span class="number">1</span>; <span class="comment">//这里就相当于去掉不该含的串</span></span><br><span class="line">nd[q].fa = nd[np].fa = nq;</span><br><span class="line"><span class="keyword">for</span> (; p &amp;&amp; nd[p].ch[x] == q; p = nd[p].fa) nd[p].ch[x] = nq; <span class="comment">//同理跟新</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SA"><a href="#SA" class="headerlink" title="SA"></a>SA</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_sa</span><span class="params">(<span class="keyword">int</span> _num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">STC <span class="keyword">int</span> x[N], y[N], c[N]; <span class="comment">//排序用,第一关键字,第二关键字,cnt</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++c[x[i] = s[i]]; <span class="comment">//第一次只有一个字符,不必离散化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= _num; ++i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) sa[c[x[i]]--] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>, num; k &lt;= n; k &lt;&lt;= <span class="number">1</span>) <span class="comment">//k枚举关键字长度,合并后长度应为2k</span></span><br><span class="line">&#123;</span><br><span class="line">num = <span class="number">0</span>; <span class="comment">//记录离散化后的值域</span></span><br><span class="line"><span class="comment">//先以第二关键字排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - k + <span class="number">1</span>; i &lt;= n; ++i) y[++num] = i; <span class="comment">//没有第二关键字的牌最前</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (sa[i] &gt; k) y[++num] = sa[i] - k;</span><br><span class="line"><span class="comment">//以第一关键字排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= _num; ++i) c[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++c[x[i]];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= _num; ++i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) sa[c[x[y[i]]]--] = y[i], y[i] = <span class="number">0</span>;  <span class="comment">//这里清空y实际上是清空x,因为后面交换了</span></span><br><span class="line">std::<span class="built_in">swap</span>(x, y);</span><br><span class="line"><span class="comment">//将排好序的字符串离散化</span></span><br><span class="line">x[sa[<span class="number">1</span>]] = num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) x[sa[i]] = (y[sa[i]] == y[sa[i - <span class="number">1</span>]] &amp;&amp; y[sa[i] + k] == y[sa[i - <span class="number">1</span>] + k]) ? num : ++num;</span><br><span class="line"><span class="keyword">if</span> (num == n) <span class="keyword">break</span>;</span><br><span class="line">_num = num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) rk[sa[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_hei</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (rk[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (k) --k;</span><br><span class="line"><span class="keyword">int</span> j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">while</span> (i + k &lt;= n &amp;&amp; j + k &lt;= n &amp;&amp; s[i + k] == s[j + k]) ++k;</span><br><span class="line">hei[rk[i]] = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h2><p>树上倍增法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">f[x][<span class="number">0</span>] = fa, dep[x] = dep[fa] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = e[i].ne) <span class="keyword">if</span> (e[i].ver != fa) <span class="built_in">dfs</span>(e[i].ver, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; D; ++j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i][j] = f[f[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dep[x] &gt; dep[y]) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = D - <span class="number">1</span>; ~i; --i) <span class="keyword">if</span> (dep[f[y][i]] &gt;= dep[x]) y = f[y][i];</span><br><span class="line"><span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = D - <span class="number">1</span>; ~i; --i) <span class="keyword">if</span> (f[y][i] != f[x][i]) y = f[y][i], x = f[x][i];</span><br><span class="line"><span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常数较打，优点是好打且可用于求一个点的 $k$ 级祖先</p><p>树剖：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">在前面树剖的基础上加入如下代码:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (top[x] != top[y])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dep[top[x]] &lt; dep[top[y]]) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">x = fa[top[x]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dep[x] &lt; dep[y] ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点是常数小</p><p>ST 表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dep[N &lt;&lt; <span class="number">1</span>], cnt = <span class="number">0</span>, id_b[N &lt;&lt; <span class="number">1</span>], id[N], lg2[N &lt;&lt; <span class="number">1</span>]; <span class="comment">//注意2倍</span></span><br><span class="line">PII mn[N &lt;&lt; <span class="number">1</span>][D]; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    id[x] = ++cnt, dep[cnt] = depth, id_b[cnt] = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne) <span class="keyword">if</span> ((y = e[i].ver) != fa)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(y, x, depth + <span class="number">1</span>);</span><br><span class="line">        id_b[++cnt] = x, dep[cnt] = depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prev</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lg2[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cnt; ++i) lg2[i] = lg2[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) mn[i][<span class="number">0</span>] = &#123;dep[i], id_b[i]&#125;;</span><br><span class="line">    <span class="keyword">int</span> t = lg2[cnt] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; t; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt - (<span class="number">1</span> &lt;&lt; j) + <span class="number">1</span>; ++i) mn[i][j] = std::<span class="built_in">min</span>(mn[i][j - <span class="number">1</span>], mn[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = lg2[r - l + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">min</span>(mn[l][t], mn[r - (<span class="number">1</span> &lt;&lt; t) + <span class="number">1</span>][t]).se;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">ask</span>(std::<span class="built_in">min</span>(id[a], id[b]), std::<span class="built_in">max</span>(id[a], id[b])); &#125;</span><br></pre></td></tr></table></figure><p>优点当然是 $O(1)$ 查询，缺点是有点难打</p><p>也可以用四毛子，但太难打了几乎用不到</p><h2 id="单源最短路"><a href="#单源最短路" class="headerlink" title="单源最短路"></a>单源最短路</h2><p>Dij ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dij</span><span class="params">(<span class="keyword">int</span> star)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::priority_queue&lt;PII&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) dis[i] = INF;</span><br><span class="line">    dis[star] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, star&#125;);</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        x = q.<span class="built_in">top</span>().se, q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne) <span class="keyword">if</span> (!vis[y = e[i].ver] &amp;&amp; dis[y] &gt; dis[x] + e[i].w)</span><br><span class="line">&#123;</span><br><span class="line">dis[y] = dis[x] + e[i].w;</span><br><span class="line">q.<span class="built_in">push</span>(&#123;-dis[y], y&#125;);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>spfa（慎用）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> star)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) dis[i] = INF;</span><br><span class="line">    dis[star] = <span class="number">0</span>, vis[star] = <span class="literal">true</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(star);</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        x = q.<span class="built_in">front</span>(), q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[x] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = e[i].ne) <span class="keyword">if</span> (dis[y = e[i].ver] &gt; dis[x] + e[i].w)</span><br><span class="line">&#123;</span><br><span class="line">dis[y] = dis[x] + e[i].w;</span><br><span class="line"><span class="keyword">if</span> (!vis[y]) vis[y] = <span class="literal">true</span>, q.<span class="built_in">push</span>(y);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判负环"><a href="#判负环" class="headerlink" title="判负环"></a>判负环</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> star)</span> <span class="comment">//判断是否有能从star到达的负环</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) dis[i] = INF, cnt[i] = <span class="number">0</span>, vis[i] = <span class="literal">false</span>;</span><br><span class="line">    dis[star] = <span class="number">0</span>, vis[star] = <span class="literal">true</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(star);</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        x = q.<span class="built_in">front</span>(), q.<span class="built_in">pop</span>();</span><br><span class="line">        v[x] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = e[i].ne) <span class="keyword">if</span> (dis[y = e[i].ver] &gt; dis[x] + e[i].w)</span><br><span class="line">&#123;</span><br><span class="line">dis[y] = dis[x] + e[i].w, cnt[y] = cnt[x] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (cnt[y] &gt;= n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (!vis[y]) vis[y] = <span class="literal">true</span>, q.<span class="built_in">push</span>(y);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">建图:</span><br><span class="line">对于每个形如x[i] - x[j] &lt;= c的不等式,连有向边(j, i, c)</span><br><span class="line">    增加一个<span class="number">0</span>号节点,对于每个i,连边(<span class="number">0</span>, i, <span class="number">0</span>),表示x[i] &lt;= <span class="number">0</span>(我们先求出一组负解)</span><br><span class="line">完成以后以<span class="number">0</span>为源点跑spfa,若出现负环则无解;否则dis[]即为一组负数解</span><br></pre></td></tr></table></figure><h2 id="多源最短路"><a href="#多源最短路" class="headerlink" title="多源最短路"></a>多源最短路</h2><p>Floyed ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) dis[i][i] = <span class="number">0</span>;</span><br><span class="line">用dis做邻接矩阵存图</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) dis[i][j] = std::<span class="built_in">min</span>(dis[i][j], dis[i][k] + dis[k][j]);</span><br></pre></td></tr></table></figure><p>当然也可以做 $n$ 次单源最短路</p><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>Kruskal ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span> <span class="keyword">int</span> from, to, w; &#125; e[M];</span><br><span class="line">读入数据,初始化并查集</span><br><span class="line"><span class="built_in">sort</span>(e + <span class="number">1</span>, e + <span class="number">1</span> + m, [&amp;](Edge x, Edge y)&#123; <span class="keyword">return</span> x.w &lt; y.w; &#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= m; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    x = <span class="built_in">get</span>(e[i].from), y = <span class="built_in">get</span>(e[i].to); <span class="comment">//这里的get和merge就是并查集</span></span><br><span class="line">    <span class="keyword">if</span> (x != y) ans += e[i].w, <span class="built_in">merge</span>(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Prim ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, t; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    t = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) <span class="keyword">if</span> (!vis[j] &amp;&amp; (t == <span class="number">-1</span> || dis[j] &lt; dis[t])) t = j;</span><br><span class="line">    vis[t] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) <span class="keyword">if</span> (!vis[j]) dis[j] = std::<span class="built_in">min</span>(dis[j], map[t][j]);</span><br><span class="line">&#125;</span><br><span class="line">此时dis[]的和就是答案</span><br></pre></td></tr></table></figure><h2 id="Kruskal-重构树"><a href="#Kruskal-重构树" class="headerlink" title="Kruskal 重构树"></a>Kruskal 重构树</h2><p>Kruskal 重构树的建树流程为：</p><ol><li>把所有边排序，记边为 $(x, y, z)$ ，表示 $x \to y$ ，权为 $z$ </li><li>构建 $n$ 个无权点，没有边</li><li>每次取出一条边 $(x, y, z)$ ：<ul><li>若 $x, y$ 联通（在同一棵树），不管它</li><li>否则，新建一个节点 $t$ ，记 $x, y$ 所在树的根为 $r_x, r_y$ ，让 $t$ 的左右儿子分别为 $r_x, r_y$ ，并让 $t$ 的点权为 $z$ </li></ul></li></ol><p>不难发现 kruskal 重构树有如下性质：</p><ol><li>它是一棵二叉树（更进一步，它其实就是个二叉堆），树上除叶子结点以外的点都对应着原来生成树中的边，叶子结点就是原来生成树上的节点</li><li>除叶节点外，儿子节点对应边一定排序在父亲前面，即从每个点到根节点上除叶子结点外按顺序访问到的点的点权是单调的</li><li>对于叶节点 $x, y$ ， $lca(x, y)$ 对应的边就是最小生成树中联通 $x, y$ 的“瓶颈边”（它排序在最后）</li></ol><h2 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h2><p>dp 自然可以，但不好求出具体的路径</p><p>两次 bfs/dfs 的流程如下：</p><ol><li>任选一个点出发，找到离该点最远的节点 $p$ </li><li>从 $p$ 出发，找到离 $p$ 最远的节点 $q$ </li><li> $p, q$ 间的路径就是树的一条直径；如要得到具体路径，在进行 $2$ 时记录前驱即可</li></ol><h2 id="无向图-Tarjan"><a href="#无向图-Tarjan" class="headerlink" title="无向图 Tarjan"></a>无向图 Tarjan</h2><p>判桥：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> in_e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dfn[x] = low[x] = ++num;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne)</span><br><span class="line"><span class="keyword">if</span> (!dfn[y = e[i].ver;])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">tarjan</span>(y, i);</span><br><span class="line">low[x] = std::<span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line"><span class="keyword">if</span> (low[y] &gt; dfn[x]) bridge[i] = bridge[i ^ <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i != (in_e ^ <span class="number">1</span>)) low[x] = std::<span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(!dfn[i]) <span class="built_in">tarjan</span>(i,<span class="number">-1</span>);</span><br></pre></td></tr></table></figure><p>边双联通分量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在判桥的代码后加入以下代码:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">c[x] = dcc;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne) <span class="keyword">if</span> (!bridge[i] &amp;&amp; !c[y = e[i].ver]) <span class="built_in">dfs</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (!c[i]) ++dcc, <span class="built_in">dfs</span>(i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;the num of e-DCC is %d\n&quot;</span>, dcc);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d blongs to e-DCC %d\n&quot;</span>, i, c[i]);</span><br></pre></td></tr></table></figure><p>判割点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dfn[x] = low[x] = ++num;</span><br><span class="line">    (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne)</span><br><span class="line"><span class="keyword">if</span> (!dfn[y = e[i].ver])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">tarjan</span>(y);</span><br><span class="line">low[x] = std::<span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line"><span class="keyword">if</span> (low[y] &gt;= dfn[x])</span><br><span class="line">&#123;</span><br><span class="line">++f;</span><br><span class="line"><span class="keyword">if</span> (x != root || f &gt; <span class="number">1</span>) cut[x] = <span class="literal">true</span>;</span><br><span class="line">(<span class="number">2</span>)</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> low[x] = std::<span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (!dfn[i]) root = i, <span class="built_in">tarjan</span>(i);</span><br></pre></td></tr></table></figure><p>点双联通分量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在上面求割点的代码的(<span class="number">1</span>), (<span class="number">2</span>)处加入以下两段代码:</span><br><span class="line">(<span class="number">1</span>):</span><br><span class="line">stk[++top] = x; <span class="comment">//栈记录经过的节点</span></span><br><span class="line"><span class="keyword">if</span> (x == root &amp;&amp; h[x] == <span class="number">-1</span>) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(dcc[++cnt].<span class="built_in">pb</span>(x)); <span class="comment">//孤立点</span></span><br><span class="line">(<span class="number">2</span>):</span><br><span class="line">++cnt;</span><br><span class="line"><span class="keyword">int</span> z;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    z = stk[top--];</span><br><span class="line">    dcc[cnt].<span class="built_in">pb</span>(z);</span><br><span class="line">&#125; <span class="keyword">while</span> (z != y);</span><br><span class="line">dcc[cnt].<span class="built_in">pb</span>(x);</span><br></pre></td></tr></table></figure><h2 id="有向图-Tarjan"><a href="#有向图-Tarjan" class="headerlink" title="有向图 Tarjan"></a>有向图 Tarjan</h2><p>强连通分量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dfn[x] = low[x] = ++num;</span><br><span class="line">stk[++top] = x, ins[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne)</span><br><span class="line"><span class="keyword">if</span> (!dfn[y = e[i].ver])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">tarjan</span>(y);</span><br><span class="line">low[x] = std::<span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ins[y]) low[x] = std::<span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line"><span class="keyword">if</span> (dfn[x] == low[x])</span><br><span class="line">&#123;</span><br><span class="line">++cnt;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">y = stk[top--], ins[y] = <span class="literal">false</span>;</span><br><span class="line">c[y] = cnt, scc[cnt].<span class="built_in">pb</span>(y);</span><br><span class="line">&#125; <span class="keyword">while</span> (x != y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-SAT"><a href="#2-SAT" class="headerlink" title="2-SAT"></a>2-SAT</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">建图:</span><br><span class="line">图中有<span class="number">2</span>n个节点,i表示x[i]为假,i + n表示x[i]为真</span><br><span class="line">    按命题连边:</span><br><span class="line"><span class="number">1.</span>x[i] <span class="keyword">and</span> x[j] = <span class="number">0</span>:连(i + n, j)和(j + n, i)</span><br><span class="line">        <span class="number">2.</span>x[i] <span class="keyword">and</span> x[j] = <span class="number">1</span>:连(i, i + n)和(j, j + n) (若有一个为<span class="number">0</span>就产生矛盾)</span><br><span class="line">        <span class="number">3.</span>x[i] <span class="keyword">or</span> x[j] = <span class="number">0</span>:连(i + n, i)和(j + n, j) (若有一个为<span class="number">1</span>就产生矛盾)</span><br><span class="line">        <span class="number">4.</span>x[i] <span class="keyword">or</span> x[j] = <span class="number">1</span>:连(i, j + n)和(j, i + n)</span><br><span class="line">        <span class="number">5.</span>x[i] <span class="keyword">xor</span> x[j] = <span class="number">0</span>:连(i, j), (j, i), (i + n, j + n)和(j + n, i + n)</span><br><span class="line">        <span class="number">6.</span>x[i] <span class="keyword">xor</span> x[j] = <span class="number">1</span>:连(i, j + n), (j, i + n), (i + n, j)和(j + n, i)</span><br><span class="line">    有向图Tarjan缩点,若i和i + n在一个强联通分量说明无解;否则任意一个强连通分量代表一组解</span><br></pre></td></tr></table></figure><h2 id="圆方树"><a href="#圆方树" class="headerlink" title="圆方树"></a>圆方树</h2><p>直接对原图进行无向图 Tarjan ，因为原图上每个环都是一个点双，而且在栈中的顺序就是环上点的顺序，如果一个点 $i$ 的出边 $(i, j)$ 满足 $dfn(i) &lt; low(j)$ ，说明 $(i, j)$ 是一条树边，直接加上即可；如果 $dfn(i) = low(j)$ ，那么我们找到了一个环（可能是重边造成的二元环），则从栈中取出点直到取出 $j$ 为止，设这样从栈中取出的点集为 $R$ ，则 $i$ 和 $R$ 构成一个环</p><p>对于环，我们新建一个方点，对环上每个点连边即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    low[x] = dfn[x] = ++dfc;</span><br><span class="line">    stk[++top] = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> y : G[x])</span><br><span class="line">        <span class="keyword">if</span> (!dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(y);</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">            <span class="keyword">if</span> (low[y] == dfn[x])<span class="comment">//标志着找到一个以x为根的点双连通分量</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++cnt; <span class="comment">//增加方点个数</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> z = <span class="number">0</span>; z != y; --top) <span class="comment">//这里一定要让z=0!</span></span><br><span class="line">                &#123;</span><br><span class="line">                    z = stk[top];</span><br><span class="line">                    T[cnt].<span class="built_in">push_back</span>(z);</span><br><span class="line">                    T[z].<span class="built_in">push_back</span>(cnt);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//注意x自身也要连边（但不退栈）</span></span><br><span class="line">                T[cnt].<span class="built_in">push_back</span>(x);</span><br><span class="line">                T[x].<span class="built_in">push_back</span>(cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[x] = <span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (!dfn[i]) <span class="built_in">tarjan</span>(i), --top; <span class="comment">//注意到退出Tarjan时栈中还有一个元素即根,将其退栈</span></span><br></pre></td></tr></table></figure><p>注意新图的节点数变成两倍</p><h2 id="三元环计数"><a href="#三元环计数" class="headerlink" title="三元环计数"></a>三元环计数</h2><p>要改造一下边，把无向图变成有向图，总时间为 $O(m \sqrt{m})$ ，这同时也是三元环的个数上界</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">读入数据,去掉重边,记录每个点的度(下面假设用PII存的边)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_e[i].fi &lt; _e[i].se) std::<span class="built_in">swap</span>(_e[i].fi, _e[i].se);</span><br><span class="line">dep[_e[i].fi] &gt;= dep[_e[i].se] ? <span class="built_in">add</span>(_e[i].fi, _e[i].se) : <span class="built_in">add</span>(_e[i].se, _e[i].fi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find3c</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = e[i].ne) vis[e[i].ver] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = e[i].ne)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = h[e[i].ver]; ~j; j = e[j].ne) res += vis[e[j].ver];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = e[i].ne) vis[e[i].ver] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四元环计数"><a href="#四元环计数" class="headerlink" title="四元环计数"></a>四元环计数</h2><p><strong>我们将每个点按度数大小重新编号，度数相同原来编号大的点在前</strong>的方法，就可以通过编号直接得到任意两个点的关系</p><p>设重新编号后排名为 $rk$ ，枚举四圆环中 $rk$ 最大的点 $x$ ，再枚举 $x$ 的出点 $y$ ，枚举  $y$ 的出点 $z$ （这里直接枚举无向边，注意判断 $rk(x) &gt; rk(y) &gt; rk(z)$ ）， 这里就得到了一个长度为 $2$ 的链了，再枚举一个点 $c$ ，只要 $rk(x) &gt; rk(c)$ 就计入答案的贡献，不管 $rk(c)$ 和 $rk(z)$ 的关系</p><p>时间复杂度还是 $O(m \sqrt{m})$ ，注意四元环的个数上界是 $nm\sqrt{m}$ ，可能要 <code>LL</code> </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">读入数据,记录每个点的度</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) id[i] = i;</span><br><span class="line">std::<span class="built_in">sort</span>(id + <span class="number">1</span>, id + n + <span class="number">1</span>, [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123; <span class="keyword">return</span> deg[x] == dep[y] ? x &lt; y : dep[x] &lt; dep[y]; &#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) rk[id[i]] = i;</span><br><span class="line"><span class="function">LL <span class="title">find4c</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = e[i].ne) <span class="keyword">if</span> (rk[x] &gt; rk[e[i].ver])</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = h[e[i].ver]; ~j; j = e[j].ne) <span class="keyword">if</span> (rk[x] &gt; rk[e[j].ver]) res += cnt[e[j].ver]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = e[i].ne) <span class="keyword">if</span> (rk[x] &gt; rk[e[i].ver])</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = h[e[i].ver]; j != <span class="number">-1</span>; j = e[j].ne) cnt[e[i].ver] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="欧拉回路"><a href="#欧拉回路" class="headerlink" title="欧拉回路"></a>欧拉回路</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">euler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">stk[++top] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (top)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x = stk[top], i = h[x];</span><br><span class="line"><span class="keyword">while</span> (i != <span class="number">-1</span> &amp;&amp; vis[i]) i = ne[i];</span><br><span class="line"><span class="keyword">if</span> (i != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">stk[++top] = e[i].ver;</span><br><span class="line">vis[i] = vis[i ^ <span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">//这里用了成对存储的技巧</span></span><br><span class="line">h[x] = ne[i]; <span class="comment">//保证时间复杂度</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">--top;</span><br><span class="line">ans[++cnt] = x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">最后ans[]存有一条欧拉回路</span><br></pre></td></tr></table></figure><h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><p>判定：染色法</p><p>求最大匹配：</p><p>网络流可做，这里介绍匈牙利，时间为 $O(nm)$ ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne) <span class="keyword">if</span> (!vis[y = e[i].ver])</span><br><span class="line">&#123;</span><br><span class="line">vis[y] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (!match[y] || <span class="built_in">dfs</span>(match[y])) <span class="keyword">return</span> match[y] = x, <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">dfs</span>(i)) ++ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一般图最大匹配"><a href="#一般图最大匹配" class="headerlink" title="一般图最大匹配"></a>一般图最大匹配</h2><p>智慧法（可能被卡）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::mt19937 <span class="title">rud</span><span class="params">(<span class="number">114514</span>)</span></span>;</span><br><span class="line"><span class="function">DB <span class="title">when</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> (DB)(<span class="built_in">clock</span>() - st) / CLOCKS_PER_SEC; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; match[x] = y, match[y] = x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="built_in">shuffle</span>(e[x].<span class="built_in">begin</span>(), e[x].<span class="built_in">end</span>(), rud);</span><br><span class="line">    vis[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> y : e[x]) <span class="keyword">if</span> (!match[y]) <span class="keyword">return</span> <span class="built_in">link</span>(x, y), vis[y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> y : e[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> z = match[y];</span><br><span class="line">        <span class="keyword">if</span> (vis[z]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">link</span>(x, y), match[z] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">work</span>(z)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">link</span>(y, z), match[x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">读入(用vector存图)</span><br><span class="line"><span class="keyword">clock_t</span> st = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">when</span>() &lt; <span class="number">0.9</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (!match[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis + <span class="number">1</span>, <span class="literal">false</span>, n * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">bool</span>));</span><br><span class="line">        ans += <span class="built_in">work</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">最后ans是最大匹配数,match即为匹配  </span><br></pre></td></tr></table></figure><p>带花树：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">link同上,get就是并查集</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dad</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!match[x] &amp;&amp; !match[y]) <span class="built_in">link</span>(x, y), ++ans; <span class="comment">//优化</span></span><br><span class="line">    <span class="built_in">add</span>(x, y), <span class="built_in">add</span>(y, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rev</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">if</span> (x) <span class="built_in">rev</span>(match[pre[x]]), <span class="built_in">link</span>(x, pre[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    STC <span class="keyword">int</span> dfn[N], cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    dfn是一个标记数组,一边打标即一边上跳，第一个重复点就是花根</span></span><br><span class="line"><span class="comment">花根一定是一个绿点,所以可以隔点上跳</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (++cnt; ;x = pre[match[x]], <span class="built_in">swap</span>(x, y))</span><br><span class="line"><span class="keyword">if</span> (dfn[x = <span class="built_in">get</span>(x)] == cnt) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x) dfn[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blossom</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span> <span class="comment">//缩奇环(开花)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">get</span>(x) != w; x = pre[y])</span><br><span class="line">    &#123;</span><br><span class="line">        pre[x] = y, y = match[x];</span><br><span class="line">        fa[x] = fa[y] = w;</span><br><span class="line">        <span class="keyword">if</span> (col[y] == <span class="number">2</span>) col[y] = <span class="number">1</span>, q.<span class="built_in">push</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aug</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//带花树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((ans + <span class="number">1</span>) * <span class="number">2</span> &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fa[i] = i, col[i] = pre[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (q.<span class="built_in">push</span>(x), col[x] = <span class="number">1</span>; !q.<span class="built_in">empty</span>(); q.<span class="built_in">pop</span>())</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = q.<span class="built_in">front</span>(), i = h[u], v, w; ~i; i = e[i].ne)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">get</span>(u) == <span class="built_in">get</span>(v = e[i].ver) || col[v] == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!col[v])</span><br><span class="line">            &#123;</span><br><span class="line">                col[v] = <span class="number">2</span>, pre[v] = u;</span><br><span class="line">                <span class="keyword">if</span> (!match[v]) <span class="keyword">return</span> <span class="built_in">rev</span>(v), <span class="number">1</span>;</span><br><span class="line">                col[match[v]] = <span class="number">1</span>, q.<span class="built_in">push</span>(match[v]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">blossom</span>(u, v, w = <span class="built_in">lca</span>(u, v)), <span class="built_in">blossom</span>(v, u, w); <span class="comment">//缩环两个方向各一次拼起来</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">读入，加边用<span class="function">dad</span></span><br><span class="line"><span class="function"><span class="title">for</span> <span class="params">(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span> ans +</span>= (!match[i] &amp;&amp; <span class="built_in">aug</span>(i));</span><br></pre></td></tr></table></figure><h2 id="Prufer-序列"><a href="#Prufer-序列" class="headerlink" title="Prufer 序列"></a>Prufer 序列</h2><p>每次选择一个编号最小的叶结点并删掉它，然后在序列中记录下它连接到的那个结点，重复 $n - 2$ 次后就只剩下两个结点，算法结束，得到的序列可以与原树一一对应</p><h2 id="虚树"><a href="#虚树" class="headerlink" title="虚树"></a>虚树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!top) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(stk[++top] = x);</span><br><span class="line">    <span class="keyword">int</span> z = <span class="built_in">lca</span>(stk[top], x);</span><br><span class="line">    <span class="keyword">for</span> (; tp &gt; <span class="number">1</span> &amp;&amp; dep[z] &lt; dep[stk[top - <span class="number">1</span>]]; --top) <span class="built_in">add</span>(stk[top - <span class="number">1</span>], stk[top]);</span><br><span class="line">    <span class="keyword">if</span> (dep[z] &lt; dep[stk[top]]) <span class="built_in">add</span>(z, stk[top--]);</span><br><span class="line">    <span class="keyword">if</span> (!top || stk[top] != z) stk[++top] = z;</span><br><span class="line">    stk[++top] = x;</span><br><span class="line">&#125;</span><br><span class="line">std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + k + <span class="number">1</span>, [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123; <span class="keyword">return</span> dfn[x] &lt; dfn[y]; &#125;);</span><br><span class="line">top = ans = idf = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">1</span>] != <span class="number">1</span>) stk[++top] = <span class="number">1</span>; <span class="comment">//根</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) <span class="built_in">ins</span>(a[i]);</span><br><span class="line"><span class="keyword">for</span> (; top &gt; <span class="number">1</span>; --top) <span class="built_in">adf</span>(stk[top - <span class="number">1</span>], stk[top]); <span class="comment">//在虚树上建边</span></span><br><span class="line">计算答案,记得撤销!</span><br></pre></td></tr></table></figure><p>虚树的空间和撤销是易错点</p><h1 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h1><h2 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h2><p>注意下面初始化都是 <code>0xcf</code> （最小值）</p><p> $01$ ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(f, <span class="number">0xcf</span>, <span class="keyword">sizeof</span> f), ans = -INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= v[i]; --j) f[j] = std::<span class="built_in">max</span>(f[j - v[i]] + w[i], f[j]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) ans = <span class="built_in">max</span>(ans, f[i]);</span><br></pre></td></tr></table></figure><p> $01$ 退背包（只能求方案数）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) f[i] -= f[i - <span class="number">1</span>] * x; <span class="comment">//禁用贡献为x的物品</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = m; i; --i) f[i] += f[i - <span class="number">1</span>] * x; <span class="comment">//加入贡献为x的物品</span></span><br></pre></td></tr></table></figure><p>完全：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(f, <span class="number">0xcf</span>, <span class="keyword">sizeof</span> f), ans = -INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = v[i]; j &lt;= m; ++j) f[j] = std::<span class="built_in">max</span>(f[j - v[i]] + w[i], f[j]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) ans = <span class="built_in">max</span>(ans, f[i]);</span><br></pre></td></tr></table></figure><p>多重背包二进制拆分（以下给出拆分代码）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(Node x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (x.p &gt;= p)</span><br><span class="line">&#123;</span><br><span class="line">b[++o].c = x.c * p;</span><br><span class="line">b[o].t = x.t * p;</span><br><span class="line">b[o].p = <span class="number">1</span>;</span><br><span class="line">x.p -= p;</span><br><span class="line">p &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x.p)</span><br><span class="line">&#123;</span><br><span class="line">b[++o].c = x.c * x.p;</span><br><span class="line">b[o].t = x.t * x.p;</span><br><span class="line">b[o].p = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多重背包单调队列优化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> u, <span class="keyword">int</span> k)</span></span>&#123; <span class="keyword">return</span> f[u + k * v[i]] - k * w[i]; &#125;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0xcf</span>, <span class="keyword">sizeof</span> f), f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; v[i]; ++u) <span class="comment">// u:余数</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">int</span> hh = <span class="number">1</span>, tt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxp = (m - u) / v[i];</span><br><span class="line">        <span class="comment">//将初始的候选集合插入队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = maxp - <span class="number">1</span>; k &gt;= <span class="built_in">max</span>(maxp - c[i], <span class="number">0</span>); --k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">calc</span>(i, u, q[tt]) &lt;= <span class="built_in">calc</span>(i, u, k)) --tt;</span><br><span class="line">            q[++tt] = k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dp</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p = maxp; p &gt;= <span class="number">0</span>; p--) <span class="comment">//循环状态</span></span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; q[hh] &gt; p - <span class="number">1</span>) ++hh; <span class="comment">//排除过时决策</span></span><br><span class="line">            <span class="keyword">if</span> (hh &lt;= tt) f[u + p * v[i]] = std::<span class="built_in">max</span>(f[u + p * v[i]], <span class="built_in">calc</span>(i, u, q[hh]) + p * w[i]); <span class="comment">//取队头转移</span></span><br><span class="line">            <span class="keyword">if</span> (p - c[i] - <span class="number">1</span> &gt;= <span class="number">0</span>) <span class="comment">//新决策入队,同时维护单调</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">calc</span>(i, u, q[tt]) &lt;= <span class="built_in">calc</span>(i, u, p - c[i] - <span class="number">1</span>)) --tt;</span><br><span class="line">                q[++tt] = p - c[i] - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) ans = std::<span class="built_in">max</span>(ans, f[i]);</span><br></pre></td></tr></table></figure><h2 id="单调队列优化"><a href="#单调队列优化" class="headerlink" title="单调队列优化"></a>单调队列优化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> q[N], l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r &amp;&amp; 队头不再合法) ++l;</span><br><span class="line">    用队头跟新d[i]</span><br><span class="line">   <span class="keyword">while</span> (l &lt;= r &amp;&amp; i优于队尾) --r;</span><br><span class="line">    q[++r] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各操作顺序不是严格</p><h2 id="斜率优化"><a href="#斜率优化" class="headerlink" title="斜率优化"></a>斜率优化</h2><p>考虑 $j$ 优与 $k$ 的条件，把 dp 方程化成 $\frac{Y(j) - Y(k)}{X(j) - X(k)} \le 无关j,k的值K$  的形式，然后分情况（以最大值为例）：</p><p> $X, K$ 单调：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> q[N], l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//有时候需要先把0入队</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r &amp;&amp; (<span class="built_in">Y</span>(q[l + <span class="number">1</span>]) - <span class="built_in">Y</span>(q[l])) &gt; <span class="built_in">K</span>(i) * (<span class="built_in">X</span>(q[l + <span class="number">1</span>]) - <span class="built_in">X</span>(q[l]))) ++l; <span class="comment">//至少保证队列中有一个数</span></span><br><span class="line">    用队头跟新<span class="function">i</span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="params">(l &lt; r &amp;&amp; (Y(i) - Y(q[r])) * (X(q[r]) - X(q[r - <span class="number">1</span>])) &gt;= (Y(q[r]) - Y(q[r - <span class="number">1</span>])) * (X(i) - X(q[r])))</span> --r</span>;</span><br><span class="line">    q[++r] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> $X$ 不单调， $K$ 单调：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> q[l];</span><br><span class="line">    <span class="keyword">int</span> ll = l, rr = r, mid, res;</span><br><span class="line">    <span class="keyword">while</span> (ll &lt;= rr)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = ll + rr &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">Y</span>(q[mid + <span class="number">1</span>]) - <span class="built_in">Y</span>(q[mid])) &lt;= (<span class="built_in">X</span>(q[mid + <span class="number">1</span>]) - <span class="built_in">X</span>(q[mid])) * k) res = mid, rr = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> ll = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q[res];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> q[N], l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="built_in">find</span>(i, <span class="built_in">K</span>(i));</span><br><span class="line">    用j跟新<span class="function">i</span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="params">(l &lt; r &amp;&amp; (Y(i) - Y(q[r])) * (X(q[r]) - X(q[r - <span class="number">1</span>])) &gt;= (Y(q[r]) - Y(q[r - <span class="number">1</span>])) * (X(i) - X(q[r])))</span> --r</span>;</span><br><span class="line">    q[++r] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> $X, K$ 都不单调：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">X</span>(x) == <span class="built_in">X</span>(y) ? <span class="built_in">Y</span>(x) &gt; <span class="built_in">Y</span>(y) : <span class="built_in">X</span>(x) &lt; <span class="built_in">X</span>(y); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdq</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        有时候这里有些操作</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    lp = l - <span class="number">1</span>, rp = mid;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) (p[i] &lt;= mid ? tmp[++lp] : tmp[++rp]) = p[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) p[i] = tmp[i];</span><br><span class="line">    <span class="built_in">cdq</span>(l, mid);</span><br><span class="line">    ql = <span class="number">1</span>, qr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= mid; ++i)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; l &amp;&amp; <span class="built_in">X</span>(p[i]) == <span class="built_in">X</span>(p[i - <span class="number">1</span>])) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span> (ql &lt; qr &amp;&amp; (<span class="built_in">Y</span>(q[qr]) - <span class="built_in">Y</span>(q[qr - <span class="number">1</span>])) * (<span class="built_in">X</span>(p[i]) - <span class="built_in">X</span>(q[qr])) &lt;= (<span class="built_in">Y</span>(p[i]) - <span class="built_in">Y</span>(q[qr])) * (<span class="built_in">X</span>(q[qr]) - <span class="built_in">X</span>(q[qr - <span class="number">1</span>]))) --qr;</span><br><span class="line">        q[++qr] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>, u, v; i &lt;= r; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (ql &lt; qr &amp;&amp; (<span class="built_in">Y</span>(q[ql + <span class="number">1</span>]) - <span class="built_in">Y</span>(q[ql])) &gt; (<span class="built_in">X</span>(q[ql + <span class="number">1</span>]) - <span class="built_in">X</span>(q[ql])) * <span class="built_in">K</span>(p[i])) ++ql;</span><br><span class="line">        u = p[i], v = q[ql];</span><br><span class="line">用v跟新u</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cdq</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    lp = tp = l, rp = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lp &lt;= mid &amp;&amp; rp &lt;= r) tmp[tp++] = (<span class="built_in">cmp</span>(p[lp], p[rp]) ? p[lp++] : p[rp++]);</span><br><span class="line">    <span class="keyword">while</span> (lp &lt;= mid) tmp[tp++] = p[lp++];</span><br><span class="line">    <span class="keyword">while</span> (rp &lt;= r) tmp[tp++] = p[rp++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) p[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">在进入cdq之前:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) p[i] = i;</span><br><span class="line">std::<span class="built_in">sort</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>, [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123; <span class="keyword">return</span> <span class="built_in">K</span>(x) &lt; <span class="built_in">K</span>(y); &#125;);</span><br><span class="line">初始化dp数组</span><br></pre></td></tr></table></figure><h2 id="四边形不等式"><a href="#四边形不等式" class="headerlink" title="四边形不等式"></a>四边形不等式</h2><p>式子： $a \le b \le c \le d$ 若 $w(a, d) + w(b, c) \ge w(a, c) + w(b, d)$ 则满足四边形不等式（想象一个四边形，对边和小于对角线和）</p><p>分治打法：</p><p>设函数 <code>sol(l, r, L, R)</code> 表示“当然正在处理 $d[l \sim r]$ ，最优决策存在于区间 $[L, R]$ ”，函数伪代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sol</span>(l, r, L, R)</span><br><span class="line"><span class="keyword">if</span> (l &gt; r || L &gt; R) <span class="keyword">return</span> ;</span><br><span class="line">mid &lt;- (l + r) &gt;&gt; <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i : L -&gt; R</span><br><span class="line">找到最优决策点 pos </span><br><span class="line">end <span class="keyword">for</span></span><br><span class="line">用 pos 跟新 d[mid]</span><br><span class="line"><span class="built_in">sol</span>(l, mid - <span class="number">1</span>, L, pos)</span><br><span class="line"><span class="built_in">sol</span>(mid + <span class="number">1</span>, r, pos, R)</span><br><span class="line">end sol</span><br></pre></td></tr></table></figure><p>要求 $val(i, j)$ 不含与 $d[j]$ 有关的项</p><p>队列 + 二分打法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">q[h = t = <span class="number">1</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, n&#125;; <span class="comment">//把0先入队</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, pos; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (h &lt;= t &amp;&amp; q[h].r &lt; i) ++h;</span><br><span class="line">用q[h].pos跟新i</span><br><span class="line">pos = n + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (h &lt;= t &amp;&amp; 对于q[t].l,i比q[t].pos优) pos = q[t--].l;</span><br><span class="line"><span class="keyword">if</span> (h &lt;= t &amp;&amp; 对于q[t].r,i比q[t].pos优)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> l = q[t].l, r = q[t].r, mid;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line">mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (对于mid,i比q[t].pos优) pos = mid, r = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">q[t].r = pos - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pos &lt;= n) q[++t] = &#123;i, pos, n&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h1><h2 id="最大流（-Dinic-）："><a href="#最大流（-Dinic-）：" class="headerlink" title="最大流（ Dinic ）："></a>最大流（ Dinic ）：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    STC <span class="keyword">int</span> q[N];</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">1</span>, tt = <span class="number">1</span>, x, y;</span><br><span class="line"><span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="keyword">sizeof</span> dep), q[dep[S] = <span class="number">1</span>] = S, cur[S] = h[S]</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x = q[hh++]]; ~i; i = e[i].ne) <span class="keyword">if</span> (!dep[y = e[i].ver] &amp;&amp; e[i].w)</span><br><span class="line">&#123;</span><br><span class="line">dep[y] = dep[x] + <span class="number">1</span>, cur[y] = h[y];</span><br><span class="line"><span class="keyword">if</span> (y == T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">q[++tt] = y;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> lim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == T) <span class="keyword">return</span> lim;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, y, t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cur[x]; i != <span class="number">-1</span> &amp;&amp; flow &lt; lim;  i = e[i].ne)</span><br><span class="line">    &#123;</span><br><span class="line">        cur[x] = i; <span class="comment">//这里非常玄学,一定要这样写,压行的话可能会TLE</span></span><br><span class="line">        <span class="keyword">if</span> (dep[y = e[i].ver] == dep[x] + <span class="number">1</span> &amp;&amp; e[i].w)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(t = <span class="built_in">find</span>(y, std::<span class="built_in">min</span>(lim - flow, e[i].w)))) dep[y] = <span class="number">0</span>;</span><br><span class="line">            e[i].w -= t, e[i ^ <span class="number">1</span>].w += t, flow += t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>, flow;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">dfs</span>()) <span class="keyword">while</span>(flow = <span class="built_in">find</span>(S, INF)) res += flow;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大流（-HLPP-）："><a href="#最大流（-HLPP-）：" class="headerlink" title="最大流（ HLPP ）："></a>最大流（ HLPP ）：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hi[N], ex[N], gap[N]; <span class="comment">//hi:高度,ex:超额流,gap[i]:高度为i的节点的数量</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; B[N]; <span class="comment">// 桶B[i]中记录所有hi[x]=i的x</span></span><br><span class="line"><span class="keyword">int</span> level = <span class="number">0</span>; <span class="comment">//溢出节点的最高高度</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) hi[i] = INF;</span><br><span class="line">hi[T] = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push</span>(T);</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">x = q.<span class="built_in">front</span>(), q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (e[i ^ <span class="number">1</span>].w &amp;&amp; hi[y] &gt; hi[x] + <span class="number">1</span>) hi[y] = hi[x] + <span class="number">1</span>, q.<span class="built_in">push</span>(y); <span class="comment">//从T倒着搜回去走的是反向边,^1以后就变回正向边</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> hi[S] != INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//尽可能通过能够推送的边推送超额流</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> init = x == S;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y, k; i != <span class="number">-1</span>; i = e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">y = e[i].ver;</span><br><span class="line"><span class="keyword">if</span> (!e[i].w || (init == <span class="literal">false</span> &amp;&amp; hi[x] != hi[y] + <span class="number">1</span>)) <span class="keyword">continue</span>; <span class="comment">//初始化时不考虑高度差为1</span></span><br><span class="line">k = init ? e[i].w : <span class="built_in">min</span>(e[i].w, ex[x]); <span class="comment">//取到剩余容量和超额流的最小值初始化时可以使源的溢出量为负数</span></span><br><span class="line"><span class="keyword">if</span> (y != S &amp;&amp; y != T &amp;&amp; !ex[y]) B[hi[y]].<span class="built_in">push_back</span>(y), level = <span class="built_in">max</span>(level, hi[y]);</span><br><span class="line">ex[x] -= k, ex[y] += k, e[i].w -=k, e[i ^ <span class="number">1</span>].w += k;</span><br><span class="line"><span class="keyword">if</span> (!ex[x]) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//如果已经推送完就返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">relabel</span><span class="params">(<span class="keyword">int</span> x)</span>  <span class="comment">//重贴标签(高度)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  hi[x] = INF;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne)<span class="keyword">if</span> (e[i].w) hi[x] = <span class="built_in">min</span>(hi[x], hi[e[i].ver]);</span><br><span class="line">  <span class="keyword">if</span> (++hi[x] &lt; n) <span class="comment">//只处理高度小于n的节点</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="comment">//新的高度,更新gap</span></span><br><span class="line">  B[hi[x]].<span class="built_in">push_back</span>(x);</span><br><span class="line">  level = <span class="built_in">max</span>(level, hi[x]);</span><br><span class="line">  ++gap[hi[x]];  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_max</span><span class="params">()</span> <span class="comment">//选出当前高度最大的节点之一,如果已经没有溢出节点返回0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (B[level].<span class="built_in">empty</span>() &amp;&amp; level &gt; <span class="number">-1</span>) --level;</span><br><span class="line"><span class="keyword">return</span> level == <span class="number">-1</span> ? <span class="number">0</span> : B[level].<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hlpp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">bfs</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i) gap[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (hi[i] != INF) ++gap[hi[i]];</span><br><span class="line">hi[S] = n;</span><br><span class="line"><span class="built_in">push</span>(S); <span class="comment">//初始化预流</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">while</span> (x = <span class="built_in">find_max</span>())</span><br><span class="line">&#123;</span><br><span class="line">B[level].<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">push</span>(x)) <span class="comment">//仍然溢出</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!--gap[hi[x]])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">if</span> (i != S &amp;&amp; i != T &amp;&amp; hi[i] &gt; hi[x] &amp;&amp; hi[i] &lt; n + <span class="number">1</span>)</span><br><span class="line">hi[i] = n + <span class="number">1</span>;  <span class="comment">// 这里重贴成 n+1 的节点都不是溢出节点</span></span><br><span class="line">      <span class="built_in">relabel</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ex[T];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="费用流"><a href="#费用流" class="headerlink" title="费用流"></a>费用流</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) dis[i] = INF, cur[i] = h[i];</span><br><span class="line">    std::queue&lt;<span class="keyword">int</span>&gt; q; <span class="comment">//这里只能stl,因为spfa一个点可能入队多次,空间大小未知</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (dis[S] = <span class="number">0</span>, q.<span class="built_in">push</span>(S), vis[S] = <span class="literal">true</span>; !q.<span class="built_in">empty</span>(); )</span><br><span class="line">    &#123;</span><br><span class="line">        vis[x = q.<span class="built_in">front</span>()] = <span class="literal">false</span>, q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = e[i].ne) <span class="keyword">if</span> (dis[y = e[i].ver] &gt; dis[x] + e[i].c &amp;&amp; e[i].w)</span><br><span class="line">        &#123;</span><br><span class="line">            dis[y] = dis[x] + e[i].c;</span><br><span class="line">            <span class="keyword">if</span> (!vis[y]) vis[y] = <span class="literal">true</span>, q.<span class="built_in">push</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[T] != INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> lim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == T) <span class="keyword">return</span> lim;</span><br><span class="line">    vis[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, y, t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cur[x]; i != <span class="number">-1</span> &amp;&amp; flow &lt; lim; i = e[i].ne)</span><br><span class="line">    &#123;</span><br><span class="line">        cur[x] = i;</span><br><span class="line">        <span class="keyword">if</span> (!vis[y = e[i].ver] &amp;&amp; dis[y] == dis[x] + e[i].c &amp;&amp; e[i].w)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(t = <span class="built_in">find</span>(y, std::<span class="built_in">min</span>(lim - flow, e[i].w)))) <span class="keyword">continue</span>;</span><br><span class="line">            e[i].w -= t, e[i ^ <span class="number">1</span>].w += t, flow += t, mincost += t * e[i].c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[x] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mcmf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    maxflow = mincost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> flow;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">spfa</span>()) <span class="keyword">while</span>(flow = <span class="built_in">find</span>(S, INF)) maxflow += flow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小割树"><a href="#最小割树" class="headerlink" title="最小割树"></a>最小割树</h2><p>把 Dinic 的函数改一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _s, <span class="keyword">int</span> <span class="keyword">_t</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S = _s, T = <span class="keyword">_t</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; idx; i += <span class="number">2</span>) e[i].w = (e[i].w + e[i ^ <span class="number">1</span>].w), e[i ^ <span class="number">1</span>].w = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> _s, <span class="keyword">int</span> <span class="keyword">_t</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>(_s, <span class="keyword">_t</span>);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, flow;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">bfs</span>()) <span class="keyword">while</span> (flow = <span class="built_in">find</span>(S, INF)) res += flow;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再加上：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> GHT <span class="comment">//Gomory-Hu Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> D = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> nd[N], h[N], idx = <span class="number">0</span>, dep[N], f[N][D], mn[N][D];</span><br><span class="line">    <span class="function">std::mt19937 <span class="title">rud</span><span class="params">(<span class="number">114514</span>)</span></span>;</span><br><span class="line">    Edge e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>&#123; e[idx] = &#123;h[x], y, z&#125;, h[x] = idx++; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line">        STC <span class="keyword">int</span> tp1[N], tp2[N];</span><br><span class="line">        <span class="keyword">int</span> s, t, flow, ct1 = <span class="number">0</span>, ct2 = <span class="number">0</span>;</span><br><span class="line">        s = nd[l], t = nd[l + <span class="number">1</span>];</span><br><span class="line">        flow = Dinic::<span class="built_in">dinic</span>(s, t);</span><br><span class="line">        <span class="built_in">add</span>(s, t, flow), <span class="built_in">add</span>(t, s, flow);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) (Dinic::dep[nd[i]] ? tp1[++ct1] : tp2[++ct2]) = nd[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ct1; ++i) nd[i + l - <span class="number">1</span>] = tp1[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ct2; ++i) nd[i + l + ct1 - <span class="number">1</span>] = tp2[i];</span><br><span class="line">        <span class="built_in">build</span>(l, l + ct1 - <span class="number">1</span>), <span class="built_in">build</span>(l + ct1, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (q.<span class="built_in">push</span>(<span class="number">1</span>), dep[<span class="number">1</span>] = <span class="number">1</span>; !q.<span class="built_in">empty</span>(); )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne) <span class="keyword">if</span> (!dep[y = e[i].ver])</span><br><span class="line">            &#123;</span><br><span class="line">                dep[y] = dep[x] + <span class="number">1</span>, f[y][<span class="number">0</span>] = x, mn[y][<span class="number">0</span>] = e[i].w;</span><br><span class="line">                q.<span class="built_in">push</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; D; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                mn[i][j] = std::<span class="built_in">min</span>(mn[i][j - <span class="number">1</span>], mn[f[i][j - <span class="number">1</span>]][j - <span class="number">1</span>]);</span><br><span class="line">                f[i][j] = f[f[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) nd[i] = i;</span><br><span class="line">        <span class="built_in">shuffle</span>(nd + <span class="number">1</span>, nd + <span class="number">1</span> + n, rud); <span class="comment">//随机化</span></span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, n), <span class="built_in">bfs</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = INF;</span><br><span class="line">        <span class="keyword">if</span> (dep[x] &gt; dep[y]) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = D - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) <span class="keyword">if</span> (dep[f[y][i]] &gt;= dep[x]) res = std::<span class="built_in">min</span>(res, mn[y][i]), y = f[y][i];</span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">return</span> res == INF ? <span class="number">-1</span> : res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = D - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) <span class="keyword">if</span> (f[x][i] != f[y][i])</span><br><span class="line">        &#123;</span><br><span class="line">            res = std::<span class="built_in">min</span>(res, std::<span class="built_in">min</span>(mn[x][i], mn[y][i]));</span><br><span class="line">            x = f[x][i], y = f[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">        res = std::<span class="built_in">min</span>(res, std::<span class="built_in">min</span>(mn[x][<span class="number">0</span>], mn[y][<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> res == INF ? <span class="number">-1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h1><h2 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a>FFT</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3000000</span> + <span class="number">5</span>; <span class="comment">//注意N要大于二倍n</span></span><br><span class="line"><span class="keyword">const</span> DB PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span> //定义复数</span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">DB a, b;</span><br><span class="line"><span class="function">Complex <span class="title">make_C</span><span class="params">(<span class="keyword">const</span> DB _a, <span class="keyword">const</span> DB _b)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Complex res;</span><br><span class="line">res.a = _a, res.b = _b;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;<span class="keyword">_t</span>) <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="built_in">make_C</span>(a + <span class="keyword">_t</span>.a, b + <span class="keyword">_t</span>.b); &#125;</span><br><span class="line">Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp;<span class="keyword">_t</span>) <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="built_in">make_C</span>(a - <span class="keyword">_t</span>.a, b - <span class="keyword">_t</span>.b); &#125;</span><br><span class="line">Complex <span class="keyword">operator</span>*(<span class="keyword">const</span> Complex &amp;<span class="keyword">_t</span>) <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="built_in">make_C</span>(a * <span class="keyword">_t</span>.a - b * <span class="keyword">_t</span>.b, a * <span class="keyword">_t</span>.b + b * <span class="keyword">_t</span>.a); &#125;</span><br><span class="line">&#125; a[N], b[N];</span><br><span class="line"><span class="keyword">int</span> r[N], bit, tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(Complex x[], <span class="keyword">int</span> inv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) <span class="keyword">if</span> (i &lt; r[i]) std::<span class="built_in">swap</span>(x[i], x[r[i]]);</span><br><span class="line">Complex w1, wk, a1, a2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; tot; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">w1 = w1.<span class="built_in">make_C</span>(<span class="built_in">cos</span>(PI / mid), inv * <span class="built_in">sin</span>(PI / mid)); <span class="comment">//由于cos正负相同,不必乘inv</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i += (mid &lt;&lt; <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">wk = wk.<span class="built_in">make_C</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; ++j, wk = wk * w1)</span><br><span class="line">&#123;</span><br><span class="line">a1 = x[i + j], a2 = wk * x[i + j + mid];</span><br><span class="line">x[i + j] = a1 + a2, x[i + j + mid] = a1 - a2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; bit) &lt; n + m + <span class="number">1</span>) ++bit;</span><br><span class="line">tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (bit - <span class="number">1</span>));</span><br></pre></td></tr></table></figure><h2 id="NTT-全家桶"><a href="#NTT-全家桶" class="headerlink" title="NTT + 全家桶"></a>NTT + 全家桶</h2><p>超长警告</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>, I = <span class="number">86583718</span>, G = <span class="number">3</span>; <span class="comment">//模数,二次剩余,原根</span></span><br><span class="line"><span class="keyword">namespace</span> Poly</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> Cipolla</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> w;</span><br><span class="line"><span class="function">std::mt19937 <span class="title">rud</span><span class="params">(<span class="number">114514</span>)</span></span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="keyword">int</span> x, y;</span><br><span class="line">            Complex <span class="keyword">operator</span> * (<span class="keyword">const</span> Complex t) <span class="keyword">const</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> (Complex)&#123;((LL)x * t.x % P + (LL)y * t.y % P * w % P) % P, ((LL)x * t.y % P + (LL)y * t.x % P) % P&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; ;</span><br><span class="line">        <span class="function">Complex <span class="title">Cqpow</span><span class="params">(Complex x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Complex res = (Complex)&#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = x * x) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = res * x;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">Csqrt</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">qpow</span>(x, (P - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) == P - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> t;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                t = <span class="built_in">rud</span>();</span><br><span class="line">                w = ((LL)t * t % P - x + P) % P;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">qpow</span>(w, (P - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) == P - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="built_in">Cqpow</span>((Complex)&#123;t, <span class="number">1</span>&#125;, (P + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>).x;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(res, P - res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> r[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; ++i) x[i] = y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; ++i) x[i] = y[i]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ready</span><span class="params">(<span class="keyword">int</span> &amp;bit, <span class="keyword">int</span> &amp;tot, <span class="keyword">int</span> len)</span></span>&#123; <span class="keyword">for</span> (tot = <span class="number">1</span>, bit = <span class="number">0</span>; tot &lt; (len &lt;&lt; <span class="number">1</span>); ) tot &lt;&lt;= <span class="number">1</span>, ++bit; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get_r</span><span class="params">(<span class="keyword">int</span> bit, <span class="keyword">int</span> tot)</span></span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (bit - <span class="number">1</span>)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ntt</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> tot, <span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) <span class="keyword">if</span> (i &lt; r[i]) std::<span class="built_in">swap</span>(x[i], x[r[i]]);</span><br><span class="line">        <span class="keyword">int</span> mid, i, j, len, gn, g, a, b;</span><br><span class="line">        <span class="keyword">for</span> (mid = <span class="number">1</span>; mid &lt; tot; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            len = mid &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            gn = <span class="built_in">qpow</span>(G, (P - <span class="number">1</span>) / len);</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="number">-1</span>) gn = <span class="built_in">qpow</span>(gn, P - <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tot; i += len)</span><br><span class="line">            &#123;</span><br><span class="line">                g = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; mid; ++j, g = (LL)g * gn % P)</span><br><span class="line">                &#123;</span><br><span class="line">                    a = x[i + j], b = (LL)g * x[i + j + mid] % P;</span><br><span class="line">                    x[i + j] = (a + b) % P;</span><br><span class="line">                    x[i + j + mid] = (a - b + P) % P;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">        gn = <span class="built_in">qpow</span>(tot, P - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) x[i] = (LL)x[i] * gn % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polymul</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bit, tot;</span><br><span class="line">        <span class="built_in">ready</span>(bit, tot, len);</span><br><span class="line">        <span class="built_in">get_r</span>(bit, tot);</span><br><span class="line">        <span class="built_in">ntt</span>(x, tot, <span class="number">1</span>), <span class="built_in">ntt</span>(y, tot, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) x[i] = (LL)x[i] * y[i] % P;</span><br><span class="line">        <span class="built_in">ntt</span>(x, tot, <span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//记得把x中不用的清0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polyinv</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> len)</span> <span class="comment">//求逆,y记录答案</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(y[<span class="number">0</span>] = <span class="built_in">qpow</span>(x[<span class="number">0</span>], P - <span class="number">2</span>));</span><br><span class="line">        <span class="built_in">polyinv</span>(x, y, (len + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> bit = <span class="number">0</span>, tot = <span class="number">1</span>;</span><br><span class="line">        STC <span class="keyword">int</span> t[N];</span><br><span class="line">        <span class="built_in">ready</span>(bit, tot, len);</span><br><span class="line">        <span class="built_in">get_r</span>(bit, tot);</span><br><span class="line">        <span class="built_in">fill</span>(y, <span class="number">0</span>, (len + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, tot);</span><br><span class="line">        <span class="built_in">fill</span>(t, x, <span class="number">0</span>, len);</span><br><span class="line">        <span class="built_in">fill</span>(t, <span class="number">0</span>, len, tot);</span><br><span class="line">        <span class="built_in">ntt</span>(t, tot, <span class="number">1</span>), <span class="built_in">ntt</span>(y, tot, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) y[i] = (<span class="number">2</span> - (LL)t[i] * y[i] % P + P) % P * y[i] % P;</span><br><span class="line">        <span class="built_in">ntt</span>(y, tot, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">fill</span>(y, <span class="number">0</span>, len, tot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polydiv</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> n, <span class="keyword">int</span> y[], <span class="keyword">int</span> m, <span class="keyword">int</span> a[], <span class="keyword">int</span> b[])</span> <span class="comment">//x除以y商a余b</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        STC <span class="keyword">int</span> ta[N], tb[N];</span><br><span class="line">        <span class="keyword">int</span> dt = n - m + <span class="number">1</span>, tot, bit;</span><br><span class="line">        <span class="built_in">ready</span>(bit, tot, n);</span><br><span class="line">        <span class="built_in">fill</span>(ta, <span class="number">0</span>, <span class="number">0</span>, tot);</span><br><span class="line">        <span class="built_in">fill</span>(tb, <span class="number">0</span>, <span class="number">0</span>, tot);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) ta[i] = y[m - i - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">polyinv</span>(ta, tb, dt);</span><br><span class="line">        <span class="built_in">get_r</span>(bit, tot);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) ta[i] = x[n - i - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">ntt</span>(ta, tot, <span class="number">1</span>), <span class="built_in">ntt</span>(tb, tot, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) ta[i] = (LL)ta[i] * tb[i] %P;</span><br><span class="line">        <span class="built_in">ntt</span>(ta, tot, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dt; ++i) a[i] = ta[dt - i - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">fill</span>(ta, <span class="number">0</span>, <span class="number">0</span>, tot);</span><br><span class="line">        <span class="built_in">fill</span>(tb, <span class="number">0</span>, <span class="number">0</span>, tot);</span><br><span class="line">        <span class="built_in">fill</span>(ta, a, <span class="number">0</span>, dt);</span><br><span class="line">        <span class="built_in">fill</span>(tb, y, <span class="number">0</span>, m);</span><br><span class="line">        <span class="built_in">ntt</span>(ta, tot, <span class="number">1</span>), <span class="built_in">ntt</span>(tb, tot, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) ta[i] = (LL)ta[i] * tb[i] % P;</span><br><span class="line">        <span class="built_in">ntt</span>(ta, tot, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; ++i) b[i] = (x[i] - ta[i] + P) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polydif</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> len)</span> <span class="comment">//求导,y记录答案</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i) y[i - <span class="number">1</span>] = (LL)x[i] * i % P;</span><br><span class="line">        y[len - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polyint</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> len)</span> <span class="comment">//积分,y记录答案</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i) y[i] = (LL)x[i - <span class="number">1</span>] * <span class="built_in">qpow</span>(i, P - <span class="number">2</span>) % P;</span><br><span class="line">        y[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polyln</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        STC <span class="keyword">int</span> a[N], b[N];</span><br><span class="line">        <span class="built_in">polydif</span>(x, a, len);</span><br><span class="line">        <span class="built_in">polyinv</span>(x, b, len);</span><br><span class="line">        <span class="keyword">int</span> bit, tot;</span><br><span class="line">        <span class="built_in">ready</span>(bit, tot, len);</span><br><span class="line">        <span class="built_in">get_r</span>(bit,tot);</span><br><span class="line">        <span class="built_in">fill</span>(a, <span class="number">0</span>, len, tot);</span><br><span class="line">        <span class="built_in">fill</span>(b, <span class="number">0</span>, len, tot);</span><br><span class="line">        <span class="built_in">ntt</span>(a, tot, <span class="number">1</span>), <span class="built_in">ntt</span>(b, tot, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) a[i] = (LL)a[i] * b[i] % P;</span><br><span class="line">        <span class="built_in">ntt</span>(a, tot, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">fill</span>(a, <span class="number">0</span>, len, tot);</span><br><span class="line">        <span class="built_in">polyint</span>(a, y, len);</span><br><span class="line">        <span class="built_in">fill</span>(y, <span class="number">0</span>, len, tot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polyexp</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(y[<span class="number">0</span>] = <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">polyexp</span>(x, y, (len + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> bit, tot;</span><br><span class="line">        STC <span class="keyword">int</span> t[N];</span><br><span class="line">        <span class="built_in">ready</span>(bit, tot, len);</span><br><span class="line">        <span class="built_in">fill</span>(t, <span class="number">0</span>, <span class="number">0</span>, tot);</span><br><span class="line">        <span class="built_in">polyln</span>(y, t, len);</span><br><span class="line">        <span class="built_in">get_r</span>(bit, tot);</span><br><span class="line">        t[<span class="number">0</span>] = (x[<span class="number">0</span>] + <span class="number">1</span> - t[<span class="number">0</span>] + P) % P;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i) t[i] = (x[i] - t[i] + P) % P;</span><br><span class="line">        <span class="built_in">fill</span>(t, <span class="number">0</span>, len, tot);</span><br><span class="line">        <span class="built_in">ntt</span>(t, tot, <span class="number">1</span>), <span class="built_in">ntt</span>(y, tot, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) y[i] = (LL)y[i] * t[i] % P;</span><br><span class="line">        <span class="built_in">ntt</span>(y, tot, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">fill</span>(y, <span class="number">0</span>, len, tot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">k1是真实指数(可以是模后的)</span></span><br><span class="line"><span class="comment">k2是真实指数模P - 1(欧拉定理)</span></span><br><span class="line"><span class="comment">k3用于确定前导0个数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polypow</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> k1, <span class="keyword">int</span> k2, <span class="keyword">int</span> k3, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!x[num] &amp;&amp; num &lt; len) ++num;</span><br><span class="line">        <span class="keyword">if</span> ((LL)num * k3 &gt;= len) <span class="keyword">return</span> <span class="built_in">fill</span>(y, <span class="number">0</span>, <span class="number">0</span>, len);</span><br><span class="line">        STC <span class="keyword">int</span> t[N];</span><br><span class="line">        <span class="keyword">int</span> x0 = x[num], inv = <span class="built_in">qpow</span>(x0, P - <span class="number">2</span>);</span><br><span class="line">        len -= num;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) x[i] = (LL)x[i + num] * inv % P;</span><br><span class="line">        <span class="keyword">int</span> bit, tot;</span><br><span class="line">        <span class="built_in">ready</span>(bit, tot, len);</span><br><span class="line">        <span class="built_in">fill</span>(t, <span class="number">0</span>, <span class="number">0</span>, tot);</span><br><span class="line">        <span class="built_in">fill</span>(x, <span class="number">0</span>, len, tot);</span><br><span class="line">        <span class="built_in">polyln</span>(x, t, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) t[i] = (LL)t[i] * k1 % P;</span><br><span class="line">        <span class="built_in">fill</span>(t, <span class="number">0</span>, len, tot);</span><br><span class="line">        <span class="built_in">polyexp</span>(t, y, len);</span><br><span class="line">        len += num;</span><br><span class="line">        x0 = <span class="built_in">qpow</span>(x0, k2);</span><br><span class="line">        num = num * k3;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= num; --i) y[i] = (LL)y[i - num] * x0 % P;</span><br><span class="line">        <span class="built_in">fill</span>(y, <span class="number">0</span>, <span class="number">0</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ready_for_pow</span><span class="params">(<span class="keyword">char</span> *k, <span class="keyword">int</span> &amp;k1, <span class="keyword">int</span> &amp;k2, <span class="keyword">int</span> &amp;k3)</span> <span class="comment">//k太大,计算k1,k2,k3</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        k1 = k2 = k3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l = <span class="built_in">strlen</span>(k + <span class="number">1</span>); i &lt;= l; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            k1 = ((LL)k1 * <span class="number">10</span> + (k[i] ^ <span class="number">48</span>)) % P;</span><br><span class="line">            k2 = ((LL)k2 * <span class="number">10</span> + (k[i] ^ <span class="number">48</span>)) % (P - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> ((LL)k3 * <span class="number">10</span> + (k[i] ^ <span class="number">48</span>) &lt;= P) k3 = (LL)k3 * <span class="number">10</span> + (k[i] ^ <span class="number">48</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polysqrt</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sq = Cipolla::<span class="built_in">Csqrt</span>(x[<span class="number">0</span>]), inv = <span class="built_in">qpow</span>(x[<span class="number">0</span>], P - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) x[i] = (LL)x[i] * inv % P;</span><br><span class="line">        <span class="built_in">polypow</span>(x, y, (P + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, (P + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, <span class="number">1</span>, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) y[i] = (LL)y[i] * sq % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polysin</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        STC <span class="keyword">int</span> a[N], b[N], c[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) a[i] = (LL)x[i] * I % P;</span><br><span class="line">        <span class="built_in">polyexp</span>(a, b, len);</span><br><span class="line">        <span class="built_in">polyinv</span>(b, c, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) b[i] = (b[i] - c[i] + P) % P;</span><br><span class="line">        <span class="keyword">int</span> inv = <span class="built_in">qpow</span>((I &lt;&lt; <span class="number">1</span>) % P, P - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) y[i] = (LL)b[i] * inv % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polycos</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        STC <span class="keyword">int</span> a[N], b[N], c[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) a[i] = (LL)x[i] * I % P;</span><br><span class="line">        <span class="built_in">polyexp</span>(a, b, len);</span><br><span class="line">        <span class="built_in">polyinv</span>(b, c, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) b[i] = (b[i] + c[i]) % P;</span><br><span class="line">        <span class="keyword">int</span> inv = <span class="built_in">qpow</span>(<span class="number">2</span>, P - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) y[i] = (LL)b[i] * inv % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polytan</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        STC <span class="keyword">int</span> a[N], b[N], c[N];</span><br><span class="line">        <span class="built_in">polysin</span>(x, a, len);</span><br><span class="line">        <span class="built_in">polycos</span>(x, b, len);</span><br><span class="line">        <span class="built_in">polyinv</span>(b, c, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) y[i] = a[i] * c[i] % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polyasin</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        STC <span class="keyword">int</span> a[N], b[N], c[N];</span><br><span class="line">        <span class="built_in">polydif</span>(x, a, len);</span><br><span class="line">        <span class="keyword">int</span> bit, tot;</span><br><span class="line">        <span class="built_in">ready</span>(bit, tot, len);</span><br><span class="line">        <span class="built_in">get_r</span>(bit, tot);</span><br><span class="line">        <span class="built_in">ntt</span>(x, tot, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) b[i] = (<span class="number">1</span> - (LL)x[i] * x[i]% P + P) % P;</span><br><span class="line">        <span class="built_in">ntt</span>(b, tot, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">fill</span>(b, <span class="number">0</span>, len, tot);</span><br><span class="line">        <span class="built_in">polysqrt</span>(b, c, len);</span><br><span class="line">        <span class="built_in">fill</span>(b, <span class="number">0</span>, <span class="number">0</span>, tot);</span><br><span class="line">        <span class="built_in">polyinv</span>(c, b, len);</span><br><span class="line">        <span class="built_in">ntt</span>(a, tot, <span class="number">1</span>), <span class="built_in">ntt</span>(b, tot, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) a[i] = (LL)a[i] * b[i] % P;</span><br><span class="line">        <span class="built_in">ntt</span>(a, tot, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">polyint</span>(a, y, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polyacos</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">polyasin</span>(x, y, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) y[i] = y[i] ? P - y[i] : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">polyatan</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        STC <span class="keyword">int</span> a[N], b[N], c[N];</span><br><span class="line">        <span class="built_in">polydif</span>(x, a, len);</span><br><span class="line">        <span class="keyword">int</span> bit, tot;</span><br><span class="line">        <span class="built_in">ready</span>(bit, tot, len);</span><br><span class="line">        <span class="built_in">get_r</span>(bit, tot);</span><br><span class="line">        <span class="built_in">ntt</span>(x, tot, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) b[i] = (<span class="number">1</span> + (LL)x[i] * x[i]% P) % P;</span><br><span class="line">        <span class="built_in">ntt</span>(b, tot, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">fill</span>(b, <span class="number">0</span>, len, tot);</span><br><span class="line">        <span class="built_in">polyinv</span>(b, c, len);</span><br><span class="line">        <span class="built_in">ntt</span>(a, tot, <span class="number">1</span>), <span class="built_in">ntt</span>(c, tot, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) a[i] = (LL)a[i] * c[i] % P;</span><br><span class="line">        <span class="built_in">ntt</span>(a, tot, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">polyint</span>(a, y, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h1><h2 id="浮点数比较"><a href="#浮点数比较" class="headerlink" title="浮点数比较"></a>浮点数比较</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(DB x, DB y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(x - y) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="平面最近点对"><a href="#平面最近点对" class="headerlink" title="平面最近点对"></a>平面最近点对</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LDB p[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Point &amp;t) <span class="keyword">const</span> &#123; <span class="keyword">return</span> p[<span class="number">0</span>] * p[<span class="number">1</span>] &lt; t.p[<span class="number">0</span>] * t.p[<span class="number">1</span>]; &#125;</span><br><span class="line">&#125; p[N];</span><br><span class="line"><span class="function">std::mt19937 <span class="title">rud</span><span class="params">(<span class="number">114514</span>)</span></span>;</span><br><span class="line">LDB th = <span class="built_in">rud</span>(), ans = INF;</span><br><span class="line">LDB z = <span class="built_in">sin</span>(th), w = <span class="built_in">cos</span>(th);</span><br><span class="line">LDB a, b, c, d;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%Lf %Lf&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    p[i] = &#123;a * w + b * z, -a * z + b * w, a, b&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">stable_sort</span>(p + <span class="number">1</span>, p + <span class="number">1</span> + n); <span class="comment">//stable是稳定排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    a = p[i].p[<span class="number">2</span>], b = p[i].p[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= K &amp;&amp; i + j &lt;= n; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        c = p[i + j].p[<span class="number">2</span>], d = p[i + j].p[<span class="number">3</span>];</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, (a - c) * (a - c) + (b - d) * (b - d));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="点间距离"><a href="#点间距离" class="headerlink" title="点间距离"></a>点间距离</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DB <span class="title">dist</span><span class="params">(Point x, Point y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point t = x - y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(t.x * t.x + t.y * t.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><p>用点表示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DB x, y;</span><br><span class="line">Point <span class="keyword">operator</span> + (Point t)&#123; <span class="keyword">return</span> (Point)&#123;x + t.x, y + t.y&#125;; &#125;</span><br><span class="line">Point <span class="keyword">operator</span> - (Point t)&#123; <span class="keyword">return</span> (Point)&#123;x - t.x, y - t.y&#125;; &#125;</span><br><span class="line">Point <span class="keyword">operator</span> * (DB t)&#123; <span class="keyword">return</span> (Point)&#123;x * t, y * t&#125;; &#125;</span><br><span class="line">DB <span class="keyword">operator</span> &amp; (Point t)&#123; <span class="keyword">return</span> x * t.x + y * t.y; &#125; <span class="comment">//点乘</span></span><br><span class="line">DB <span class="keyword">operator</span> * (Point t)&#123; <span class="keyword">return</span> x * t.y - y * t.x; &#125; <span class="comment">//叉乘</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DB <span class="title">mo</span><span class="params">(Point x)</span></span>&#123; <span class="keyword">return</span> std::<span class="built_in">sqrt</span>(x &amp; x); &#125; <span class="comment">//模长</span></span><br><span class="line"><span class="function">DB <span class="title">angle</span><span class="params">(Point x, Point y)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">acos</span>((x &amp; y) / <span class="built_in">mo</span>(x) / <span class="built_in">mo</span>(y)); &#125; <span class="comment">//计算向量夹角</span></span><br><span class="line"><span class="function">Point <span class="title">rot</span><span class="params">(Point x, DB theta)</span> <span class="comment">//向量(点)顺时针旋转角度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;x.x * <span class="built_in">cos</span>(theta) + x.y * <span class="built_in">sin</span>(theta), -x.x * <span class="built_in">sin</span>(theta) + x.y * <span class="built_in">cos</span>(theta)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DB <span class="title">area</span><span class="params">(Point x, Point y, Point z)</span></span>&#123; <span class="keyword">return</span> (y - x) * (z - x); &#125; <span class="comment">//计算XY,XZ围成平行四边形面积</span></span><br></pre></td></tr></table></figure><h2 id="点与线"><a href="#点与线" class="headerlink" title="点与线"></a>点与线</h2><p>点到直线距离：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DB <span class="title">dis_z</span><span class="params">(Point p, Point x, Point y)</span> <span class="comment">//p到直线(x-&gt;y)的距离</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point u = y - x, v = p - x;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>((u * v) / <span class="built_in">mo</span>(u));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点到线段距离：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DB <span class="title">dis_x</span><span class="params">(Point p, Point x, Point y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="built_in">mo</span>(p - x);</span><br><span class="line">    Point u = y - x, v = p - x, w = p - y;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cmp</span>(u &amp; v, <span class="number">0</span>) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">mo</span>(v);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cmp</span>(u &amp; w, <span class="number">0</span>) &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">mo</span>(w);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dis_z</span>(p, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点在直线上的投影：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DB <span class="title">proj</span><span class="params">(Point p, Point x, Point y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point u = y - x;</span><br><span class="line">    <span class="keyword">return</span> x + u * (u &amp; (p - x)) / (u &amp; u));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点是否在直线上：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_on</span><span class="params">(Point p, Point x, Point y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">cmp</span>((p - x) * (p - y), <span class="number">0</span>) &amp;&amp; <span class="built_in">cmp</span>((p - x) &amp; (p - y), <span class="number">0</span>) &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线与线"><a href="#线与线" class="headerlink" title="线与线"></a>线与线</h2><p>直线交点：</p><p> 注意点向式表达直线： $p = p_0 + t \vec{v}$ </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">jiao</span><span class="params">(Point p, Point u, Point q, Point v)</span> <span class="comment">//点项式</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u * v == <span class="number">0</span>) <span class="keyword">return</span> &#123;INF, INF&#125;; <span class="comment">//平行或者重合</span></span><br><span class="line">    DB t = (p - q) * v / (u * v);</span><br><span class="line">    <span class="keyword">return</span> p + u * t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断线段是否相交：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_jiao</span><span class="params">(Point x_1, Point y_1, Point x_2, Point y_2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> c1 = <span class="built_in">cross</span>(y_1 - x_1, x_2 - x_1), c2 = <span class="built_in">cross</span>(y_1 - x_1, y_2 - x_1);</span><br><span class="line">    <span class="keyword">double</span> c3 = <span class="built_in">cross</span>(y_2 - x_2, y_1 - x_2), c4 = <span class="built_in">cross</span>(y_2 - x_2, x_1 - x_2);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cmp</span>(c1, <span class="number">0</span>) * <span class="built_in">cmp</span>(c2, <span class="number">0</span>) &lt;= <span class="number">0</span> &amp;&amp; <span class="built_in">cmp</span>(c3, <span class="number">0</span>) * <span class="built_in">cmp</span>(c4, <span class="number">0</span>) &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多边形"><a href="#多边形" class="headerlink" title="多边形"></a>多边形</h2><p>按<strong>逆时针</strong>存储所有点</p><p>面积：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DB <span class="title">pgarea</span><span class="params">(Point p[], <span class="keyword">int</span> n)</span> <span class="comment">//polygon area</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DB res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i) res += (p[i] - p[<span class="number">0</span>]) * (p[i + <span class="number">1</span>] - p[<span class="number">0</span>]); <span class="comment">// //这里点编号为0~n-1</span></span><br><span class="line">    <span class="keyword">return</span> res / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断点是否在多边形内：</p><p>射线法，从该点任意做一条和所有边都不平行的射线，交点个数为偶数，则在多边形外，为奇数，则在多边形内</p><h2 id="最小圆覆盖"><a href="#最小圆覆盖" class="headerlink" title="最小圆覆盖"></a>最小圆覆盖</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::mt19937 <span class="title">rud</span><span class="params">(<span class="number">114514</span>)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span>&#123;</span> Point p; DB r; &#125; ;</span><br><span class="line"><span class="function">PR&lt;Point, Point&gt; <span class="title">get_line</span><span class="params">(Point x, Point y)</span> </span>&#123; <span class="keyword">return</span> &#123;(x + y) / <span class="number">2</span>, <span class="built_in">rotate</span>(y - x, PI / <span class="number">2</span>)&#125;; &#125; <span class="comment">//找中垂线</span></span><br><span class="line"><span class="function">Circle <span class="title">get_c</span><span class="params">(Point x, Point y, Point z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> u = <span class="built_in">get_line</span>(x, y), v = <span class="built_in">get_line</span>(x, z);</span><br><span class="line">    <span class="keyword">auto</span> p = <span class="built_in">jiao</span>(u.first, u.second, v.first, v.second);</span><br><span class="line">    <span class="keyword">return</span> &#123;p, <span class="built_in">dist</span>(p, x)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(Point p[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::<span class="built_in">shuffle</span>(q, q + n, rud);</span><br><span class="line">    <span class="function">Circle <span class="title">c</span><span class="params">(&#123;q[<span class="number">0</span>], <span class="number">0</span>&#125;)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) <span class="keyword">if</span> (<span class="built_in">cmp</span>(c.r, <span class="built_in">dist</span>(c.p, q[i])) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c = &#123;q[i], <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) <span class="keyword">if</span> (<span class="built_in">cmp</span>(c.r, <span class="built_in">dist</span>(c.p, q[j])) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            c = &#123;(q[i] + q[j]) / <span class="number">2</span>, <span class="built_in">dist</span>(q[i], q[j]) / <span class="number">2</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; j; ++k) <span class="keyword">if</span> (<span class="built_in">cmp</span>(c.r, <span class="built_in">dist</span>(c.p, q[k])) &lt; <span class="number">0</span>) c = <span class="built_in">get_c</span>(q[i], q[j], q[k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DB <span class="title">andrew</span><span class="params">(Point x[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    STC <span class="keyword">int</span> stk[N];</span><br><span class="line">    STC <span class="keyword">bool</span> used[N];</span><br><span class="line">    std::<span class="built_in">sort</span>(x, x + n);</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &gt;= <span class="number">2</span> &amp;&amp; <span class="built_in">area</span>(x[stk[top - <span class="number">1</span>]], x[stk[top]], x[i]) &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 凸包边界上的点即使被从栈中删掉，也不能删掉used上的标记</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">area</span>(x[stk[top - <span class="number">1</span>]], x[stk[top]], x[i])) --top;</span><br><span class="line">            <span class="keyword">else</span> used[stk[top--]] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stk[++top] = i;</span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    used[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (used[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//为了应对所有点共线的情况,这里不能取&lt;=</span></span><br><span class="line">        <span class="keyword">while</span> (top &gt;= <span class="number">2</span> &amp;&amp; <span class="built_in">area</span>(x[stk[top - <span class="number">1</span>]], x[stk[top]], x[i]) &lt; <span class="number">0</span>) --top;</span><br><span class="line">        stk[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    DB res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= top; ++i) res += <span class="built_in">dist</span>(x[stk[i - <span class="number">1</span>]], x[stk[i]]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数也叫 <code>convex(int x[], int n)</code> </p><h2 id="半平面交"><a href="#半平面交" class="headerlink" title="半平面交"></a>半平面交</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Point st, ed;</span><br><span class="line"><span class="function">DB <span class="title">angle</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="built_in">atan2</span>(ed.y - st.y, ed.x - st.x); &#125;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="function">Point <span class="title">jiao</span><span class="params">(Line x, Line y)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">jiao</span>(x.st, x.ed - x.st, y.st, y.ed - y.st); &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">on_r</span><span class="params">(Line &amp;x, Line y, Line z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Point o = <span class="built_in">jiao</span>(y, z);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">cmp</span>(<span class="built_in">area</span>(x.st, x.ed, o), <span class="number">0</span>) &lt;= <span class="number">0</span>; <span class="comment">//这里取不取等依题意</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DB <span class="title">halfp</span><span class="params">(Line x[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(x, x + len);</span><br><span class="line"><span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">STC <span class="keyword">int</span> q[N];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &amp;&amp; !<span class="built_in">cmp</span>(x[i].<span class="built_in">angle</span>(), x[i - <span class="number">1</span>].<span class="built_in">angle</span>())) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_r</span>(x[i], x[q[tt - <span class="number">1</span>]], x[q[tt]])) --tt;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_r</span>(x[i], x[q[hh + <span class="number">1</span>]], x[q[hh]])) ++hh;</span><br><span class="line">q[++tt] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_r</span>(x[q[hh]], x[q[tt - <span class="number">1</span>]], x[q[tt]])) --tt;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_r</span>(x[q[tt]], x[q[hh + <span class="number">1</span>]], x[q[hh]])) ++hh;</span><br><span class="line">q[++tt] = q[hh];</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = hh; i &lt; tt; ++i) ans[k++] = <span class="built_in">jiao</span>(x[q[i]], x[q[i + <span class="number">1</span>]]);</span><br><span class="line">   DB res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + <span class="number">1</span> &lt; k; ++i) res += <span class="built_in">area</span>(ans[<span class="number">0</span>], ans[i], ans[i + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> res / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="旋转卡壳"><a href="#旋转卡壳" class="headerlink" title="旋转卡壳"></a>旋转卡壳</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DB <span class="title">rot_cal</span><span class="params">(Point x[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">convex</span>(x, len);</span><br><span class="line">    <span class="keyword">if</span> (top &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">dist</span>(x[<span class="number">0</span>], x[len - <span class="number">1</span>]);</span><br><span class="line">    DB res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">2</span>; i &lt; top; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> d = x[stk[i]], e = x[stk[i + <span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">area</span>(d, e, x[stk[j]]) &lt; <span class="built_in">area</span>(d, e, x[stk[j + <span class="number">1</span>]])) j = (j + <span class="number">1</span>) % top;</span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="built_in">max</span>(<span class="built_in">dist</span>(d, x[stk[j]]), <span class="built_in">dist</span>(e, x[stk[j]])));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = <span class="built_in">LL</span>(x) * x % P) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = <span class="built_in">LL</span>(res) * x % P;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="光速幂"><a href="#光速幂" class="headerlink" title="光速幂"></a>光速幂</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BL = (<span class="number">1</span> &lt;&lt; <span class="number">16</span>) + <span class="number">5</span>, B = <span class="built_in">sqrt</span>(P);</span><br><span class="line"><span class="keyword">int</span> qp[BL][<span class="number">2</span>], ph;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= x; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) res = res / x * (x - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ph = <span class="built_in">phi</span>(P);</span><br><span class="line">    qp[<span class="number">0</span>][<span class="number">0</span>] = qp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= B; ++i) qp[i][<span class="number">0</span>] = qp[i - <span class="number">1</span>][<span class="number">0</span>] * x % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= B; ++i) qp[i][<span class="number">1</span>] = qp[i - <span class="number">1</span>][<span class="number">1</span>] * qp[B][<span class="number">0</span>] % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qqpow</span><span class="params">(<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    y %= ph;</span><br><span class="line">    <span class="keyword">return</span> qp[y % B][<span class="number">0</span>] * qp[y / B][<span class="number">1</span>] % P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="龟速乘"><a href="#龟速乘" class="headerlink" title="龟速乘"></a>龟速乘</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">mul</span><span class="params">(LL x, LL y, LL p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (x + x) % P) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (res + x) % P;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h2><p>质数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[i]) pri[++cnt] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; <span class="built_in">LL</span>(pri[j]) * i &lt;= n; ++j)</span><br><span class="line">&#123;</span><br><span class="line">vis[pri[j] * i] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>莫比乌斯函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mu[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 1特判</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[i]) pri[++cnt] = i, mu[i] = <span class="number">-1</span>; <span class="comment">//质数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; <span class="built_in">LL</span>(pri[j]) * i &lt;= n; ++j)</span><br><span class="line">&#123;</span><br><span class="line">vis[pri[j] * i] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>) <span class="comment">//若有一个质因数指数大于1</span></span><br><span class="line">&#123; </span><br><span class="line">mu[i * pri[j]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">mu[i * pri[j]] = -mu[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>欧拉函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[i]) pri[++cnt] = i, phi[i] = i - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; <span class="built_in">LL</span>(pri[j]) * i &lt;= n; ++j)</span><br><span class="line">&#123;</span><br><span class="line">vis[pri[j] * i] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">phi[i * pri[j]] = phi[i] * pri[j];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">phi[i * pri[j]] = phi[i] * (pri[j] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分解因数-质因数"><a href="#分解因数-质因数" class="headerlink" title="分解因数/质因数"></a>分解因数/质因数</h2><p>根号暴力即可</p><h2 id="数论分块"><a href="#数论分块" class="headerlink" title="数论分块"></a>数论分块</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">r = n / (n / l);</span><br><span class="line">[l, r]之间的数的(n/i)都相等</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">return</span> y ? <span class="built_in">gcd</span>(y, x % y) : x; &#125;</span><br></pre></td></tr></table></figure><p>拓展版：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!b) <span class="keyword">return</span> x = <span class="number">1</span>, y = <span class="number">0</span>, a;</span><br><span class="line"><span class="keyword">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">y -= a / b * x;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BSGS"><a href="#BSGS" class="headerlink" title="BSGS"></a>BSGS</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsgs</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> % p == b % p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> k = <span class="built_in">sqrt</span>(p) + <span class="number">1</span>;</span><br><span class="line">std::map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ha;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = b % p; i &lt; k; ++i)</span><br><span class="line">&#123;</span><br><span class="line">ha[j] = i;</span><br><span class="line">j = (LL)j * a % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ak = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) ak = (LL)ak * a % p;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = ak; i &lt;= k; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ha.<span class="built_in">find</span>(j) != ha.<span class="built_in">end</span>()) <span class="keyword">return</span> i * k - ha[j];</span><br><span class="line">j = (LL)j * ak % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -INF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拓展版：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exbsgs</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">b = (b % p + p) % p; <span class="comment">//保证b为正数</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> % p == b % p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">int</span> d = <span class="built_in">exgcd</span>(a, p, x, y);</span><br><span class="line"><span class="keyword">if</span> (d &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (b % d) <span class="keyword">return</span> -INF;</span><br><span class="line"><span class="built_in">exgcd</span>(a / d, p / d, x, y);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">exbsgs</span>(a, (LL)b / d * x % (p / d), p / d) + <span class="number">1</span>; <span class="comment">//注意加1 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">bsgs</span>(a, b, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">crt</span><span class="params">(<span class="keyword">int</span> m[], <span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL M = <span class="number">1</span>, res = <span class="number">0</span>, mt, x, y;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) M *= m[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">mt = M / m[i];</span><br><span class="line"><span class="built_in">exgcd</span>(mt, m[i], x, y);</span><br><span class="line">res += mt * a[i] * (x &lt; <span class="number">0</span> ? x + m[t] : x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拓展：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">excrt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL x, y, k, M = m[<span class="number">1</span>], res = a[<span class="number">1</span>]; <span class="comment">//第一个方程的解特判</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">LL a = M, b = m[i], c = (a[i] - res % b + b) % b; <span class="comment">// ax = c (p b)</span></span><br><span class="line">LL d = <span class="built_in">exgcd</span>(a, b, x, y), bg = b / d;</span><br><span class="line"><span class="keyword">if</span> (c % d != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//判断是否无解</span></span><br><span class="line">x = <span class="built_in">mul</span>(x, c / d, bg); <span class="comment">//龟速乘</span></span><br><span class="line">res += x * M; <span class="comment">//更新前k个方程组的答案</span></span><br><span class="line">M *= bg;  <span class="comment">// M为前k个m的lcm</span></span><br><span class="line">res = (res % M + M) % M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (res % M + M) % M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逆元递推式"><a href="#逆元递推式" class="headerlink" title="逆元递推式"></a>逆元递推式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) inv[i] = -(P / i) * inv[P % i];</span><br></pre></td></tr></table></figure><h2 id="斐波拉契数列推导"><a href="#斐波拉契数列推导" class="headerlink" title="斐波拉契数列推导"></a>斐波拉契数列推导</h2><p>$$<br>\begin{aligned}<br>&amp; 设系数r,s使得: \\<br>&amp; F(n) - r F(n - 1) = s[F(n - 1) - rF(n - 2)] \\<br>&amp; F(n) = (s + r)F(n - 1) - sr F(n - 2) \\<br>&amp; 那么有: \\<br>&amp; r + s = 1, rs = -1 \\<br>&amp; 再考虑这些式子: \\<br>&amp; \begin{cases}<br>F(n) - rF(n - 1) = s [F(n - 1) - rF(n - 2)] \\<br>F(n - 1) - rF(n - 2) = s [F(n - 2) - rF(n - 3)] \\<br>…\\<br>F(3) - F(2) = s [F(2) - r F(1)]<br>\end{cases} \\<br>&amp; 联立得: \\<br>&amp; F(n) - rF(n - 1) = s^{n - 2} [F(2) - F(1)] \\<br>&amp; 又因为: s = 1 - r, F(1) = F(2) = 1 \\<br>&amp; 有: F(n) = s^{n - 1} + r F(n - 1) \\<br>&amp; F(n) = s^{n - 1} + r F(n - 1) \\<br>&amp; F(n) = s^{n - 1} + r s^{n - 2} + r^{2} F(n - 2) \\<br>&amp; … \\<br>&amp; F(n) = s^{n - 1} + r s^{n - 2} + r^{2} s^{n - 3} + … + r^{n - 2} s + r^{n - 1} \\<br>&amp; 等比数列求和得: F(n) = \frac{s^{n - 1} - r^{n - 1}\frac{r}{s}}{1 - \frac{r}{s}} \\<br>&amp; F(n) = \frac{s^n - r^n}{s - r} \\<br>&amp; 再由: r + s = 1, rs = -1得: \\<br>&amp; \begin{cases}<br>s = \frac{1 + \sqrt{5}}{2} \\<br>r = \frac{1 - \sqrt{5}}{2}<br>\end{cases} \\<br>&amp; 于是 F(n) = \frac{\sqrt{5}}{5}[(\frac{1 + \sqrt{5}}{2})^n - (\frac{1 - \sqrt{5}}{2})^n]<br>\end{aligned}<br>$$</p><h2 id="威尔逊定理"><a href="#威尔逊定理" class="headerlink" title="威尔逊定理"></a>威尔逊定理</h2><p>$(P - 1)! \equiv -1 \pmod P$ </p><h2 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h2><p>$a^b \equiv a^{b \mod \varphi(P)} \pmod P$ </p><p>顺便还有欧拉函数的一个运用：<br>$$<br>[1 \sim n] 之间与 m 互质的数的个数为 Ans = \frac{n}{m} \varphi(m)<br>$$<br>再给出计算式： $\varphi(x) = x \prod \frac{p - 1}{p}, 其中p是x的质因数$ </p><h2 id="Miller-Rabin-素数测试"><a href="#Miller-Rabin-素数测试" class="headerlink" title="Miller-Rabin 素数测试"></a>Miller-Rabin 素数测试</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="function">std::mt19937 <span class="title">rud</span><span class="params">(<span class="number">114514</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>) <span class="keyword">return</span> a % p;</span><br><span class="line">    <span class="keyword">int</span> w = <span class="built_in">exp</span>(a, m / <span class="number">2</span>, p);</span><br><span class="line">    w = <span class="built_in">LL</span>(w) * w % p;</span><br><span class="line">    <span class="keyword">if</span> (m &amp; <span class="number">1</span>) w = <span class="built_in">LL</span>(w) * a % p;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">miller_rabin</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="built_in">rud</span>() % (n - <span class="number">2</span>) + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">exp</span>(a, n, n) != a) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="组合计数"><a href="#组合计数" class="headerlink" title="组合计数"></a>组合计数</h1><h2 id="组合数计算"><a href="#组合数计算" class="headerlink" title="组合数计算"></a>组合数计算</h2><p>$A_n^m = \frac{n!}{(n - m)!}$ </p><p>$C_n^m = \binom{n}{m} =  \frac{A_n^m}{m!} = \frac{n!}{m!(n - m)!}$ </p><p>特别的，当 $m &gt; n$ 时， $C_n^m = A_n^m = 0$ </p><p>多重排列： $\binom{n}{n_1, n_2, …, n_k} = \frac{n!}{\prod n_i!}$ </p><p>错位排列： $f(n) = (n - 1)(f(n - 1) + f(n - 2))$ </p><p>错位排列2 ： $f(n) = n!(\frac{1}{1!} - \frac{1}{2!} + \frac{1}{3!} - … + (-1)^{n - 1} \frac{1}{n!})$ </p><p> 圆排： $Q_n^r = \frac{A_n^r}{r}$  </p><p>组合数的一些性质：<br>$$<br>\begin{aligned}<br>&amp; \binom{n}{m} = \binom{n}{n - m} \\<br>&amp; \binom{n}{k} = \frac{n}{k} \binom{n - 1}{k - 1} \\<br>&amp; \binom{n}{m} = \binom{n - 1}{m} + \binom{n - 1}{m} \\<br>&amp; \binom{n}{0} + \binom{n}{1} + … + \binom{n}{n} = 2^n \\<br>&amp; \sum_{0}^n (-1)^i \binom{n}{i} = [n == 0] \<br>&amp; \sum_{i = 0}^{m} \binom{n}{i} \binom{m}{m - i} = \binom{m + n}{m} (n \ge m)\\<br>&amp; \sum_{i = 0}^n \binom{n}{i}^2 = \binom{2n}{n} \\<br>&amp; \sum_{i = 0}^n i \binom{n}{i} = n 2^{n - 1} \\<br>&amp; \sum_{i = 0}^n i^2 \binom{n}{i} = n (n + 1) 2^{n - 2} \\<br>&amp; \sum_{i = 0}^n \binom{i}{k} = \binom{n + 1}{k + 1} \\<br>&amp; \binom{n}{t} \binom{t}{k} = \binom{n}{k} = \binom{n - k}{t - k} \\<br>&amp; \sum_{i = 0}^n \binom{n - i}{i} = F(n + 1) (其中F(n + 1)表示斐波拉契数列)<br>\end{aligned}<br>$$</p><h2 id="Lucas-定理"><a href="#Lucas-定理" class="headerlink" title="Lucas 定理"></a>Lucas 定理</h2><p>$\binom{n}{m} \mod P = \binom{\lfloor n / P \rfloor}{\lfloor m / P \rfloor} * \binom{n \mod P}{m \mod P} \mod P$ </p><h2 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h2><p>$$<br>\begin{aligned}<br>&amp; Cat(n) = \frac{\binom{2n}{n}}{n + 1} \\<br>&amp; Cat(n) =<br>\begin{cases}<br>\sum_{i = 1}^n Cat(i - 1)Cat(n - i) &amp; n \ge 2 \\<br>1 &amp; n = 0, 1<br>\end{cases} \\<br>&amp; Cat(n) = \frac{Cat(n - 1)(4n - 2)}{n + 1} \\<br>&amp; Cat(n) = \binom{2n}{n} - \binom{2n}{n - 1}<br>\end{aligned}<br>$$</p><h2 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h2><p>$$<br>\begin{aligned}<br>&amp; F(n) = \sum_{d \mid n} f(d) \Rightarrow f(n) = \sum_{d \mid n} \mu(d) F(\frac{n}{d}) \\<br>&amp; F(n) = \sum_{n \mid d} f(d) \Rightarrow f(n) = \sum_{n \mid d} \mu(\frac{d}{n}) F(d) \\<br>&amp; \sum_{d \mid n} \mu(d) = [n == 1] \\<br>&amp; \sum_{d \mid n} \frac{\mu(d)}{d} = \frac{\varphi(n)}{n} \\<br>&amp; d(nm) = \sum_{i \mid n} \sum_{j \mid m} [\gcd(i, j) == 1] (其中d(x)表示x的约数个数)<br>\end{aligned}<br>$$</p><h2 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h2><p>普通型 OGF ：<br>$$<br>\begin{aligned}<br>&amp; \prod_{i = 1}^n( \sum_{m \in M_i} x^m) (其中M_i是a_i的出现次数集合) \\<br>&amp; 常见的有: \\<br>&amp; \frac{1}{(1 - x)^n} = 1 + nx + \frac{n * (n + 1)}{2!}x^2 + \frac{n * (n + 1) * (n + 2)}{3!} + … \\<br>&amp; \frac{1}{1 - x} = 1 + x + x^2 + x^3 + …<br>\end{aligned}<br>$$<br>指数型 EGF ：<br>$$<br>\begin{aligned}<br>&amp; \prod_{i = 1}^n( \sum_{m \in M_i} \frac{x^m}{m!}) (其中M_i是a_i的出现次数集合) \\<br>&amp; 常见的有: \\<br>&amp; e^x = \sum_{n = 0}^{\infty} \frac{x^n}{n!} = 1 + x + \frac{x^2}{2!} + … \\<br>&amp; \frac{e^x + e{-x}}{2} = \sum_{n = 0}^{\infty} \frac{x^{2n}}{(2n)!} = 1 + \frac{x^2}{2!} + \frac{x^4}{4!} + … \\<br>&amp; \frac{e^x - e^{-x}}{2} = \sum_{n = 0}^{\infty} \frac{x^{2n + 1}}{(2n + 1)!} = x + \frac{x^3}{3!} + \frac{x^5}{5!} + …<br>\end{aligned}<br>$$</p><h1 id="群论"><a href="#群论" class="headerlink" title="群论"></a>群论</h1><h2 id="置换群"><a href="#置换群" class="headerlink" title="置换群"></a>置换群</h2><p> $n$ 个元素 $1, 2, …, n$ 之间的一个置换 $f = \binom{1, 2, 3, …, n}{a_1, a_2, a_3, …, a_n}$ ，表示“ $1$ 被 $a_1$ 取代， $2$ 被 $a_2$ 取代，依此类推”，其中 $a_1, a_2, …, a_n$是 $1 \sim n$ 的一个排列</p><h2 id="Burnside-引理"><a href="#Burnside-引理" class="headerlink" title="Burnside 引理"></a>Burnside 引理</h2><p>$$<br>L = \frac{1}{\mid G \mid} \sum_{j = 1}^s D(a_j)<br>$$</p><p>其中 $L$ 表示本质不同的方案数，$D(a_j)$  表示在置换 $a_i$ 下不变的元素个数， $\mid G \mid$ 是置换群大小</p><h2 id="Polya-定理"><a href="#Polya-定理" class="headerlink" title="Polya 定理"></a>Polya 定理</h2><p>记 $c(f)$ 为置换 $f$ 的循环节个数， .$m$ 为颜色总数，有 $D(f) = m^{c(f)}$  ，则有：<br>$$<br>L = \frac{1}{\mid G \mid} (\sum_{j = 1}^s m^{c(a_j)})<br>$$</p><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mtx</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DB x[N][N];</span><br><span class="line">    DB* <span class="keyword">operator</span> [] (<span class="keyword">int</span> id)&#123; <span class="keyword">return</span> x[id]; &#125;</span><br><span class="line">&#125; a;</span><br></pre></td></tr></table></figure><h2 id="LU分解"><a href="#LU分解" class="headerlink" title="LU分解"></a>LU分解</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> DLT <span class="comment">//Doolittle</span></span><br><span class="line">&#123;</span><br><span class="line">    Mtx l, u;</span><br><span class="line">    DB X[N], Y[N];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_lu</span><span class="params">(Mtx x, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k, i, j, r;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= len; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = k; j &lt;= len; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                u[k][j] = x[k][j];</span><br><span class="line">                <span class="keyword">for</span> (r = k - <span class="number">1</span>; r; --r) u[k][j] -= l[k][r] * u[r][j];</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">fabs</span>(u[k][j]) &lt; eps) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!(<span class="built_in">fabs</span>(u[k][j]) &gt; eps)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i = k; i &lt;= len; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                l[i][k] = x[i][k];</span><br><span class="line">                <span class="keyword">for</span> (r = k - <span class="number">1</span>; r; --r) l[i][k] -= l[i][r] * u[r][k];</span><br><span class="line">                l[i][k] /= u[k][k];</span><br><span class="line">            &#125;</span><br><span class="line">            l[k][k] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(DB x[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k, r;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= len; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            Y[k] = x[k];</span><br><span class="line">            <span class="keyword">for</span> (r = k - <span class="number">1</span>; r; --r) Y[k] -= l[k][r] * Y[r];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (k = len; k; --k)</span><br><span class="line">        &#123;</span><br><span class="line">            X[k] = Y[k];</span><br><span class="line">            <span class="keyword">for</span> (r = k + <span class="number">1</span>; r &lt;= len; ++r) X[k] -= u[k][r] * X[r];</span><br><span class="line">            X[k] /= u[k][k];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(X[k]) &lt; eps) X[k] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">guass</span><span class="params">(Mtx &amp;x, <span class="keyword">int</span> len)</span> <span class="comment">//注意传实参</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, t, now;</span><br><span class="line">    <span class="keyword">for</span> (i = now = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t = now;</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &lt;= len; ++j) <span class="keyword">if</span> (<span class="built_in">fabs</span>(x[j][i]) &gt; <span class="built_in">fabs</span>(x[t][i])) t = j;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(x[t][i]) &lt; eps) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (t != now) std::<span class="built_in">swap</span>(x.x[t], x.x[now]);</span><br><span class="line">        <span class="keyword">for</span> (j = len + <span class="number">1</span>; j &gt;= i; --j) x[now][j] /= x[now][i];</span><br><span class="line">        <span class="keyword">for</span> (j = now + <span class="number">1</span>; j &lt;= len; ++j) <span class="keyword">if</span> (<span class="built_in">fabs</span>(x[j][i]))</span><br><span class="line">            <span class="keyword">for</span> (k = len + <span class="number">1</span>; k &gt;= i; --k) x[j][k] -= x[j][i] * x[now][k];</span><br><span class="line">        ++now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (now &lt;= len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = now; i &lt;= len; ++i) <span class="keyword">if</span> (<span class="built_in">fabs</span>(x[i][len + <span class="number">1</span>]) &gt; eps) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> len - now + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = len; i; --i)</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= len; ++j) x[i][len + <span class="number">1</span>] -= x[i][j] * x[j][len + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = len; i; --i) <span class="keyword">if</span> (<span class="built_in">fabs</span>(x[i][len + <span class="number">1</span>]) &lt; eps) x[i][len + <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//防止出现-0.00</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="矩阵求逆"><a href="#矩阵求逆" class="headerlink" title="矩阵求逆"></a>矩阵求逆</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mtxinv</span><span class="params">(Mtx &amp;x, Mtx &amp;as, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, t;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (t = i; t &lt;= len; ++t) <span class="keyword">if</span> (x[t][i]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (t &gt; len) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (t != i) std::<span class="built_in">swap</span>(x.x[t], x.x[i]), std::<span class="built_in">swap</span>(as.x[t], as.x[i]);</span><br><span class="line">        <span class="keyword">if</span> (x[i][i] != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = len, t = <span class="built_in">qpow</span>(x[i][i], P - <span class="number">2</span>); j &gt;= <span class="number">1</span>; --j) as[i][j] = <span class="built_in">LL</span>(t) * as[i][j] % P;</span><br><span class="line">            <span class="keyword">for</span> (j = len, t = <span class="built_in">qpow</span>(x[i][i], P - <span class="number">2</span>); j &gt;= i; --j) x[i][j] = <span class="built_in">LL</span>(t) * x[i][j] % P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= len; ++j) <span class="keyword">if</span> (x[j][i])</span><br><span class="line">            <span class="keyword">for</span> (k = len; k &gt;= <span class="number">1</span>; --k) <span class="built_in">adj</span>(as[j][k] -= <span class="built_in">LL</span>(x[j][i]) * as[i][k] % P);</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= len; ++j) <span class="keyword">if</span> (x[j][i])</span><br><span class="line">            <span class="keyword">for</span> (k = len; k &gt;= i; --k) <span class="built_in">adj</span>(x[j][k] -= <span class="built_in">LL</span>(x[j][i]) * x[i][k] % P);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = len; i; --i)</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= len; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (k = len; k &gt;= <span class="number">1</span>; --k) <span class="built_in">adj</span>(as[i][k] -= <span class="built_in">LL</span>(x[i][j]) * as[j][k] % P);</span><br><span class="line">            <span class="built_in">adj</span>(x[i][len + <span class="number">1</span>] -= <span class="built_in">LL</span>(x[i][j]) * x[j][len + <span class="number">1</span>] % P);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">det</span><span class="params">(Mtx x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>, i, j, t, k, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (x[i][i]) <span class="comment">//对第i行和第j行做辗转相减</span></span><br><span class="line">            &#123;</span><br><span class="line">                t = x[j][i] / x[i][i];</span><br><span class="line">                <span class="keyword">for</span> (k = i; k &lt;= n; ++k) <span class="built_in">adj</span>(x[j][k] -= <span class="built_in">LL</span>(t) * x[i][k] % p);</span><br><span class="line">                std::<span class="built_in">swap</span>(x.x[i], x.x[j]), f ^= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            std::<span class="built_in">swap</span>(x.x[i], x.x[j]), f ^= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">LL</span>(res) * x[i][i] % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!f) <span class="built_in">adj</span>(res = -res); <span class="comment">//注意res=0时</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用前要保证是正数</p><h2 id="Matrix-Tree"><a href="#Matrix-Tree" class="headerlink" title="Matrix-Tree"></a>Matrix-Tree</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">det</span><span class="params">(<span class="keyword">int</span> x[][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>, w = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">2</span>; i &lt;= n; ++i) <span class="comment">//以1为根,故删掉1行1列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (x[i][i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> div = x[j][i] / x[i][i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= n; ++k)</span><br><span class="line">x[j][k] = (x[j][k] - (LL)div * x[i][k] % P + P) % P;</span><br><span class="line"><span class="built_in">swap</span>(x[i], x[j]);</span><br><span class="line">w = -w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(x[i], x[j]);</span><br><span class="line">w = -w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">res = (LL)x[i][i] * res % P;</span><br><span class="line">res *= w;</span><br><span class="line"><span class="keyword">return</span> (res + P) % P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  $k$ 是度数矩阵减邻接矩阵 </p><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><h2 id="快读快输"><a href="#快读快输" class="headerlink" title="快读快输"></a>快读快输</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> FIO</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L = (<span class="number">1</span> &lt;&lt; <span class="number">20</span>) + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">char</span> buf[L], out[L], *S, *E;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gh() (S == E ? E = (S = buf) + fread(buf, 1, L, stdin), (S == E ? EOF : *S++) : *S++)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flus</span><span class="params">()</span></span>&#123; <span class="built_in">fwrite</span>(out, <span class="number">1</span>, l, stdout), l = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chk</span><span class="params">()</span></span>&#123; <span class="keyword">if</span> (l &gt;= L - <span class="number">100</span>) <span class="built_in">flus</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putc</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123; out[l++] = x, <span class="built_in">chk</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rd</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch = <span class="built_in">gh</span>();</span><br><span class="line"><span class="keyword">while</span> (ch &lt; <span class="number">33</span> || ch &gt; <span class="number">126</span>) ch = <span class="built_in">gh</span>();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt;= <span class="number">33</span> &amp;&amp; ch &lt;= <span class="number">126</span>; ch = <span class="built_in">gh</span>()) *s++ = ch;</span><br><span class="line">*s = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wt</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123; <span class="keyword">while</span> (*s != <span class="string">&#x27;\0&#x27;</span>) <span class="built_in">putc</span>(*s++); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>&#123; <span class="keyword">while</span> (*s != <span class="string">&#x27;\0&#x27;</span>) <span class="built_in">putc</span>(*s++); &#125; <span class="comment">//这是为了可以直接&quot;&quot;构造字符串输出</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rd</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch = <span class="built_in">gh</span>(), t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>; ch = <span class="built_in">gh</span>()) t |= ch == <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">0</span>; ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>; ch = <span class="built_in">gh</span>()) x = x * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line"><span class="keyword">if</span> (t) x = -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wt</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">0</span>) x = -x;</span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">9</span>) <span class="built_in">wt</span>(x / <span class="number">10</span>);</span><br><span class="line">out[l++] = x % <span class="number">10</span> + <span class="number">48</span>, <span class="built_in">chk</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rd</span><span class="params">(T &amp;x, Args &amp;...args)</span></span>&#123; <span class="built_in">rd</span>(x), <span class="built_in">rd</span>(args...); &#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rd</span><span class="params">(<span class="keyword">char</span> *x, Args ...args)</span></span>&#123; <span class="built_in">rd</span>(x), <span class="built_in">rd</span>(args...); &#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wt</span><span class="params">(T x, Args ...args)</span></span>&#123; <span class="built_in">wt</span>(x), <span class="built_in">wt</span>(args...); &#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wt</span><span class="params">(<span class="keyword">char</span> *x, Args ...args)</span></span>&#123; <span class="built_in">wt</span>(x), <span class="built_in">wt</span>(args...); &#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *x, Args ...args)</span></span>&#123; <span class="built_in">wt</span>(x), <span class="built_in">wt</span>(args...); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> gh</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> FIO::flus;</span><br><span class="line"><span class="keyword">using</span> FIO::rd;</span><br><span class="line"><span class="keyword">using</span> FIO::wt;</span><br></pre></td></tr></table></figure><p>无法读入浮点数；不可以字符串和整型一起读入（但可以一起输出）；注意最后要 <code>flus()</code> 一下；只能文件输入（但可以随意输出），如果要本地输入请 <code>#define gh() getchar()</code>  </p><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><p>只会很不优美的写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> l, r, mid, res;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line">    mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">chk</span>(mid)) l = mid + <span class="number">1</span>, res = mid;</span><br><span class="line">    <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><h2 id="三分"><a href="#三分" class="headerlink" title="三分"></a>三分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> l, r, lm, rm, res, len;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line">    len = (r - l + <span class="number">1</span>) / <span class="number">3</span>;</span><br><span class="line">    lm = l + len;</span><br><span class="line">    rm = lm + len;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">f</span>(lm) &lt; <span class="built_in">f</span>(rm)) res = rm, l = lm + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">f</span>(lm) &gt; <span class="built_in">f</span>(rm)) res = lm, r = rm - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><h2 id="模拟退火"><a href="#模拟退火" class="headerlink" title="模拟退火"></a>模拟退火</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> DB T0 = <span class="number">1e4</span>, TE = <span class="number">1e-4</span>, C = <span class="number">0.99</span>, SP = <span class="number">1e3</span>; <span class="comment">//这是参数,影响时间和精度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">E</span><span class="params">()</span></span>&#123; 这是一个估计函数(同时会跟新ans),越优的状态其估计越小 &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simulate_anneal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    预处理</span><br><span class="line">    DB now = <span class="built_in">E</span>(), np, dt, ct;</span><br><span class="line">    <span class="keyword">for</span> (DB t = E0; t &gt; TE; t *= C)</span><br><span class="line">    &#123;</span><br><span class="line">        随机进入新的状态,新状态与现状态的差异大小最好和t正相关</span><br><span class="line">        np = <span class="built_in">E</span>();</span><br><span class="line">        dt = np - now;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">exp</span>(-dt / t) &gt; 生成的一个(<span class="number">0</span>, <span class="number">1</span>)之间的随机数)</span><br><span class="line">        &#123;</span><br><span class="line">            跳至新状态</span><br><span class="line">           now = np；</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            恢复原状态</span><br><span class="line">            <span class="keyword">if</span> ((++ct) &gt; SP) <span class="keyword">return</span> ; <span class="comment">//一个优化:多次为转移就直接以当前状态做最优解</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">一般会多次调用simulate_anneal或调小C以保证正确性</span><br></pre></td></tr></table></figure><h2 id="取模优化"><a href="#取模优化" class="headerlink" title="取模优化"></a>取模优化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adj</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123; x += (x &gt;&gt; <span class="number">31</span>) &amp; P; &#125;</span><br></pre></td></tr></table></figure><p>仅限 $x$ 为负数时可用，当 $x$ 是 <code>LL</code> 时把 $31$ 改成 $63$ </p><h2 id="Min-Max-容斥"><a href="#Min-Max-容斥" class="headerlink" title="Min-Max 容斥"></a>Min-Max 容斥</h2><p>$$<br>\begin{aligned}<br>&amp; \max(S) = \sum_{T \subseteq S} (-1)^{\mid T \mid - 1} \min(T) \\<br>&amp; \min(S) = \sum_{T \subseteq S} (-1)^{\mid T \mid - 1} \max(T) \\<br>&amp; kmax(S) = \sum_{T \subseteq S} (-1)^{\mid T \mid - k} \binom{\mid T \mid - 1}{k - 1} \min(T)<br>\end{aligned}<br>$$</p><h2 id="FWT"><a href="#FWT" class="headerlink" title="FWT"></a>FWT</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> FWT</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> iv2 = <span class="number">499122177</span>; <span class="comment">//2的逆元</span></span><br><span class="line"><span class="keyword">void</span> _or(<span class="keyword">int</span> x[], <span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; i &lt;&lt;= <span class="number">1</span>) <span class="comment">//当前区间长度</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = i &gt;&gt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; len; j += i) <span class="comment">//j当前区间前端</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k) <span class="built_in">adj</span>(x[k + mid] += x[k] - P);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">u_or</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = i &gt;&gt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; len; j += i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k) <span class="built_in">adj</span>(x[k + mid] -= x[k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _and(<span class="keyword">int</span> x[], <span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = i &gt;&gt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; len; j += i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k) <span class="built_in">adj</span>(x[k] += x[k + mid] - P);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">u_and</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = i &gt;&gt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; len; j += i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k) <span class="built_in">adj</span>(x[k] -= x[k + mid]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _xor(<span class="keyword">int</span> x[], <span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, t1, t2; i &lt;= len; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = i &gt;&gt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; len; j += i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k)</span><br><span class="line">&#123;</span><br><span class="line">t1 = x[k], t2 = x[k + mid];</span><br><span class="line"><span class="built_in">adj</span>(x[k] = t1 + t2 - P), <span class="built_in">adj</span>(x[k + mid] = t1 - t2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">u_xor</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, t1, t2; i &lt;= len; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = i &gt;&gt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; len; j += i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k)</span><br><span class="line">&#123;</span><br><span class="line">t1 = x[k], t2 = x[k + mid];</span><br><span class="line"><span class="built_in">adj</span>(x[k] = t1 + t2 - P), <span class="built_in">adj</span>(x[k + mid] = t1 - t2);</span><br><span class="line">x[k] = <span class="built_in">LL</span>(iv2) * x[k] % P, x[k + mid] = <span class="built_in">LL</span>(iv2) * x[k + mid] % P;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="子集卷积"><a href="#子集卷积" class="headerlink" title="子集卷积"></a>子集卷积</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pct(x) __builtin_popcount(x)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;bit), n = (<span class="number">1</span> &lt;&lt; bit);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;f[<span class="built_in">pct</span>(i)][i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;g[<span class="built_in">pct</span>(i)][i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= bit; ++i) <span class="built_in">fwt</span>(f[i], n), <span class="built_in">fwtor</span>(g[i], n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= bit; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j + i &lt;= bit; ++j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; n; ++s) <span class="built_in">adj</span>(h[i + j][s] += <span class="built_in">LL</span>(f[i][s]) * g[j][s] % P - P);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= bit; ++i) <span class="built_in">ufwtor</span>(h[i], n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, h[<span class="built_in">pct</span>(i)][i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性基"><a href="#线性基" class="headerlink" title="线性基"></a>线性基</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STC static</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">int</span> n; <span class="comment">//n是题目中插入到线性基里的个数</span></span><br><span class="line"><span class="keyword">namespace</span> LB  <span class="comment">//Linear Basis</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">63</span>;</span><br><span class="line">    LL a[L + <span class="number">5</span>], si;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123; <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a), si = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(LL  x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L; ~i; --i) <span class="keyword">if</span> ((x &gt;&gt; i) &amp; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> (!a[i]) <span class="keyword">return</span> ++si, <span class="built_in"><span class="keyword">void</span></span>(a[i] = x);</span><br><span class="line">            <span class="keyword">else</span> x ^= a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">LL <span class="title">gmx</span><span class="params">()</span> <span class="comment">//get max</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LL res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L; ~i; --i) res = std::<span class="built_in">max</span>(res ^ a[i], res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">LL <span class="title">gmn</span><span class="params">()</span> <span class="comment">//get min</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (si &lt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= L; ++i) <span class="keyword">if</span> (a[i]) <span class="keyword">return</span> a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L; ~i; --i) <span class="keyword">if</span> ((x &gt;&gt; i) &amp; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> (!a[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> x ^= a[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reb</span><span class="params">()</span> <span class="comment">//rebuild</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        STC <span class="keyword">int</span> tp[L + <span class="number">5</span>];</span><br><span class="line">        si = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= L; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; ~j; --j) <span class="keyword">if</span> ((a[i] &gt;&gt; j) &amp; <span class="number">1</span>) a[i] ^= a[j];</span><br><span class="line">            <span class="keyword">if</span> (a[i]) tp[si++] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; si; ++i) a[i] = tp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">LL <span class="title">gk</span><span class="params">(LL k)</span> <span class="comment">//get k</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LL res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (si &lt; n &amp;&amp; !(--k)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= (<span class="number">1ll</span> &lt;&lt; si)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; si; ++i) <span class="keyword">if</span> ((k &gt;&gt; i) &amp; <span class="number">1</span>) res ^= a[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; rt&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="模板" scheme="https://dyd-true.github.io/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>CF1119H Triple</title>
    <link href="https://dyd-true.github.io/2022/05/28/CF1119H-Triple/"/>
    <id>https://dyd-true.github.io/2022/05/28/CF1119H-Triple/</id>
    <published>2022-05-28T06:51:50.000Z</published>
    <updated>2022-05-28T09:11:22.678Z</updated>
    
    <content type="html"><![CDATA[<p> FWT + 解方程 高级版</p><span id="more"></span><p><a href="https://codeforces.com/problemset/problem/1119/H">Triple</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定常数 $k \le 17$ 和常数 $x, y, z \le 10^9$ ，现在有 $n \le 10^5$ 个数组，对于每个数组，给定 $a_i, b_i, c_i \le 2^k$ ，表示该数组有 $x$ 个 $a_i$ ， $y$ 个 $b_i$ ， $z$ 个 $c_i$ ，现在从每个数组中选一个数字异或起来得到 $sum$ ，对于每个 $sum \in [0, 2^k)$ ，输出方案数</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先考虑暴力 FWT ：构造幂级数 $f_i(t) = xt^{a_i} + yt^{b_i} + zt^{c_i}$ ，定义幂级数乘法为异或卷积，那么设 $F = \prod f_i$ ，则 $F[i]$ 即为 $sum = i$ 的方案数，直接暴力 FWT 是 $O(nk2^k)$ </p><p>任然考虑手玩一下 FWT ，记幂级数 $f’ = FWT(f)$ ，有 $f’[s] = (-1)^{\mid a_i \&amp; s\mid} x + (-1)^{\mid b_i \&amp; s\mid} y + (-1)^{\mid c_i \&amp; s\mid} z$  $f’[s] = (-1)^{\mid a_i &amp; s\mid} x + (-1)^{\mid b_i &amp; s\mid} y + (-1)^{\mid c_i &amp; s\mid} z$ </p><p>这有点痛苦，考虑把三元组 $(a_i, b_i, c_i)$ 变成 $(a_i \oplus c_i, b_i \oplus c_i, 0)$ ，记 $C = c_1 \oplus c_2 \oplus … \oplus c_n$ ，最后 $sum$ 的答案存在 $sum \oplus C$ 处；以下的讨论中，$a, b, sum$ 都是已经变换了的</p><p>那么 $f’[s] = (-1)^{\mid a_i \&amp; s\mid} x + (-1)^{\mid b_i \&amp; s\mid} y + z$  $f’[s] = (-1)^{\mid a_i &amp; s\mid} x + (-1)^{\mid b_i &amp; s\mid} y + z$ ，就只有四种情况：</p><ol><li> $x + y + z$ </li><li> $x - y + z$ </li><li> $-x + y + z$ </li><li> $-x - y + z$ </li></ol><p>不妨记以上四种情况出现的次数分别为 $d_1, d_2, d_3, d_4$ ，可得： $F’[s] = (x + y + z)^{d_1}(x - y + z)^{d_2}(-x + y + z)^{d_3}(-x - y + z)^{d_4}$ ，于是问题变成求 $d_1, d_2, d_3, d_4$ </p><p>考虑解方程，我们现在有 $d_1 + d_2 + d_3 + d_4 = n$ ，还要再找到 $3$ 个方程，我们使用 FWT 找方程：</p><ol><li>构造 $G(t) = \sum_{i = 1}^{n} t^{a_i}$ ，那么 $G’[s] = (-1)^{\mid s \&amp; a_i \mid}$ $G’[s] = (-1)^{\mid s &amp; a_i \mid}$ ，即只有 $x$ 符号的贡献，那么有 $G’[s] = d_1 + d_2 - d_3 - d_4$ ，不妨记作 $d_1 + d_2 - d_3 - d_4 = p_1$ </li><li>同理构造 $G(t) = \sum_{i = 1}^{n} t^{b_i}$ ，有 $G’[s] = d_1 + d_3 - d_2 - d_4$ 不妨记作 $d_1 - d_2 + d_3 - d_4 = p_2$ </li><li>最后再构造 $G(t) = \sum_{i = 1}^{n} t^{a_i \oplus b_i}$ ，有 $G’[s] = d_1 + d_4 - d_2 - d_3$ ，不妨记作 $d_1 - d_2 - d_3 + d_4 = p_3$ </li></ol><p>于是我们有：<br>$$<br>\begin{cases}<br>d_1 + d_2 + d_3 + d_4 = n \\<br>d_1 + d_2 - d_3 - d_4 = p_1 \\<br>d_1 - d_2 + d_3 - d_4 = p_2 \\<br>d_1 - d_2 - d_3 + d_4 = p_3<br>\end{cases}<br>$$<br>手玩解得：<br>$$<br>\begin{cases}<br>d_1 = \frac{n + p_1 + p_2 + p_3}{4} \\<br>d_2 = \frac{n + p_1 - p_2 - p_3}{4} \\<br>d_3 = \frac{n - p_1 + p_2 - p_3}{4} \\<br>d_4 = \frac{n - p_1 - p_2 + p_3}{4}<br>\end{cases}<br>$$<br>时间复杂度 $O(k2^k)$ </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">100</span>, K = <span class="number">20</span>, P = <span class="number">998244353</span>, iv2 = <span class="number">499122177</span>, iv4 = <span class="number">748683265</span>;</span><br><span class="line"><span class="keyword">int</span> n, tot, C;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N], c[N], g[N &lt;&lt; <span class="number">1</span>], f[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line">std::array&lt;<span class="keyword">int</span>, 4&gt; d[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adj</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123; x += (x &gt;&gt; <span class="number">31</span>) &amp; P; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = <span class="built_in">LL</span>(x) * x % P) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = <span class="built_in">LL</span>(res) * x % P;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fwtor</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, t1, t2; i &lt;= len; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> mid = i &gt;&gt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; len; j += i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                t1 = x[k], t2 = x[k + mid];</span><br><span class="line">                <span class="built_in">adj</span>(x[k] = t1 + t2 - P), <span class="built_in">adj</span>(x[k + mid] = t1 - t2);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ifwtor</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, t1, t2; i &lt;= len; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> mid = i &gt;&gt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; len; j += i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                t1 = x[k], t2 = x[k + mid];</span><br><span class="line">                <span class="built_in">adj</span>(x[k] = t1 + t2 - P), <span class="built_in">adj</span>(x[k + mid] = t1 - t2);</span><br><span class="line">                x[k] = <span class="built_in">LL</span>(iv2) * x[k] % P, x[k + mid] = <span class="built_in">LL</span>(iv2) * x[k + mid] % P;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;tot), tot = <span class="number">1</span> &lt;&lt; tot;</span><br><span class="line">    <span class="keyword">int</span> u, v, w, t0, t1, t2, t3;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">    t0 = (<span class="built_in">LL</span>(u) + v + w) % P;</span><br><span class="line">    t1 = ((<span class="built_in">LL</span>(u) - v + w ) % P + P) % P;</span><br><span class="line">    t2 = ((<span class="built_in">LL</span>(-u) + v + w) % P + P) % P;</span><br><span class="line">    t3 = ((<span class="built_in">LL</span>(-u) - v + w) % P + P) % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a[i], &amp;b[i], &amp;c[i]);</span><br><span class="line">        a[i] ^= c[i], b[i] ^= c[i], C ^= c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= tot; ++i) d[i] = &#123;n, n, n, n&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">adj</span>(++g[a[i]]);</span><br><span class="line">    <span class="built_in">fwtor</span>(g, tot);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= tot; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">adj</span>(d[i][<span class="number">0</span>] += g[i] - P);</span><br><span class="line">        <span class="built_in">adj</span>(d[i][<span class="number">1</span>] += g[i] - P);</span><br><span class="line">        <span class="built_in">adj</span>(d[i][<span class="number">2</span>] -= g[i]);</span><br><span class="line">        <span class="built_in">adj</span>(d[i][<span class="number">3</span>] -= g[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0</span>, (tot + <span class="number">1</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">adj</span>(++g[b[i]]);</span><br><span class="line">    <span class="built_in">fwtor</span>(g, tot);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= tot; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">adj</span>(d[i][<span class="number">0</span>] += g[i] - P);</span><br><span class="line">        <span class="built_in">adj</span>(d[i][<span class="number">1</span>] -= g[i]);</span><br><span class="line">        <span class="built_in">adj</span>(d[i][<span class="number">2</span>] += g[i] - P);</span><br><span class="line">        <span class="built_in">adj</span>(d[i][<span class="number">3</span>] -= g[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0</span>, (tot + <span class="number">1</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">adj</span>(++g[a[i] ^ b[i]]);</span><br><span class="line">    <span class="built_in">fwtor</span>(g, tot);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= tot; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">adj</span>(d[i][<span class="number">0</span>] += g[i] - P);</span><br><span class="line">        <span class="built_in">adj</span>(d[i][<span class="number">1</span>] -= g[i]);</span><br><span class="line">        <span class="built_in">adj</span>(d[i][<span class="number">2</span>] -= g[i]);</span><br><span class="line">        <span class="built_in">adj</span>(d[i][<span class="number">3</span>] += g[i] - P);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= tot; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        d[i][<span class="number">0</span>] = <span class="built_in">LL</span>(iv4) * d[i][<span class="number">0</span>] % P;</span><br><span class="line">        d[i][<span class="number">1</span>] = <span class="built_in">LL</span>(iv4) * d[i][<span class="number">1</span>] % P;</span><br><span class="line">        d[i][<span class="number">2</span>] = <span class="built_in">LL</span>(iv4) * d[i][<span class="number">2</span>] % P;</span><br><span class="line">        d[i][<span class="number">3</span>] = <span class="built_in">LL</span>(iv4) * d[i][<span class="number">3</span>] % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= tot; ++i) f[i] = <span class="built_in">LL</span>(<span class="built_in">qpow</span>(t0, d[i][<span class="number">0</span>])) * <span class="built_in">qpow</span>(t1, d[i][<span class="number">1</span>]) % P * <span class="built_in">qpow</span>(t2, d[i][<span class="number">2</span>]) % P * <span class="built_in">qpow</span>(t3, d[i][<span class="number">3</span>]) % P;</span><br><span class="line">    ifwtor(f, tot);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, f[i ^ C]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; FWT + 解方程 高级版&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="数论,数学" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
    <category term="CF" scheme="https://dyd-true.github.io/tags/CF/"/>
    
    <category term="FWT" scheme="https://dyd-true.github.io/tags/FWT/"/>
    
  </entry>
  
  <entry>
    <title>UOJ310黎明前的巧克力</title>
    <link href="https://dyd-true.github.io/2022/05/28/UOJ310%E9%BB%8E%E6%98%8E%E5%89%8D%E7%9A%84%E5%B7%A7%E5%85%8B%E5%8A%9B/"/>
    <id>https://dyd-true.github.io/2022/05/28/UOJ310%E9%BB%8E%E6%98%8E%E5%89%8D%E7%9A%84%E5%B7%A7%E5%85%8B%E5%8A%9B/</id>
    <published>2022-05-28T06:08:16.000Z</published>
    <updated>2022-05-28T07:00:35.523Z</updated>
    
    <content type="html"><![CDATA[<p> FWT + 解方程</p><span id="more"></span><p><a href="https://uoj.ac/problem/310">黎明前的巧克力</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>设集合 $S$ 中的数异或和为 $0$ ，那么显然集合 $S$ 的任意一种划分方案都是答案，即答案为 $2^{\mid S \mid}$ ，考虑 FWT ，对于每个数 $a_i$ ，构造幂级数 $f_i(x) = (1 + 2x^{a_i})$ （不选为 $1$ ，选了集合大小 $+1$ ，在指数上就是 $\times 2$ ），那么定义乘法为异或卷积，记 $A = \max(a_i), F = \prod_{i = 1}^n f_i$ ， $F[0]$ 显然就是答案（其实要 $-1$ 因为不能划分成空集），但直接暴力 FWT 时间为 $O(nA \log A)$ 无法接受</p><p>这里引入一个技巧，考虑到 $f_i$ 其实只要两项，它 FWT 变换后的数组 $f’_i$ 其实可以手玩，即 $f’<em>i = \sum</em>{s = 0}^A (1 + (-1)^{\mid a_i \&amp; s \mid} \times 2)x^s$ $f’<em>i(x) = \sum</em>{s = 0}^A (1 + (-1)^{\mid a_i &amp; s \mid} \times 2)x^s$，不难发现 $f’<em>i$ 的每一位其实只有 $-1$ 和 $3$ 两种取值，把它们连乘，得到 $F’(x) = \sum</em>{s = 0}^A (-1)^{n - t_s} \times 3^t_s x^s$ ，那么我们只要得到每一个 $t_s$ 即可得到 $F’$ </p><p>考虑幂级数 $G = \sum_{i = 1}^n f_i$  ，由于 FWT 的线性，它的 FWT 变换为  $G’(x) = \sum_{i = 1}^n f’<em>i(x) = \sum</em>{s = 0}^A (-1 \times (n - t_s) + 3 \times t_s) x^s$ ，那么只要求得 $G’$ 即可解出 $t_s$ ，得到 $F’$ 后再 IFWT 回去即得 $F$ </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>注意由于 $tot$ 是 $2$ 的次幂，数组要开两倍</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span> + <span class="number">100</span>, P = <span class="number">998244353</span>, iv2 = <span class="number">499122177</span>, iv4 = <span class="number">748683265</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N], mx, tot;</span><br><span class="line"><span class="keyword">int</span> f[N], pw3[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adj</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123; x += (x &gt;&gt; <span class="number">31</span>) &amp; P; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fwtor</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, t1, t2; i &lt;= len; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> mid = i &gt;&gt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; len; j += i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                t1 = x[k], t2 = x[k + mid];</span><br><span class="line">                <span class="built_in">adj</span>(x[k] = t1 + t2 - P), <span class="built_in">adj</span>(x[k + mid] = t1 - t2);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ifwtor</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, t1, t2; i &lt;= len; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> mid = i &gt;&gt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; len; j += i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                t1 = x[k], t2 = x[k + mid];</span><br><span class="line">                <span class="built_in">adj</span>(x[k] = t1 + t2 - P), <span class="built_in">adj</span>(x[k + mid] = t1 - t2);</span><br><span class="line">                x[k] = <span class="built_in">LL</span>(x[k]) * iv2 % P, x[k + mid] = <span class="built_in">LL</span>(x[k + mid]) * iv2 % P;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    pw3[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) pw3[i] = <span class="built_in">LL</span>(pw3[i - <span class="number">1</span>]) * <span class="number">3</span> % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        f[<span class="number">0</span>] += <span class="number">1</span>, f[a[i]] += <span class="number">2</span>;</span><br><span class="line">        mx = std::<span class="built_in">max</span>(mx, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    tot = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (tot &lt;= mx) tot &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">fwtor</span>(f, tot);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t; i &lt; tot; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t = <span class="built_in">LL</span>(f[i] + n) * iv4 % P;</span><br><span class="line">        <span class="built_in">adj</span>(f[i] = pw3[t] * ((n - t) &amp; <span class="number">1</span> ? <span class="number">-1</span> : <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    ifwtor(f, tot);</span><br><span class="line">    <span class="built_in">adj</span>(f[<span class="number">0</span>] -= <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; FWT + 解方程&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="数论,数学" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
    <category term="FWT" scheme="https://dyd-true.github.io/tags/FWT/"/>
    
    <category term="UOJ" scheme="https://dyd-true.github.io/tags/UOJ/"/>
    
  </entry>
  
  <entry>
    <title>luoguP4655 [CEOI2017]Building Bridges</title>
    <link href="https://dyd-true.github.io/2022/05/27/luoguP4655-CEOI2017-Building-Bridges/"/>
    <id>https://dyd-true.github.io/2022/05/27/luoguP4655-CEOI2017-Building-Bridges/</id>
    <published>2022-05-27T01:49:48.000Z</published>
    <updated>2022-05-27T07:55:37.784Z</updated>
    
    <content type="html"><![CDATA[<p> 斜率优化 + cdq分治</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P4655">Building Bridges</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>直接上 dp ，设 $d[i]$ 表示“连接 $1$ 和 $i$ 的最小代价” ，并令 $s[i]$ 表示 $w$ 的前缀和，那么有：<br>$$<br>d[i] = \min(d[j] + (h[i] - h[j])^2 + s[i - 1] - s[j])<br>$$<br>同样考虑决策 $j$ 优于 $k$ ，有：<br>$$<br>\begin{aligned}<br>d_j + (h_i - h_j)^2 + s_{i - 1} - s_j &amp;&lt; d_k + (h_i - h_k)^2 + s_{i - 1} - s_k \\<br>d_j + h_j^2 - 2h_ih_j - s_j &amp;&lt; d_k + h_k^2 - 2h_ih_k - s_k \\<br>\frac{(d_j + h_j^2 - s_j) - (d_k + h_k^2 - s_k)}{h_j - h_k} &amp;&lt; 2h_i<br>\end{aligned}<br>$$<br>发现 $h_j$ 和 $2h_i$ 都不单调，考虑 cdq 分治，先按 $2h_i$ 排序，每次先递归计算 $[l, mid]$ ，回来时把它们按 $h_j$ 排序，然后用 $[l, mid]$ 去跟新 $[mid + 1, r]$ ，再递归 $[mid + 1, r]$ 即可</p><p>时间 $O(n \log n)$ </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>一定要注意是 $p[i]$ 不是 $i$ ！一定要考虑 $X$ 相同的情况！</p><p>另外，实测加了 <code>inline</code> 的函数打法和 <code>#define</code> 的打法一样快</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IL inline</span></span><br><span class="line"><span class="comment">// #define X(x) (h[x])</span></span><br><span class="line"><span class="comment">// #define Y(x) (d[x] + h[x] * h[x] - s[x])</span></span><br><span class="line"><span class="comment">// #define K(x) (2 * h[x])</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> p[N], tmp[N], lp, rp, tp, q[N], ql, qr;</span><br><span class="line">IL LL s[N], d[N], h[N]; </span><br><span class="line"><span class="function">IL LL <span class="title">X</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> h[x]; &#125;</span><br><span class="line"><span class="function">IL LL <span class="title">Y</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> d[x] + h[x] * h[x] - s[x]; &#125;</span><br><span class="line"><span class="function">IL LL <span class="title">K</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> <span class="number">2</span> * h[x]; &#125;</span><br><span class="line"><span class="function">IL <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">X</span>(x) == <span class="built_in">X</span>(y) ? <span class="built_in">Y</span>(x) &lt; <span class="built_in">Y</span>(y) : <span class="built_in">X</span>(x) &lt; <span class="built_in">X</span>(y); &#125;</span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">cdq</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    lp = l - <span class="number">1</span>, rp = mid;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) (p[i] &lt;= mid ? tmp[++lp] : tmp[++rp]) = p[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) p[i] = tmp[i];</span><br><span class="line">    <span class="built_in">cdq</span>(l, mid);</span><br><span class="line">    ql = <span class="number">1</span>, qr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= mid; ++i)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; l &amp;&amp; <span class="built_in">X</span>(p[i]) == <span class="built_in">X</span>(p[i - <span class="number">1</span>])) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span> (ql &lt; qr &amp;&amp; (<span class="built_in">Y</span>(q[qr]) - <span class="built_in">Y</span>(q[qr - <span class="number">1</span>])) * (<span class="built_in">X</span>(p[i]) - <span class="built_in">X</span>(q[qr])) &gt;= (<span class="built_in">Y</span>(p[i]) - <span class="built_in">Y</span>(q[qr])) * (<span class="built_in">X</span>(q[qr]) - <span class="built_in">X</span>(q[qr - <span class="number">1</span>]))) --qr;</span><br><span class="line">        q[++qr] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>, u, v; i &lt;= r; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (ql &lt; qr &amp;&amp; (<span class="built_in">Y</span>(q[ql + <span class="number">1</span>]) - <span class="built_in">Y</span>(q[ql])) &lt; (<span class="built_in">X</span>(q[ql + <span class="number">1</span>]) - <span class="built_in">X</span>(q[ql])) * <span class="built_in">K</span>(p[i])) ++ql;</span><br><span class="line">        u = p[i], v = q[ql];</span><br><span class="line">d[u] = std::<span class="built_in">min</span>(d[u], d[v] + (h[u] - h[v]) * (h[u] - h[v]) + s[u - <span class="number">1</span>] - s[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cdq</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    lp = tp = l, rp = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lp &lt;= mid &amp;&amp; rp &lt;= r) tmp[tp++] = (<span class="built_in">cmp</span>(p[lp], p[rp]) ? p[lp++] : p[rp++]);</span><br><span class="line">    <span class="keyword">while</span> (lp &lt;= mid) tmp[tp++] = p[lp++];</span><br><span class="line">    <span class="keyword">while</span> (rp &lt;= r) tmp[tp++] = p[rp++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) p[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;h[i]), p[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;s[i]), s[i] += s[i - <span class="number">1</span>];</span><br><span class="line">    std::<span class="built_in">sort</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>, [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123; <span class="keyword">return</span> <span class="built_in">K</span>(x) &lt; <span class="built_in">K</span>(y); &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) d[i] = INF;</span><br><span class="line">    <span class="built_in">cdq</span>(<span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, d[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 斜率优化 + cdq分治&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
    <category term="斜率优化" scheme="https://dyd-true.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
    <category term="CDQ" scheme="https://dyd-true.github.io/tags/CDQ/"/>
    
  </entry>
  
  <entry>
    <title>luoguP3628 [APIO2010]特别行动队</title>
    <link href="https://dyd-true.github.io/2022/05/26/luoguP3628-APIO2010-%E7%89%B9%E5%88%AB%E8%A1%8C%E5%8A%A8%E9%98%9F/"/>
    <id>https://dyd-true.github.io/2022/05/26/luoguP3628-APIO2010-%E7%89%B9%E5%88%AB%E8%A1%8C%E5%8A%A8%E9%98%9F/</id>
    <published>2022-05-26T12:54:02.000Z</published>
    <updated>2022-05-26T13:03:13.777Z</updated>
    
    <content type="html"><![CDATA[<p> 斜率优化</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P3628">特别行动队</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先上个前缀和，设 $d[i]$ 表示“前 $i$ 个数能得到的最大值”，转移为：<br>$$<br>d[i] = \max(d[j] + a(s[i] - s[j])^2 + b(s[i] - s[j]) + c)<br>$$<br>显然斜率优化，化式子，考虑 $j$ 优于 $k$ 的条件：<br>$$<br>\begin{aligned}<br>d[j] + a(s[i] - s[j])^2 + b(s[i] - s[j]) + c &amp;&gt; d[k] + a(s[i] - s[k])^2 + b(s[i] - s[k]) + c \\<br>d[j] + as[i]^2 - 2as[i]s[j] + as[j]^2 + bs[i] -  bs[j] + c &amp;&gt; d[k] + as[i]^2 - 2as[i]s[k] + as[k]^2 + bs[i] -  bs[k] + c \\<br>d[j] - 2as[i]s[j] + as[j]^2 -  bs[j] &amp;&gt; d[k] - 2as[i]s[k] + as[k]^2 -  bs[k] \\<br>\frac{(d[j] + as[j]^2 - bs[j]) - (d[k] + as[k]^2 - bs[k])}{s[j] - s[k]} &amp;&gt; 2as[i]<br>\end{aligned}<br>$$<br>显然维护斜率递增即可，考虑到 $X(t) = s[t]$ ， $K(t) = 2as[t]$ 都是单调的，直接上单调队列即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>太久没打了，调了半天</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n, a, b, c, s[N], q[N], l, r;</span><br><span class="line">LL d[N];</span><br><span class="line"><span class="function">LL <span class="title">X</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> s[x]; &#125;</span><br><span class="line"><span class="function">LL <span class="title">Y</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> d[x] + <span class="built_in">LL</span>(a) * s[x] * s[x] - <span class="built_in">LL</span>(b) * s[x]; &#125;</span><br><span class="line"><span class="function">LL <span class="title">K</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> <span class="number">2ll</span> * a * s[x]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) s[i] += s[i - <span class="number">1</span>];</span><br><span class="line">    q[l = r = <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; (<span class="built_in">Y</span>(q[l + <span class="number">1</span>]) - <span class="built_in">Y</span>(q[l])) &gt; (<span class="built_in">X</span>(q[l + <span class="number">1</span>]) - <span class="built_in">X</span>(q[l])) * <span class="built_in">K</span>(i)) ++l;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= r) d[i] = d[q[l]] + <span class="built_in">LL</span>(s[i] - s[q[l]]) * (s[i] - s[q[l]]) * a + <span class="built_in">LL</span>(s[i] - s[q[l]]) * b + c;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; (<span class="built_in">Y</span>(q[r]) - <span class="built_in">Y</span>(q[r - <span class="number">1</span>])) * (<span class="built_in">X</span>(i) - <span class="built_in">X</span>(q[r])) &lt;= (<span class="built_in">Y</span>(i) - <span class="built_in">Y</span>(q[r])) * (<span class="built_in">X</span>(q[r]) - <span class="built_in">X</span>(q[r - <span class="number">1</span>]))) --r;</span><br><span class="line">        q[++r] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, d[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 斜率优化&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
    <category term="斜率优化" scheme="https://dyd-true.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>luoguP2989 [USACO10MAR]Need For Speed S</title>
    <link href="https://dyd-true.github.io/2022/05/26/luoguP2989-USACO10MAR-Need-For-Speed-S/"/>
    <id>https://dyd-true.github.io/2022/05/26/luoguP2989-USACO10MAR-Need-For-Speed-S/</id>
    <published>2022-05-26T11:53:04.000Z</published>
    <updated>2022-05-26T12:09:29.508Z</updated>
    
    <content type="html"><![CDATA[<p> 01分数规划</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P2989">Need For Speed S</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>一眼望过去就是01分数规划的板子题，但又要求保证 $M + \sum M_i X_i$ 最小</p><p>结论是：按照 $\frac{F_i}{M_i}$ 降序排序可以保证</p><p>证明：反设无法保证，那么，对于当前二分的答案 $e$ ，存在 $a, b, c, d$ 满足：</p><ol><li> $a$ 是已选中的但不在最优答案的 $i$ 的 $F_i$ 之和</li><li> $b$ 是已选中的但不在最优答案的 $i$ 的 $M_i$ 之和</li><li> $c$ 是未选中的但在最优答案的 $i$ 的 $F_i$ 之和</li><li> $d$ 是未选中的但在最优答案的 $i$ 的 $M_i$ 之和</li></ol><p>再设 $e = \frac{A}{B}$ ，那么有：<br>$$<br>\begin{aligned}<br>&amp; \frac{A - a + c}{B - b + d} = e \\<br>\Rightarrow &amp; \frac{a - c}{b - d} = e<br>\end{aligned}<br>$$<br>且 $b &gt; d$ （因为 $c, d$ 更优）</p><p>不妨设 $a = c + ke$ （这个 $k$ 不是题目中的 $k$ ），则 $b = d + k$ ，那么由于我们假设的是无法保证，所以 $\frac{c}{d}$ 排在 $\frac{a}{b}$ 的后面，即：<br>$$<br>\begin{aligned}<br>&amp; \frac{c + ke}{d + k} &gt; \frac{c}{d} \\<br>\Rightarrow &amp; ed &gt; c<br>\end{aligned}<br>$$<br>但考虑设 $A’ = A - a, B’ = B - b$ ，有 $\frac{A’ + c}{B’ + d} = e$ ，必有 $\frac{c}{d} &gt; e$ ，因为如果 $\frac{c}{d} &lt; e$ ，我们可推得 $\frac{A’}{B’} &gt; e$ ，选了反而让答案变小，这和 $c, d$ 是最优解矛盾，所以 $\frac{c}{d} &gt; e$ ，那么有 $c &gt; ed$ ，又矛盾</p><p>综上，原命题成立</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> DB = <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">const</span> DB eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">100</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">DB m, f;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> DB f, m; <span class="keyword">int</span> id; &#125; a[N];</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; ans, as;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(DB x, DB y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(x - y) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(DB x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">as.<span class="built_in">clear</span>();</span><br><span class="line">DB t = m * x - f, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (<span class="built_in">cmp</span>(a[i].f - a[i].m * x, <span class="number">0</span>) == <span class="number">1</span>) </span><br><span class="line">&#123;</span><br><span class="line">as.<span class="built_in">push_back</span>(a[i].id);</span><br><span class="line">sum += a[i].f - a[i].m * x;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">cmp</span>(sum, t) != <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">cmp</span>(sum, t) != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">ans = as;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf %d&quot;</span>, &amp;f, &amp;m, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf&quot;</span>, &amp;a[i].f, &amp;a[i].m), a[i].id = i;</span><br><span class="line">std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, [&amp;](Node x, Node y)&#123; <span class="keyword">return</span> x.f * y.m &gt; y.f * x.m; &#125;);</span><br><span class="line">DB l = <span class="number">0</span>, r = INF, mid;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cmp</span>(l, r) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">chk</span>(mid)) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid;</span><br><span class="line">&#125;</span><br><span class="line">std::<span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">if</span> (!ans.<span class="built_in">size</span>()) <span class="built_in">puts</span>(<span class="string">&quot;NONE&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">for</span> (<span class="keyword">int</span> i : ans) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 01分数规划&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="贪心" scheme="https://dyd-true.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="二分" scheme="https://dyd-true.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
    <category term="01分数规划" scheme="https://dyd-true.github.io/tags/01%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>luoguP2254 [NOI2005] 瑰丽华尔兹</title>
    <link href="https://dyd-true.github.io/2022/05/26/luoguP2254-NOI2005-%E7%91%B0%E4%B8%BD%E5%8D%8E%E5%B0%94%E5%85%B9/"/>
    <id>https://dyd-true.github.io/2022/05/26/luoguP2254-NOI2005-%E7%91%B0%E4%B8%BD%E5%8D%8E%E5%B0%94%E5%85%B9/</id>
    <published>2022-05-26T11:22:03.000Z</published>
    <updated>2022-05-26T11:53:38.280Z</updated>
    
    <content type="html"><![CDATA[<p> 实现有点麻烦</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P2254">瑰丽华尔兹</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>不难发现，对于每一段，如果要停，就在最后停，答案不变，考虑设 $d[i][x][y]$ 表示“第 $i$ 段时间，在 $x, y$  停下的最长路”，转移显然是：<br>$$<br>d[i][x][y] = \max(d[i - 1][x’][y’]) + abs(x - x’) + abs(y - y’)<br>$$<br>不难发现，对于每个 $i$ ，方向是固定的， $x, y$ 中只会有一个变化，且是单调的，所以直接上单调队列，第一维可以滚动掉，时间为 $O(knm)$ </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>单调队列一定要看清楚队头和队尾！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> PII = std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200</span> + <span class="number">100</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, num, a, b, d[<span class="number">2</span>][N][N], l, r, ans, dx[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dy[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">PII q[N]; </span><br><span class="line"><span class="keyword">char</span> mp[N][N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Time</span>&#123;</span> <span class="keyword">int</span> s, t, d; &#125; c[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">return</span> x &gt;= <span class="number">1</span> &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; x &lt;= n &amp;&amp; y &lt;= m; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> sx, <span class="keyword">int</span> sy, <span class="keyword">int</span> len)</span></span>&#123; <span class="keyword">return</span> std::<span class="built_in">abs</span>(x - sx) + std::<span class="built_in">abs</span>(y - sy) &lt;= len; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> sx, <span class="keyword">int</span> sy, <span class="keyword">int</span> len, <span class="keyword">int</span> o, <span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">in</span>(sx, sy); sx += dx[id], sy += dy[id])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mp[sx][sy] == <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r &amp;&amp; d[o][q[r].fi][q[r].se] + std::<span class="built_in">abs</span>(sx - q[r].fi) + std::<span class="built_in">abs</span>(sy - q[r].se) &lt;= d[o][sx][sy]) --r;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r &amp;&amp; !<span class="built_in">in</span>(q[l].fi, q[l].se, sx, sy, len)) ++l;</span><br><span class="line">        q[++r] = &#123;sx, sy&#125;;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= r) d[o ^ <span class="number">1</span>][sx][sy] = d[o][q[l].fi][q[l].se] + std::<span class="built_in">abs</span>(sx - q[l].fi) + std::<span class="built_in">abs</span>(sy - q[l].se);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d %d&quot;</span>, &amp;n, &amp;m, &amp;a, &amp;b, &amp;num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, mp[i] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;c[i].s, &amp;c[i].t, &amp;c[i].d);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) d[<span class="number">0</span>][i][j] = -INF;</span><br><span class="line">    d[<span class="number">0</span>][a][b] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, o = <span class="number">0</span>, len; i &lt;= num; ++i, o ^= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        len = c[i].t - c[i].s + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (c[i].d == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) <span class="built_in">work</span>(n, j, len, o, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c[i].d == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) <span class="built_in">work</span>(<span class="number">1</span>, j, len, o, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c[i].d == <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) <span class="built_in">work</span>(j, m, len, o, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) <span class="built_in">work</span>(j, <span class="number">1</span>, len, o, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) ans = std::<span class="built_in">max</span>(ans, d[num &amp; <span class="number">1</span>][i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 实现有点麻烦&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="单调队列" scheme="https://dyd-true.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
    <category term="dp" scheme="https://dyd-true.github.io/tags/dp/"/>
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
  </entry>
  
  <entry>
    <title>luoguP3631 [APIO2011]方格染色</title>
    <link href="https://dyd-true.github.io/2022/05/23/luoguP3631-APIO2011-%E6%96%B9%E6%A0%BC%E6%9F%93%E8%89%B2/"/>
    <id>https://dyd-true.github.io/2022/05/23/luoguP3631-APIO2011-%E6%96%B9%E6%A0%BC%E6%9F%93%E8%89%B2/</id>
    <published>2022-05-23T02:18:17.000Z</published>
    <updated>2022-05-23T02:42:11.104Z</updated>
    
    <content type="html"><![CDATA[<p> 边带权并查集</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P3631">方格染色</a></p><p>转化有点多</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给一个转化：我们就是要保证任意一个 $2 \times 2$ 的矩阵异或和为 $1$ </p><p>那么不难发现，只要第一行和第一列定了，整个矩阵就出来了，所以，如果 $k = 0$ 的话，答案就是 $2^{n + m - 1}$ </p><p>考虑每个确定的点，这里有一个结论：任意一个 $a \times b$ 的矩阵四个角的异或值只和 $a, b$ 的奇偶性有关，证明：把 $2 \times 2$ 的矩阵依次覆盖在上面，当且仅当 $a, b$ 同时为偶数时，四个角异或和为 $1$ （因为最后只有四个角只被覆盖了一次，而只有 $a, b$ 为偶数的时候，所有 $2 \times 2$ 的矩阵异或和为 $1$ ）</p><p>那么对于给定 $(x, y) = c$ ，有 $(1, 1) \oplus (1, y) \oplus (x, 1) \oplus c = [x, y同时为偶数]$ ，我们发现，当 $(1, 1)$ 确定后， $(1, y)$ 和 $(x, 1)$ 的关系（相等或不等）就定了，用带权并查集维护这个关系，最后答案就是 $2^{联通个数 - 1}$ </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>一个特别难调的地方：合并时一定要先 $get()$ 再计算权值，因为 $get()$ 里面会修改权值！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">100</span>, P = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, num, nm, fa[N &lt;&lt; <span class="number">1</span>], w[N &lt;&lt; <span class="number">1</span>], rk[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Q</span>&#123;</span> <span class="keyword">int</span> x, y, c; &#125; q[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = <span class="built_in">LL</span>(x) * x % P) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = <span class="built_in">LL</span>(res) * x % P;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="built_in">get</span>(fa[x]);</span><br><span class="line">    w[x] ^= w[fa[x]];</span><br><span class="line">    <span class="keyword">return</span> fa[x] = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = <span class="built_in">get</span>(x), fy = <span class="built_in">get</span>(y);</span><br><span class="line">    v ^= w[x] ^ w[y];</span><br><span class="line">    <span class="keyword">if</span> (fx == fy) <span class="keyword">return</span> !v;</span><br><span class="line">    <span class="keyword">if</span> (rk[fx] &gt; rk[fy]) std::<span class="built_in">swap</span>(fx, fy);</span><br><span class="line">    fa[fx] = fy, w[fx] = v, rk[fy] += rk[fx] == rk[fy];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nm; ++i) fa[i] = i, w[i] = <span class="number">0</span>;</span><br><span class="line">    fa[n + <span class="number">1</span>] = <span class="number">1</span>; <span class="comment">//n+1和1是一个点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y, c; i &lt;= num; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        x = q[i].x, y = q[i].y, c = q[i].c;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span> &amp;&amp; y == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> (c == col) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        c ^= !(x &amp; <span class="number">1</span>) &amp;&amp; !(y &amp; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">1</span> &amp;&amp; y &gt; <span class="number">1</span>) c ^= col; </span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">merge</span>(x, y + n, c)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nm; ++i) res += <span class="built_in">get</span>(i) == i;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">qpow</span>(<span class="number">2</span>, res - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;num);</span><br><span class="line">    nm = n + m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;q[i].x, &amp;q[i].y, &amp;q[i].c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (<span class="built_in">work</span>(<span class="number">0</span>) + <span class="built_in">work</span>(<span class="number">1</span>)) % P);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 边带权并查集&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="并查集" scheme="https://dyd-true.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="数论,数学" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
    <category term="luogu" scheme="https://dyd-true.github.io/tags/luogu/"/>
    
  </entry>
  
  <entry>
    <title>UVA1316 Supermarket</title>
    <link href="https://dyd-true.github.io/2022/05/22/UVA1316-Supermarket/"/>
    <id>https://dyd-true.github.io/2022/05/22/UVA1316-Supermarket/</id>
    <published>2022-05-22T13:54:31.000Z</published>
    <updated>2022-05-22T13:58:52.477Z</updated>
    
    <content type="html"><![CDATA[<p> 简单题？</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/UVA1316">Supermarket</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>按 $p_i$ 排序，贪心取，用并查集维护每一天，使用它就让 $fa[x] = x - 1$ 即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>最开始打的 <code>scanf(&quot;%d&quot;, &amp;n) != EOF</code> 一直 TLE</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> PII = std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n, fa[N], mxt, ans;</span><br><span class="line">PII a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">get</span>(fa[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (std::cin &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        mxt = ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a[i].fi, &amp;a[i].se), mxt = std::<span class="built_in">max</span>(mxt, a[i].se);</span><br><span class="line">        std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, [&amp;](PII x, PII y)&#123; <span class="keyword">return</span> x.fi &gt; y.fi; &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= mxt; ++i) fa[i] = i; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, t; i &lt;= n; ++i) <span class="keyword">if</span> ((t = <span class="built_in">get</span>(a[i].se)) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += a[i].fi;</span><br><span class="line">            fa[t] = t - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 简单题？&lt;/p&gt;</summary>
    
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="并查集" scheme="https://dyd-true.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="贪心" scheme="https://dyd-true.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>luoguP3243 [HNOI2015]菜肴制作</title>
    <link href="https://dyd-true.github.io/2022/05/22/luoguP3243-HNOI2015-%E8%8F%9C%E8%82%B4%E5%88%B6%E4%BD%9C/"/>
    <id>https://dyd-true.github.io/2022/05/22/luoguP3243-HNOI2015-%E8%8F%9C%E8%82%B4%E5%88%B6%E4%BD%9C/</id>
    <published>2022-05-22T13:29:11.000Z</published>
    <updated>2022-05-22T13:32:39.123Z</updated>
    
    <content type="html"><![CDATA[<p> 反过来做大根堆的转化很巧妙</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P3243">菜肴制作</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>建反图，跑拓扑，每次取时贪心取最大，最后反过来输出即可，正确性显然，因为最大的往后了小的就更有机会向前（说的简单但当时想半天每想到）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span> <span class="keyword">int</span> ne, ver; &#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> h[N], idx = <span class="number">0</span>, du[N];</span><br><span class="line">std::priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; e[idx] = &#123;h[x], y&#125;, h[x] = idx++; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (!du[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        ans.<span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne)</span><br><span class="line">        &#123;</span><br><span class="line">            --du[y = e[i].ver];</span><br><span class="line">            <span class="keyword">if</span> (!du[y]) q.<span class="built_in">push</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T); T--; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="built_in">memset</span>(h + <span class="number">1</span>, <span class="number">-1</span>, n &lt;&lt; <span class="number">2</span>), idx = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(du + <span class="number">1</span>, <span class="number">0</span>, n &lt;&lt; <span class="number">2</span>), ans.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">            <span class="built_in">add</span>(v, u), ++du[u];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">topu</span>();</span><br><span class="line">        <span class="keyword">bool</span> f = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; f; ++i) <span class="keyword">if</span> (du[i]) f = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!f) <span class="built_in">printf</span>(<span class="string">&quot;Impossible!&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = ans.<span class="built_in">size</span>() - <span class="number">1</span>; ~i; --i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 反过来做大根堆的转化很巧妙&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="贪心" scheme="https://dyd-true.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="堆" scheme="https://dyd-true.github.io/tags/%E5%A0%86/"/>
    
    <category term="拓扑" scheme="https://dyd-true.github.io/tags/%E6%8B%93%E6%89%91/"/>
    
  </entry>
  
  <entry>
    <title>主席树</title>
    <link href="https://dyd-true.github.io/2022/05/21/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    <id>https://dyd-true.github.io/2022/05/21/%E4%B8%BB%E5%B8%AD%E6%A0%91/</id>
    <published>2022-05-21T11:12:31.000Z</published>
    <updated>2022-05-21T12:39:00.286Z</updated>
    
    <content type="html"><![CDATA[<p> 就是可持久化线段树</p><span id="more"></span><h1 id="主席树"><a href="#主席树" class="headerlink" title="主席树"></a>主席树</h1><p>名字似乎有点来历，但懒得考究了，发现同机房就我这个蒟蒻还不会，所以来补补</p><h2 id="普通"><a href="#普通" class="headerlink" title="普通"></a>普通</h2><p>其实就是可持久化线段树，这里说几个个人认为的要点：</p><ol><li>最初的树不必一个个插，可以直接建</li><li>区间修改的化必须标记永久化</li><li>空间要开够，大概是 $O(4n + m \log n)$ 的</li></ol><p>这里给出一个实现（最快的用时是我的一半，我是大常数选手实锤了）：</p><p><a href="https://www.luogu.com.cn/problem/P3834">可持久化线段树 2</a></p><p>就是维护静态区间第 $k$ 大，建值域线段树，把每个点依次加入然后线段树上二分即可， $O(n \log n)$ </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n, num, m;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; xx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lsh</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    xx.<span class="built_in">reserve</span>(n + <span class="number">1</span>);</span><br><span class="line">    xx.<span class="built_in">pb</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) xx.<span class="built_in">pb</span>(a[i]);</span><br><span class="line">    std::<span class="built_in">sort</span>(xx.<span class="built_in">begin</span>(), xx.<span class="built_in">end</span>());</span><br><span class="line">    xx.<span class="built_in">erase</span>(std::<span class="built_in">unique</span>(xx.<span class="built_in">begin</span>(), xx.<span class="built_in">end</span>()), xx.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = std::<span class="built_in">lower_bound</span>(xx.<span class="built_in">begin</span>(), xx.<span class="built_in">end</span>(), a[i]) - xx.<span class="built_in">begin</span>();</span><br><span class="line">    num = xx.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> CT <span class="comment">//Chairman Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> NN = <span class="number">5e6</span> + <span class="number">100</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> <span class="keyword">int</span> lc, rc, dat; &#125; tr[NN];</span><br><span class="line">    <span class="keyword">int</span> rt[N], tot = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc(x) tr[(x)].lc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc(x) tr[(x)].rc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> dat(x) tr[(x)].dat</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">(<span class="keyword">int</span> &amp;u, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        u = ++tot;</span><br><span class="line">        tr[u] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) <span class="built_in">bd</span>(<span class="built_in">lc</span>(u), l, mid), <span class="built_in">bd</span>(<span class="built_in">rc</span>(u), mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cg</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> d, <span class="keyword">int</span> &amp;u, <span class="keyword">int</span> la, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        u = ++tot;</span><br><span class="line">        tr[u] = tr[la];</span><br><span class="line">        <span class="built_in">dat</span>(u) += d;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line">        (pos &lt;= mid) ? <span class="built_in">cg</span>(pos, d, <span class="built_in">lc</span>(u), <span class="built_in">lc</span>(la), l, mid) : <span class="built_in">cg</span>(pos, d, <span class="built_in">rc</span>(u), <span class="built_in">rc</span>(la), mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> ul, <span class="keyword">int</span> ur, <span class="keyword">int</span> k, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="built_in">dat</span>(<span class="built_in">lc</span>(ur)) - <span class="built_in">dat</span>(<span class="built_in">lc</span>(ul));</span><br><span class="line">        <span class="keyword">return</span> (t &gt;= k) ? <span class="built_in">ask</span>(<span class="built_in">lc</span>(ul), <span class="built_in">lc</span>(ur), k, l, mid) : <span class="built_in">ask</span>(<span class="built_in">rc</span>(ul), <span class="built_in">rc</span>(ur), k - t, mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> dat</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> mid </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> CT::rt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">lsh</span>(), CT::<span class="built_in">bd</span>(rt[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) CT::<span class="built_in">cg</span>(a[i], <span class="number">1</span>, rt[i], rt[i - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l, r, k; m--; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;l, &amp;r, &amp;k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, xx[CT::<span class="built_in">ask</span>(rt[l - <span class="number">1</span>], rt[r], k)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="带修"><a href="#带修" class="headerlink" title="带修"></a>带修</h2><p>看看这个：</p><p><a href="https://www.luogu.com.cn/problem/P2617">Dynamic Rankings</a></p><p>上面问题的带修版本</p><p>直接考虑把主席树套到树状数组上（反正 BIT 擅长维护前缀和），代码也很好写，时空都是 $O(n \log^2 n)$ </p><p>实现的时候，由于套上的一个 BIT 不好建最初的树，反正那棵树里面啥都没有，就懒得建了（其实感觉已经不是主席树，或者可持久化线段树了，因为没有从上一个状态继承，而是完全动态开点），一个要点是 BIT 是建在“时间“上的，大小该是 $n$ ，而主席树是建在值域上的、</p><p>代码（我常数过大被整体二分做法吊打）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, num;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Q</span>&#123;</span> <span class="keyword">int</span> op, l, r, k; &#125; q[N];</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; xx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lsh</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    xx.<span class="built_in">reserve</span>(n + m + <span class="number">1</span>);</span><br><span class="line">    xx.<span class="built_in">pb</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) xx.<span class="built_in">pb</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="keyword">if</span> (!q[i].k) xx.<span class="built_in">pb</span>(q[i].r);</span><br><span class="line">    std::<span class="built_in">sort</span>(xx.<span class="built_in">begin</span>(), xx.<span class="built_in">end</span>());</span><br><span class="line">    xx.<span class="built_in">erase</span>(std::<span class="built_in">unique</span>(xx.<span class="built_in">begin</span>(), xx.<span class="built_in">end</span>()), xx.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = std::<span class="built_in">lower_bound</span>(xx.<span class="built_in">begin</span>(), xx.<span class="built_in">end</span>(), a[i]) - xx.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="keyword">if</span> (!q[i].k) q[i].r = std::<span class="built_in">lower_bound</span>(xx.<span class="built_in">begin</span>(), xx.<span class="built_in">end</span>(), q[i].r) - xx.<span class="built_in">begin</span>();</span><br><span class="line">    num = xx.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> BIT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> NN = <span class="number">6e7</span> + <span class="number">100</span>, D = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> rts[<span class="number">2</span>][D];</span><br><span class="line">    <span class="keyword">namespace</span> CT</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> <span class="keyword">int</span> lc, rc, cnt; &#125; tr[NN];</span><br><span class="line">        <span class="keyword">int</span> rt[N], tot = <span class="number">0</span>;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> lc(x) tr[(x)].lc</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> rc(x) tr[(x)].rc</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> ct(x) tr[(x)].cnt</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">cg</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> d, <span class="keyword">int</span> &amp;u, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = num)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!u) u = ++tot;</span><br><span class="line">            <span class="built_in">ct</span>(u) += d;</span><br><span class="line">            <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line">            (pos &lt;= mid) ? <span class="built_in">cg</span>(pos, d, <span class="built_in">lc</span>(u), l, mid) : <span class="built_in">cg</span>(pos, d, <span class="built_in">rc</span>(u), mid + <span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = num)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = rts[<span class="number">1</span>][<span class="number">0</span>]; i; --i) sum += <span class="built_in">ct</span>(<span class="built_in">lc</span>(rts[<span class="number">1</span>][i]));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = rts[<span class="number">0</span>][<span class="number">0</span>]; i; --i) sum -= <span class="built_in">ct</span>(<span class="built_in">lc</span>(rts[<span class="number">0</span>][i]));</span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = rts[<span class="number">1</span>][<span class="number">0</span>]; i; --i) rts[<span class="number">1</span>][i] = <span class="built_in">lc</span>(rts[<span class="number">1</span>][i]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = rts[<span class="number">0</span>][<span class="number">0</span>]; i; --i) rts[<span class="number">0</span>][i] = <span class="built_in">lc</span>(rts[<span class="number">0</span>][i]);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">ask</span>(k, l, mid);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = rts[<span class="number">1</span>][<span class="number">0</span>]; i; --i) rts[<span class="number">1</span>][i] = <span class="built_in">rc</span>(rts[<span class="number">1</span>][i]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = rts[<span class="number">0</span>][<span class="number">0</span>]; i; --i) rts[<span class="number">0</span>][i] = <span class="built_in">rc</span>(rts[<span class="number">0</span>][i]);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">ask</span>(k - sum, mid + <span class="number">1</span>, r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">undef</span> ct</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">undef</span> mid</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">using</span> CT::rt;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lb(x) ((x) &amp; (-(x)))</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cg</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span></span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += <span class="built_in">lb</span>(i)) CT::<span class="built_in">cg</span>(a[x], d, rt[i]); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        rts[<span class="number">0</span>][<span class="number">0</span>] = rts[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i; i ^= <span class="built_in">lb</span>(i)) rts[<span class="number">1</span>][++rts[<span class="number">1</span>][<span class="number">0</span>]] = rt[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l - <span class="number">1</span>; i; i ^= <span class="built_in">lb</span>(i)) rts[<span class="number">0</span>][++rts[<span class="number">0</span>][<span class="number">0</span>]] = rt[i];</span><br><span class="line">        <span class="keyword">return</span> CT::<span class="built_in">ask</span>(k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> lb</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> c[<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, c);</span><br><span class="line">        <span class="keyword">if</span> (c[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;q[i].l, &amp;q[i].r, &amp;q[i].k);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;q[i].l, &amp;q[i].r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">lsh</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) BIT::<span class="built_in">cg</span>(i, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) </span><br><span class="line">        <span class="keyword">if</span> (q[i].k) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, xx[BIT::<span class="built_in">ask</span>(q[i].l, q[i].r, q[i].k)]);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            BIT::<span class="built_in">cg</span>(q[i].l, <span class="number">-1</span>);</span><br><span class="line">            a[q[i].l] = q[i].r;</span><br><span class="line">            BIT::<span class="built_in">cg</span>(q[i].l, <span class="number">1</span>);</span><br><span class="line">        &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 就是可持久化线段树&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="线段树" scheme="https://dyd-true.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    <category term="笔记" scheme="https://dyd-true.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="可持久化" scheme="https://dyd-true.github.io/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
    <category term="主席树" scheme="https://dyd-true.github.io/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>虚树</title>
    <link href="https://dyd-true.github.io/2022/05/19/%E8%99%9A%E6%A0%91/"/>
    <id>https://dyd-true.github.io/2022/05/19/%E8%99%9A%E6%A0%91/</id>
    <published>2022-05-19T11:02:04.000Z</published>
    <updated>2022-05-19T14:25:50.858Z</updated>
    
    <content type="html"><![CDATA[<p> 构造只包含有用信息的新图，减少数据规模</p><span id="more"></span><h1 id="虚树"><a href="#虚树" class="headerlink" title="虚树"></a>虚树</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>对于一棵树 $T$ ，构造一棵新树 $T’$ ，使得 $T’$ 中包含一些给定的节点和它们的 lca 且节点数尽量少，这个 $T’$ 就是虚树</p><p>明显， $T’$ 的点数少于 $T$ ，不妨假设 $n$ 为 $T$ 中节点个数，给定的关键节点集合为 $S$ ，那么对于每组 $S$ ，回答询问的时间复杂度可优化至 $O(\mid S \mid (\log n + \log \mid S \mid) + f( \mid S \mid))$ ，其中 $f(x)$ 表示对于一个 $x$ 个点的树回答询问的时间，另外，这只是一组点集，虚树可以处理多组点集，对于每组点集，可以证明，虚树的节点个数最多为 $2 \mid S \mid$ 个</p><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>其实是有点暴力的</p><p>处理出 lca 和 dfn 序，然后对于每个点集 $S$ 按 dfn 序进行排序 ，同时维护一个栈，对于当前节点 $x$ ，记 $z = lca(x, stk[top])$  ：</p><ol><li>若 $z = stk[top]$ ，说明 $x$ 是 $stk[top]$ 的儿子，把 $x$ 入栈</li><li>否则，不断弹出 $stk[top]$ 直到 $dep[stk[top]] \le dep[z]$ ，每次弹出连边 $stk[top - 1] \to stk[top]$ ；弹完后，若 $z \ne stk[top]$ ，把 $z$ 入栈，最后把 $x$ 入栈</li><li>最后，当所有点的跟新结束后，还要弹出栈</li></ol><p>具体实现时，有更简洁的打法（另外，为了简单，我们一般会把根先丢进栈）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!top) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(stk[++top] = x);</span><br><span class="line">    <span class="keyword">int</span> z = <span class="built_in">lca</span>(stk[top], x);</span><br><span class="line">    <span class="keyword">for</span> (; tp &gt; <span class="number">1</span> &amp;&amp; dep[z] &lt; dep[stk[top - <span class="number">1</span>]]; --top) <span class="built_in">add</span>(stk[top - <span class="number">1</span>], stk[top]);</span><br><span class="line">    <span class="keyword">if</span> (dep[z] &lt; dep[stk[top]]) <span class="built_in">add</span>(z, stk[top--]);</span><br><span class="line">    <span class="keyword">if</span> (!top || stk[top] != z) stk[++top] = z;</span><br><span class="line">    stk[++top] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若用的是 $O(\log n)$ 的 lca ， $O(\mid S \mid \log \mid S \mid)$ 的排序，时间为 $O(\mid S \mid (\log n + \log \mid S \mid))$ </p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>还是给一题</p><p><a href="https://codeforces.com/contest/613/problem/D">Kingdom and its Cities</a></p><p>直接每次询问建虚树，然后把关键节点的 $si$ 设为 $1$ ，其它为 $0$ ，在虚树上 dfs ，对于一个节点：</p><ol><li>若它的 $si \ne 0$ ，那么它的每一个 $si \ne 0$ 的儿子都不能和它联通，必须删掉（删掉该子树的任何一个点都一样）</li><li>否则，令它的 $si$  等于所有子树 $si$ 和，计算出来若它的 $si &gt; 1$ ，显然把它删除就是最优的办法</li></ol><p>一个要注意的是，邻接表和 $si$ 的清空不能 <code>memset</code> ，否则时间会退化，记 $K = \sum k$ 下面的代码时间为 $O(n \log n + K(\log n + \log K) + K)$ </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">100</span>, D = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">int</span> n, num = <span class="number">0</span>, q, k, ans;</span><br><span class="line"><span class="keyword">int</span> a[N], si[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span> <span class="keyword">int</span> ne, ver; &#125; e[N &lt;&lt; <span class="number">1</span>], ef[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> h[N], idx = <span class="number">0</span>, hf[N], idf = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> f[N][D], dep[N], dfn[N];</span><br><span class="line"><span class="keyword">int</span> stk[N], top;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; e[idx] = &#123;h[x], y&#125;, h[x] = idx++; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adf</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; ef[idf] = &#123;hf[x], y&#125;, hf[x] = idf++; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x] = ++num, f[x][<span class="number">0</span>] = fa, dep[x] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = e[i].ne) <span class="keyword">if</span> (e[i].ver != fa) <span class="built_in">dfs1</span>(e[i].ver, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &gt; dep[y]) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = D - <span class="number">1</span>; ~i; --i) <span class="keyword">if</span> (dep[f[y][i]] &gt;= dep[x]) y = f[y][i];</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = D - <span class="number">1</span>; ~i; --i) <span class="keyword">if</span> (f[y][i] != f[x][i]) y = f[y][i], x = f[x][i];</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!top) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(stk[++top] = x);</span><br><span class="line">    <span class="keyword">int</span> z = <span class="built_in">lca</span>(x, stk[top]);</span><br><span class="line">    <span class="keyword">for</span> (; top &gt; <span class="number">1</span> &amp;&amp; dep[z] &lt; dep[stk[top - <span class="number">1</span>]]; --top) <span class="built_in">adf</span>(stk[top - <span class="number">1</span>], stk[top]);</span><br><span class="line">    <span class="keyword">if</span> (dep[z] &lt; dep[stk[top]]) <span class="built_in">adf</span>(z, stk[top--]);</span><br><span class="line">    <span class="keyword">if</span> (!top || stk[top] != z) stk[++top] = z;</span><br><span class="line">    stk[++top] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (si[x])</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = hf[x], y; ~i; i = ef[i].ne)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs2</span>(y = ef[i].ver);</span><br><span class="line">            <span class="keyword">if</span> (si[y]) si[y] = <span class="number">0</span>, ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = hf[x], y; ~i; i = ef[i].ne)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs2</span>(y = ef[i].ver);</span><br><span class="line">            si[x] += si[y];</span><br><span class="line">            si[y] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (si[x] &gt; <span class="number">1</span>) si[x] = <span class="number">0</span>, ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">    hf[x] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + k + <span class="number">1</span>, [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123; <span class="keyword">return</span> dfn[x] &lt; dfn[y]; &#125;);</span><br><span class="line">    top = ans = idf = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">1</span>] != <span class="number">1</span>) stk[++top] = <span class="number">1</span>; <span class="comment">//根</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) <span class="built_in">ins</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span> (; top &gt; <span class="number">1</span>; --top) <span class="built_in">adf</span>(stk[top - <span class="number">1</span>], stk[top]);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>), si[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h), <span class="built_in">memset</span>(hf, <span class="number">-1</span>, <span class="keyword">sizeof</span> hf);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u, v), <span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; D; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i][j] = f[f[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q); q--; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">            si[a[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) <span class="keyword">if</span> (si[f[a[i]][<span class="number">0</span>]])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(k) si[a[k--]] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!k) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">work</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 构造只包含有用信息的新图，减少数据规模&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://dyd-true.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="图论" scheme="https://dyd-true.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="笔记" scheme="https://dyd-true.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="lca" scheme="https://dyd-true.github.io/tags/lca/"/>
    
  </entry>
  
  <entry>
    <title>AtCoder ABC250 EX</title>
    <link href="https://dyd-true.github.io/2022/05/17/AtCoder-ABC250-EX/"/>
    <id>https://dyd-true.github.io/2022/05/17/AtCoder-ABC250-EX/</id>
    <published>2022-05-17T12:16:52.000Z</published>
    <updated>2022-05-17T12:32:52.251Z</updated>
    
    <content type="html"><![CDATA[<p> dij求“多源”最短</p><span id="more"></span><p><a href="https://atcoder.jp/contests/abc250/tasks/abc250_h">Trespassing Takahashi</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>据说有最小生成树的做法，但没看懂</p><p>考虑转化，用 dij 求出每个点的 $dis$ 表示”该点到最近的特殊点的距离“，这可以 $O(m \log m)$ 做到，然后对于每条边，其权值改为 $c_i’ = dis_{a_i} + dis_{b_i} + c_i$ ，然后，对于新图，两个点在 $t$ 时间内可达当且仅当两点之间的路径中所有权值 $c_i’ \le t$ ，可以用瓶颈生成树做，但直接离线 + 并查集更简单</p><p>关于上述转化的证明：</p><p>记 $dis(a, b)$ 表示“点 $a, b$ 的最短路径长”</p><ul><li><p>必要性：</p><p>任取原图答案中某一条边 $(a, b, c)$ ，我们必然是通过关键点 $k_1$ 走到关键点 $k_2$ ，即 $dis(k_1, a) + c + dis(b, k_2) \le t$ ，由 $dis_{a_i}, dis_{b_i}$ 的最小性质不难得到 $dis_{a_i} + dis_{b_i} + c = c’ \le dis(k_1, a) + c + dis(b, k_2) \le t$ </p></li><li><p>充分性：</p><p>只要 $c’ \le t$ ，我们一定可以“安全”走过对应的边，又因为新图中找到的路径联通了两个关键点，其间的边都是“安全”的，所以必定可以走到</p></li></ul><p>时间复杂度 $O(m \log m)$ </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k, tq, fa[N], h[N], idx = <span class="number">0</span>, ct = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span> <span class="keyword">int</span> ne, ver, w; &#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge2</span>&#123;</span> <span class="keyword">int</span> u, v; LL w; &#125; e2[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Q</span>&#123;</span> <span class="keyword">int</span> x, y, id; LL t; &#125; que[N];</span><br><span class="line">LL dis[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N], ans[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">get</span>(fa[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>&#123; e[idx] = &#123;h[x], y, z&#125;, h[x] = idx++; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dij</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    std::priority_queue&lt; std::pair&lt;LL, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k + <span class="number">1</span>; i &lt;= n; ++i) dis[i] = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, i&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.<span class="built_in">top</span>().second; q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne) <span class="keyword">if</span> (!vis[y = e[i].ver])</span><br><span class="line">            <span class="keyword">if</span> (dis[y] &gt; dis[x] + e[i].w) </span><br><span class="line">            &#123;</span><br><span class="line">                dis[y] = dis[x] + e[i].w;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;-dis[y], y&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; fa[<span class="built_in">get</span>(x)] = <span class="built_in">get</span>(y); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, w; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        <span class="built_in">add</span>(u, v, w), <span class="built_in">add</span>(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dij</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; idx; i += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = e[i].ver, v = e[i ^ <span class="number">1</span>].ver, w = e[i].w;</span><br><span class="line">        e2[++ct] = &#123;u, v, dis[u] + dis[v] + w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(e2 + <span class="number">1</span>, e2 + ct + <span class="number">1</span>, [&amp;](Edge2 a, Edge2 b)&#123; <span class="keyword">return</span> a.w &lt; b.w; &#125;);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tq);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tq; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %lld&quot;</span>, &amp;que[i].x, &amp;que[i].y, &amp;que[i].t);</span><br><span class="line">        que[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(que + <span class="number">1</span>, que + tq + <span class="number">1</span>, [&amp;](Q a, Q b)&#123; <span class="keyword">return</span> a.t &lt; b.t; &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= tq; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt;= ct &amp;&amp; e2[j].w &lt;= que[i].t; ++j) <span class="built_in">merge</span>(e2[j].u, e2[j].v);</span><br><span class="line">        ans[que[i].id] = <span class="built_in">get</span>(que[i].x) == <span class="built_in">get</span>(que[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tq; ++i)</span><br><span class="line">        <span class="keyword">if</span> (ans[i]) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; dij求“多源”最短&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="AtCoder" scheme="https://dyd-true.github.io/tags/AtCoder/"/>
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="图论" scheme="https://dyd-true.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="最短路" scheme="https://dyd-true.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
    <category term="并查集" scheme="https://dyd-true.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>AtCoder ABC250 G</title>
    <link href="https://dyd-true.github.io/2022/05/16/AtCoder-ABC250-G/"/>
    <id>https://dyd-true.github.io/2022/05/16/AtCoder-ABC250-G/</id>
    <published>2022-05-16T08:43:19.000Z</published>
    <updated>2022-05-17T12:17:22.689Z</updated>
    
    <content type="html"><![CDATA[<p> 贪心</p><span id="more"></span><p><a href="https://atcoder.jp/contests/abc250/tasks/abc250_g">Stonks</a></p><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p>记 $b[i] = -1/1/0$ 表示卖出/买入/什么都不干，再记 $s[i]$ 为 $b[i]$ 的前缀和，显然，要求 $s[i] \ge 0$ ，且答案就是 $-\sum b[i] * a[i]$ </p><p>先令所有 $b[i] = 1$ ，计算出 $s[i]$  ，以 $a[i]$ 降序考虑每一个 $i$ ，把它变成 $b[i] = -1$ ，要求 $\forall j \in[i, n], s[j] \ge 2$ ；或者变成 $b[i] = 0$ ，要求 $\forall j \in[i, n], s[j] \ge 1$ ，用线段树维护，跟新即可</p><p>时间 $O(n \log n)$ </p><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>然鹅不用这么麻烦，直接贪心（官方题解写的太复杂了我看了半天），用一个小根堆维护买入，对于当前天数：</p><ol><li>若最小的买入比当前小（即可以赚），就从堆中弹出堆顶，跟新答案，然后插入两个当前天</li><li>否则，只插入一个当前天</li></ol><p>这里插入两个当前天有点带悔贪心的味道，第一个是为了取消当前天的卖出，第二个是保证当前天可以买入</p><p>时间仍然是 $O(n \log n)$ </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line">std::priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    q.<span class="built_in">push</span>(-a[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (-q.<span class="built_in">top</span>() &lt; a[i])</span><br><span class="line">        &#123;</span><br><span class="line">            ans += a[i] + q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            q.<span class="built_in">push</span>(-a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">push</span>(-a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 贪心&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="AtCoder" scheme="https://dyd-true.github.io/tags/AtCoder/"/>
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="贪心" scheme="https://dyd-true.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="数据结构" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="线段树" scheme="https://dyd-true.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>AtCoder ABC250 F</title>
    <link href="https://dyd-true.github.io/2022/05/16/AtCoder-ABC250-F/"/>
    <id>https://dyd-true.github.io/2022/05/16/AtCoder-ABC250-F/</id>
    <published>2022-05-16T03:59:51.000Z</published>
    <updated>2022-05-17T12:17:31.593Z</updated>
    
    <content type="html"><![CDATA[<p> 比较基础的计算几何，但架不住我计几拉吖</p><span id="more"></span><p><a href="https://atcoder.jp/contests/abc250/tasks/abc250_f">One Fourth</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先把面积算出来，记为 $s$ </p><p>然后有一个滑动窗口的技巧，枚举 $l$ ，若当前面积小于四分之一，就让 $r$ 加 $1$ ，计算面积；每次 $l$  加 $1$ 后面积减小；</p><p>因为 $l, r$ 都是单调的，所以是 $O(n)$ 的</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>一个坑是 <code>abs()</code> 的返回值是 <code>int</code> ，只有 <code>std::abs()</code> 的返回值才可以是任意类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">8e18</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">LL s = <span class="number">0</span>, ans = INF, e = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LL x, y;</span><br><span class="line">    Point <span class="keyword">operator</span> - (Point <span class="keyword">_t</span>)&#123; <span class="keyword">return</span> &#123;x - <span class="keyword">_t</span>.x, y - <span class="keyword">_t</span>.y&#125;; &#125;</span><br><span class="line">    LL <span class="keyword">operator</span> * (Point <span class="keyword">_t</span>)&#123; <span class="keyword">return</span> x * <span class="keyword">_t</span>.y - y * <span class="keyword">_t</span>.x; &#125;</span><br><span class="line">&#125; p[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) s += std::<span class="built_in">abs</span>((p[i] - p[<span class="number">1</span>]) * (p[i + <span class="number">1</span>] - p[<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">2</span>; l &lt;= n; ++l)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">4</span> * e &lt; s)</span><br><span class="line">        &#123;</span><br><span class="line">            e += std::<span class="built_in">abs</span>((p[r] - p[l]) * (p[r % n + <span class="number">1</span>] - p[l]));</span><br><span class="line">            r = r % n + <span class="number">1</span>;</span><br><span class="line">            ans = std::<span class="built_in">min</span>(ans, std::<span class="built_in">abs</span>(s - <span class="number">4</span> * e));</span><br><span class="line">        &#125;</span><br><span class="line">        e -= std::<span class="built_in">abs</span>((p[l] - p[r]) * (p[l % n + <span class="number">1</span>] - p[r]));</span><br><span class="line">        ans = std::<span class="built_in">min</span>(ans, std::<span class="built_in">abs</span>(s - <span class="number">4</span> * e));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 比较基础的计算几何，但架不住我计几拉吖&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="AtCoder" scheme="https://dyd-true.github.io/tags/AtCoder/"/>
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="计算几何" scheme="https://dyd-true.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
    <category term="单调队列" scheme="https://dyd-true.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>CF1033G Chip Game</title>
    <link href="https://dyd-true.github.io/2022/05/15/CF1033G-Chip-Game/"/>
    <id>https://dyd-true.github.io/2022/05/15/CF1033G-Chip-Game/</id>
    <published>2022-05-15T10:10:47.000Z</published>
    <updated>2022-05-15T12:32:22.569Z</updated>
    
    <content type="html"><![CDATA[<p> 神仙数学题，感觉很考思维</p><span id="more"></span><p><a href="https://codeforces.com/problemset/problem/1033/G">Chip Game</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p> $n$ 堆石子，每堆有 $v_i$ 个，两个人 $A, B$ ，每次分别可以取 $a, b$ 个，且满足 $a, b \in [1, m]$ ，给定 $n, m, v$ 求满足以下条件的 $(a, b)$ 的对数：</p><ol><li> $A$ 必胜</li><li> $B$ 必胜</li><li>先手必胜</li><li>后手必胜</li></ol><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>瞟题解瞟了一下午才看懂</p><p>先考虑已知 $(a, b)$  如何判胜负，不妨让 $a \le b$  ，显然 $v_i$ 和 $v_i \mod (a+ b)$  等价（赢家一定可以通过 $k$ 此次和对方一起取，在胜负不变的情况下使石子多 $k(a + b)$ 个），我们讨论模后的 $v_i$ ：</p><ol><li> $v_i \in [0, a)$ ，它没用</li><li> $v_i \in [a, b)$ ，它只有 $a$ 可以取，所以只要存在这种情况， $A$ 必胜（ $A$ 可以先留着这堆和 $B$ 一起取其它堆石子），它是有利于小者的</li><li> $v_i \in [b, 2a)$ ，它对 $A, B$ 都只可取一次，是中性的，注意 $b \ge 2a$ 时不存在这种情况</li><li> $v_i \in [\max(2a, b), a + b)$ ，若 $A$ 先手取它，它变成 $2$ ，使 $A$ 必胜；若 $B$ 先手取它，它变成 $1$ ，没用</li></ol><p>于是：</p><ol><li>当存在 $2$  或者存在两个以上 $4$ 时，小者必胜</li><li>否则，若只存在一个 $4$ ，若有小者 + 先手则必胜；否则统计 $3$ 的个数，奇数个小的（同时是后手）胜，偶数个大的胜</li><li>否则，统计 $3$ 的个数，奇数个先手胜，偶数个后手胜</li></ol><p>于是枚举 $(a, b)$ 就有了 $O(m^2n)$  的做法，考虑优化</p><p>枚举 $sum = a + b$ ，我们钦定 $B$ 为后手（但不保证 $a, b$ 的大小关系）来计算后手胜的个数，在 $b$ 从小增大的途中，必定存在 $pos$ 使 $b$ 大于 $pos$ 后必败（显然后手、大的是不利的），更具体的，如图：</p><p><img src="https://s2.loli.net/2022/05/15/qF7HDMz1aGnwCEv.png" alt="tu"></p><p> $A, B$ 必胜显然是对称的，一样多，就是 $\min(pos - l + 1, r - pos)$ 个，那么后手必胜就有 $pos - l + 1 - \min(pos - l + 1, r - pos)$ 个，先手必胜最后用总方案数减即得</p><p>那么现在考虑如何如何求 $pos$ ，大力分讨，同样设 $v_i$ 为模后的：</p><ol><li><p>若 $b &lt; a$ ，则它的胜利条件为以下两者之一：</p><ul><li>存在 $v_i \in [b, a)$ </li><li>存在多于两个 $v_i \in [2b, sum)$ </li></ul><p>对于第二个，考虑记录最大值 $mx$  和次大值 $mx2$ ，那么 $b \le \frac{mx2}{2}$ 都满足第二个，所以 $pos \ge \frac{mx2}{2}$ </p><p>对于第一个，即 $b \le v_i &lt; sum - b$ ，得 $b \le v_i$  和 $b &lt; sum - v_i$ 即 $b \le sum - v_i - 1$ ，所以 $b \le \min(v_i, sum - v_i - 1)$ ，由于存在即可， $pos$ 当取所有 $v_i$ 计算得的最大值</p></li><li><p>若 $b = a$ ，统计 $v_i \ge \frac{sum}{2}$ 的个数，偶数数个则可以使 $pos = \frac{sum}{2}$ ；这里结束后，若 $pos &lt; \frac{sum}{2}$ ，说明已经无法在让 $pos$ 变大了（过不去 $b = a = \frac{sum}{2}$ 这个点），直接返回</p></li><li><p>若 $b &gt; a$ ，则它的胜利条件必须满足：</p><ul><li>所有 $v_i \in [0， a) \cup [b, 2a)$ </li></ul><p>我们有 $0 \le v_i &lt; sum - b$ 或 $b \le v_i &lt; 2(sum - b)$ ，化简得 $b \le \max(v_i, sum - v_i - 1)$ ， $b \le sum - \frac{v_i}{2} - 1$ ，最后一个条件可以直接带 $mx$ ，第一个只好枚举，由于是必须满足，所以 $pos$ 当取所有计算值的最小值</p></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, b[N];</span><br><span class="line">LL a[N], ans[<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>, mx2 = <span class="number">0</span>, res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((b[i] = a[i] % sum) &gt;= (sum + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) ++cnt;</span><br><span class="line">        <span class="keyword">if</span> (b[i] &gt; mx) mx2 = mx, mx = b[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (b[i] &gt; mx2) mx2 = b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    res = mx2 &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) res = std::<span class="built_in">max</span>(res, std::<span class="built_in">min</span>(b[i], sum - b[i] - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (!(cnt &amp; <span class="number">1</span>)) res = sum &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (res &lt; (sum &gt;&gt; <span class="number">1</span>)) <span class="keyword">return</span> res;</span><br><span class="line">    res = sum - (mx &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) res = std::<span class="built_in">min</span>(res, std::<span class="built_in">max</span>(b[i], sum - b[i] - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">2</span>, pos, l, r; s &lt;= (m &lt;&lt; <span class="number">1</span>); ++s)</span><br><span class="line">    &#123;</span><br><span class="line">        l = std::<span class="built_in">max</span>(<span class="number">1</span>, s - m), r = std::<span class="built_in">min</span>(s - <span class="number">1</span>, m);</span><br><span class="line">        pos = std::<span class="built_in">min</span>(std::<span class="built_in">max</span>(<span class="built_in">find</span>(s), l - <span class="number">1</span>), r);</span><br><span class="line">        ans[<span class="number">0</span>] += std::<span class="built_in">min</span>(pos - l + <span class="number">1</span>, r - pos);</span><br><span class="line">        ans[<span class="number">1</span>] += pos - l + <span class="number">1</span> - std::<span class="built_in">min</span>(pos - l + <span class="number">1</span>, r - pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld %lld %lld\n&quot;</span>, ans[<span class="number">0</span>], ans[<span class="number">0</span>], <span class="built_in">LL</span>(m) * m - (ans[<span class="number">0</span>] &lt;&lt; <span class="number">1</span>) - ans[<span class="number">1</span>], ans[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 神仙数学题，感觉很考思维&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="数论,数学" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
    <category term="博弈论" scheme="https://dyd-true.github.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>kmp 乱讲</title>
    <link href="https://dyd-true.github.io/2022/05/03/kmp-%E4%B9%B1%E8%AE%B2/"/>
    <id>https://dyd-true.github.io/2022/05/03/kmp-%E4%B9%B1%E8%AE%B2/</id>
    <published>2022-05-03T09:08:23.000Z</published>
    <updated>2022-05-03T09:18:36.696Z</updated>
    
    <content type="html"><![CDATA[<p> 好像以前写过一个</p><span id="more"></span><h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h2 id="题"><a href="#题" class="headerlink" title="题"></a>题</h2><p> <a href="https://www.luogu.com.cn/problem/P2375">动物园</a></p><p><a href="https://www.luogu.com.cn/problem/P7114">字符串匹配</a></p><h2 id="Z"><a href="#Z" class="headerlink" title="Z"></a>Z</h2><p>板子+上题</p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>感觉自己好水啊</p>]]></content>
    
    
    <summary type="html">&lt;p&gt; 好像以前写过一个&lt;/p&gt;</summary>
    
    
    
    <category term="others" scheme="https://dyd-true.github.io/categories/others/"/>
    
    
    <category term="字符串" scheme="https://dyd-true.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="备讲" scheme="https://dyd-true.github.io/tags/%E5%A4%87%E8%AE%B2/"/>
    
  </entry>
  
  <entry>
    <title>luoguP7735 [NOI2021] 轻重边</title>
    <link href="https://dyd-true.github.io/2022/05/03/luoguP7735-NOI2021-%E8%BD%BB%E9%87%8D%E8%BE%B9/"/>
    <id>https://dyd-true.github.io/2022/05/03/luoguP7735-NOI2021-%E8%BD%BB%E9%87%8D%E8%BE%B9/</id>
    <published>2022-05-03T06:13:02.000Z</published>
    <updated>2022-05-03T06:37:15.288Z</updated>
    
    <content type="html"><![CDATA[<p> 第一步的转化非常巧妙</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P7735">轻重边</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最开始想的 LCT ，发现取消重边这个操作不好维护，这里有一个巧妙的转化：把每次操作当成一次染色，每次染一种新颜色，一条边是重边当且仅当两端点颜色相同，然后就是上树剖维护连续颜色即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p> dbug 时的几个点：</p><ol><li>一条链上边比点少一个，所以 <code>ct = len - 1</code> </li><li>初始化 <code>num</code> </li><li> <code>up</code> 时记得改 <code>col</code> </li></ol><p>最后， <code>ask</code> 里我是把 lca 求得然后两端分开跳的，但好像也可以不必，只要交换 $u, v$ 的同时也交换 $lastu, lastv$ 即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, h[N], idx, id[N], num, dep[N], si[N], top[N], fa[N], son[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span> <span class="keyword">int</span> ver, ne; &#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; e[idx] = &#123;y, h[x]&#125;, h[x] = idx++; &#125;</span><br><span class="line"><span class="keyword">namespace</span> LT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> <span class="keyword">int</span> tag, lcol, rcol, cnt, len; &#125; tr[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> tg(x) tr[(x)].tag</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> cl(x) tr[(x)].lcol</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> cr(x) tr[(x)].rcol</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ct(x) tr[(x)].cnt</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> len(x) tr[(x)].len</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc (u &lt;&lt; 1)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc ((u &lt;&lt; 1) | 1)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">tg</span>(u) = <span class="built_in">cl</span>(u) = <span class="built_in">cr</span>(u) = <span class="built_in">ct</span>(u) = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">len</span>(u) = r - l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) <span class="built_in">bd</span>(lc, l, mid), <span class="built_in">bd</span>(rc, mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adt</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> d)</span></span>&#123; <span class="built_in">tg</span>(u) = <span class="built_in">cl</span>(u) = <span class="built_in">cr</span>(u) = d, <span class="built_in">ct</span>(u) = <span class="built_in">len</span>(u) - <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dw</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123; <span class="keyword">if</span> (<span class="built_in">tg</span>(u))&#123; <span class="built_in">adt</span>(lc, <span class="built_in">tg</span>(u)), <span class="built_in">adt</span>(rc, <span class="built_in">tg</span>(u)), <span class="built_in">tg</span>(u) = <span class="number">0</span>; &#125; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">ct</span>(u) = <span class="built_in">ct</span>(lc) + <span class="built_in">ct</span>(rc);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">cl</span>(rc) == <span class="built_in">cr</span>(lc) &amp;&amp; <span class="built_in">cl</span>(rc) != <span class="number">0</span>) ++<span class="built_in">ct</span>(u);</span><br><span class="line">        <span class="built_in">cl</span>(u) = <span class="built_in">cl</span>(lc), <span class="built_in">cr</span>(u) = <span class="built_in">cr</span>(rc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mdf</span><span class="params">(<span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> d, <span class="keyword">int</span> u = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) <span class="keyword">return</span> <span class="built_in">adt</span>(u, d);</span><br><span class="line">        <span class="built_in">dw</span>(u);</span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= mid) <span class="built_in">mdf</span>(ql, qr, d, lc, l, mid);</span><br><span class="line">        <span class="keyword">if</span> (qr &gt; mid) <span class="built_in">mdf</span>(ql, qr, d, rc, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">up</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::array&lt;<span class="keyword">int</span>, 3&gt; <span class="title">ask</span><span class="params">(<span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> u = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) <span class="keyword">return</span> &#123;<span class="built_in">ct</span>(u), <span class="built_in">cl</span>(u), <span class="built_in">cr</span>(u)&#125;;</span><br><span class="line">        <span class="built_in">dw</span>(u);</span><br><span class="line">        <span class="keyword">if</span> (ql &gt; mid) <span class="keyword">return</span> <span class="built_in">ask</span>(ql, qr, rc, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (qr &lt;= mid) <span class="keyword">return</span> <span class="built_in">ask</span>(ql, qr, lc, l, mid);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> rl = <span class="built_in">ask</span>(ql, qr, lc, l, mid), rr = <span class="built_in">ask</span>(ql, qr, rc, mid + <span class="number">1</span>, r);</span><br><span class="line">            rl[<span class="number">0</span>] = rl[<span class="number">0</span>] + rr[<span class="number">0</span>] + (rl[<span class="number">2</span>] == rr[<span class="number">1</span>] &amp;&amp; rl[<span class="number">2</span>] != <span class="number">0</span>);</span><br><span class="line">            rl[<span class="number">2</span>] = rr[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">return</span> rl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> tg</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> cl</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> cr</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> ct</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> len</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> mid</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[x] = d, fa[x] = f, si[x] = <span class="number">1</span>, son[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne) <span class="keyword">if</span> ((y = e[i].ver) != f)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs1</span>(y, x, d + <span class="number">1</span>);</span><br><span class="line">        si[x] += si[y];</span><br><span class="line">        <span class="keyword">if</span> (si[son[x]] &lt; si[y]) son[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    id[x] = ++num, top[x] = t;</span><br><span class="line">    <span class="keyword">if</span> (!son[x]) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[x], t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], y; ~i; i = e[i].ne) <span class="keyword">if</span> ((y = e[i].ver) != fa[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (y == son[x]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(y, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[u] != top[v])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[u]] &lt; dep[top[v]]) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">        u = fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (dep[u] &lt; dep[v]) ? u : v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mdf</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[u] != top[v])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[u]] &lt; dep[top[v]]) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">        LT::<span class="built_in">mdf</span>(id[top[u]], id[u], d);</span><br><span class="line">        u = fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dep[u] &lt; dep[v]) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">    LT::<span class="built_in">mdf</span>(id[v], id[u], d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, lastu = <span class="number">0</span>, lastv = <span class="number">0</span>, w = <span class="built_in">lca</span>(u, v);</span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>&amp;, <span class="keyword">int</span>&amp;)&gt; jump = [&amp;](<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;last)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (top[x] != top[w])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = LT::<span class="built_in">ask</span>(id[top[x]], id[x]);</span><br><span class="line">            res += t[<span class="number">0</span>] + (t[<span class="number">2</span>] == last &amp;&amp; last != <span class="number">0</span>);</span><br><span class="line">            last = t[<span class="number">1</span>];</span><br><span class="line">            x = fa[top[x]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; ;</span><br><span class="line">    <span class="built_in">jump</span>(u, lastu), <span class="built_in">jump</span>(v, lastv);</span><br><span class="line">    <span class="keyword">if</span> (dep[u] &lt; dep[v]) std::<span class="built_in">swap</span>(u, v), std::<span class="built_in">swap</span>(lastu, lastv);</span><br><span class="line">    <span class="keyword">auto</span> t = LT::<span class="built_in">ask</span>(id[v], id[u]);</span><br><span class="line">    res += t[<span class="number">0</span>] + (t[<span class="number">1</span>] == lastv &amp;&amp; lastv != <span class="number">0</span>) + (t[<span class="number">2</span>] == lastu &amp;&amp; lastu != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T); T--; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h), idx = num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++i)&#123; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v), <span class="built_in">add</span>(u, v), <span class="built_in">add</span>(v, u); &#125;</span><br><span class="line">        <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>), <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>), LT::<span class="built_in">bd</span>(<span class="number">1</span>, <span class="number">1</span>, num);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> op, a, b, ccol = <span class="number">0</span>; m--; )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;op, &amp;a, &amp;b);</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="number">1</span>) <span class="built_in">mdf</span>(a, b, ++ccol);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">ask</span>(a, b));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 第一步的转化非常巧妙&lt;/p&gt;</summary>
    
    
    
    <category term="练习" scheme="https://dyd-true.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="练习" scheme="https://dyd-true.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="数据结构" scheme="https://dyd-true.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="线段树" scheme="https://dyd-true.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    <category term="树链剖分" scheme="https://dyd-true.github.io/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    
  </entry>
  
</feed>
